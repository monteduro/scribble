var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn2) {
  return fn2();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
var src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (element_src === url)
    return true;
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function create_slot(definition, ctx, $$scope, fn2) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn2);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn2) {
  return definition[1] && fn2 ? assign($$scope.ctx.slice(), definition[1](fn2(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn2) {
  if (definition[2] && fn2) {
    const lets = definition[2](fn2(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys2) {
  const rest = {};
  keys2 = new Set(keys2);
  for (const k in props)
    if (!keys2.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    return this._observer ?? (this._observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        this._listeners.get(entry.target)?.(entry);
      }
    }));
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn2) {
  return function(event) {
    event.preventDefault();
    return fn2.call(this, event);
  };
}
function stop_propagation(fn2) {
  return function(event) {
    event.stopPropagation();
    return fn2.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
var always_set_through_set_attribute = ["width", "height"];
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function set_custom_element_data_map(node, data_map) {
  Object.keys(data_map).forEach((key) => {
    set_custom_element_data(node, key, data_map[key]);
  });
}
function set_custom_element_data(node, prop, value) {
  const lower = prop.toLowerCase();
  if (lower in node) {
    node[lower] = typeof node[lower] === "boolean" && value === "" ? true : value;
  } else if (prop in node) {
    node[prop] = typeof node[prop] === "boolean" && value === "" ? true : value;
  } else {
    attr(node, prop, value);
  }
}
function set_dynamic_element_data(tag) {
  return /-/.test(tag) ? set_custom_element_data_map : set_attributes;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
var HtmlTag = class {
  constructor(is_svg = false) {
    /**
     * @private
     * @default false
     */
    __publicField(this, "is_svg", false);
    /** parent for creating node */
    __publicField(this, "e");
    /** html tag nodes */
    __publicField(this, "n");
    /** target */
    __publicField(this, "t");
    /** anchor */
    __publicField(this, "a");
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(html) {
    this.h(html);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(
          /** @type {keyof SVGElementTagNameMap} */
          target.nodeName
        );
      else
        this.e = element(
          /** @type {keyof HTMLElementTagNameMap} */
          target.nodeType === 11 ? "TEMPLATE" : target.nodeName
        );
      this.t = target.tagName !== "TEMPLATE" ? target : (
        /** @type {HTMLTemplateElement} */
        target.content
      );
      this.c(html);
    }
    this.i(anchor);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
};
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn2) {
  get_current_component().$$.on_mount.push(fn2);
}
function onDestroy(fn2) {
  get_current_component().$$.on_destroy.push(fn2);
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn2) => fn2.call(this, event));
  }
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn2) {
  render_callbacks.push(fn2);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}

// node_modules/svelte/src/runtime/internal/spread.js
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance18, create_fragment18, not_equal, props, append_styles = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance18 ? instance18(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment18 ? create_fragment18($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      this.$$c?.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  const type = props_definition[prop]?.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/orderedmap/dist/index.js
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key)
        return i;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self.find(key), content = self.content.slice();
    if (found2 == -1) {
      content.push(newKey || key, value);
    } else {
      content[found2 + 1] = value;
      if (newKey)
        content[found2] = newKey;
    }
    return new OrderedMap(content);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content = this.content.slice();
    content.splice(found2, 2);
    return new OrderedMap(content);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found2 = without.find(place);
    content.splice(found2 == -1 ? content.length : found2, 0, key, value);
    return new OrderedMap(content);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size)
      return this;
    return new OrderedMap(map2.content.concat(this.subtract(map2).content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size)
      return this;
    return new OrderedMap(this.subtract(map2).content.concat(map2.content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map2) {
    var result = this;
    map2 = OrderedMap.from(map2);
    for (var i = 0; i < map2.content.length; i += 2)
      result = result.remove(map2.content[i]);
    return result;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var result = {};
    this.forEach(function(key, value) {
      result[key] = value;
    });
    return result;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap)
    return value;
  var content = [];
  if (value)
    for (var prop in value)
      content.push(prop, value[prop]);
  return new OrderedMap(content);
};
var dist_default = OrderedMap;

// node_modules/prosemirror-model/dist/index.js
function findDiffStart(a, b, pos) {
  for (let i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount)
      return a.childCount == b.childCount ? null : pos;
    let childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j = 0; childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b, posA, posB) {
  for (let iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment = class _Fragment {
  /**
  @internal
  */
  constructor(content, size) {
    this.content = content;
    this.size = size || 0;
    if (size == null)
      for (let i = 0; i < content.length; i++)
        this.size += content[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(from2, to, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to; i++) {
      let child = this.content[i], end2 = pos + child.nodeSize;
      if (end2 > from2 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
        let start2 = pos + 1;
        child.nodesBetween(Math.max(0, from2 - start2), Math.min(child.content.size, to - start2), f, nodeStart + start2);
      }
      pos = end2;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(from2, to, blockSeparator, leafText) {
    let text2 = "", first2 = true;
    this.nodesBetween(from2, to, (node, pos) => {
      let nodeText = node.isText ? node.text.slice(Math.max(from2, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
      if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
        if (first2)
          first2 = false;
        else
          text2 += blockSeparator;
      }
      text2 += nodeText;
    }, 0);
    return text2;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i = 0;
    if (last.isText && last.sameMarkup(first2)) {
      content[content.length - 1] = last.withText(last.text + first2.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content.push(other.content[i]);
    return new _Fragment(content, this.size + other.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(from2, to = this.size) {
    if (from2 == 0 && to == this.size)
      return this;
    let result = [], size = 0;
    if (to > from2)
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i], end2 = pos + child.nodeSize;
        if (end2 > from2) {
          if (pos < from2 || end2 > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size += child.nodeSize;
        }
        pos = end2;
      }
    return new _Fragment(result, size);
  }
  /**
  @internal
  */
  cutByIndex(from2, to) {
    if (from2 == to)
      return _Fragment.empty;
    if (from2 == 0 && to == this.content.length)
      return this;
    return new _Fragment(this.content.slice(from2, to));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(index, node) {
    let current = this.content[index];
    if (current == node)
      return this;
    let copy2 = this.content.slice();
    let size = this.size + node.nodeSize - current.nodeSize;
    copy2[index] = node;
    return new _Fragment(copy2, size);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(node) {
    return new _Fragment([node].concat(this.content), this.size + node.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(node) {
    return new _Fragment(this.content.concat(node), this.size + node.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(index) {
    let found2 = this.content[index];
    if (!found2)
      throw new RangeError("Index " + index + " out of range for " + this);
    return found2;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index) {
    return this.content[index] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    for (let i = 0, p = 0; i < this.content.length; i++) {
      let child = this.content[i];
      f(child, p, i);
      p += child.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. (Not public.)
  */
  findIndex(pos, round2 = -1) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0; ; i++) {
      let cur = this.child(i), end2 = curPos + cur.nodeSize;
      if (end2 >= pos) {
        if (end2 == pos || round2 > 0)
          return retIndex(i + 1, end2);
        return retIndex(i, curPos);
      }
      curPos = end2;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((n) => n.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(schema, value) {
    if (!value)
      return _Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new _Fragment(value.map(schema.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(array) {
    if (!array.length)
      return _Fragment.empty;
    let joined, size = 0;
    for (let i = 0; i < array.length; i++) {
      let node = array[i];
      size += node.nodeSize;
      if (i && node.isText && array[i - 1].sameMarkup(node)) {
        if (!joined)
          joined = array.slice(0, i);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new _Fragment(joined || array, size);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(nodes) {
    if (!nodes)
      return _Fragment.empty;
    if (nodes instanceof _Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new _Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
};
Fragment.empty = new Fragment([], 0);
var found = { index: 0, offset: 0 };
function retIndex(index, offset2) {
  found.index = index;
  found.offset = offset2;
  return found;
}
function compareDeep(a, b) {
  if (a === b)
    return true;
  if (!(a && typeof a == "object") || !(b && typeof b == "object"))
    return false;
  let array = Array.isArray(a);
  if (Array.isArray(b) != array)
    return false;
  if (array) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compareDeep(a[i], b[i]))
        return false;
  } else {
    for (let p in a)
      if (!(p in b) || !compareDeep(a[p], b[p]))
        return false;
    for (let p in b)
      if (!(p in a))
        return false;
  }
  return true;
}
var Mark = class _Mark {
  /**
  @internal
  */
  constructor(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(set) {
    let copy2, placed = false;
    for (let i = 0; i < set.length; i++) {
      let other = set[i];
      if (this.eq(other))
        return set;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set.slice(0, i);
      } else if (other.type.excludes(this.type)) {
        return set;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set.slice(0, i);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return set.slice(0, i).concat(set.slice(i + 1));
    return set;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return true;
    return false;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type = schema.marks[json.type];
    if (!type)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    return type.create(json.attrs);
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(a, b) {
    if (a == b)
      return true;
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].eq(b[i]))
        return false;
    return true;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return _Mark.none;
    if (marks instanceof _Mark)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a, b) => a.type.rank - b.type.rank);
    return copy2;
  }
};
Mark.none = [];
var ReplaceError = class extends Error {
};
var Slice = class _Slice {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new _Slice(content, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(from2, to) {
    return new _Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      return _Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new _Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
      openStart++;
    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
      openEnd++;
    return new _Slice(fragment, openStart, openEnd);
  }
};
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content, from2, to) {
  let { index, offset: offset2 } = content.findIndex(from2), child = content.maybeChild(index);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset2 == from2 || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from2).append(content.cut(to));
  }
  if (index != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index, child.copy(removeRange(child.content, from2 - offset2 - 1, to - offset2 - 1)));
}
function insertInto(content, dist, insert2, parent) {
  let { index, offset: offset2 } = content.findIndex(dist), child = content.maybeChild(index);
  if (offset2 == dist || child.isText) {
    if (parent && !parent.canReplace(index, index, insert2))
      return null;
    return content.cut(0, dist).append(insert2).append(content.cut(dist));
  }
  let inner = insertInto(child.content, dist - offset2 - 1, insert2);
  return inner && content.replaceChild(index, child.copy(inner));
}
function replace($from, $to, slice2) {
  if (slice2.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice2, 0);
}
function replaceOuter($from, $to, slice2, depth) {
  let index = $from.index(depth), node = $from.node(depth);
  if (index == $to.index(depth) && depth < $from.depth - slice2.openStart) {
    let inner = replaceOuter($from, $to, slice2, depth + 1);
    return node.copy(node.content.replaceChild(index, inner));
  } else if (!slice2.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
  } else {
    let { start: start2, end: end2 } = prepareSliceForReplace(slice2, $from);
    return close(node, replaceThreeWay($from, start2, end2, $to, depth));
  }
}
function checkJoin(main2, sub) {
  if (!sub.type.compatibleContent(main2.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main2.type.name);
}
function joinable($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  let last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    target[last] = child.withText(target[last].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i = startIndex; i < endIndex; i++)
    addNode(node.child(i), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function prepareSliceForReplace(slice2, $along) {
  let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
  let node = parent.copy(slice2.content);
  for (let i = extra - 1; i >= 0; i--)
    node = $along.node(i).copy(Fragment.from(node));
  return {
    start: node.resolveNoCache(slice2.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
  };
}
var ResolvedPos = class _ResolvedPos {
  /**
  @internal
  */
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let parent = this.parent, index = this.index(this.depth);
    if (index == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
    return dOff ? parent.child(index).cut(dOff) : child;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let index = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index).cut(0, dOff);
    return index == 0 ? null : this.parent.child(index - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(index, depth) {
    depth = this.resolveDepth(depth);
    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i = 0; i < index; i++)
      pos += node.child(i).nodeSize;
    return pos;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let parent = this.parent, index = this.index();
    if (parent.content.size == 0)
      return Mark.none;
    if (this.textOffset)
      return parent.child(index).marks;
    let main2 = parent.maybeChild(index - 1), other = parent.maybeChild(index);
    if (!main2) {
      let tmp = main2;
      main2 = other;
      other = tmp;
    }
    let marks = main2.marks;
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
        return new NodeRange(this, other, d);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  /**
  @internal
  */
  toString() {
    let str = "";
    for (let i = 1; i <= this.depth; i++)
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    return str + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(doc3, pos) {
    if (!(pos >= 0 && pos <= doc3.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start2 = 0, parentOffset = pos;
    for (let node = doc3; ; ) {
      let { index, offset: offset2 } = node.content.findIndex(parentOffset);
      let rem = parentOffset - offset2;
      path.push(node, index, start2 + offset2);
      if (!rem)
        break;
      node = node.child(index);
      if (node.isText)
        break;
      parentOffset = rem - 1;
      start2 += offset2 + 1;
    }
    return new _ResolvedPos(pos, path, parentOffset);
  }
  /**
  @internal
  */
  static resolveCached(doc3, pos) {
    for (let i = 0; i < resolveCache.length; i++) {
      let cached = resolveCache[i];
      if (cached.pos == pos && cached.doc == doc3)
        return cached;
    }
    let result = resolveCache[resolveCachePos] = _ResolvedPos.resolve(doc3, pos);
    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
    return result;
  }
};
var resolveCache = [];
var resolveCachePos = 0;
var resolveCacheSize = 12;
var NodeRange = class {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
};
var emptyAttrs = /* @__PURE__ */ Object.create(null);
var Node = class _Node {
  /**
  @internal
  */
  constructor(type, attrs, content, marks = Mark.none) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(index) {
    return this.content.child(index);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index) {
    return this.content.maybeChild(index);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    this.content.forEach(f);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(from2, to, f, startPos = 0) {
    this.content.nodesBetween(from2, to, f, startPos, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(from2, to, blockSeparator, leafText) {
    return this.content.textBetween(from2, to, blockSeparator, leafText);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(type, attrs, marks) {
    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(content = null) {
    if (content == this.content)
      return this;
    return new _Node(this.type, this.attrs, content, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(marks) {
    return marks == this.marks ? this : new _Node(this.type, this.attrs, this.content, marks);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(from2, to = this.content.size) {
    if (from2 == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from2, to));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(from2, to = this.content.size, includeParents = false) {
    if (from2 == to)
      return Slice.empty;
    let $from = this.resolve(from2), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start2 = $from.start(depth), node = $from.node(depth);
    let content = node.content.cut($from.pos - start2, $to.pos - start2);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(from2, to, slice2) {
    return replace(this.resolve(from2), this.resolve(to), slice2);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(pos) {
    for (let node = this; ; ) {
      let { index, offset: offset2 } = node.content.findIndex(pos);
      node = node.maybeChild(index);
      if (!node)
        return null;
      if (offset2 == pos || node.isText)
        return node;
      pos -= offset2 + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(pos) {
    let { index, offset: offset2 } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index), index, offset: offset2 };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index, offset: offset2 } = this.content.findIndex(pos);
    if (offset2 < pos)
      return { node: this.content.child(index), index, offset: offset2 };
    let node = this.content.child(index - 1);
    return { node, index: index - 1, offset: offset2 - node.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  /**
  @internal
  */
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(from2, to, type) {
    let found2 = false;
    if (to > from2)
      this.nodesBetween(from2, to, (node) => {
        if (type.isInSet(node.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(index) {
    let match = this.type.contentMatch.matchFragment(this.content, 0, index);
    if (!match)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(from2, to, replacement = Fragment.empty, start2 = 0, end2 = replacement.childCount) {
    let one = this.contentMatchAt(from2).matchFragment(replacement, start2, end2);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i = start2; i < end2; i++)
      if (!this.type.allowsMarks(replacement.child(i).marks))
        return false;
    return true;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(from2, to, type, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start2 = this.contentMatchAt(from2).matchType(type);
    let end2 = start2 && start2.matchFragment(this.content, to);
    return end2 ? end2.validEnd : false;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise error when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    let copy2 = Mark.none;
    for (let i = 0; i < this.marks.length; i++)
      copy2 = this.marks[i].addToSet(copy2);
    if (!Mark.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
    this.content.forEach((node) => node.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n) => n.toJSON());
    return obj;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = null;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json.text, marks);
    }
    let content = Fragment.fromJSON(schema, json.content);
    return schema.nodeType(json.type).create(json.attrs, content, marks);
  }
};
Node.prototype.text = void 0;
var TextNode = class _TextNode extends Node {
  /**
  @internal
  */
  constructor(type, attrs, content, marks) {
    super(type, attrs, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from2, to) {
    return this.text.slice(from2, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new _TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text2) {
    if (text2 == this.text)
      return this;
    return new _TextNode(this.type, this.attrs, text2, this.marks);
  }
  cut(from2 = 0, to = this.text.length) {
    if (from2 == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from2, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base2 = super.toJSON();
    base2.text = this.text;
    return base2;
  }
};
function wrapMarks(marks, str) {
  for (let i = marks.length - 1; i >= 0; i--)
    str = marks[i].type.name + "(" + str + ")";
  return str;
}
var ContentMatch = class _ContentMatch {
  /**
  @internal
  */
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(string, nodeTypes) {
    let stream = new TokenStream(string, nodeTypes);
    if (stream.next == null)
      return _ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match = dfa(nfa(expr));
    checkForDeadEnds(match, stream);
    return match;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(type) {
    for (let i = 0; i < this.next.length; i++)
      if (this.next[i].type == type)
        return this.next[i].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(frag, start2 = 0, end2 = frag.childCount) {
    let cur = this;
    for (let i = start2; cur && i < end2; i++)
      cur = cur.matchType(frag.child(i).type);
    return cur;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let i = 0; i < this.next.length; i++) {
      let { type } = this.next[i];
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(other) {
    for (let i = 0; i < this.next.length; i++)
      for (let j = 0; j < other.next.length; j++)
        if (this.next[i].type == other.next[j].type)
          return true;
    return false;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(after, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search(match, types) {
      let finished = match.matchFragment(after, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment.from(types.map((tp) => tp.createAndFill()));
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found2 = search(next, types.concat(type));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(target) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == target)
        return this.wrapCache[i + 1];
    let computed = this.computeWrapping(target);
    this.wrapCache.push(target, computed);
    return computed;
  }
  /**
  @internal
  */
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        let result = [];
        for (let obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(n) {
    if (n >= this.next.length)
      throw new RangeError(`There's no ${n}th edge in this content match`);
    return this.next[n];
  }
  /**
  @internal
  */
  toString() {
    let seen = [];
    function scan(m) {
      seen.push(m);
      for (let i = 0; i < m.next.length; i++)
        if (seen.indexOf(m.next[i].next) == -1)
          scan(m.next[i].next);
    }
    scan(this);
    return seen.map((m, i) => {
      let out = i + (m.validEnd ? "*" : " ") + " ";
      for (let i2 = 0; i2 < m.next.length; i2++)
        out += (i2 ? ", " : "") + m.next[i2].type.name + "->" + seen.indexOf(m.next[i2].next);
      return out;
    }).join("\n");
  }
};
ContentMatch.empty = new ContentMatch(true);
var TokenStream = class {
  constructor(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
};
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min2 = parseNum(stream), max2 = min2;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max2 = parseNum(stream);
    else
      max2 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min2, max: max2, expr };
}
function resolveName(stream, name) {
  let types = stream.nodeTypes, type = types[name];
  if (type)
    return [type];
  let result = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.groups.indexOf(name) > -1)
      result.push(type2);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from2, to, term) {
    let edge2 = { term, to };
    nfa2[from2].push(edge2);
    return edge2;
  }
  function connect(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile(expr2, from2) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);
    } else if (expr2.type == "seq") {
      for (let i = 0; ; i++) {
        let next = compile(expr2.exprs[i], from2);
        if (i == expr2.exprs.length - 1)
          return next;
        connect(next, from2 = node());
      }
    } else if (expr2.type == "star") {
      let loop2 = node();
      edge(from2, loop2);
      connect(compile(expr2.expr, loop2), loop2);
      return [edge(loop2)];
    } else if (expr2.type == "plus") {
      let loop2 = node();
      connect(compile(expr2.expr, from2), loop2);
      connect(compile(expr2.expr, loop2), loop2);
      return [edge(loop2)];
    } else if (expr2.type == "opt") {
      return [edge(from2)].concat(compile(expr2.expr, from2));
    } else if (expr2.type == "range") {
      let cur = from2;
      for (let i = 0; i < expr2.min; i++) {
        let next = node();
        connect(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect(compile(expr2.expr, cur), cur);
      } else {
        for (let i = expr2.min; i < expr2.max; i++) {
          let next = node();
          edge(cur, next);
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from2, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a, b) {
  return b - a;
}
function nullFrom(nfa2, node) {
  let result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node2) {
    let edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node2);
    for (let i = 0; i < edges.length; i++) {
      let { term, to } = edges[i];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node) => {
      nfa2[node].forEach(({ term, to }) => {
        if (!term)
          return;
        let set;
        for (let i = 0; i < out.length; i++)
          if (out[i][0] == term)
            set = out[i][1];
        nullFrom(nfa2, to).forEach((node2) => {
          if (!set)
            out.push([term, set = []]);
          if (set.indexOf(node2) == -1)
            set.push(node2);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i = 0; i < out.length; i++) {
      let states2 = out[i][1].sort(cmp);
      state.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (let i = 0, work = [match]; i < work.length; i++) {
    let state = work[i], dead = !state.validEnd, nodes = [];
    for (let j = 0; j < state.next.length; j++) {
      let { type, next } = state.next[j];
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults2 = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr2 = attrs[attrName];
    if (!attr2.hasDefault)
      return null;
    defaults2[attrName] = attr2.default;
  }
  return defaults2;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === void 0) {
      let attr2 = attrs[name];
      if (attr2.hasDefault)
        given = attr2.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function initAttrs(attrs) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name in attrs)
      result[name] = new Attribute(attrs[name]);
  return result;
}
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let n in this.attrs)
      if (this.attrs[n].isRequired)
        return true;
    return false;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(attrs = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(attrs = null, content, marks) {
    content = Fragment.from(content);
    this.checkContent(content);
    return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(attrs = null, content, marks) {
    attrs = this.computeAttrs(attrs);
    content = Fragment.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before)
        return null;
      content = before.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after = matched && matched.fillBefore(Fragment.empty, true);
    if (!after)
      return null;
    return new Node(this, attrs, content.append(after), Mark.setFrom(marks));
  }
  /**
  Returns true if the given fragment is valid content for this node
  type with the given attributes.
  */
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd)
      return false;
    for (let i = 0; i < content.childCount; i++)
      if (!this.allowsMarks(content.child(i).marks))
        return false;
    return true;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(content) {
    if (!this.validContent(content))
      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i = 0; i < marks.length; i++)
      if (!this.allowsMarkType(marks[i].type))
        return false;
    return true;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i = 0; i < marks.length; i++) {
      if (!this.allowsMarkType(marks[i].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i);
      } else if (copy2) {
        copy2.push(marks[i]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark.none;
  }
  /**
  @internal
  */
  static compile(nodes, schema) {
    let result = /* @__PURE__ */ Object.create(null);
    nodes.forEach((name, spec) => result[name] = new _NodeType(name, schema, spec));
    let topType = schema.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _ in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
};
var Attribute = class {
  constructor(options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
  }
  get isRequired() {
    return !this.hasDefault;
  }
};
var MarkType = class _MarkType {
  /**
  @internal
  */
  constructor(name, rank, schema, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(spec.attrs);
    this.excluded = null;
    let defaults2 = defaultAttrs(this.attrs);
    this.instance = defaults2 ? new Mark(this, defaults2) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark(this, computeAttrs(this.attrs, attrs));
  }
  /**
  @internal
  */
  static compile(marks, schema) {
    let result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new _MarkType(name, rank++, schema, spec));
    return result;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(set) {
    for (var i = 0; i < set.length; i++)
      if (set[i].type == this) {
        set = set.slice(0, i).concat(set.slice(i + 1));
        i--;
      }
    return set;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (set[i].type == this)
        return set[i];
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
};
var Schema = class {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(spec) {
    this.cached = /* @__PURE__ */ Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes;
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(type, attrs = null, content, marks) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs, content, marks);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(text2, marks) {
    let type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text2, Mark.setFrom(marks));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(type, attrs) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(json) {
    return Node.fromJSON(this, json);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(json) {
    return Mark.fromJSON(this, json);
  }
  /**
  @internal
  */
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
};
function gatherMarks(schema, marks) {
  let found2 = [];
  for (let i = 0; i < marks.length; i++) {
    let name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema.marks) {
        let mark2 = schema.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }
  return found2;
}
var DOMParser2 = class _DOMParser {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(schema, rules) {
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    rules.forEach((rule) => {
      if (rule.tag)
        this.tags.push(rule);
      else if (rule.style)
        this.styles.push(rule);
    });
    this.normalizeLists = !this.tags.some((r2) => {
      if (!/^(ul|ol)\b/.test(r2.tag) || !r2.node)
        return false;
      let node = schema.nodes[r2.node];
      return node.contentMatch.matchType(node);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(dom, options = {}) {
    let context = new ParseContext(this, options, false);
    context.addAll(dom, options.from, options.to);
    return context.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(dom, options = {}) {
    let context = new ParseContext(this, options, true);
    context.addAll(dom, options.from, options.to);
    return Slice.maxOpen(context.finish());
  }
  /**
  @internal
  */
  matchTag(dom, context, after) {
    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
      let rule = this.tags[i];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(prop, value, context, after) {
    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
      let rule = this.styles[i], style2 = rule.style;
      if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  }
  /**
  @internal
  */
  static schemaRules(schema) {
    let result = [];
    function insert2(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result.length; i++) {
        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i, 0, rule);
    }
    for (let name in schema.marks) {
      let rules = schema.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert2(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name;
        });
    }
    for (let name in schema.nodes) {
      let rules = schema.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert2(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name;
        });
    }
    return result;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new _DOMParser(schema, _DOMParser.schemaRules(schema)));
  }
};
var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = { ol: true, ul: true };
var OPT_PRESERVE_WS = 1;
var OPT_PRESERVE_WS_FULL = 2;
var OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
var NodeContext = class {
  constructor(type, attrs, marks, pendingMarks, solid, match, options) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.pendingMarks = pendingMarks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark.none;
    this.stashMarks = [];
    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  findWrapping(node) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start2 = this.type.contentMatch, wrap2;
        if (wrap2 = start2.findWrapping(node.type)) {
          this.match = start2;
          return wrap2;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last = this.content[this.content.length - 1], m;
      if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
        let text2 = last;
        if (last.text.length == m[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text2.withText(text2.text.slice(0, text2.text.length - m[0].length));
      }
    }
    let content = Fragment.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  popFromStashMark(mark) {
    for (let i = this.stashMarks.length - 1; i >= 0; i--)
      if (mark.eq(this.stashMarks[i]))
        return this.stashMarks.splice(i, 1)[0];
  }
  applyPending(nextType) {
    for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {
      let mark = pending[i];
      if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
        this.activeMarks = mark.addToSet(this.activeMarks);
        this.pendingMarks = mark.removeFromSet(this.pendingMarks);
      }
    }
  }
  inlineContext(node) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
  }
};
var ParseContext = class {
  constructor(parser, options, isOpen) {
    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    let topNode = options.topNode, topContext;
    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(dom) {
    if (dom.nodeType == 3)
      this.addTextNode(dom);
    else if (dom.nodeType == 1)
      this.addElement(dom);
  }
  withStyleRules(dom, f) {
    let style2 = dom.getAttribute("style");
    if (!style2)
      return f();
    let marks = this.readStyles(parseStyles(style2));
    if (!marks)
      return;
    let [addMarks, removeMarks] = marks, top2 = this.top;
    for (let i = 0; i < removeMarks.length; i++)
      this.removePendingMark(removeMarks[i], top2);
    for (let i = 0; i < addMarks.length; i++)
      this.addPendingMark(addMarks[i]);
    f();
    for (let i = 0; i < addMarks.length; i++)
      this.removePendingMark(addMarks[i], top2);
    for (let i = 0; i < removeMarks.length; i++)
      this.addPendingMark(removeMarks[i]);
  }
  addTextNode(dom) {
    let value = dom.nodeValue;
    let top2 = this.top;
    if (top2.options & OPT_PRESERVE_WS_FULL || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!(top2.options & OPT_PRESERVE_WS)) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top2.content[top2.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (!(top2.options & OPT_PRESERVE_WS_FULL)) {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value)
        this.insertNode(this.parser.schema.text(value));
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(dom, matchAfter) {
    let name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom);
      this.ignoreFallback(dom);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom = rule.skip;
      let sync, top2 = this.top, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        if (top2.content.length && top2.content[0].isInline && this.open) {
          this.open--;
          top2 = this.top;
        }
        sync = true;
        if (!top2.type)
          this.needsBlock = true;
      } else if (!dom.firstChild) {
        this.leafFallback(dom);
        return;
      }
      if (rule && rule.skip)
        this.addAll(dom);
      else
        this.withStyleRules(dom, () => this.addAll(dom));
      if (sync)
        this.sync(top2);
      this.needsBlock = oldNeedsBlock;
    } else {
      this.withStyleRules(dom, () => {
        this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : void 0);
      });
    }
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(dom) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"));
  }
  // Called for ignored nodes
  ignoreFallback(dom) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"));
  }
  // Run any style parser associated with the node's styles. Either
  // return an array of marks, or null to indicate some of the styles
  // had a rule with `ignore` set.
  readStyles(styles) {
    let add = Mark.none, remove = Mark.none;
    for (let i = 0; i < styles.length; i += 2) {
      for (let after = void 0; ; ) {
        let rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);
        if (!rule)
          break;
        if (rule.ignore)
          return null;
        if (rule.clearMark) {
          this.top.pendingMarks.concat(this.top.activeMarks).forEach((m) => {
            if (rule.clearMark(m))
              remove = m.addToSet(remove);
          });
        } else {
          add = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(add);
        }
        if (rule.consuming === false)
          after = rule;
        else
          break;
      }
    }
    return [add, remove];
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(dom, rule, continueAfter) {
    let sync, nodeType, mark;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
      } else if (!this.insertNode(nodeType.create(rule.attrs))) {
        this.leafFallback(dom);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      mark = markType.create(rule.attrs);
      this.addPendingMark(mark);
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM);
    }
    if (sync && this.sync(startIn))
      this.open--;
    if (mark)
      this.removePendingMark(mark, startIn);
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(parent, startIndex, endIndex) {
    let index = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end2 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end2; dom = dom.nextSibling, ++index) {
      this.findAtPoint(parent, index);
      this.addDOM(dom);
    }
    this.findAtPoint(parent, index);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(node) {
    let route, sync;
    for (let depth = this.open; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node);
      if (found2 && (!route || route.length > found2.length)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid)
        break;
    }
    if (!route)
      return false;
    this.sync(sync);
    for (let i = 0; i < route.length; i++)
      this.enterInner(route[i], null, false);
    return true;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(node) {
    if (node.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        this.enterInner(block);
    }
    if (this.findPlace(node)) {
      this.closeExtra();
      let top2 = this.top;
      top2.applyPending(node.type);
      if (top2.match)
        top2.match = top2.match.matchType(node.type);
      let marks = top2.activeMarks;
      for (let i = 0; i < node.marks.length; i++)
        if (!top2.type || top2.type.allowsMarkType(node.marks[i].type))
          marks = node.marks[i].addToSet(marks);
      top2.content.push(node.mark(marks));
      return true;
    }
    return false;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(type, attrs, preserveWS) {
    let ok = this.findPlace(type.create(attrs));
    if (ok)
      this.enterInner(type, attrs, true, preserveWS);
    return ok;
  }
  // Open a node of the given type
  enterInner(type, attrs = null, solid = false, preserveWS) {
    this.closeExtra();
    let top2 = this.top;
    top2.applyPending(type);
    top2.match = top2.match && top2.match.matchType(type);
    let options = wsOptionsFor(type, preserveWS, top2.options);
    if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0)
      options |= OPT_OPEN_LEFT;
    this.nodes.push(new NodeContext(type, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options));
    this.open++;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(openEnd = false) {
    let i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--)
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(to) {
    for (let i = this.open; i >= 0; i--)
      if (this.nodes[i] == to) {
        this.open = i;
        return true;
      }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i = this.open; i >= 0; i--) {
      let content = this.nodes[i].content;
      for (let j = content.length - 1; j >= 0; j--)
        pos += content[j].nodeSize;
      if (i)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset2) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset2)
          this.find[i].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
          this.find[i].pos = this.currentPos;
      }
  }
  findAround(parent, content, before) {
    if (parent != content && this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          let pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4))
            this.find[i].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode)
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
  }
  // Determines whether the given context string matches this context.
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match = (i, depth) => {
      for (; i >= 0; i--) {
        let part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match(i - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && next.groups.indexOf(part) == -1)
            return false;
          depth--;
        }
      }
      return true;
    };
    return match(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d = $context.depth; d >= 0; d--) {
        let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  }
  addPendingMark(mark) {
    let found2 = findSameMarkInSet(mark, this.top.pendingMarks);
    if (found2)
      this.top.stashMarks.push(found2);
    this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
  }
  removePendingMark(mark, upto) {
    for (let depth = this.open; depth >= 0; depth--) {
      let level = this.nodes[depth];
      let found2 = level.pendingMarks.lastIndexOf(mark);
      if (found2 > -1) {
        level.pendingMarks = mark.removeFromSet(level.pendingMarks);
      } else {
        level.activeMarks = mark.removeFromSet(level.activeMarks);
        let stashMark = level.popFromStashMark(mark);
        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
          level.activeMarks = stashMark.addToSet(level.activeMarks);
      }
      if (level == upto)
        break;
    }
  }
};
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles(style2) {
  let re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
  while (m = re.exec(style2))
    result.push(m[1], m[2].trim());
  return result;
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name in nodes) {
    let parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match) => {
      seen.push(match);
      for (let i = 0; i < match.edgeCount; i++) {
        let { type, next } = match.edge(i);
        if (type == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
function findSameMarkInSet(mark, set) {
  for (let i = 0; i < set.length; i++) {
    if (mark.eq(set[i]))
      return set[i];
  }
}
var DOMSerializer = class _DOMSerializer {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(fragment, options = {}, target) {
    if (!target)
      target = doc(options).createDocumentFragment();
    let top2 = target, active = [];
    fragment.forEach((node) => {
      if (active.length || node.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node.marks.length) {
          let next = node.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top2 = active.pop()[1];
        while (rendered < node.marks.length) {
          let add = node.marks[rendered++];
          let markDOM = this.serializeMark(add, node.isInline, options);
          if (markDOM) {
            active.push([add, top2]);
            top2.appendChild(markDOM.dom);
            top2 = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top2.appendChild(this.serializeNodeInner(node, options));
    });
    return target;
  }
  /**
  @internal
  */
  serializeNodeInner(node, options) {
    let { dom, contentDOM } = _DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));
    if (contentDOM) {
      if (node.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node.content, options, contentDOM);
    }
    return dom;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(node, options = {}) {
    let dom = this.serializeNodeInner(node, options);
    for (let i = node.marks.length - 1; i >= 0; i--) {
      let wrap2 = this.serializeMark(node.marks[i], node.isInline, options);
      if (wrap2) {
        (wrap2.contentDOM || wrap2.dom).appendChild(dom);
        dom = wrap2.dom;
      }
    }
    return dom;
  }
  /**
  @internal
  */
  serializeMark(mark, inline, options = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && _DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));
  }
  /**
  Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
  the spec has a hole (zero) in it, `contentDOM` will point at the
  node with the hole.
  */
  static renderSpec(doc3, structure, xmlNS = null) {
    if (typeof structure == "string")
      return { dom: doc3.createTextNode(structure) };
    if (structure.nodeType != null)
      return { dom: structure };
    if (structure.dom && structure.dom.nodeType != null)
      return structure;
    let tagName = structure[0], space2 = tagName.indexOf(" ");
    if (space2 > 0) {
      xmlNS = tagName.slice(0, space2);
      tagName = tagName.slice(space2 + 1);
    }
    let contentDOM;
    let dom = xmlNS ? doc3.createElementNS(xmlNS, tagName) : doc3.createElement(tagName);
    let attrs = structure[1], start2 = 1;
    if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
      start2 = 2;
      for (let name in attrs)
        if (attrs[name] != null) {
          let space3 = name.indexOf(" ");
          if (space3 > 0)
            dom.setAttributeNS(name.slice(0, space3), name.slice(space3 + 1), attrs[name]);
          else
            dom.setAttribute(name, attrs[name]);
        }
    }
    for (let i = start2; i < structure.length; i++) {
      let child = structure[i];
      if (child === 0) {
        if (i < structure.length - 1 || i > start2)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom, contentDOM: dom };
      } else {
        let { dom: inner, contentDOM: innerContent } = _DOMSerializer.renderSpec(doc3, child, xmlNS);
        dom.appendChild(inner);
        if (innerContent) {
          if (contentDOM)
            throw new RangeError("Multiple content holes");
          contentDOM = innerContent;
        }
      }
    }
    return { dom, contentDOM };
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(schema) {
    let result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = (node) => node.text;
    return result;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
};
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc(options) {
  return options.document || window.document;
}

// node_modules/prosemirror-transform/dist/index.js
var lower16 = 65535;
var factor16 = Math.pow(2, 16);
function makeRecover(index, offset2) {
  return index + offset2 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
var DEL_BEFORE = 1;
var DEL_AFTER = 2;
var DEL_ACROSS = 4;
var DEL_SIDE = 8;
var MapResult = class {
  /**
  @internal
  */
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
};
var StepMap = class _StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && _StepMap.empty)
      return _StepMap.empty;
  }
  /**
  @internal
  */
  recover(value) {
    let diff = 0, index = recoverIndex(value);
    if (!this.inverted)
      for (let i = 0; i < index; i++)
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start2 > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end2 = start2 + oldSize;
      if (pos <= end2) {
        let side = !oldSize ? assoc : pos == start2 ? -1 : pos == end2 ? 1 : assoc;
        let result = start2 + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start2 : end2) ? null : makeRecover(i / 3, pos - start2);
        let del2 = pos == start2 ? DEL_AFTER : pos == end2 ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start2 : pos != end2)
          del2 |= DEL_SIDE;
        return new MapResult(result, del2, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  /**
  @internal
  */
  touches(pos, recover) {
    let diff = 0, index = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start2 > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], end2 = start2 + oldSize;
      if (pos <= end2 && i == index * 3)
        return true;
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i], oldStart = start2 - (this.inverted ? diff : 0), newStart = start2 + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new _StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(n) {
    return n == 0 ? _StepMap.empty : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
  }
};
StepMap.empty = new StepMap([]);
var Mapping = class _Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(maps = [], mirror, from2 = 0, to = maps.length) {
    this.maps = maps;
    this.mirror = mirror;
    this.from = from2;
    this.to = to;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(from2 = 0, to = this.maps.length) {
    return new _Mapping(this.maps, this.mirror, from2, to);
  }
  /**
  @internal
  */
  copy() {
    return new _Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(map2, mirrors) {
    this.to = this.maps.push(map2);
    if (mirrors != null)
      this.setMirror(this.maps.length - 1, mirrors);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(mapping) {
    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(n) {
    if (this.mirror) {
      for (let i = 0; i < this.mirror.length; i++)
        if (this.mirror[i] == n)
          return this.mirror[i + (i % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(n, m) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n, m);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(mapping) {
    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let inverse = new _Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  /**
  Map a position through this mapping.
  */
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i = this.from; i < this.to; i++)
      pos = this.maps[i].map(pos, assoc);
    return pos;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i = this.from; i < this.to; i++) {
      let map2 = this.maps[i], result = map2.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this.maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
};
var stepsByID = /* @__PURE__ */ Object.create(null);
var Step = class {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(other) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type = stepsByID[json.stepType];
    if (!type)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type.fromJSON(schema, json);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
};
var StepResult = class _StepResult {
  /**
  @internal
  */
  constructor(doc3, failed) {
    this.doc = doc3;
    this.failed = failed;
  }
  /**
  Create a successful step result.
  */
  static ok(doc3) {
    return new _StepResult(doc3, null);
  }
  /**
  Create a failed step result.
  */
  static fail(message) {
    return new _StepResult(null, message);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(doc3, from2, to, slice2) {
    try {
      return _StepResult.ok(doc3.replace(from2, to, slice2));
    } catch (e) {
      if (e instanceof ReplaceError)
        return _StepResult.fail(e.message);
      throw e;
    }
  }
};
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i = 0; i < fragment.childCount; i++) {
    let child = fragment.child(i);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}
var AddMarkStep = class _AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc3) {
    let oldSlice = doc3.slice(this.from, this.to), $from = doc3.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node;
      return node.mark(this.mark.addToSet(node.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc3, this.from, this.to, slice2);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new _AddMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new _AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("addMark", AddMarkStep);
var RemoveMarkStep = class _RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc3) {
    let oldSlice = doc3.slice(this.from, this.to);
    let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {
      return node.mark(this.mark.removeFromSet(node.marks));
    }, doc3), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc3, this.from, this.to, slice2);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new _RemoveMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new _RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("removeMark", RemoveMarkStep);
var AddNodeMarkStep = class _AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (node) {
      let newSet = this.mark.addToSet(node.marks);
      if (newSet.length == node.marks.length) {
        for (let i = 0; i < node.marks.length; i++)
          if (!node.marks[i].isInSet(newSet))
            return new _AddNodeMarkStep(this.pos, node.marks[i]);
        return new _AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new _AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("addNodeMark", AddNodeMarkStep);
var RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node || !this.mark.isInSet(node.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new _RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
var ReplaceStep = class _ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(from2, to, slice2, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.slice = slice2;
    this.structure = structure;
  }
  apply(doc3) {
    if (this.structure && contentBetween(doc3, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc3, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc3) {
    return new _ReplaceStep(this.from, this.from + this.slice.size, doc3.slice(this.from, this.to));
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deletedAcross && to.deletedAcross)
      return null;
    return new _ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice);
  }
  merge(other) {
    if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new _ReplaceStep(other.from, this.to, slice2, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new _ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
};
Step.jsonID("replace", ReplaceStep);
var ReplaceAroundStep = class _ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(from2, to, gapFrom, gapTo, slice2, insert2, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice2;
    this.insert = insert2;
    this.structure = structure;
  }
  apply(doc3) {
    if (this.structure && (contentBetween(doc3, this.from, this.gapFrom) || contentBetween(doc3, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc3.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc3, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc3) {
    let gap = this.gapTo - this.gapFrom;
    return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc3.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
      return null;
    return new _ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new _ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
};
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc3, from2, to) {
  let $from = doc3.resolve(from2), dist = to - from2, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr2, from2, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr2.doc.nodesBetween(from2, to, (node, pos, parent) => {
    if (!node.isInline)
      return;
    let marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start2 = Math.max(pos, from2), end2 = Math.min(pos + node.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start2 && removing.mark.eq(marks[i]))
            removing.to = end2;
          else
            removed.push(removing = new RemoveMarkStep(start2, end2, marks[i]));
        }
      }
      if (adding && adding.to == start2)
        adding.to = end2;
      else
        added.push(adding = new AddMarkStep(start2, end2, mark));
    }
  });
  removed.forEach((s) => tr2.step(s));
  added.forEach((s) => tr2.step(s));
}
function removeMark(tr2, from2, to, mark) {
  let matched = [], step = 0;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set = node.marks, found2;
      while (found2 = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found2);
        set = found2.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end2 = Math.min(pos + node.nodeSize, to);
      for (let i = 0; i < toRemove.length; i++) {
        let style2 = toRemove[i], found2;
        for (let j = 0; j < matched.length; j++) {
          let m = matched[j];
          if (m.step == step - 1 && style2.eq(matched[j].style))
            found2 = m;
        }
        if (found2) {
          found2.to = end2;
          found2.step = step;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from2), to: end2, step });
        }
      }
    }
  });
  matched.forEach((m) => tr2.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr2, pos, parentType, match = parentType.contentMatch) {
  let node = tr2.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i = 0; i < node.childCount; i++) {
    let child = node.child(i), end2 = cur + child.nodeSize;
    let allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end2, Slice.empty));
    } else {
      match = allowed;
      for (let j = 0; j < child.marks.length; j++)
        if (!parentType.allowsMarkType(child.marks[j].type))
          tr2.step(new RemoveMarkStep(cur, end2, child.marks[j]));
      if (child.isText && !parentType.spec.code) {
        let m, newline = /\r?\n|\r/g, slice2;
        while (m = newline.exec(child.text)) {
          if (!slice2)
            slice2 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
        }
      }
    }
    cur = end2;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment.empty, true);
    tr2.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i = replSteps.length - 1; i >= 0; i--)
    tr2.step(replSteps[i]);
}
function canCut(node, start2, end2) {
  return (start2 == 0 || node.canReplace(start2, node.childCount)) && (end2 == node.childCount || node.canReplace(0, end2));
}
function liftTarget(range) {
  let parent = range.parent;
  let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (let depth = range.depth; ; --depth) {
    let node = range.$from.node(depth);
    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index, endIndex, content))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))
      break;
  }
  return null;
}
function lift(tr2, range, target) {
  let { $from, $to, depth } = range;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start2 = gapStart, end2 = gapEnd;
  let before = Fragment.empty, openStart = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start2--;
    }
  let after = Fragment.empty, openEnd = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $to.after(d + 1) < $to.end(d)) {
      splitting = true;
      after = Fragment.from($to.node(d).copy(after));
      openEnd++;
    } else {
      end2++;
    }
  tr2.step(new ReplaceAroundStep(start2, end2, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range, nodeType, attrs = null, innerRange = range) {
  let around = findWrappingOutside(range, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let inner = parent.child(startIndex);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i = startIndex; innerMatch && i < endIndex; i++)
    innerMatch = innerMatch.matchType(parent.child(i).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap(tr2, range, wrappers) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      let match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }
  let start2 = range.start, end2 = range.end;
  tr2.step(new ReplaceAroundStep(start2, end2, start2, end2, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType(tr2, from2, to, type, attrs) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr2.steps.length;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr2.doc, tr2.mapping.slice(mapFrom).map(pos), type)) {
      tr2.clearIncompatible(tr2.mapping.slice(mapFrom).map(pos, 1), type);
      let mapping = tr2.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr2.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
      return false;
    }
  });
}
function canChangeType(doc3, pos, type) {
  let $pos = doc3.resolve(pos), index = $pos.index();
  return $pos.parent.canReplaceWith(index, index + 1, type);
}
function setNodeMarkup(tr2, pos, type, attrs, marks) {
  let node = tr2.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type)
    type = node.type;
  let newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    return tr2.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr2.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
}
function canSplit(doc3, pos, depth = 1, typesAfter) {
  let $pos = doc3.resolve(pos), base2 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
    let node = $pos.node(d), index2 = $pos.index(d);
    if (node.type.spec.isolating)
      return false;
    let rest = node.content.cutByIndex(index2, node.childCount);
    let overrideChild = typesAfter && typesAfter[i + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i] || node;
    if (!node.canReplace(index2 + 1, node.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index = $pos.indexAfter(base2);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function split(tr2, pos, depth = 1, typesAfter) {
  let $pos = tr2.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before = Fragment.from($pos.node(d).copy(before));
    let typeAfter = typesAfter && typesAfter[i];
    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  tr2.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc3, pos) {
  let $pos = doc3.resolve(pos), index = $pos.index();
  return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
}
function joinable2(a, b) {
  return !!(a && b && !a.isLeaf && a.canAppend(b));
}
function joinPoint(doc3, pos, dir = -1) {
  let $pos = doc3.resolve(pos);
  for (let d = $pos.depth; ; d--) {
    let before, after, index = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index++;
      after = $pos.node(d).maybeChild(index);
    } else {
      before = $pos.node(d).maybeChild(index - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d).canReplace(index, index + 1))
      return pos;
    if (d == 0)
      break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
function join(tr2, pos, depth) {
  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
  tr2.step(step);
}
function insertPoint(doc3, pos, nodeType) {
  let $pos = doc3.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType))
        return $pos.before(d + 1);
      if (index > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index = $pos.indexAfter(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType))
        return $pos.after(d + 1);
      if (index < $pos.node(d).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc3, pos, slice2) {
  let $pos = doc3.resolve(pos);
  if (!slice2.content.size)
    return pos;
  let content = slice2.content;
  for (let i = 0; i < slice2.openStart; i++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
    for (let d = $pos.depth; d >= 0; d--) {
      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return null;
}
function replaceStep(doc3, from2, to = from2, slice2 = Slice.empty) {
  if (from2 == to && !slice2.size)
    return null;
  let $from = doc3.resolve(from2), $to = doc3.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return new ReplaceStep(from2, to, slice2);
  return new Fitter($from, $to, slice2).fit();
}
function fitsTrivially($from, $to, slice2) {
  return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
}
var Fitter = class {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment.empty;
    for (let i = 0; i <= $from.depth; i++) {
      let node = $from.node(i);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i))
      });
    }
    for (let i = $from.depth; i > 0; i--)
      this.placed = Fragment.from($from.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice2 = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
    if (slice2.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice2);
    return null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
      let node = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node.type.spec.isolating && openEnd <= d) {
        startDepth = d;
        break;
      }
      cur = node.content;
    }
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first2 = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;
          if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i = 0; i < wrap2.length; i++)
        this.openFrontierNode(wrap2[i]);
    let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
    let openStart = slice2.openStart - sliceDepth;
    let taken = 0, add = [];
    let { match, type } = this.frontier[frontierDepth];
    if (inject) {
      for (let i = 0; i < inject.childCount; i++)
        add.push(inject.child(i));
      match = match.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches2 = match.matchType(next.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = matches2;
        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i = 0, cur = fragment; i < openEndCount; i++) {
      let node = cur.lastChild;
      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
      cur = node.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top2 = this.frontier[this.depth], level;
    if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan:
      for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
        let { match, type } = this.frontier[i];
        let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        let fit = contentAfterFits($to, i, type, match, dropInner);
        if (!fit)
          continue;
        for (let d = i - 1; d >= 0; d--) {
          let { match: match2, type: type2 } = this.frontier[d];
          let matches2 = contentAfterFits($to, d, type2, match2, true);
          if (!matches2 || matches2.childCount)
            continue scan;
        }
        return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
      }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d = close2.depth + 1; d <= $to.depth; d++) {
      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
      this.openFrontierNode(node.type, node.attrs, add);
    }
    return $to;
  }
  openFrontierNode(type, attrs = null, content) {
    let top2 = this.frontier[this.depth];
    top2.match = top2.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
    this.frontier.push({ type, match: type.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add = open.match.fillBefore(Fragment.empty, true);
    if (add.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add);
  }
};
function dropFromFragment(fragment, depth, count) {
  if (depth == 0)
    return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i = 0; i < depth; i++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  let frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match, open) {
  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index == node.childCount && !type.compatibleContent(node.type))
    return null;
  let fit = match.fillBefore(node.content, true, index);
  return fit && !invalidMarks(type, node.content, index) ? fit : null;
}
function invalidMarks(type, fragment, start2) {
  for (let i = start2; i < fragment.childCount; i++)
    if (!type.allowsMarks(fragment.child(i).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr2, from2, to, slice2) {
  if (!slice2.size)
    return tr2.deleteRange(from2, to);
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return tr2.step(new ReplaceStep(from2, to, slice2));
  let targetDepths = coveredDepths($from, tr2.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    let spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d) > -1)
      preferredTarget = d;
    else if ($from.before(d) == pos)
      targetDepths.splice(1, 0, -d);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice2.openStart;
  for (let content = slice2.content, i = 0; ; i++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i == slice2.openStart)
      break;
    content = node.content;
  }
  for (let d = preferredDepth - 1; d >= 0; d--) {
    let leftNode = leftNodes[d], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j = slice2.openStart; j >= 0; j--) {
    let openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);
    let insert2 = leftNodes[openDepth];
    if (!insert2)
      continue;
    for (let i = 0; i < targetDepths.length; i++) {
      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index, index, insert2.type, insert2.marks))
        return tr2.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
    }
  }
  let startSteps = tr2.steps.length;
  for (let i = targetDepths.length - 1; i >= 0; i--) {
    tr2.replace(from2, to, slice2);
    if (tr2.steps.length > startSteps)
      break;
    let depth = targetDepths[i];
    if (depth < 0)
      continue;
    from2 = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    let match = parent.contentMatchAt(0);
    let start2 = match.fillBefore(fragment).append(fragment);
    fragment = start2.append(match.matchFragment(start2).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr2, from2, to, node) {
  if (!node.isInline && from2 == to && tr2.doc.resolve(from2).parent.content.size) {
    let point = insertPoint(tr2.doc, from2, node.type);
    if (point != null)
      from2 = to = point;
  }
  tr2.replaceRange(from2, to, new Slice(Fragment.from(node), 0, 0));
}
function deleteRange(tr2, from2, to) {
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i = 0; i < covered.length; i++) {
    let depth = covered[i], last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr2.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr2.delete($from.before(depth), $to.after(depth));
  }
  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)
      return tr2.delete($from.before(d), to);
  }
  tr2.delete(from2, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d = minDepth; d >= 0; d--) {
    let start2 = $from.start(d);
    if (start2 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
      break;
    if (start2 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start2 - 1)
      result.push(d);
  }
  return result;
}
var AttrStep = class _AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(pos, attr2, value) {
    super();
    this.pos = pos;
    this.attr = attr2;
    this.value = value;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at attribute step's position");
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in node.attrs)
      attrs[name] = node.attrs[name];
    attrs[this.attr] = this.value;
    let updated = node.type.create(attrs, null, node.marks);
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc3) {
    return new _AttrStep(this.pos, this.attr, doc3.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new _AttrStep(json.pos, json.attr, json.value);
  }
};
Step.jsonID("attr", AttrStep);
var DocAttrStep = class _DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(attr2, value) {
    super();
    this.attr = attr2;
    this.value = value;
  }
  apply(doc3) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in doc3.attrs)
      attrs[name] = doc3.attrs[name];
    attrs[this.attr] = this.value;
    let updated = doc3.type.create(attrs, doc3.content, doc3.marks);
    return StepResult.ok(updated);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc3) {
    return new _DocAttrStep(this.attr, doc3.attrs[this.attr]);
  }
  map(mapping) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new _DocAttrStep(json.attr, json.value);
  }
};
Step.jsonID("docAttr", DocAttrStep);
var TransformError = class extends Error {
};
TransformError = function TransformError2(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
var Transform = class {
  /**
  Create a transform that starts with the given document.
  */
  constructor(doc3) {
    this.doc = doc3;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(step, doc3) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc3;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(from2, to = from2, slice2 = Slice.empty) {
    let step = replaceStep(this.doc, from2, to, slice2);
    if (step)
      this.step(step);
    return this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(from2, to, content) {
    return this.replace(from2, to, new Slice(Fragment.from(content), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(from2, to) {
    return this.replace(from2, to, Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(from2, to, slice2) {
    replaceRange(this, from2, to, slice2);
    return this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(from2, to, node) {
    replaceRangeWith(this, from2, to, node);
    return this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(from2, to) {
    deleteRange(this, from2, to);
    return this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(range, target) {
    lift(this, range, target);
    return this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(range, wrappers) {
    wrap(this, range, wrappers);
    return this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(from2, to = from2, type, attrs = null) {
    setBlockType(this, from2, to, type, attrs);
    return this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(pos, type, attrs = null, marks) {
    setNodeMarkup(this, pos, type, attrs, marks);
    return this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(pos, attr2, value) {
    this.step(new AttrStep(pos, attr2, value));
    return this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(attr2, value) {
    this.step(new DocAttrStep(attr2, value));
    return this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(pos, mark) {
    if (!(mark instanceof Mark)) {
      let node = this.doc.nodeAt(pos);
      if (!node)
        throw new RangeError("No node at position " + pos);
      mark = mark.isInSet(node.marks);
      if (!mark)
        return this;
    }
    this.step(new RemoveNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(from2, to, mark) {
    addMark(this, from2, to, mark);
    return this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(from2, to, mark) {
    removeMark(this, from2, to, mark);
    return this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(pos, parentType, match) {
    clearIncompatible(this, pos, parentType, match);
    return this;
  }
};

// node_modules/prosemirror-state/dist/index.js
var classesById = /* @__PURE__ */ Object.create(null);
var Selection = class {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(tr2, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i = 0; i < content.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      tr2.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
      if (i == 0)
        selectionToInsertionEnd(tr2, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(tr2, node) {
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr2.deleteRange(from2, to);
      } else {
        tr2.replaceRangeWith(from2, to, node);
        selectionToInsertionEnd(tr2, mapFrom, node.isInline ? -1 : 1);
      }
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(doc3) {
    return findSelectionIn(doc3, doc3, 0, 0, 1) || new AllSelection(doc3);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(doc3) {
    return findSelectionIn(doc3, doc3, doc3.content.size, doc3.childCount, -1) || new AllSelection(doc3);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(doc3, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc3, json);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
};
Selection.prototype.visible = true;
var SelectionRange = class {
  /**
  Create a range.
  */
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
};
var warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
var TextSelection = class _TextSelection extends Selection {
  /**
  Construct a text selection between the given points.
  */
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc3, mapping) {
    let $head = doc3.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc3.resolve(mapping.map(this.anchor));
    return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr2, content = Slice.empty) {
    super.replace(tr2, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr2.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new _TextSelection(doc3.resolve(json.anchor), doc3.resolve(json.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(doc3, anchor, head = anchor) {
    let $anchor = doc3.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc3.resolve(head));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new _TextSelection($anchor, $head);
  }
};
Selection.jsonID("text", TextSelection);
var TextBookmark = class _TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc3) {
    return TextSelection.between(doc3.resolve(this.anchor), doc3.resolve(this.head));
  }
};
var NodeSelection = class _NodeSelection extends Selection {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor($pos) {
    let node = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    super($pos, $end);
    this.node = node;
  }
  map(doc3, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc3.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new _NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof _NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new _NodeSelection(doc3.resolve(json.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(doc3, from2) {
    return new _NodeSelection(doc3.resolve(from2));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false;
  }
};
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
var NodeBookmark = class _NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
  }
  resolve(doc3) {
    let $pos = doc3.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
};
var AllSelection = class _AllSelection extends Selection {
  /**
  Create an all-selection over the given document.
  */
  constructor(doc3) {
    super(doc3.resolve(0), doc3.resolve(doc3.content.size));
  }
  replace(tr2, content = Slice.empty) {
    if (content == Slice.empty) {
      tr2.delete(0, tr2.doc.content.size);
      let sel = Selection.atStart(tr2.doc);
      if (!sel.eq(tr2.selection))
        tr2.setSelection(sel);
    } else {
      super.replace(tr2, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(doc3) {
    return new _AllSelection(doc3);
  }
  map(doc3) {
    return new _AllSelection(doc3);
  }
  eq(other) {
    return other instanceof _AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
};
Selection.jsonID("all", AllSelection);
var AllBookmark = {
  map() {
    return this;
  },
  resolve(doc3) {
    return new AllSelection(doc3);
  }
};
function findSelectionIn(doc3, node, pos, index, dir, text2 = false) {
  if (node.inlineContent)
    return TextSelection.create(doc3, pos);
  for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    let child = node.child(i);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc3, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text2);
      if (inner)
        return inner;
    } else if (!text2 && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc3, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd(tr2, startLen, bias) {
  let last = tr2.steps.length - 1;
  if (last < startLen)
    return;
  let step = tr2.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map2 = tr2.mapping.maps[last], end2;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end2 == null)
      end2 = newTo;
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end2), bias));
}
var UPDATED_SEL = 1;
var UPDATED_MARKS = 2;
var UPDATED_SCROLL = 4;
var Transaction = class extends Transform {
  /**
  @internal
  */
  constructor(state) {
    super(state.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.storedMarks = state.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(marks) {
    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  /**
  @internal
  */
  addStep(step, doc3) {
    super.addStep(step, doc3);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(time) {
    this.time = time;
    return this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(slice2) {
    this.selection.replace(this, slice2);
    return this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(node, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
    selection.replaceWith(this, node);
    return this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(text2, from2, to) {
    let schema = this.doc.type.schema;
    if (from2 == null) {
      if (!text2)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text2), true);
    } else {
      if (to == null)
        to = from2;
      to = to == null ? from2 : to;
      if (!text2)
        return this.deleteRange(from2, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from2);
        marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from2, to, schema.text(text2, marks));
      if (!this.selection.empty)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let _ in this.meta)
      return false;
    return true;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
};
function bind(f, self) {
  return !self || !f ? f : f.bind(self);
}
var FieldDesc = class {
  constructor(name, desc, self) {
    this.name = name;
    this.init = bind(desc.init, self);
    this.apply = bind(desc.apply, self);
  }
};
var baseFields = [
  new FieldDesc("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr2) {
      return tr2.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config, instance18) {
      return config.selection || Selection.atStart(instance18.doc);
    },
    apply(tr2) {
      return tr2.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr2, _marks, _old, state) {
      return state.selection.$cursor ? tr2.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr2, prev) {
      return tr2.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
var Configuration = class {
  constructor(schema, plugins) {
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin) => {
        if (this.pluginsByKey[plugin.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        this.plugins.push(plugin);
        this.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      });
  }
};
var EditorState = class _EditorState {
  /**
  @internal
  */
  constructor(config) {
    this.config = config;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(tr2) {
    return this.applyTransaction(tr2).state;
  }
  /**
  @internal
  */
  filterTransaction(tr2, ignore = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != ignore) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr2, this))
          return false;
      }
    return true;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i = 0; i < this.config.plugins.length; i++) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.appendTransaction) {
          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          let tr2 = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
          if (tr2 && newState.filterTransaction(tr2, i)) {
            tr2.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j = 0; j < this.config.plugins.length; j++)
                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr2);
            newState = newState.applyInner(tr2);
            haveNew = true;
          }
          if (seen)
            seen[i] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  /**
  @internal
  */
  applyInner(tr2) {
    if (!tr2.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new _EditorState(this.config), fields = this.config.fields;
    for (let i = 0; i < fields.length; i++) {
      let field = fields[i];
      newInstance[field.name] = field.apply(tr2, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Transaction(this);
  }
  /**
  Create a new state.
  */
  static create(config) {
    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    let instance18 = new _EditorState($config);
    for (let i = 0; i < $config.fields.length; i++)
      instance18[$config.fields[i].name] = $config.fields[i].init(config, instance18);
    return instance18;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(config) {
    let $config = new Configuration(this.schema, config.plugins);
    let fields = $config.fields, instance18 = new _EditorState($config);
    for (let i = 0; i < fields.length; i++) {
      let name = fields[i].name;
      instance18[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance18);
    }
    return instance18;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m) => m.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON)
          result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    return result;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(config, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config.schema, config.plugins);
    let instance18 = new _EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance18.doc = Node.fromJSON(config.schema, json.doc);
      } else if (field.name == "selection") {
        instance18.selection = Selection.fromJSON(instance18.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance18.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance18[field.name] = state.fromJSON.call(plugin, config, json[prop], instance18);
              return;
            }
          }
        instance18[field.name] = field.init(config, instance18);
      }
    });
    return instance18;
  }
};
function bindProps(obj, self, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self, {});
    target[prop] = val;
  }
  return target;
}
var Plugin = class {
  /**
  Create a plugin.
  */
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
};
var keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
var PluginKey = class {
  /**
  Create a plugin key.
  */
  constructor(name = "key") {
    this.key = createKey(name);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(state) {
    return state.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
};

// node_modules/prosemirror-view/dist/index.js
var domIndex = function(node) {
  for (var index = 0; ; index++) {
    node = node.previousSibling;
    if (!node)
      return index;
  }
};
var parentNode = function(node) {
  let parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var reusedRange = null;
var textRange = function(node, from2, to) {
  let range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from2 || 0);
  return range;
};
var isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};
var atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.contentEditable == "false")
        return false;
      off = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isOnEdge(node, offset2, parent) {
  for (let atStart = offset2 == 0, atEnd = offset2 == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index == 0;
    atEnd = atEnd && index == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
var selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc3) {
  let elt = doc3.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc3, x, y) {
  if (doc3.caretPositionFromPoint) {
    try {
      let pos = doc3.caretPositionFromPoint(x, y);
      if (pos)
        return { node: pos.offsetNode, offset: pos.offset };
    } catch (_) {
    }
  }
  if (doc3.caretRangeFromPoint) {
    let range = doc3.caretRangeFromPoint(x, y);
    if (range)
      return { node: range.startContainer, offset: range.startOffset };
  }
}
var nav = typeof navigator != "undefined" ? navigator : null;
var doc2 = typeof document != "undefined" ? document : null;
var agent = nav && nav.userAgent || "";
var ie_edge = /Edge\/(\d+)/.exec(agent);
var ie_upto10 = /MSIE \d/.exec(agent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
var ie = !!(ie_upto10 || ie_11up || ie_edge);
var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
var gecko = !ie && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
var chrome = !!_chrome;
var chrome_version = _chrome ? +_chrome[1] : 0;
var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
var windows = nav ? /Win/.test(nav.platform) : false;
var android = /Android \d/.test(agent);
var webkit = !!doc2 && "webkitFontSmoothing" in doc2.documentElement.style;
var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc3) {
  return {
    left: 0,
    right: doc3.documentElement.clientWidth,
    top: 0,
    bottom: doc3.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  let rect = node.getBoundingClientRect();
  let scaleX = rect.width / node.offsetWidth || 1;
  let scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc3 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; parent = parentNode(parent)) {
    if (!parent)
      break;
    if (parent.nodeType != 1)
      continue;
    let elt = parent;
    let atTop = elt == doc3.body;
    let bounding = atTop ? windowRect(doc3) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc3.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    if (atTop || /^(fixed|sticky)$/.test(getComputedStyle(parent).position))
      break;
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    let dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack = [], doc3 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode(cur)) {
    stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc3)
      break;
  }
  return stack;
}
function resetScrollPos({ refDOM, refTop, stack }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (let i = 0; i < stack.length; i++) {
    let { dom, top: top2, left: left2 } = stack[i];
    if (dom.scrollTop != top2 + dTop)
      dom.scrollTop = top2 + dTop;
    if (dom.scrollLeft != left2)
      dom.scrollLeft = left2;
  }
}
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  let closest, dxClosest = 2e8, coordsClosest, offset2 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  let firstBelow, coordsBelow;
  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset2 = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node, offset: offset2 };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range = document.createRange();
  for (let i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    let rect = singleRect(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node, offset: offset2 } = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset2, bias);
}
function posFromCaret(view, node, offset2, coords) {
  let outsideBlock = -1;
  for (let cur = node, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true);
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent && !sawBlock || !desc.contentDOM)) {
      let rect = desc.dom.getBoundingClientRect();
      if (desc.node.isBlock && desc.parent && !sawBlock) {
        sawBlock = true;
        if (rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset2, -1);
}
function elementFromPoint(element2, coords, box) {
  let len = element2.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
      let child = element2.childNodes[i];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i = (i + 1) % len) == startI)
        break;
    }
  }
  return element2;
}
function posAtCoords(view, coords) {
  let doc3 = view.dom.ownerDocument, node, offset2 = 0;
  let caret = caretFromPoint(doc3, coords.left, coords.top);
  if (caret)
    ({ node, offset: offset2 } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc3).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p = elt; node && p; p = parentNode(p))
      if (p.draggable)
        node = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      offset2 = Math.min(offset2, node.childNodes.length);
      if (offset2 < node.childNodes.length) {
        let next = node.childNodes[offset2], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset2++;
      }
    }
    let prev;
    if (webkit && offset2 && node.nodeType == 1 && (prev = node.childNodes[offset2 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset2--;
    if (node == view.dom && offset2 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset2 == 0 || node.nodeType != 1 || node.childNodes[offset2 - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset2, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first2 = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first2))
      return first2;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node, offset: offset2, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset2 : offset2 == node.nodeValue.length))) {
      let rect = singleRect(textRange(node, offset2, offset2), side);
      if (gecko && offset2 && /\s/.test(node.nodeValue[offset2 - 1]) && offset2 < node.nodeValue.length) {
        let rectBefore = singleRect(textRange(node, offset2 - 1, offset2 - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node, offset2, offset2 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from2 = offset2, to = offset2, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset2) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset2 == node.nodeValue.length) {
        from2--;
        takeSide = 1;
      } else if (side < 0) {
        from2--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node, from2, to), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom || 0));
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
      let before = node.childNodes[offset2 - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom == null && offset2 < nodeSize(node)) {
      let after = node.childNodes[offset2];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
    let before = node.childNodes[offset2 - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom == null && offset2 < nodeSize(node)) {
    let after = node.childNodes[offset2];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left2) {
  if (rect.width == 0)
    return rect;
  let x = left2 ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top2) {
  if (rect.height == 0)
    return rect;
  let y = top2 ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i = 0; i < boxes.length; i++) {
        let box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
var maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset2 = $head.parentOffset, atStart = !offset2, atEnd = offset2 == $head.parent.content.size;
  let sel = view.domSelection();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
var cachedState = null;
var cachedDir = null;
var cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
var NOT_DIRTY = 0;
var CHILD_DIRTY = 1;
var CONTENT_DIRTY = 2;
var NODE_DIRTY = 3;
var ViewDesc = class {
  constructor(parent, children2, dom, contentDOM) {
    this.parent = parent;
    this.children = children2;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(event) {
    return false;
  }
  // The size of the content represented by this desc.
  get size() {
    let size = 0;
    for (let i = 0; i < this.children.length; i++)
      size += this.children[i].size;
    return size;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i = 0; i < this.children.length; i++)
      this.children[i].destroy();
  }
  posBeforeChild(child) {
    for (let i = 0, pos = this.posAtStart; ; i++) {
      let cur = this.children[i];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset2, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset2 - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset2];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset2 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset2 == 0)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }
          if (search.previousSibling)
            break;
        }
      if (atEnd == null && offset2 == dom.childNodes.length)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = true;
            break;
          }
          if (search.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first2 = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset2, bias) {
    for (let scan = dom; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset2, bias);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(pos) {
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (offset2 == pos && end2 != offset2) {
        while (!child.border && child.children.length)
          child = child.children[0];
        return child;
      }
      if (pos < end2)
        return child.descAt(pos - offset2 - child.border);
      offset2 = end2;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i = 0, offset2 = 0;
    for (let curPos = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = curPos + child.size;
      if (end2 > pos || child instanceof TrailingHackViewDesc) {
        offset2 = pos - curPos;
        break;
      }
      curPos = end2;
    }
    if (offset2)
      return this.children[i].domFromPos(offset2 - this.children[i].border, side);
    for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
    }
    if (side <= 0) {
      let prev, enter2 = true;
      for (; ; i--, enter2 = false) {
        prev = i ? this.children[i - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter2 && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter2 = true;
      for (; ; i++, enter2 = false) {
        next = i < this.children.length ? this.children[i] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter2 && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(from2, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset2 = base2, i = 0; ; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (fromOffset == -1 && from2 <= end2) {
        let childBase = offset2 + child.border;
        if (from2 >= childBase && to <= end2 - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from2, to, childBase);
        from2 = offset2;
        for (let j = i; j > 0; j--) {
          let prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from2 -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end2 > to || i == this.children.length - 1)) {
        to = end2;
        for (let j = i + 1; j < this.children.length; j++) {
          let next = this.children[j];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset2 = end2;
    }
    return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node, offset: offset2 } = this.domFromPos(pos, 0);
    if (node.nodeType != 1 || offset2 == node.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node.childNodes[offset2];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(anchor, head, root, force = false) {
    let from2 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (from2 > offset2 && to < end2)
        return child.setSelection(anchor - offset2 - child.border, head - offset2 - child.border, root, force);
      offset2 = end2;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = root.getSelection();
    let brKludge = false;
    if ((gecko || safari) && anchor == head) {
      let { node, offset: offset2 } = anchorDOM;
      if (node.nodeType == 3) {
        brKludge = !!(offset2 && node.nodeValue[offset2 - 1] == "\n");
        if (brKludge && offset2 == node.nodeValue.length) {
          for (let scan = node, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node.childNodes[offset2 - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
      let after = domSel.focusNode.childNodes[domSel.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(from2, to) {
    for (let offset2 = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (offset2 == end2 ? from2 <= end2 && to >= offset2 : from2 < end2 && to > offset2) {
        let startInside = offset2 + child.border, endInside = end2 - child.border;
        if (from2 >= startInside && to <= endInside) {
          this.dirty = from2 == offset2 || to == end2 ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from2 - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset2 = end2;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node = this.parent; node; node = node.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node.dirty < dirty)
        node.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
};
var WidgetViewDesc = class extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, () => {
        if (!self)
          return pos;
        if (self.parent)
          return self.parent.posBeforeChild(self);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap2 = document.createElement("span");
        wrap2.appendChild(dom);
        dom = wrap2;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget;
    this.widget = widget;
    self = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get side() {
    return this.widget.type.side;
  }
};
var CompositionViewDesc = class extends ViewDesc {
  constructor(parent, dom, textDOM, text2) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text2;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset2) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset2 ? this.size : 0);
    return this.posAtStart + offset2;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
};
var MarkViewDesc = class _MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom, contentDOM) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
  }
  static create(parent, mark, inline, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));
    return new _MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from2, to, view) {
    let copy2 = _MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size = this.size;
    if (to < size)
      nodes = replaceNodes(nodes, to, size, view);
    if (from2 > 0)
      nodes = replaceNodes(nodes, 0, from2, view);
    for (let i = 0; i < nodes.length; i++)
      nodes[i].parent = copy2;
    copy2.children = nodes;
    return copy2;
  }
};
var NodeViewDesc = class _NodeViewDesc extends ViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(parent, node, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node.type.name], descObj;
    let spec = custom && custom(node, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom)
        dom = document.createTextNode(node.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      ({ dom, contentDOM } = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)));
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new _NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i = this.children.length - 1; i >= 0; i--) {
        let child = this.children[i];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment.empty;
    }
    return rule;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(view, pos) {
    let inline = this.node.inlineContent, off = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline, view);
      updater.placeWidget(widget, view, off);
    }, (child, outerDeco, innerDeco, i) => {
      updater.syncToMarks(child.marks, inline, view);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i))
        ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view))
        ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off))
        ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    updater.syncToMarks([], inline, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from: from2, to } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
      return null;
    let sel = view.domSelectionRange();
    let textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text2 = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text2, from2 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text: text2 };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node, pos, text: text2 }) {
    if (this.getDesc(node))
      return;
    let topNode = node;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node, text2);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text2.length, view, desc);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
      return false;
    this.updateInner(node, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  // Mark this node as being the selected node.
  selectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.draggable = true;
  }
  // Remove selected node marking from this node.
  deselectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.removeAttribute("draggable");
  }
  get domAtom() {
    return this.node.isAtom;
  }
};
function docViewDesc(doc3, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc3);
  let docView = new NodeViewDesc(void 0, doc3, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
var TextViewDesc = class _TextViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset2, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset2, this.node.text.length);
    return super.localPosFromDOM(dom, offset2, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from2, to, view) {
    let node = this.node.cut(from2, to), dom = document.createTextNode(node.text);
    return new _TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
};
var TrailingHackViewDesc = class extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
};
var CustomNodeViewDesc = class extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update) {
      let result = this.spec.update(node, outerDeco, innerDeco);
      if (result)
        this.updateInner(node, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node.isLeaf) {
      return false;
    } else {
      return super.update(node, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, root, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : super.setSelection(anchor, head, root, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
};
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i = 0; i < descs.length; i++) {
    let desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
var OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
var noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top2];
  for (let i = 0; i < outerDeco.length; i++) {
    let attrs = outerDeco[i].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top2 = new OuterDecoLevel(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top2 = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top2.class = (top2.class ? top2.class + " " : "") + val;
      else if (name == "style")
        top2.style = (top2.style ? top2.style + ";" : "") + val;
      else if (name != "nodeName")
        top2[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i = 0; i < curComputed.length; i++) {
    let deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < prevList.length; i++)
      if (curList.indexOf(prevList[i]) == -1)
        dom.classList.remove(prevList[i]);
    for (let i = 0; i < curList.length; i++)
      if (prevList.indexOf(curList[i]) == -1)
        dom.classList.add(curList[i]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        dom.style.removeProperty(m[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].type.eq(b[i].type))
      return false;
  return true;
}
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ViewTreeUpdater = class {
  constructor(top2, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top2;
    this.preMatch = preMatch(top2.node.content, top2);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(start2, end2) {
    if (start2 == end2)
      return;
    for (let i = start2; i < end2; i++)
      this.top.children[i].destroy();
    this.top.children.splice(start2, end2 - start2);
    this.changed = true;
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(marks, inline, view) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1;
      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
        let next = this.top.children[i];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          found2 = i;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(node, outerDeco, innerDeco, index) {
    let found2 = -1, targetDesc;
    if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
        let child = this.top.children[i];
        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = i;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node, outerDeco, innerDeco, index, view) {
    let child = this.top.children[index];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc)
              return i;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(node, outerDeco, innerDeco, view, index, pos) {
    for (let i = this.index; i < this.top.children.length; i++) {
      let next = this.top.children[i];
      if (next instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index)
          return false;
        let nextDOM = next.dom, updated;
        let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content))
      return null;
    let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (let ch of wrapper.children)
        ch.parent = wrapper;
    }
    next.destroy();
    return wrapper;
  }
  // Insert the node as a newly created node desc.
  addNode(node, outerDeco, innerDeco, view, pos) {
    let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || // Empty textblock
    !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node) {
    return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
  }
};
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer:
    while (fI > 0) {
      let desc;
      for (; ; ) {
        if (descI) {
          let next = curDesc.children[descI - 1];
          if (next instanceof MarkViewDesc) {
            curDesc = next;
            descI = next.children.length;
          } else {
            desc = next;
            descI--;
            break;
          }
        } else if (curDesc == parentDesc) {
          break outer;
        } else {
          descI = curDesc.parent.children.indexOf(curDesc);
          curDesc = curDesc.parent;
        }
      }
      let node = desc.node;
      if (!node)
        continue;
      if (node != frag.child(fI - 1))
        break;
      --fI;
      matched.set(desc, fI);
      matches2.push(desc);
    }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset2 = 0;
  if (locals.length == 0) {
    for (let i = 0; i < parent.childCount; i++) {
      let child = parent.child(i);
      onNode(child, locals, deco.forChild(offset2, child), i);
      offset2 += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset2) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i = 0; i < widgets.length; i++)
          onWidget(widgets[i], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index;
    if (restNode) {
      index = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i = 0; i < active.length; i++)
      if (active[i].to <= offset2)
        active.splice(i--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset2 && locals[decoIndex].to > offset2)
      active.push(locals[decoIndex++]);
    let end2 = offset2 + child.nodeSize;
    if (child.isText) {
      let cutAt = end2;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i = 0; i < active.length; i++)
        if (active[i].to < cutAt)
          cutAt = active[i].to;
      if (cutAt < end2) {
        restNode = child.cut(cutAt - offset2);
        child = child.cut(0, cutAt - offset2);
        end2 = cutAt;
        index = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end2)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset2, child), index);
    offset2 = end2;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function nearbyTextNode(node, offset2) {
  for (; ; ) {
    if (node.nodeType == 3)
      return node;
    if (node.nodeType == 1 && offset2 > 0) {
      if (node.childNodes.length > offset2 && node.childNodes[offset2].nodeType == 3)
        return node.childNodes[offset2];
      node = node.childNodes[offset2 - 1];
      offset2 = nodeSize(node);
    } else if (node.nodeType == 1 && offset2 < node.childNodes.length) {
      node = node.childNodes[offset2];
      offset2 = 0;
    } else {
      return null;
    }
  }
}
function findTextInFragment(frag, text2, from2, to) {
  for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
    let child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i < frag.childCount) {
      let next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from2) {
      if (pos >= to && str.slice(to - text2.length - childStart, to - childStart) == text2)
        return to - text2.length;
      let found2 = childStart < to ? str.lastIndexOf(text2, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text2.length + childStart >= from2)
        return childStart + found2;
      if (from2 == to && str.length >= to + text2.length - childStart && str.slice(to - childStart, to - childStart + text2.length) == text2)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from2, to, view, replacement) {
  let result = [];
  for (let i = 0, off = 0; i < nodes.length; i++) {
    let child = nodes[i], start2 = off, end2 = off += child.size;
    if (start2 >= to || end2 <= from2) {
      result.push(child);
    } else {
      if (start2 < from2)
        result.push(child.slice(0, from2 - start2, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end2 > to)
        result.push(child.slice(to - start2, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc3 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc3.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc3.resolve(pos));
    }
  } else {
    let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    if (anchor < 0)
      return null;
    $anchor = doc3.resolve(anchor);
  }
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node, offset: offset2 } = view.docView.domFromPos(pos, 0);
  let after = offset2 < node.childNodes.length ? node.childNodes[offset2] : null;
  let before = offset2 ? node.childNodes[offset2 - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element2) {
  element2.contentEditable = "true";
  if (safari && element2.draggable) {
    element2.draggable = false;
    element2.wasDraggable = true;
  }
  return element2;
}
function resetEditable(element2) {
  element2.contentEditable = "false";
  if (element2.wasDraggable) {
    element2.draggable = true;
    element2.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc3 = view.dom.ownerDocument;
  doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc3.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset2) {
      doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection(), range = document.createRange();
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    range.setEnd(node.parentNode, domIndex(node) + 1);
  else
    range.setEnd(node, 0);
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply(view, new TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
      return false;
    } else if (!(mac && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset2 < nodeLen(node) && isIgnorable(node.childNodes[offset2], -1))
    force = true;
  for (; ; ) {
    if (offset2 > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before = node.childNodes[offset2 - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset2;
        } else if (before.nodeType == 3) {
          node = before;
          offset2 = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = 0;
      } else {
        node = prev;
        offset2 = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset2);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node.nodeType != 1)
        break;
      let after = node.childNodes[offset2];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset2;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = len = 0;
      } else {
        node = next;
        offset2 = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset2) {
  while (node && offset2 == node.childNodes.length && !hasBlockDesc(node)) {
    offset2 = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset2 < node.childNodes.length) {
    let next = node.childNodes[offset2];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = 0;
  }
}
function textNodeBefore(node, offset2) {
  while (node && !offset2 && !hasBlockDesc(node)) {
    offset2 = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset2) {
    let next = node.childNodes[offset2 - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset2) {
  if (node.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node, offset2)) {
      node = after;
      offset2 = 0;
    } else if (before = textNodeBefore(node, offset2)) {
      node = before;
      offset2 = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node, offset2);
    range.setStart(node, offset2);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset2);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed = getComputedStyle(view.dom).direction;
  return computed == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty3 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty3)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr2 = view.state.tr;
    if (dir < 0)
      tr2.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr2.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr2);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code = event.keyCode, mods = getMods(event);
  if (code == 8 || mac && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac && code == 66 && mods == "c") {
    let dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 39 || mac && code == 70 && mods == "c") {
    let dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 38 || mac && code == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code == 40 || mac && code == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  view.someProp("transformCopied", (f) => {
    slice2 = f(slice2, view);
  });
  let context = [], { content, openStart, openEnd } = slice2;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc3 = detachedDoc(), wrap2 = doc3.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content, { document: doc3 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      let wrapper = doc3.createElement(needsWrap[i]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text2 = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap2, text: text2 };
}
function parseFromClipboard(view, text2, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice2;
  if (!html && !text2)
    return null;
  let asText = text2 && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text2 = f(text2, inCode || plainText, view);
    });
    if (inCode)
      return text2 ? new Slice(Fragment.from(view.state.schema.text(text2.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    let parsed = view.someProp("clipboardTextParser", (f) => f(text2, $context, plainText, view));
    if (parsed) {
      slice2 = parsed;
    } else {
      let marks = $context.marks();
      let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text2.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p = dom.appendChild(document.createElement("p"));
        if (block)
          p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html = f(html, view);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i = +sliceData[3]; i > 0; i--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice2) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
    slice2 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice2 = f(slice2, view);
  });
  return slice2;
}
var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match = parent.contentMatchAt($context.index(d));
    let lastWrap, result = [];
    fragment.forEach((node) => {
      if (!result)
        return;
      let wrap2 = match.findWrapping(node.type), inLast;
      if (!wrap2)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap2);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result)
      return Fragment.from(result);
  }
  return fragment;
}
function withWrappers(node, wrap2, from2 = 0) {
  for (let i = wrap2.length - 1; i >= from2; i--)
    node = wrap2[i].create(null, Fragment.from(node));
  return node;
}
function addToSibling(wrap2, lastWrap, node, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from2, to, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
  if (depth >= from2)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap2.map((n) => "<" + n + ">").join("") + html + wrap2.map((n) => "</" + n + ">").reverse().join("");
  elt.innerHTML = html;
  if (wrap2)
    for (let i = 0; i < wrap2.length; i++)
      elt = elt.querySelector(wrap2[i]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i = 0; i < nodes.length; i++) {
    let node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode)
      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  let schema = slice2.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice2;
  }
  let { content, openStart, openEnd } = slice2;
  for (let i = array.length - 2; i >= 0; i -= 2) {
    let type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment.from(type.create(array[i + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
var handlers = {};
var editHandlers = {};
var passiveHandlers = { touchstart: true, touchmove: true };
var InputState = class {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "" };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastAndroidDelete = 0;
    this.composing = false;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.compositionID = 1;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
};
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now2 = Date.now();
    view.input.lastIOSEnter = now2;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now2) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text2 = String.fromCharCode(event.charCode);
    if (!/[\r\n]/.test(text2) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text2)))
      view.dispatch(view.state.tr.insertText(text2).scrollIntoView());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  let tr2 = view.state.tr.setSelection(selection);
  if (origin == "pointer")
    tr2.setMeta("pointer", true);
  view.dispatch(tr2);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc3 = view.state.doc;
  if (inside == -1) {
    if (doc3.inlineContent) {
      updateSelection(view, TextSelection.create(doc3, 0, doc3.content.size), "pointer");
      return true;
    }
    return false;
  }
  let $pos = doc3.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc3, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc3, nodePos), "pointer");
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
var selectNodeModifier = mac ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now2 = Date.now(), type = "singleClick";
  if (now2 - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now2, x: event.clientX, y: event.clientY, type };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
var MouseDown = class {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc ? targetDesc.dom : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
};
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
var timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state } = view, $pos = state.selection.$from;
    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let node = sel.focusNode, offset2 = sel.focusOffset; node && node.nodeType == 1 && offset2 != 0; ) {
          let before = offset2 < 0 ? node.lastChild : node.childNodes[offset2 - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            view.domSelection().collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset2 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    if (view.input.compositionPendingChanges)
      Promise.resolve().then(() => view.domObserver.flush());
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, forceUpdate = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection))
      view.dispatch(view.state.tr.setSelection(sel));
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut2 = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice2 = sel.content(), { dom, text: text2 } = serializeForClipboard(view, slice2);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text2);
  } else {
    captureCopy(view, dom);
  }
  if (cut2)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text2, html, preferPlain, event) {
  let slice2 = parseFromClipboard(view, text2, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
    return true;
  if (!slice2)
    return false;
  let singleNode = sliceSingleNode(slice2);
  let tr2 = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr2.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText(clipboardData) {
  let text2 = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text2)
    return text2;
  let uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
var Dragging = class {
  constructor(slice2, move, node) {
    this.slice = slice2;
    this.move = move;
    this.node = node;
  }
};
var dragCopyModifier = mac ? "altKey" : "ctrlKey";
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  let node;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node = NodeSelection.create(view.state.doc, desc.posBefore);
  }
  let slice2 = (node || view.state.selection).content(), { dom, text: text2 } = serializeForClipboard(view, slice2);
  event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text2);
  view.dragging = new Dragging(slice2, !event[dragCopyModifier], node);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
editHandlers.drop = (view, _event) => {
  let event = _event;
  let dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice2 = dragging && dragging.slice;
  if (slice2) {
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view);
    });
  } else {
    slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move = !!(dragging && !event[dragCopyModifier]);
  if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move))) {
    event.preventDefault();
    return;
  }
  if (!slice2)
    return;
  event.preventDefault();
  let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr2 = view.state.tr;
  if (move) {
    let { node } = dragging;
    if (node)
      node.replace(tr2);
    else
      tr2.deleteSelection();
  }
  let pos = tr2.mapping.map(insertPos);
  let isNode = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
  let beforeInsert = tr2.doc;
  if (isNode)
    tr2.replaceRangeWith(pos, pos, slice2.content.firstChild);
  else
    tr2.replaceRange(pos, pos, slice2);
  if (tr2.doc.eq(beforeInsert))
    return;
  let $pos = tr2.doc.resolve(pos);
  if (isNode && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
    tr2.setSelection(new NodeSelection($pos));
  } else {
    let end2 = tr2.mapping.map(insertPos);
    tr2.mapping.maps[tr2.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end2 = newTo);
    tr2.setSelection(selectionBetween(view, $pos, tr2.doc.resolve(end2)));
  }
  view.focus();
  view.dispatch(tr2.setMeta("uiEvent", "drop"));
};
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a, b) {
  if (a == b)
    return true;
  for (let p in a)
    if (a[p] !== b[p])
      return false;
  for (let p in b)
    if (!(p in a))
      return false;
  return true;
}
var WidgetType = class _WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset2, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset2, pos - offset2, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node) {
    if (this.spec.destroy)
      this.spec.destroy(node);
  }
};
var InlineType = class _InlineType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
    return from2 >= to ? null : new Decoration(from2, to, this);
  }
  valid(_, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof _InlineType;
  }
  destroy() {
  }
};
var NodeType2 = class _NodeType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from2 = mapping.mapResult(span.from + oldOffset, 1);
    if (from2.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from2.pos)
      return null;
    return new Decoration(from2.pos - offset2, to.pos - offset2, this);
  }
  valid(node, span) {
    let { index, offset: offset2 } = node.content.findIndex(span.from), child;
    return offset2 == span.from && !(child = node.child(index)).isText && offset2 + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
};
var Decoration = class _Decoration {
  /**
  @internal
  */
  constructor(from2, to, type) {
    this.from = from2;
    this.to = to;
    this.type = type;
  }
  /**
  @internal
  */
  copy(from2, to) {
    return new _Decoration(from2, to, this.type);
  }
  /**
  @internal
  */
  eq(other, offset2 = 0) {
    return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
  }
  /**
  @internal
  */
  map(mapping, offset2, oldOffset) {
    return this.type.map(mapping, this, offset2, oldOffset);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(pos, toDOM, spec) {
    return new _Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(from2, to, attrs, spec) {
    return new _Decoration(from2, to, new InlineType(attrs, spec));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(from2, to, attrs, spec) {
    return new _Decoration(from2, to, new NodeType2(attrs, spec));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof InlineType;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof WidgetType;
  }
};
var none = [];
var noSpec = {};
var DecorationSet = class _DecorationSet {
  /**
  @internal
  */
  constructor(local, children2) {
    this.local = local.length ? local : none;
    this.children = children2.length ? children2 : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(doc3, decorations) {
    return decorations.length ? buildTree(decorations, doc3, 0, noSpec) : empty2;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(start2, end2, predicate) {
    let result = [];
    this.findInner(start2 == null ? 0 : start2, end2 == null ? 1e9 : end2, result, 0, predicate);
    return result;
  }
  findInner(start2, end2, result, offset2, predicate) {
    for (let i = 0; i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end2 && span.to >= start2 && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset2, span.to + offset2));
    }
    for (let i = 0; i < this.children.length; i += 3) {
      if (this.children[i] < end2 && this.children[i + 1] > start2) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start2 - childOff, end2 - childOff, result, offset2 + childOff, predicate);
      }
    }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(mapping, doc3, options) {
    if (this == empty2 || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc3, 0, 0, options || noSpec);
  }
  /**
  @internal
  */
  mapInner(mapping, node, offset2, oldOffset, options) {
    let newLocal;
    for (let i = 0; i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset2, oldOffset);
      if (mapped && mapped.type.valid(node, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove)
        options.onRemove(this.local[i].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node, offset2, oldOffset, options);
    else
      return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty2;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(doc3, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty2)
      return _DecorationSet.create(doc3, decorations);
    return this.addInner(doc3, decorations, 0);
  }
  addInner(doc3, decorations, offset2) {
    let children2, childIndex = 0;
    doc3.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset2, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children2)
        children2 = this.children.slice();
      while (childIndex < children2.length && children2[childIndex] < childOffset)
        childIndex += 3;
      if (children2[childIndex] == childOffset)
        children2[childIndex + 2] = children2[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children2.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
    for (let i = 0; i < local.length; i++)
      if (!local[i].type.valid(doc3, local[i]))
        local.splice(i--, 1);
    return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children2 || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(decorations) {
    if (decorations.length == 0 || this == empty2)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset2) {
    let children2 = this.children, local = this.local;
    for (let i = 0; i < children2.length; i += 3) {
      let found2;
      let from2 = children2[i] + offset2, to = children2[i + 1] + offset2;
      for (let j = 0, span; j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > from2 && span.to < to) {
            decorations[j] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children2 == this.children)
        children2 = this.children.slice();
      let removed = children2[i + 2].removeInner(found2, from2 + 1);
      if (removed != empty2) {
        children2[i + 2] = removed;
      } else {
        children2.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (let i = 0, span; i < decorations.length; i++)
        if (span = decorations[i]) {
          for (let j = 0; j < local.length; j++)
            if (local[j].eq(span, offset2)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j--, 1);
            }
        }
    }
    if (children2 == this.children && local == this.local)
      return this;
    return local.length || children2.length ? new _DecorationSet(local, children2) : empty2;
  }
  forChild(offset2, node) {
    if (this == empty2)
      return this;
    if (node.isLeaf)
      return _DecorationSet.empty;
    let child, local;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] >= offset2) {
        if (this.children[i] == offset2)
          child = this.children[i + 2];
        break;
      }
    let start2 = offset2 + 1, end2 = start2 + node.content.size;
    for (let i = 0; i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end2 && dec.to > start2 && dec.type instanceof InlineType) {
        let from2 = Math.max(start2, dec.from) - start2, to = Math.min(end2, dec.to) - start2;
        if (from2 < to)
          (local || (local = [])).push(dec.copy(from2, to));
      }
    }
    if (local) {
      let localSet = new _DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty2;
  }
  /**
  @internal
  */
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i = 0; i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i]))
        return false;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
        return false;
    return true;
  }
  /**
  @internal
  */
  locals(node) {
    return removeOverlap(this.localsInner(node));
  }
  /**
  @internal
  */
  localsInner(node) {
    if (this == empty2)
      return none;
    if (node.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType))
        result.push(this.local[i]);
    }
    return result;
  }
};
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
var empty2 = DecorationSet.empty;
var DecorationGroup = class _DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc3) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc3, noSpec));
    return _DecorationGroup.from(mappedDecos);
  }
  forChild(offset2, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found2 = [];
    for (let i = 0; i < this.members.length; i++) {
      let result = this.members[i].forChild(offset2, child);
      if (result == empty2)
        continue;
      if (result instanceof _DecorationGroup)
        found2 = found2.concat(result.members);
      else
        found2.push(result);
    }
    return _DecorationGroup.from(found2);
  }
  eq(other) {
    if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i = 0; i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i]))
        return false;
    return true;
  }
  locals(node) {
    let result, sorted = true;
    for (let i = 0; i < this.members.length; i++) {
      let locals = this.members[i].localsInner(node);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j = 0; j < locals.length; j++)
          result.push(locals[j]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(members) {
    switch (members.length) {
      case 0:
        return empty2;
      case 1:
        return members[0];
      default:
        return new _DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r2, m) => r2.concat(m instanceof DecorationSet ? m : m.members), []));
    }
  }
};
function mapChildren(oldChildren, newLocal, mapping, node, offset2, oldOffset, options) {
  let children2 = oldChildren.slice();
  for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
    let moved = 0;
    mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i2 = 0; i2 < children2.length; i2 += 3) {
        let end2 = children2[i2 + 1];
        if (end2 < 0 || oldStart > end2 + baseOffset - moved)
          continue;
        let start2 = children2[i2] + baseOffset - moved;
        if (oldEnd >= start2) {
          children2[i2 + 1] = oldStart <= start2 ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children2[i2] += dSize;
          children2[i2 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i = 0; i < children2.length; i += 3)
    if (children2[i + 1] < 0) {
      if (children2[i + 1] == -2) {
        mustRebuild = true;
        children2[i + 1] = -1;
        continue;
      }
      let from2 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from2 - offset2;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset2;
      let { index, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children2[i + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i] + oldOffset + 1, options);
        if (mapped != empty2) {
          children2[i] = fromLocal;
          children2[i + 1] = toLocal;
          children2[i + 2] = mapped;
        } else {
          children2[i + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children2, oldChildren, newLocal, mapping, offset2, oldOffset, options);
    let built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (let i = 0; i < children2.length; i += 3)
      if (children2[i + 1] < 0) {
        children2.splice(i, 3);
        i -= 3;
      }
    for (let i = 0, j = 0; i < built.children.length; i += 3) {
      let from2 = built.children[i];
      while (j < children2.length && children2[j] < from2)
        j += 3;
      children2.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children2);
}
function moveSpans(spans, offset2) {
  if (!offset2 || !spans.length)
    return spans;
  let result = [];
  for (let i = 0; i < spans.length; i++) {
    let span = spans[i];
    result.push(new Decoration(span.from + offset2, span.to + offset2, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children2, oldChildren, decorations, mapping, offset2, oldOffset, options) {
  function gather(set, oldOffset2) {
    for (let i = 0; i < set.local.length; i++) {
      let mapped = set.local[i].map(mapping, offset2, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set.local[i].spec);
    }
    for (let i = 0; i < set.children.length; i += 3)
      gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);
  }
  for (let i = 0; i < children2.length; i += 3)
    if (children2[i + 1] == -1)
      gather(children2[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset2) {
  if (node.isLeaf)
    return null;
  let end2 = offset2 + node.nodeSize, found2 = null;
  for (let i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset2 && span.to < end2) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  let result = [];
  for (let i = 0; i < array.length; i++)
    if (array[i] != null)
      result.push(array[i]);
  return result;
}
function buildTree(spans, node, offset2, options) {
  let children2 = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset2);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset2 + localStart + 1, options);
      if (subtree != empty2)
        children2.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
  for (let i = 0; i < locals.length; i++)
    if (!locals[i].type.valid(node, locals[i])) {
      if (options.onRemove)
        options.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  return locals.length || children2.length ? new DecorationSet(locals, children2) : empty2;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i = 0; i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to)
      for (let j = i + 1; j < working.length; j++) {
        let next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0)
    i++;
  array.splice(i, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f) => {
    let result = f(view.state);
    if (result && result != empty2)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData = ie && ie_version <= 11;
var SelectionState = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
};
var DOMObserver = class {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i = 0; i < mutations.length; i++)
        this.queue.push(mutations[i]);
      if (ie && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData) {
      this.onCharData = (e) => {
        this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i = 0; i < take.length; i++)
          this.queue.push(take[i]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = /* @__PURE__ */ new Set(), container;
    for (let scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  pendingRecords() {
    if (this.observer)
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
    return this.queue;
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from2 = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i = 0; i < mutations.length; i++) {
        let result = this.registerMutation(mutations[i], added);
        if (result) {
          from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length > 1) {
      let brs = added.filter((n) => n.nodeName == "BR");
      if (brs.length == 2) {
        let a = brs[0], b = brs[1];
        if (a.parentNode && a.parentNode.parentNode == b.parentNode)
          b.remove();
        else
          a.remove();
      }
    }
    let readSel = null;
    if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from2 > -1 || newSel) {
      if (from2 > -1) {
        view.docView.markDirty(from2, to);
        checkCSS(view);
      }
      this.handleDOMChange(from2, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i = 0; i < mut.addedNodes.length; i++)
        added.push(mut.addedNodes[i]);
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev = mut.previousSibling, next = mut.nextSibling;
      if (ie && ie_version <= 11 && mut.addedNodes.length) {
        for (let i = 0; i < mut.addedNodes.length; i++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from2, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
};
var cssChecked = /* @__PURE__ */ new WeakMap();
var cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function safariShadowSelectionRange(view) {
  let found2;
  function read2(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read2, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read2, true);
  let anchorNode = found2.startContainer, anchorOffset = found2.startOffset;
  let focusNode = found2.endContainer, focusOffset = found2.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find2;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (let off = toOffset; off > fromOffset; off--) {
      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from2);
  let sel = null, doc3 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find2,
    ruleFromNode,
    context: $from
  });
  if (find2 && find2[0].pos != null) {
    let anchor2 = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from2, head: head + from2 };
  }
  return { doc: doc3, sel, from: from2, to };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from2, to, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from2 < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
        return;
      let tr3 = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr3.setMeta("pointer", true);
      else if (origin == "key")
        tr3.scrollIntoView();
      if (compositionID)
        tr3.setMeta("composition", compositionID);
      view.dispatch(tr3);
    }
    return;
  }
  let $before = view.state.doc.resolve(from2);
  let shared = $before.sharedDepth(to);
  from2 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  let sel = view.state.selection;
  let parse = parseBetween(view, from2, to);
  let doc3 = view.state.doc, compare = doc3.slice(parse.from, parse.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr3 = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr3.setMeta("composition", compositionID);
          view.dispatch(tr3);
        }
      }
      return;
    }
  }
  if (chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from && parse.sel.head == parse.sel.anchor) {
    let size = change.endB - change.start;
    parse.sel = { anchor: parse.sel.anchor + size, head: parse.sel.anchor + size };
  }
  view.input.domChangeCount++;
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse.doc.resolveNoCache(change.start - parse.from);
  let $to = parse.doc.resolveNoCache(change.endB - parse.from);
  let $fromA = doc3.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  let nextSel;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse.doc.content.size && !$from.sameParent($to) && (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeJoin(doc3, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && android && change.endB == change.start)
    view.input.lastAndroidDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let tr2, storedMarks, markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      tr2 = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc3.resolve(change.start).marksAcross(doc3.resolve(change.endA));
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      tr2 = view.state.tr;
      if (markChange.type == "add")
        tr2.addMark(chFrom, chTo, markChange.mark);
      else
        tr2.removeMark(chFrom, chTo, markChange.mark);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text2 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text2)))
        return;
      tr2 = view.state.tr.insertText(text2, chFrom, chTo);
    }
  }
  if (!tr2)
    tr2 = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
  if (parse.sel) {
    let sel2 = resolveSelection(view, tr2.doc, parse.sel);
    if (sel2 && !(chrome && android && view.composing && sel2.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr2.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))
      tr2.setSelection(sel2);
  }
  if (storedMarks)
    tr2.ensureMarks(storedMarks);
  if (compositionID)
    tr2.setMeta("composition", compositionID);
  view.dispatch(tr2.scrollIntoView());
}
function resolveSelection(view, doc3, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc3.content.size)
    return null;
  return selectionBetween(view, doc3.resolve(parsedSel.anchor), doc3.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update2;
  for (let i = 0; i < prevMarks.length; i++)
    added = prevMarks[i].removeFromSet(added);
  for (let i = 0; i < curMarks.length; i++)
    removed = curMarks[i].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update2 = (node) => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update2 = (node) => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i = 0; i < prev.childCount; i++)
    updated.push(update2(prev.child(i)));
  if (Fragment.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeJoin(old, start2, end2, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || // The content must have shrunk
  end2 - start2 <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
  skipClosingAndOpening($newStart, true, false) < $newEnd.pos)
    return false;
  let $start = old.resolve(start2);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end2 || skipClosingAndOpening($next, true, false) < end2)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end2 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end2++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end2++;
    }
  }
  return end2;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  let start2 = a.findDiffStart(b, pos);
  if (start2 == null)
    return null;
  let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start2 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start2;
  }
  if (endA < start2 && a.size < b.size) {
    let move = preferredPos <= start2 && preferredPos >= endA ? start2 - preferredPos : 0;
    start2 -= move;
    if (start2 && start2 < b.size && isSurrogatePair(b.textBetween(start2 - 1, start2 + 1)))
      start2 += move ? 1 : -1;
    endB = start2 + (endB - endA);
    endA = start2;
  } else if (endB < start2) {
    let move = preferredPos <= start2 && preferredPos >= endB ? start2 - preferredPos : 0;
    start2 -= move;
    if (start2 && start2 < a.size && isSurrogatePair(a.textBetween(start2 - 1, start2 + 1)))
      start2 += move ? 1 : -1;
    endA = start2 + (endA - endB);
    endB = start2;
  }
  return { start: start2, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  let a = str.charCodeAt(0), b = str.charCodeAt(1);
  return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
}
var EditorView = class {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(props) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props)
      updated[name] = props[name];
    this.update(updated);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(state) {
    this.updateStateInner(state, this._props);
  }
  updateStateInner(state, prevProps) {
    var _a;
    let prev = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
      if (updateDoc) {
        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco([]);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  /**
  @internal
  */
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (this.someProp("handleScrollToSelection", (f) => f(this)))
      ;
    else if (this.state.selection instanceof NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i = 0; i < this.directPlugins.length; i++) {
        let plugin = this.directPlugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
      for (let i = 0; i < this.state.plugins.length; i++) {
        let plugin = this.state.plugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
    } else {
      for (let i = 0; i < this.pluginViews.length; i++) {
        let pluginView = this.pluginViews[i];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  updateDraggedNode(dragging, prev) {
    let sel = dragging.node, found2 = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found2 = sel.from;
    } else {
      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found2 = movedPos;
    }
    this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
  }
  someProp(propName, f) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop))
      return value;
    for (let i = 0; i < this.directPlugins.length; i++) {
      let prop2 = this.directPlugins[i].props[propName];
      if (prop2 != null && (value = f ? f(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i = 0; i < plugins.length; i++) {
        let prop2 = plugins[i].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ie) {
      let node = this.root.activeElement;
      if (node == this.dom)
        return true;
      if (!node || !this.dom.contains(node))
        return false;
      while (node && this.dom != node && this.dom.contains(node)) {
        if (node.contentEditable == "false")
          return false;
        node = node.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search = this.dom.parentNode; search; search = search.parentNode) {
        if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
          if (!search.getSelection)
            Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
          return this._root = search;
        }
      }
    return cached || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(node, offset2, bias = -1) {
    let pos = this.docView.posFromDOM(node, offset2, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(dir, state) {
    return endOfTextblock(this, state || this.state, dir);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(html, event) {
    return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(text2, event) {
    return doPaste(this, text2, null, true, event || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(tr2) {
    let dispatchTransaction = this._props.dispatchTransaction;
    if (dispatchTransaction)
      dispatchTransaction.call(this, tr2);
    else
      this.updateState(this.state.apply(tr2));
  }
  /**
  @internal
  */
  domSelectionRange() {
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom ? safariShadowSelectionRange(this) : this.domSelection();
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
};
function computeDocDeco(view) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr2 in value) {
        if (attr2 == "class")
          attrs.class += " " + value[attr2];
        else if (attr2 == "style")
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr2];
        else if (!attrs[attr2] && attr2 != "contenteditable" && attr2 != "nodeName")
          attrs[attr2] = String(value[attr2]);
      }
  });
  if (!attrs.translate)
    attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}
function changedNodeViews(a, b) {
  let nA = 0, nB = 0;
  for (let prop in a) {
    if (a[prop] != b[prop])
      return true;
    nA++;
  }
  for (let _ in b)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}

// node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (i = 0; i < 10; i++)
  base[48 + i] = base[96 + i] = String(i);
var i;
for (i = 1; i <= 24; i++)
  base[i + 111] = "F" + i;
var i;
for (i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
var i;
for (code in base)
  if (!shift.hasOwnProperty(code))
    shift[code] = base[code];
var code;
function keyName(event) {
  var ignoreKey = mac2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc")
    name = "Escape";
  if (name == "Del")
    name = "Delete";
  if (name == "Left")
    name = "ArrowLeft";
  if (name == "Up")
    name = "ArrowUp";
  if (name == "Right")
    name = "ArrowRight";
  if (name == "Down")
    name = "ArrowDown";
  return name;
}

// node_modules/prosemirror-keymap/dist/index.js
var mac3 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function normalizeKeyName(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta;
  for (let i = 0; i < parts.length - 1; i++) {
    let mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac3)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function normalize(map2) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop in map2)
    copy2[normalizeKeyName(prop)] = map2[prop];
  return copy2;
}
function modifiers(name, event, shift2 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift2 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map2 = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map2[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map2[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
        let fromCode = map2[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}

// node_modules/prosemirror-commands/dist/index.js
var deleteSelection = (state, dispatch) => {
  if (state.selection.empty)
    return false;
  if (dispatch)
    dispatch(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
var joinBackward = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr2 = state.tr.step(delStep);
        tr2.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr2.doc, $cut.pos - before.nodeSize));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
var joinTextblockBackward = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
var joinTextblockForward = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
function joinTextblocksAround(state, $cut, dispatch) {
  let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
  for (; !beforeText.isTextblock; beforePos--) {
    if (beforeText.type.spec.isolating)
      return false;
    let child = beforeText.lastChild;
    if (!child)
      return false;
    beforeText = child;
  }
  let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
  for (; !afterText.isTextblock; afterPos++) {
    if (afterText.type.spec.isolating)
      return false;
    let child = afterText.firstChild;
    if (!child)
      return false;
    afterText = child;
  }
  let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
  if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
    return false;
  if (dispatch) {
    let tr2 = state.tr.step(step);
    tr2.setSelection(TextSelection.create(tr2.doc, beforePos));
    dispatch(tr2.scrollIntoView());
  }
  return true;
}
function textblockAt(node, side, only = false) {
  for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
var selectNodeBackward = (state, dispatch, view) => {
  let { $head, empty: empty3 } = state.selection, $cut = $head;
  if (!empty3)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node = $cut && $cut.nodeBefore;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0)
        return $pos.doc.resolve($pos.before(i + 1));
      if ($pos.node(i).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
var joinForward = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr2 = state.tr.step(delStep);
        tr2.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos)), 1) : NodeSelection.create(tr2.doc, tr2.mapping.map($cut.pos)));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
var selectNodeForward = (state, dispatch, view) => {
  let { $head, empty: empty3 } = state.selection, $cut = $head;
  if (!empty3)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node = $cut && $cut.nodeAfter;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      let parent = $pos.node(i);
      if ($pos.index(i) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
var joinUp = (state, dispatch) => {
  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = joinPoint(state.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch) {
    let tr2 = state.tr.join(point);
    if (nodeSel)
      tr2.setSelection(NodeSelection.create(tr2.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
var joinDown = (state, dispatch) => {
  let sel = state.selection, point;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = joinPoint(state.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch)
    dispatch(state.tr.join(point).scrollIntoView());
  return true;
};
var lift2 = (state, dispatch) => {
  let { $from, $to } = state.selection;
  let range = $from.blockRange($to), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
var newlineInCode = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch)
    dispatch(state.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt(match) {
  for (let i = 0; i < match.edgeCount; i++) {
    let { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
var exitCode = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch) {
    let pos = $head.after(), tr2 = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr2.setSelection(Selection.near(tr2.doc.resolve(pos), 1));
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
var createParagraphNear = (state, dispatch) => {
  let sel = state.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr2 = state.tr.insert(side, type.createAndFill());
    tr2.setSelection(TextSelection.create(tr2.doc, side + 1));
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
var liftEmptyBlock = (state, dispatch) => {
  let { $cursor } = state.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (canSplit(state.doc, before)) {
      if (dispatch)
        dispatch(state.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range = $cursor.blockRange(), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
function splitBlockAs(splitNode) {
  return (state, dispatch) => {
    let { $from, $to } = state.selection;
    if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
        return false;
      if (dispatch)
        dispatch(state.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.parent.isBlock)
      return false;
    if (dispatch) {
      let atEnd = $to.parentOffset == $to.parent.content.size;
      let tr2 = state.tr;
      if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
        tr2.deleteSelection();
      let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      let splitType = splitNode && splitNode($to.parent, atEnd);
      let types = splitType ? [splitType] : atEnd && deflt ? [{ type: deflt }] : void 0;
      let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
      if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
        if (deflt)
          types = [{ type: deflt }];
        can = true;
      }
      if (can) {
        tr2.split(tr2.mapping.map($from.pos), 1, types);
        if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
          let first2 = tr2.mapping.map($from.before()), $first = tr2.doc.resolve(first2);
          if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))
            tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
        }
      }
      dispatch(tr2.scrollIntoView());
    }
    return true;
  };
}
var splitBlock = splitBlockAs();
var selectParentNode = (state, dispatch) => {
  let { $from, to } = state.selection, pos;
  let same = $from.sharedDepth(to);
  if (same == 0)
    return false;
  pos = $from.before(same);
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
  return true;
};
var selectAll = (state, dispatch) => {
  if (dispatch)
    dispatch(state.tr.setSelection(new AllSelection(state.doc)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
    if (dispatch)
      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch)
    dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  if (before.type.spec.isolating || after.type.spec.isolating)
    return false;
  if (joinMaybeClear(state, $cut, dispatch))
    return true;
  let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      let end2 = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
      for (let i = conn.length - 1; i >= 0; i--)
        wrap2 = Fragment.from(conn[i].create(null, wrap2));
      wrap2 = Fragment.from(before.copy(wrap2));
      let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end2, $cut.pos, end2, new Slice(wrap2, 1, 0), conn.length, true));
      let joinAt = end2 + 2 * conn.length;
      if (canJoin(tr2.doc, joinAt))
        tr2.join(joinAt);
      dispatch(tr2.scrollIntoView());
    }
    return true;
  }
  let selAfter = Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at = before, wrap2 = [];
    for (; ; ) {
      wrap2.push(at);
      if (at.isTextblock)
        break;
      at = at.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        let end2 = Fragment.empty;
        for (let i = wrap2.length - 1; i >= 0; i--)
          end2 = Fragment.from(wrap2[i].copy(end2));
        let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end2, wrap2.length, 0), 0, true));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
var selectTextblockStart = selectTextblockSide(-1);
var selectTextblockEnd = selectTextblockSide(1);
function wrapIn(nodeType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
    if (!wrapping)
      return false;
    if (dispatch)
      dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType2(nodeType, attrs = null) {
  return function(state, dispatch) {
    let applicable = false;
    for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
      let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index = $pos.index();
          applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch) {
      let tr2 = state.tr;
      for (let i = 0; i < state.selection.ranges.length; i++) {
        let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
        tr2.setBlockType(from2, to, nodeType, attrs);
      }
      dispatch(tr2.scrollIntoView());
    }
    return true;
  };
}
function chainCommands(...commands2) {
  return function(state, dispatch, view) {
    for (let i = 0; i < commands2.length; i++)
      if (commands2[i](state, dispatch, view))
        return true;
    return false;
  };
}
var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};
for (let key in pcBaseKeymap)
  macBaseKeymap[key] = pcBaseKeymap[key];
var mac4 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;

// node_modules/prosemirror-schema-list/dist/index.js
function wrapInList(listType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), doJoin = false, outerRange = range;
    if (!range)
      return false;
    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
      if ($from.index(range.depth - 1) == 0)
        return false;
      let $insert = state.doc.resolve(range.start - 2);
      outerRange = new NodeRange($insert, $insert, range.depth);
      if (range.endIndex < range.parent.childCount)
        range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
      doJoin = true;
    }
    let wrap2 = findWrapping(outerRange, listType, attrs, range);
    if (!wrap2)
      return false;
    if (dispatch)
      dispatch(doWrapInList(state.tr, range, wrap2, doJoin, listType).scrollIntoView());
    return true;
  };
}
function doWrapInList(tr2, range, wrappers, joinBefore, listType) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--)
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  tr2.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i = 0; i < wrappers.length; i++)
    if (wrappers[i].type == listType)
      found2 = i + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (let i = range.startIndex, e = range.endIndex, first2 = true; i < e; i++, first2 = false) {
    if (!first2 && canSplit(tr2.doc, splitPos, splitDepth)) {
      tr2.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i).nodeSize;
  }
  return tr2;
}
function liftListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    if (!dispatch)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch, itemType, range);
    else
      return liftOutOfList(state, dispatch, range);
  };
}
function liftToOuterList(state, dispatch, itemType, range) {
  let tr2 = state.tr, end2 = range.end, endOfList = range.$to.end(range.depth);
  if (end2 < endOfList) {
    tr2.step(new ReplaceAroundStep(end2 - 1, endOfList, end2, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr2.doc.resolve(range.$from.pos), tr2.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null)
    return false;
  tr2.lift(range, target);
  let after = tr2.mapping.map(end2, -1) - 1;
  if (canJoin(tr2.doc, after))
    tr2.join(after);
  dispatch(tr2.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch, range) {
  let tr2 = state.tr, list = range.parent;
  for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr2.delete(pos - 1, pos + 1);
  }
  let $start = tr2.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr2.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
    return false;
  let start2 = $start.pos, end2 = start2 + item.nodeSize;
  tr2.step(new ReplaceAroundStep(start2 - (atStart ? 1 : 0), end2 + (atEnd ? 1 : 0), start2 + 1, end2 - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr2.scrollIntoView());
  return true;
}
function sinkListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    let startIndex = range.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment.from(nestedBefore ? itemType.create() : null);
      let slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range.start, after = range.end;
      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
    }
    return true;
  };
}

// node_modules/@tiptap/core/dist/index.js
function createChainableState(config) {
  const { state, transaction } = config;
  let { selection } = transaction;
  let { doc: doc3 } = transaction;
  let { storedMarks } = transaction;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc3;
    },
    get tr() {
      selection = transaction.selection;
      doc3 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  };
}
var CommandManager = class {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr: tr2 } = state;
    const props = this.buildProps(tr2);
    return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      const method = (...args) => {
        const callback = command2(...args)(props);
        if (!tr2.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr2);
        }
        return callback;
      };
      return [name, method];
    }));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr2 = startTr || state.tr;
    const run4 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr2.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr2);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain = {
      ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        const chainedCommand = (...args) => {
          const props = this.buildProps(tr2, shouldDispatch);
          const callback = command2(...args)(props);
          callbacks.push(callback);
          return chain;
        };
        return [name, chainedCommand];
      })),
      run: run4
    };
    return chain;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch = false;
    const tr2 = startTr || state.tr;
    const props = this.buildProps(tr2, dispatch);
    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
    }));
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr2, dispatch)
    };
  }
  buildProps(tr2, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const props = {
      tr: tr2,
      editor,
      view,
      state: createChainableState({
        state,
        transaction: tr2
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr2, shouldDispatch),
      can: () => this.createCan(tr2),
      get commands() {
        return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          return [name, (...args) => command2(...args)(props)];
        }));
      }
    };
    return props;
  }
};
var EventEmitter = class {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn2) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn2);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn2) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn2) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn2);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
function getExtensionField(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
function splitExtensions(extensions2) {
  const baseExtensions = extensions2.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions2.filter((extension) => extension.type === "node");
  const markExtensions = extensions2.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions(extensions2) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions2.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField(extension, "addAttributes", context);
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      const mergedAttr = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === "function") {
        mergedAttr.default = mergedAttr.default();
      }
      if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = { ...items };
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        const valueClasses = value ? value.split(" ") : [];
        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key === "style") {
        mergedAttributes[key] = [mergedAttributes[key], value].join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
}
function isFunction(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = void 0, ...props) {
  if (isFunction(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
  if (parseRule.style) {
    return parseRule;
  }
  return {
    ...parseRule,
    getAttrs: (node) => {
      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items;
        }
        return {
          ...items,
          [item.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(data).filter(([key, value]) => {
      if (key === "attrs" && isEmptyObject(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    })
  );
}
function getSchemaByResolvedExtensions(extensions2, editor) {
  var _a;
  const allAttributes = getAttributesFromExtensions(extensions2);
  const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
  const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a === void 0 ? void 0 : _a.name;
  const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraNodeFields = extensions2.reduce((fields, e) => {
      const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
      return {
        ...fields,
        ...extendNodeSchema ? extendNodeSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraNodeFields,
      content: callOrReturn(getExtensionField(extension, "content", context)),
      marks: callOrReturn(getExtensionField(extension, "marks", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      inline: callOrReturn(getExtensionField(extension, "inline", context)),
      atom: callOrReturn(getExtensionField(extension, "atom", context)),
      selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
      draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      defining: callOrReturn(getExtensionField(extension, "defining", context)),
      isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (node) => renderHTML({
        node,
        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
      });
    }
    const renderText = getExtensionField(extension, "renderText", context);
    if (renderText) {
      schema.toText = renderText;
    }
    return [extension.name, schema];
  }));
  const marks = Object.fromEntries(markExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraMarkFields = extensions2.reduce((fields, e) => {
      const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
      return {
        ...fields,
        ...extendMarkSchema ? extendMarkSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraMarkFields,
      inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
      excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (mark) => renderHTML({
        mark,
        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
      });
    }
    return [extension.name, schema];
  }));
  return new Schema({
    topNode,
    nodes,
    marks
  });
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
var getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {
    var _a, _b;
    const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {
      node,
      pos,
      parent,
      index
    })) || node.textContent || "%leaf%";
    textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
var InputRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var inputRuleMatcherHandler = (text2, find2) => {
  if (isRegExp(find2)) {
    return find2.exec(text2);
  }
  const inputRuleMatch = find2(text2);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text2;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
function run$1(config) {
  var _a;
  const { editor, from: from2, to, text: text2, rules, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from2);
  if (
    // check for code node
    $from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark) => mark.type.spec.code))
  ) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text2;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match) {
      return;
    }
    const tr2 = view.state.tr;
    const state = createChainableState({
      state: view.state,
      transaction: tr2
    });
    const range = {
      from: from2 - (match[0].length - text2.length),
      to
    };
    const { commands: commands2, chain, can } = new CommandManager({
      editor,
      state
    });
    const handler = rule.handler({
      state,
      range,
      match,
      commands: commands2,
      chain,
      can
    });
    if (handler === null || !tr2.steps.length) {
      return;
    }
    tr2.setMeta(plugin, {
      transform: tr2,
      from: from2,
      to,
      text: text2
    });
    view.dispatch(tr2);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props) {
  const { editor, rules } = props;
  const plugin = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr2, prev) {
        const stored = tr2.getMeta(plugin);
        if (stored) {
          return stored;
        }
        return tr2.selectionSet || tr2.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from2, to, text2) {
        return run$1({
          editor,
          from: from2,
          to,
          text: text2,
          rules,
          plugin
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run$1({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules,
                plugin
              });
            }
          });
          return false;
        }
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run$1({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin
          });
        }
        return false;
      }
    },
    // @ts-ignore
    isInputRules: true
  });
  return plugin;
}
function isNumber(value) {
  return typeof value === "number";
}
var PasteRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var pasteRuleMatcherHandler = (text2, find2, event) => {
  if (isRegExp(find2)) {
    return [...text2.matchAll(find2)];
  }
  const matches2 = find2(text2, event);
  if (!matches2) {
    return [];
  }
  return matches2.map((pasteRuleMatch) => {
    const result = [pasteRuleMatch.text];
    result.index = pasteRuleMatch.index;
    result.input = text2;
    result.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result.push(pasteRuleMatch.replaceWith);
    }
    return result;
  });
};
function run2(config) {
  const { editor, state, from: from2, to, rule, pasteEvent, dropEvent } = config;
  const { commands: commands2, chain, can } = new CommandManager({
    editor,
    state
  });
  const handlers2 = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isTextblock || node.type.spec.code) {
      return;
    }
    const resolvedFrom = Math.max(from2, pos);
    const resolvedTo = Math.min(to, pos + node.content.size);
    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "\uFFFC");
    const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
    matches2.forEach((match) => {
      if (match.index === void 0) {
        return;
      }
      const start2 = resolvedFrom + match.index + 1;
      const end2 = start2 + match[0].length;
      const range = {
        from: state.tr.mapping.map(start2),
        to: state.tr.mapping.map(end2)
      };
      const handler = rule.handler({
        state,
        range,
        match,
        commands: commands2,
        chain,
        can,
        pasteEvent,
        dropEvent
      });
      handlers2.push(handler);
    });
  });
  const success = handlers2.every((handler) => handler !== null);
  return success;
}
function pasteRulesPlugin(props) {
  const { editor, rules } = props;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
  let dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
  const plugins = rules.map((rule) => {
    return new Plugin({
      // we register a global drag handler to track the current drag source element
      view(view) {
        const handleDragstart = (event) => {
          var _a;
          dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
        };
        window.addEventListener("dragstart", handleDragstart);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view, event) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            dropEvent = event;
            return false;
          },
          paste: (_view, event) => {
            var _a;
            const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
            pasteEvent = event;
            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state) => {
        const transaction = transactions[0];
        const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        if (!isPaste && !isDrop) {
          return;
        }
        const from2 = oldState.doc.content.findDiffStart(state.doc.content);
        const to = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber(from2) || !to || from2 === to.b) {
          return;
        }
        const tr2 = state.tr;
        const chainableState = createChainableState({
          state,
          transaction: tr2
        });
        const handler = run2({
          editor,
          state: chainableState,
          from: Math.max(from2 - 1, 0),
          to: to.b - 1,
          rule,
          pasteEvent,
          dropEvent
        });
        if (!handler || !tr2.steps.length) {
          return;
        }
        dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
        pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
        return tr2;
      }
    });
  });
  return plugins;
}
function findDuplicates(items) {
  const filtered = items.filter((el, index) => items.indexOf(el) !== index);
  return [...new Set(filtered)];
}
var ExtensionManager = class _ExtensionManager {
  constructor(extensions2, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.extensions = _ExtensionManager.resolve(extensions2);
    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
    this.extensions.forEach((extension) => {
      var _a;
      this.editor.extensionStorage[extension.name] = extension.storage;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a !== void 0 ? _a : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      const onCreate2 = getExtensionField(extension, "onCreate", context);
      if (onCreate2) {
        this.editor.on("create", onCreate2);
      }
      const onUpdate = getExtensionField(extension, "onUpdate", context);
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      const onTransaction = getExtensionField(extension, "onTransaction", context);
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      const onFocus = getExtensionField(extension, "onFocus", context);
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      const onBlur = getExtensionField(extension, "onBlur", context);
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      const onDestroy3 = getExtensionField(extension, "onDestroy", context);
      if (onDestroy3) {
        this.editor.on("destroy", onDestroy3);
      }
    });
  }
  static resolve(extensions2) {
    const resolvedExtensions = _ExtensionManager.sort(_ExtensionManager.flatten(extensions2));
    const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
    if (duplicatedNames.length) {
      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
    }
    return resolvedExtensions;
  }
  static flatten(extensions2) {
    return extensions2.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addExtensions = getExtensionField(extension, "addExtensions", context);
      if (addExtensions) {
        return [extension, ...this.flatten(addExtensions())];
      }
      return extension;
    }).flat(10);
  }
  static sort(extensions2) {
    const defaultPriority = 100;
    return extensions2.sort((a, b) => {
      const priorityA = getExtensionField(a, "priority") || defaultPriority;
      const priorityB = getExtensionField(b, "priority") || defaultPriority;
      if (priorityA > priorityB) {
        return -1;
      }
      if (priorityA < priorityB) {
        return 1;
      }
      return 0;
    });
  }
  get commands() {
    return this.extensions.reduce((commands2, extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionField(extension, "addCommands", context);
      if (!addCommands) {
        return commands2;
      }
      return {
        ...commands2,
        ...addCommands()
      };
    }, {});
  }
  get plugins() {
    const { editor } = this;
    const extensions2 = _ExtensionManager.sort([...this.extensions].reverse());
    const inputRules = [];
    const pasteRules = [];
    const allPlugins = extensions2.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
      let defaultBindings = {};
      if (extension.type === "mark" && extension.config.exitable) {
        defaultBindings.ArrowRight = () => Mark2.handleExit({ editor, mark: extension });
      }
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
          return [shortcut, () => method({ editor })];
        }));
        defaultBindings = { ...defaultBindings, ...bindings };
      }
      const keyMapPlugin = keymap(defaultBindings);
      plugins.push(keyMapPlugin);
      const addInputRules = getExtensionField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        inputRules.push(...addInputRules());
      }
      const addPasteRules = getExtensionField(extension, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
        pasteRules.push(...addPasteRules());
      }
      const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins.push(...proseMirrorPlugins);
      }
      return plugins;
    }).flat();
    return [
      inputRulesPlugin({
        editor,
        rules: inputRules
      }),
      ...pasteRulesPlugin({
        editor,
        rules: pasteRules
      }),
      ...allPlugins
    ];
  }
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
      const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getNodeType(extension.name, this.schema)
      };
      const addNodeView = getExtensionField(extension, "addNodeView", context);
      if (!addNodeView) {
        return [];
      }
      const nodeview = (node, view, getPos, decorations) => {
        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
        return addNodeView()({
          editor,
          node,
          getPos,
          decorations,
          HTMLAttributes,
          extension
        });
      };
      return [extension.name, nodeview];
    }));
  }
};
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source) {
  const output = { ...target };
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject(source[key])) {
        if (!(key in target)) {
          Object.assign(output, { [key]: source[key] });
        } else {
          output[key] = mergeDeep(target[key], source[key]);
        }
      } else {
        Object.assign(output, { [key]: source[key] });
      }
    });
  }
  return output;
}
var Extension = class _Extension {
  constructor(config = {}) {
    this.type = "extension";
    this.name = "extension";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Extension(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Extension({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
};
function getTextBetween(startNode, range, options) {
  const { from: from2, to } = range;
  const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
  let text2 = "";
  let separated = true;
  startNode.nodesBetween(from2, to, (node, pos, parent, index) => {
    var _a;
    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (node.isBlock && !separated) {
        text2 += blockSeparator;
        separated = true;
      }
      if (parent) {
        text2 += textSerializer({
          node,
          pos,
          parent,
          index,
          range
        });
      }
    } else if (node.isText) {
      text2 += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from2, pos) - pos, to - pos);
      separated = false;
    } else if (node.isBlock && !separated) {
      text2 += blockSeparator;
      separated = true;
    }
  });
  return text2;
}
function getTextSerializersFromSchema(schema) {
  return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
}
var ClipboardTextSerializer = Extension.create({
  name: "clipboardTextSerializer",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema } = editor;
            const { doc: doc3, selection } = state;
            const { ranges } = selection;
            const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
            const to = Math.max(...ranges.map((range2) => range2.$to.pos));
            const textSerializers = getTextSerializersFromSchema(schema);
            const range = { from: from2, to };
            return getTextBetween(doc3, range, {
              textSerializers
            });
          }
        }
      })
    ];
  }
});
var blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
    }
  });
  return true;
};
var clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
  return commands2.setContent("", emitUpdate);
};
var clearNodes = () => ({ state, tr: tr2, dispatch }) => {
  const { selection } = tr2;
  const { ranges } = selection;
  if (!dispatch) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) {
        return;
      }
      const { doc: doc3, mapping } = tr2;
      const $mappedFrom = doc3.resolve(mapping.map(pos));
      const $mappedTo = doc3.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr2.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr2.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
var command = (fn2) => (props) => {
  return fn2(props);
};
var createParagraphNear2 = () => ({ state, dispatch }) => {
  return createParagraphNear(state, dispatch);
};
var cut = (originRange, targetPos) => ({ editor, tr: tr2 }) => {
  const { state } = editor;
  const contentSlice = state.doc.slice(originRange.from, originRange.to);
  tr2.deleteRange(originRange.from, originRange.to);
  const newPos = tr2.mapping.map(targetPos);
  tr2.insert(newPos, contentSlice.content);
  tr2.setSelection(new TextSelection(tr2.doc.resolve(newPos - 1)));
  return true;
};
var deleteCurrentNode = () => ({ tr: tr2, dispatch }) => {
  const { selection } = tr2;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === currentNode.type) {
      if (dispatch) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteNode = (typeOrName) => ({ tr: tr2, state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === type) {
      if (dispatch) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteRange2 = (range) => ({ tr: tr2, dispatch }) => {
  const { from: from2, to } = range;
  if (dispatch) {
    tr2.delete(from2, to);
  }
  return true;
};
var deleteSelection2 = () => ({ state, dispatch }) => {
  return deleteSelection(state, dispatch);
};
var enter = () => ({ commands: commands2 }) => {
  return commands2.keyboardShortcut("Enter");
};
var exitCode2 = () => ({ state, dispatch }) => {
  return exitCode(state, dispatch);
};
function objectIncludes(object1, object2, options = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes(item.attrs, attributes);
  });
}
function isMarkInSet(marks, type, attributes = {}) {
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes = {}) {
  if (!$pos || !type) {
    return;
  }
  let start2 = $pos.parent.childAfter($pos.parentOffset);
  if ($pos.parentOffset === start2.offset && start2.offset !== 0) {
    start2 = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start2.node) {
    return;
  }
  const mark = findMarkInSet([...start2.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex = start2.index;
  let startPos = $pos.start() + start2.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start2.node.nodeSize;
  findMarkInSet([...start2.node.marks], type, attributes);
  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
var extendMarkRange = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
  const type = getMarkType(typeOrName, state.schema);
  const { doc: doc3, selection } = tr2;
  const { $from, from: from2, to } = selection;
  if (dispatch) {
    const range = getMarkRange($from, type, attributes);
    if (range && range.from <= from2 && range.to >= to) {
      const newSelection = TextSelection.create(doc3, range.from, range.to);
      tr2.setSelection(newSelection);
    }
  }
  return true;
};
var first = (commands2) => (props) => {
  const items = typeof commands2 === "function" ? commands2(props) : commands2;
  for (let i = 0; i < items.length; i += 1) {
    if (items[i](props)) {
      return true;
    }
  }
  return false;
};
function isTextSelection(value) {
  return value instanceof TextSelection;
}
function minMax(value = 0, min2 = 0, max2 = 0) {
  return Math.min(Math.max(value, min2), max2);
}
function resolveFocusPosition(doc3, position = null) {
  if (!position) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc3);
  const selectionAtEnd = Selection.atEnd(doc3);
  if (position === "start" || position === true) {
    return selectionAtStart;
  }
  if (position === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position === "all") {
    return TextSelection.create(doc3, minMax(0, minPos, maxPos), minMax(doc3.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc3, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
}
function isiOS() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var focus = (position = null, options = {}) => ({ editor, view, tr: tr2, dispatch }) => {
  options = {
    scrollIntoView: true,
    ...options
  };
  const delayedFocus = () => {
    if (isiOS()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position === null || position === false) {
    return true;
  }
  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(tr2.doc, position) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch) {
    if (!isSameSelection) {
      tr2.setSelection(selection);
    }
    if (isSameSelection && tr2.storedMarks) {
      tr2.setStoredMarks(tr2.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
var forEach = (items, fn2) => (props) => {
  return items.every((item, index) => fn2(item, { ...props, index }));
};
var insertContent = (value, options) => ({ tr: tr2, commands: commands2 }) => {
  return commands2.insertContentAt({ from: tr2.selection.from, to: tr2.selection.to }, value, options);
};
var removeWhitespaces = (node) => {
  const children2 = node.childNodes;
  for (let i = children2.length - 1; i >= 0; i -= 1) {
    const child = children2[i];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function elementFromString(value) {
  const wrappedValue = `<body>${value}</body>`;
  const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces(html);
}
function createNodeFromContent(content, schema, options) {
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  if (typeof content === "object" && content !== null) {
    try {
      if (Array.isArray(content) && content.length > 0) {
        return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      return schema.nodeFromJSON(content);
    } catch (error) {
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent("", schema, options);
    }
  }
  if (typeof content === "string") {
    const parser = DOMParser2.fromSchema(schema);
    return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);
  }
  return createNodeFromContent("", schema, options);
}
function selectionToInsertionEnd2(tr2, startLen, bias) {
  const last = tr2.steps.length - 1;
  if (last < startLen) {
    return;
  }
  const step = tr2.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map2 = tr2.mapping.maps[last];
  let end2 = 0;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end2 === 0) {
      end2 = newTo;
    }
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end2), bias));
}
var isFragment = (nodeOrFragment) => {
  return nodeOrFragment.toString().startsWith("<");
};
var insertContentAt = (position, value, options) => ({ tr: tr2, dispatch, editor }) => {
  if (dispatch) {
    options = {
      parseOptions: {},
      updateSelection: true,
      ...options
    };
    const content = createNodeFromContent(value, editor.schema, {
      parseOptions: {
        preserveWhitespace: "full",
        ...options.parseOptions
      }
    });
    if (content.toString() === "<>") {
      return true;
    }
    let { from: from2, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from2 === to && isOnlyBlockContent) {
      const { parent } = tr2.doc.resolve(from2);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from2 -= 1;
        to += 1;
      }
    }
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        tr2.insertText(value.map((v) => v.text || "").join(""), from2, to);
      } else if (typeof value === "object" && !!value && !!value.text) {
        tr2.insertText(value.text, from2, to);
      } else {
        tr2.insertText(value, from2, to);
      }
    } else {
      tr2.replaceWith(from2, to, content);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd2(tr2, tr2.steps.length - 1, -1);
    }
  }
  return true;
};
var joinUp2 = () => ({ state, dispatch }) => {
  return joinUp(state, dispatch);
};
var joinDown2 = () => ({ state, dispatch }) => {
  return joinDown(state, dispatch);
};
var joinBackward2 = () => ({ state, dispatch }) => {
  return joinBackward(state, dispatch);
};
var joinForward2 = () => ({ state, dispatch }) => {
  return joinForward(state, dispatch);
};
var joinItemBackward = () => ({ tr: tr2, state, dispatch }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, -1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch) {
      dispatch(tr2);
    }
    return true;
  } catch {
    return false;
  }
};
var joinItemForward = () => ({ state, dispatch, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, 1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch) {
      dispatch(tr2);
    }
    return true;
  } catch (e) {
    return false;
  }
};
var joinTextblockBackward2 = () => ({ state, dispatch }) => {
  return joinTextblockBackward(state, dispatch);
};
var joinTextblockForward2 = () => ({ state, dispatch }) => {
  return joinTextblockForward(state, dispatch);
};
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName2(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift2;
  let meta;
  for (let i = 0; i < parts.length - 1; i += 1) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift2) {
    result = `Shift-${result}`;
  }
  return result;
}
var keyboardShortcut = (name) => ({ editor, view, tr: tr2, dispatch }) => {
  const keys2 = normalizeKeyName2(name).split(/-(?!$)/);
  const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f) => f(view, event));
  });
  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr2.mapping);
    if (newStep && dispatch) {
      tr2.maybeStep(newStep);
    }
  });
  return true;
};
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from: from2, to, empty: empty3 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from2, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from2;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty3) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
var lift3 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift2(state, dispatch);
};
var liftEmptyBlock2 = () => ({ state, dispatch }) => {
  return liftEmptyBlock(state, dispatch);
};
var liftListItem2 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return liftListItem(type)(state, dispatch);
};
var newlineInCode2 = () => ({ state, dispatch }) => {
  return newlineInCode(state, dispatch);
};
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
var resetAttributes = (typeOrName, attributes) => ({ tr: tr2, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr2.selection.ranges.forEach((range) => {
      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr2.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr2.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
var scrollIntoView = () => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    tr2.scrollIntoView();
  }
  return true;
};
var selectAll2 = () => ({ tr: tr2, commands: commands2 }) => {
  return commands2.setTextSelection({
    from: 0,
    to: tr2.doc.content.size
  });
};
var selectNodeBackward2 = () => ({ state, dispatch }) => {
  return selectNodeBackward(state, dispatch);
};
var selectNodeForward2 = () => ({ state, dispatch }) => {
  return selectNodeForward(state, dispatch);
};
var selectParentNode2 = () => ({ state, dispatch }) => {
  return selectParentNode(state, dispatch);
};
var selectTextblockEnd2 = () => ({ state, dispatch }) => {
  return selectTextblockEnd(state, dispatch);
};
var selectTextblockStart2 = () => ({ state, dispatch }) => {
  return selectTextblockStart(state, dispatch);
};
function createDocument(content, schema, parseOptions = {}) {
  return createNodeFromContent(content, schema, { slice: false, parseOptions });
}
var setContent = (content, emitUpdate = false, parseOptions = {}) => ({ tr: tr2, editor, dispatch }) => {
  const { doc: doc3 } = tr2;
  const document2 = createDocument(content, editor.schema, parseOptions);
  if (dispatch) {
    tr2.replaceWith(0, doc3.content.size, document2).setMeta("preventUpdate", !emitUpdate);
  }
  return true;
};
function getMarkAttributes(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from: from2, to, empty: empty3 } = state.selection;
  const marks = [];
  if (empty3) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from2, to, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function combineTransactionSteps(oldDoc, transactions) {
  const transform = new Transform(oldDoc);
  transactions.forEach((transaction) => {
    transaction.steps.forEach((step) => {
      transform.step(step);
    });
  });
  return transform;
}
function defaultBlockAt2(match) {
  for (let i = 0; i < match.edgeCount; i += 1) {
    const { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findChildren(node, predicate) {
  const nodesWithPos = [];
  node.descendants((child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function findChildrenInRange(node, range, predicate) {
  const nodesWithPos = [];
  node.nodesBetween(range.from, range.to, (child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (let i = $pos.depth; i > 0; i -= 1) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
function getText2(node, options) {
  const range = {
    from: 0,
    to: node.content.size
  };
  return getTextBetween(node, range, options);
}
function getNodeAttributes(state, typeOrName) {
  const type = getNodeType(typeOrName, state.schema);
  const { from: from2, to } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from2, to, (node2) => {
    nodes.push(node2);
  });
  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node) {
    return {};
  }
  return { ...node.attrs };
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function removeDuplicates(array, by = JSON.stringify) {
  const seen = {};
  return array.filter((item) => {
    const key = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
  });
}
function simplifyChangedRanges(changes) {
  const uniqueChanges = removeDuplicates(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index) => {
    const rest = uniqueChanges.filter((_, i) => i !== index);
    return !rest.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges(transform) {
  const { mapping, steps } = transform;
  const changes = [];
  mapping.maps.forEach((stepMap, index) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from2, to } = steps[index];
      if (from2 === void 0 || to === void 0) {
        return;
      }
      ranges.push({ from: from2, to });
    } else {
      stepMap.forEach((from2, to) => {
        ranges.push({ from: from2, to });
      });
    }
    ranges.forEach(({ from: from2, to }) => {
      const newStart = mapping.slice(index).map(from2, -1);
      const newEnd = mapping.slice(index).map(to);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges(changes);
}
function getMarksBetween(from2, to, doc3) {
  const marks = [];
  if (from2 === to) {
    doc3.resolve(from2).marks().forEach((mark) => {
      const $pos = doc3.resolve(from2 - 1);
      const range = getMarkRange($pos, mark.type);
      if (!range) {
        return;
      }
      marks.push({
        mark,
        ...range
      });
    });
  } else {
    doc3.nodesBetween(from2, to, (node, pos) => {
      if (!node || (node === null || node === void 0 ? void 0 : node.nodeSize) === void 0) {
        return;
      }
      marks.push(...node.marks.map((mark) => ({
        from: pos,
        to: pos + node.nodeSize,
        mark
      })));
    });
  }
  return marks;
}
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
    const extensionAttribute = extensionAttributes.find((item) => {
      return item.type === typeName && item.name === name;
    });
    if (!extensionAttribute) {
      return false;
    }
    return extensionAttribute.attribute.keepOnSplit;
  }));
}
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty3, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty3) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from2 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(...node.marks.map((mark) => ({
        mark,
        from: relativeFrom,
        to: relativeTo
      })));
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function isActive(state, name, attributes = {}) {
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
function isList(name, extensions2) {
  const { nodeExtensions } = splitExtensions(extensions2);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function isNodeEmpty(node) {
  var _a;
  const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();
  const content = node.toJSON();
  return JSON.stringify(defaultContent) === JSON.stringify(content);
}
function isNodeSelection(value) {
  return value instanceof NodeSelection;
}
function posToDOMRect(view, from2, to) {
  const minPos = 0;
  const maxPos = view.state.doc.content.size;
  const resolvedFrom = minMax(from2, minPos, maxPos);
  const resolvedEnd = minMax(to, minPos, maxPos);
  const start2 = view.coordsAtPos(resolvedFrom);
  const end2 = view.coordsAtPos(resolvedEnd, -1);
  const top2 = Math.min(start2.top, end2.top);
  const bottom2 = Math.max(start2.bottom, end2.bottom);
  const left2 = Math.min(start2.left, end2.left);
  const right2 = Math.max(start2.right, end2.right);
  const width = right2 - left2;
  const height = bottom2 - top2;
  const x = left2;
  const y = top2;
  const data = {
    top: top2,
    bottom: bottom2,
    left: left2,
    right: right2,
    width,
    height,
    x,
    y
  };
  return {
    ...data,
    toJSON: () => data
  };
}
function canSetMark(state, tr2, newMarkType) {
  var _a;
  const { selection } = tr2;
  let cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
var setMark = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
  const { selection } = tr2;
  const { empty: empty3, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch) {
    if (empty3) {
      const oldAttributes = getMarkAttributes(state, type);
      tr2.addStoredMark(type.create({
        ...oldAttributes,
        ...attributes
      }));
    } else {
      ranges.forEach((range) => {
        const from2 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from2, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from2);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr2.addMark(trimmedFrom, trimmedTo, type.create({
                  ...mark.attrs,
                  ...attributes
                }));
              }
            });
          } else {
            tr2.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(state, tr2, type);
};
var setMeta = (key, value) => ({ tr: tr2 }) => {
  tr2.setMeta(key, value);
  return true;
};
var setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
  const type = getNodeType(typeOrName, state.schema);
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain().command(({ commands: commands2 }) => {
    const canSetBlock = setBlockType2(type, attributes)(state);
    if (canSetBlock) {
      return true;
    }
    return commands2.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType2(type, attributes)(updatedState, dispatch);
  }).run();
};
var setNodeSelection = (position) => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    const { doc: doc3 } = tr2;
    const from2 = minMax(position, 0, doc3.content.size);
    const selection = NodeSelection.create(doc3, from2);
    tr2.setSelection(selection);
  }
  return true;
};
var setTextSelection = (position) => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    const { doc: doc3 } = tr2;
    const { from: from2, to } = typeof position === "number" ? { from: position, to: position } : position;
    const minPos = TextSelection.atStart(doc3).from;
    const maxPos = TextSelection.atEnd(doc3).to;
    const resolvedFrom = minMax(from2, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const selection = TextSelection.create(doc3, resolvedFrom, resolvedEnd);
    tr2.setSelection(selection);
  }
  return true;
};
var sinkListItem2 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return sinkListItem(type)(state, dispatch);
};
function ensureMarks(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
var splitBlock2 = ({ keepMarks = true } = {}) => ({ tr: tr2, state, dispatch, editor }) => {
  const { selection, doc: doc3 } = tr2;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc3, $from.pos)) {
      return false;
    }
    if (dispatch) {
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr2.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  if (dispatch) {
    const atEnd = $to.parentOffset === $to.parent.content.size;
    if (selection instanceof TextSelection) {
      tr2.deleteSelection();
    }
    const deflt = $from.depth === 0 ? void 0 : defaultBlockAt2($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    let types = atEnd && deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
    let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
    if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
      can = true;
      types = deflt ? [
        {
          type: deflt,
          attrs: newAttributes
        }
      ] : void 0;
    }
    if (can) {
      tr2.split(tr2.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr2.mapping.map($from.before());
        const $first = tr2.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state, editor.extensionManager.splittableMarks);
    }
    tr2.scrollIntoView();
  }
  return true;
};
var splitListItem = (typeOrName) => ({ tr: tr2, state, dispatch, editor }) => {
  var _a;
  const type = getNodeType(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node = state.selection.node;
  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch) {
      let wrap2 = Fragment.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
        wrap2 = Fragment.from($from.node(d).copy(wrap2));
      }
      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
      const newNextTypeAttributes2 = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
      const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
      const start2 = $from.before($from.depth - (depthBefore - 1));
      tr2.replace(start2, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
      let sel = -1;
      tr2.doc.nodesBetween(start2, tr2.doc.content.size, (n, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n.isTextblock && n.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr2.setSelection(TextSelection.near(tr2.doc.resolve(sel)));
      }
      tr2.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
  const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  tr2.delete($from.pos, $to.pos);
  const types = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr2.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch) {
    const { selection, storedMarks } = state;
    const { splittableMarks } = editor.extensionManager;
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    tr2.split($from.pos, 2, types).scrollIntoView();
    if (!marks || !dispatch) {
      return true;
    }
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
  }
  return true;
};
var joinListBackwards = (tr2, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const before = tr2.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === void 0) {
    return true;
  }
  const nodeBefore = tr2.doc.nodeAt(before);
  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr2.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr2.join(list.pos);
  return true;
};
var joinListForwards = (tr2, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const after = tr2.doc.resolve(list.start).after(list.depth);
  if (after === void 0) {
    return true;
  }
  const nodeAfter = tr2.doc.nodeAt(after);
  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr2.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr2.join(after);
  return true;
};
var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr: tr2, state, dispatch, chain, commands: commands2, can }) => {
  const { extensions: extensions2, splittableMarks } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state.schema);
  const itemType = getNodeType(itemTypeOrName, state.schema);
  const { selection, storedMarks } = state;
  const { $from, $to } = selection;
  const range = $from.blockRange($to);
  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
  if (!range) {
    return false;
  }
  const parentList = findParentNode((node) => isList(node.type.name, extensions2))(selection);
  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands2.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions2) && listType.validContent(parentList.node.content) && dispatch) {
      return chain().command(() => {
        tr2.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
    }
  }
  if (!keepMarks || !marks || !dispatch) {
    return chain().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      if (canWrapInList) {
        return true;
      }
      return commands2.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
  }
  return chain().command(() => {
    const canWrapInList = can().wrapInList(listType, attributes);
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
    if (canWrapInList) {
      return true;
    }
    return commands2.clearNodes();
  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
};
var toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands: commands2 }) => {
  const { extendEmptyMarkRange = false } = options;
  const type = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type, attributes);
  if (isActive2) {
    return commands2.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands2.setMark(type, attributes);
};
var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands2.setNode(toggleType);
  }
  return commands2.setNode(type, attributes);
};
var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands2.lift(type);
  }
  return commands2.wrapIn(type, attributes);
};
var undoInputRule = () => ({ state, dispatch }) => {
  const plugins = state.plugins;
  for (let i = 0; i < plugins.length; i += 1) {
    const plugin = plugins[i];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        const tr2 = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
          tr2.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks = tr2.doc.resolve(undoable.from).marks();
          tr2.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr2.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
var unsetAllMarks = () => ({ tr: tr2, dispatch }) => {
  const { selection } = tr2;
  const { empty: empty3, ranges } = selection;
  if (empty3) {
    return true;
  }
  if (dispatch) {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
var unsetMark = (typeOrName, options = {}) => ({ tr: tr2, state, dispatch }) => {
  var _a;
  const { extendEmptyMarkRange = false } = options;
  const { selection } = tr2;
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty3, ranges } = selection;
  if (!dispatch) {
    return true;
  }
  if (empty3 && extendEmptyMarkRange) {
    let { from: from2, to } = selection;
    const attrs = (_a = $from.marks().find((mark) => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;
    const range = getMarkRange($from, type, attrs);
    if (range) {
      from2 = range.from;
      to = range.to;
    }
    tr2.removeMark(from2, to, type);
  } else {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr2.removeStoredMark(type);
  return true;
};
var updateAttributes = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr2.selection.ranges.forEach((range) => {
      const from2 = range.$from.pos;
      const to = range.$to.pos;
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr2.setNodeMarkup(pos, void 0, {
            ...node.attrs,
            ...attributes
          });
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              const trimmedFrom = Math.max(pos, from2);
              const trimmedTo = Math.min(pos + node.nodeSize, to);
              tr2.addMark(trimmedFrom, trimmedTo, markType.create({
                ...mark.attrs,
                ...attributes
              }));
            }
          });
        }
      });
    });
  }
  return true;
};
var wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapIn(type, attributes)(state, dispatch);
};
var wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapInList(type, attributes)(state, dispatch);
};
var commands = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur,
  clearContent,
  clearNodes,
  command,
  createParagraphNear: createParagraphNear2,
  cut,
  deleteCurrentNode,
  deleteNode,
  deleteRange: deleteRange2,
  deleteSelection: deleteSelection2,
  enter,
  exitCode: exitCode2,
  extendMarkRange,
  first,
  focus,
  forEach,
  insertContent,
  insertContentAt,
  joinUp: joinUp2,
  joinDown: joinDown2,
  joinBackward: joinBackward2,
  joinForward: joinForward2,
  joinItemBackward,
  joinItemForward,
  joinTextblockBackward: joinTextblockBackward2,
  joinTextblockForward: joinTextblockForward2,
  keyboardShortcut,
  lift: lift3,
  liftEmptyBlock: liftEmptyBlock2,
  liftListItem: liftListItem2,
  newlineInCode: newlineInCode2,
  resetAttributes,
  scrollIntoView,
  selectAll: selectAll2,
  selectNodeBackward: selectNodeBackward2,
  selectNodeForward: selectNodeForward2,
  selectParentNode: selectParentNode2,
  selectTextblockEnd: selectTextblockEnd2,
  selectTextblockStart: selectTextblockStart2,
  setContent,
  setMark,
  setMeta,
  setNode,
  setNodeSelection,
  setTextSelection,
  sinkListItem: sinkListItem2,
  splitBlock: splitBlock2,
  splitListItem,
  toggleList,
  toggleMark,
  toggleNode,
  toggleWrap,
  undoInputRule,
  unsetAllMarks,
  unsetMark,
  updateAttributes,
  wrapIn: wrapIn2,
  wrapInList: wrapInList2
});
var Commands = Extension.create({
  name: "commands",
  addCommands() {
    return {
      ...commands
    };
  }
});
var Editable = Extension.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
var FocusEvents = Extension.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: new PluginKey("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            }
          }
        }
      })
    ];
  }
});
var Keymap = Extension.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.undoInputRule(),
      // maybe convert first text block node to default node
      () => commands2.command(({ tr: tr2 }) => {
        const { selection, doc: doc3 } = tr2;
        const { empty: empty3, $anchor } = selection;
        const { pos, parent } = $anchor;
        const $parentPos = $anchor.parent.isTextblock ? tr2.doc.resolve(pos - 1) : $anchor;
        const parentIsIsolating = $parentPos.parent.type.spec.isolating;
        const parentPos = $anchor.pos - $anchor.parentOffset;
        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc3).from === pos;
        if (!empty3 || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {
          return false;
        }
        return commands2.clearNodes();
      }),
      () => commands2.deleteSelection(),
      () => commands2.joinBackward(),
      () => commands2.selectNodeBackward()
    ]);
    const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.deleteSelection(),
      () => commands2.deleteCurrentNode(),
      () => commands2.joinForward(),
      () => commands2.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.newlineInCode(),
      () => commands2.createParagraphNear(),
      () => commands2.liftEmptyBlock(),
      () => commands2.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace,
      "Mod-Backspace": handleBackspace,
      "Shift-Backspace": handleBackspace,
      Delete: handleDelete,
      "Mod-Delete": handleDelete,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace,
      "Alt-Backspace": handleBackspace,
      "Ctrl-d": handleDelete,
      "Ctrl-Alt-Backspace": handleDelete,
      "Alt-Delete": handleDelete,
      "Alt-d": handleDelete,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
          if (!docChanges) {
            return;
          }
          const { empty: empty3, from: from2, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from2 === allFrom && to === allEnd;
          if (empty3 || !allWasSelected) {
            return;
          }
          const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, " ", " ").length === 0;
          if (!isEmpty) {
            return;
          }
          const tr2 = newState.tr;
          const state = createChainableState({
            state: newState,
            transaction: tr2
          });
          const { commands: commands2 } = new CommandManager({
            editor: this.editor,
            state
          });
          commands2.clearNodes();
          if (!tr2.steps.length) {
            return;
          }
          return tr2;
        }
      })
    ];
  }
});
var Tabindex = Extension.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var extensions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ClipboardTextSerializer,
  Commands,
  Editable,
  FocusEvents,
  Keymap,
  Tabindex
});
var NodePos = class _NodePos {
  constructor(pos, editor, isBlock = false, node = null) {
    this.currentNode = null;
    this.actualDepth = null;
    this.isBlock = isBlock;
    this.resolvedPos = pos;
    this.editor = editor;
    this.currentNode = node;
  }
  get name() {
    return this.node.type.name;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var _a;
    return (_a = this.actualDepth) !== null && _a !== void 0 ? _a : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(content) {
    let from2 = this.from;
    let to = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can\u2019t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      from2 = this.from + 1;
      to = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: from2, to }, content);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    if (this.isBlock) {
      return this.pos;
    }
    return this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    if (this.isBlock) {
      return this.pos + this.size;
    }
    return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0) {
      return null;
    }
    const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
    const $pos = this.resolvedPos.doc.resolve(parentPos);
    return new _NodePos($pos, this.editor);
  }
  get before() {
    let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.from - 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get after() {
    let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.to + 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get children() {
    const children2 = [];
    this.node.content.forEach((node, offset2) => {
      const isBlock = node.isBlock && !node.isTextblock;
      const targetPos = this.pos + offset2 + (isBlock ? 0 : 1);
      const $pos = this.resolvedPos.doc.resolve(targetPos);
      if (!isBlock && $pos.depth <= this.depth) {
        return;
      }
      const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node : null);
      if (isBlock) {
        childNodePos.actualDepth = this.depth + 1;
      }
      children2.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node : null));
    });
    return children2;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const children2 = this.children;
    return children2[children2.length - 1] || null;
  }
  closest(selector, attributes = {}) {
    let node = null;
    let currentNode = this.parent;
    while (currentNode && !node) {
      if (currentNode.node.type.name === selector) {
        if (Object.keys(attributes).length > 0) {
          const nodeAttributes = currentNode.node.attrs;
          const attrKeys = Object.keys(attributes);
          for (let index = 0; index < attrKeys.length; index += 1) {
            const key = attrKeys[index];
            if (nodeAttributes[key] !== attributes[key]) {
              break;
            }
          }
        } else {
          node = currentNode;
        }
      }
      currentNode = currentNode.parent;
    }
    return node;
  }
  querySelector(selector, attributes = {}) {
    return this.querySelectorAll(selector, attributes, true)[0] || null;
  }
  querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
    let nodes = [];
    if (this.isBlock || !this.children || this.children.length === 0) {
      return nodes;
    }
    this.children.forEach((childPos) => {
      if (childPos.node.type.name === selector) {
        if (Object.keys(attributes).length > 0) {
          const nodeAttributes = childPos.node.attrs;
          const attrKeys = Object.keys(attributes);
          for (let index = 0; index < attrKeys.length; index += 1) {
            const key = attrKeys[index];
            if (nodeAttributes[key] !== attributes[key]) {
              return;
            }
          }
        }
        nodes.push(childPos);
        if (firstItemOnly) {
          return;
        }
      }
      nodes = nodes.concat(childPos.querySelectorAll(selector));
    });
    return nodes;
  }
  setAttribute(attributes) {
    const oldSelection = this.editor.state.selection;
    this.editor.chain().setTextSelection(this.from).updateAttributes(this.node.type.name, attributes).setTextSelection(oldSelection.from).run();
  }
};
var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function createStyleTag(style2, nonce, suffix) {
  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ""}]`);
  if (tiptapStyleTag !== null) {
    return tiptapStyleTag;
  }
  const styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ""}`, "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
var Editor = class extends EventEmitter {
  constructor(options = {}) {
    super();
    this.isFocused = false;
    this.extensionStorage = {};
    this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: true,
      injectNonce: void 0,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.setOptions(options);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.createView();
    this.injectCSS();
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      this.commands.focus(this.options.autofocus);
      this.emit("create", { editor: this });
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    if (this.options.injectCSS && document) {
      this.css = createStyleTag(style, this.options.injectNonce);
    }
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(options = {}) {
    this.options = {
      ...this.options,
      ...options
    };
    if (!this.view || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(editable, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr });
    }
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   */
  registerPlugin(plugin, handlePlugins) {
    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKey The plugins name
   */
  unregisterPlugin(nameOrPluginKey) {
    if (this.isDestroyed) {
      return;
    }
    const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
    const state = this.state.reconfigure({
      // @ts-ignore
      plugins: this.state.plugins.filter((plugin) => !plugin.key.startsWith(name))
    });
    this.view.updateState(state);
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new CommandManager({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    const doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions);
    const selection = resolveFocusPosition(doc3, this.options.autofocus);
    this.view = new EditorView(this.options.element, {
      ...this.options.editorProps,
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: EditorState.create({
        doc: doc3,
        selection: selection || void 0
      })
    });
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.createNodeViews();
    this.prependClass();
    const dom = this.view.dom;
    dom.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(fn2) {
    this.isCapturingTransaction = true;
    fn2();
    this.isCapturingTransaction = false;
    const tr2 = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr2;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(transaction) {
    if (this.view.isDestroyed) {
      return;
    }
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction;
        return;
      }
      transaction.steps.forEach((step) => {
        var _a;
        return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);
      });
      return;
    }
    const state = this.state.apply(transaction);
    const selectionHasChanged = !this.state.selection.eq(state.selection);
    this.view.updateState(state);
    this.emit("transaction", {
      editor: this,
      transaction
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction
      });
    }
    const focus2 = transaction.getMeta("focus");
    const blur2 = transaction.getMeta("blur");
    if (focus2) {
      this.emit("focus", {
        editor: this,
        event: focus2.event,
        transaction
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        transaction
      });
    }
    if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(options) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    return getText2(this.state.doc, {
      blockSeparator,
      textSerializers: {
        ...getTextSerializersFromSchema(this.schema),
        ...textSerializers
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return isNodeEmpty(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
    return this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy");
    if (this.view) {
      this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var _a;
    return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
  }
  $node(selector, attributes) {
    var _a;
    return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelector(selector, attributes)) || null;
  }
  $nodes(selector, attributes) {
    var _a;
    return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector, attributes)) || null;
  }
  $pos(pos) {
    const $pos = this.state.doc.resolve(pos);
    return new NodePos($pos, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function markInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        const markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}
function nodeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const { tr: tr2 } = state;
      const start2 = range.from;
      let end2 = range.to;
      const newNode = config.type.create(attributes);
      if (match[1]) {
        const offset2 = match[0].lastIndexOf(match[1]);
        let matchStart = start2 + offset2;
        if (matchStart > end2) {
          matchStart = end2;
        } else {
          end2 = matchStart + match[1].length;
        }
        const lastChar = match[0][match[0].length - 1];
        tr2.insertText(lastChar, start2 + match[0].length - 1);
        tr2.replaceWith(matchStart, end2, newNode);
      } else if (match[0]) {
        tr2.insert(start2 - 1, config.type.create(attributes)).delete(tr2.mapping.map(start2), tr2.mapping.map(end2));
      }
      tr2.scrollIntoView();
    }
  });
}
function textblockTypeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const $start = state.doc.resolve(range.from);
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
    }
  });
}
function wrappingInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match, chain }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const tr2 = state.tr.delete(range.from, range.to);
      const $start = tr2.doc.resolve(range.from);
      const blockRange = $start.blockRange();
      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr2.wrap(blockRange, wrapping);
      if (config.keepMarks && config.editor) {
        const { selection, storedMarks } = state;
        const { splittableMarks } = config.editor.extensionManager;
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        if (marks) {
          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
          tr2.ensureMarks(filteredMarks);
        }
      }
      if (config.keepAttributes) {
        const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
        chain().updateAttributes(nodeType, attributes).run();
      }
      const before = tr2.doc.resolve(range.from - 1).nodeBefore;
      if (before && before.type === config.type && canJoin(tr2.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {
        tr2.join(range.from - 1);
      }
    }
  });
}
var Mark2 = class _Mark {
  constructor(config = {}) {
    this.type = "mark";
    this.name = "mark";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Mark(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Mark({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  static handleExit({ editor, mark }) {
    const { tr: tr2 } = editor.state;
    const currentPos = editor.state.selection.$from;
    const isAtEnd = currentPos.pos === currentPos.end();
    if (isAtEnd) {
      const currentMarks = currentPos.marks();
      const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (!isInMark) {
        return false;
      }
      const removeMark2 = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (removeMark2) {
        tr2.removeStoredMark(removeMark2);
      }
      tr2.insertText(" ", currentPos.pos);
      editor.view.dispatch(tr2);
      return true;
    }
    return false;
  }
};
var Node2 = class _Node {
  constructor(config = {}) {
    this.type = "node";
    this.name = "node";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Node(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Node({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
};
function isAndroid() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
var NodeView = class {
  constructor(component, props, options) {
    this.isDragging = false;
    this.component = component;
    this.editor = props.editor;
    this.options = {
      stopEvent: null,
      ignoreMutation: null,
      ...options
    };
    this.extension = props.extension;
    this.node = props.node;
    this.decorations = props.decorations;
    this.getPos = props.getPos;
    this.mount();
  }
  mount() {
    return;
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(event) {
    var _a, _b, _c, _d, _e, _f, _g;
    const { view } = this.editor;
    const target = event.target;
    const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest("[data-drag-handle]") : target.closest("[data-drag-handle]");
    if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {
      return;
    }
    let x = 0;
    let y = 0;
    if (this.dom !== dragHandle) {
      const domBox = this.dom.getBoundingClientRect();
      const handleBox = dragHandle.getBoundingClientRect();
      const offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;
      const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;
      x = handleBox.x - domBox.x + offsetX;
      y = handleBox.y - domBox.y + offsetY;
    }
    (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(this.dom, x, y);
    const selection = NodeSelection.create(view.state.doc, this.getPos());
    const transaction = view.state.tr.setSelection(selection);
    view.dispatch(transaction);
  }
  stopEvent(event) {
    var _a;
    if (!this.dom) {
      return false;
    }
    if (typeof this.options.stopEvent === "function") {
      return this.options.stopEvent({ event });
    }
    const target = event.target;
    const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));
    if (!isInElement) {
      return false;
    }
    const isDragEvent = event.type.startsWith("drag");
    const isDropEvent = event.type === "drop";
    const isInput = ["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(target.tagName) || target.isContentEditable;
    if (isInput && !isDropEvent && !isDragEvent) {
      return true;
    }
    const { isEditable } = this.editor;
    const { isDragging } = this;
    const isDraggable = !!this.node.type.spec.draggable;
    const isSelectable = NodeSelection.isSelectable(this.node);
    const isCopyEvent = event.type === "copy";
    const isPasteEvent = event.type === "paste";
    const isCutEvent = event.type === "cut";
    const isClickEvent = event.type === "mousedown";
    if (!isDraggable && isSelectable && isDragEvent) {
      event.preventDefault();
    }
    if (isDraggable && isDragEvent && !isDragging) {
      event.preventDefault();
      return false;
    }
    if (isDraggable && isEditable && !isDragging && isClickEvent) {
      const dragHandle = target.closest("[data-drag-handle]");
      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));
      if (isValidDragHandle) {
        this.isDragging = true;
        document.addEventListener("dragend", () => {
          this.isDragging = false;
        }, { once: true });
        document.addEventListener("drop", () => {
          this.isDragging = false;
        }, { once: true });
        document.addEventListener("mouseup", () => {
          this.isDragging = false;
        }, { once: true });
      }
    }
    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {
      return false;
    }
    return true;
  }
  ignoreMutation(mutation) {
    if (!this.dom || !this.contentDOM) {
      return true;
    }
    if (typeof this.options.ignoreMutation === "function") {
      return this.options.ignoreMutation({ mutation });
    }
    if (this.node.isLeaf || this.node.isAtom) {
      return true;
    }
    if (mutation.type === "selection") {
      return false;
    }
    if (this.dom.contains(mutation.target) && mutation.type === "childList" && (isiOS() || isAndroid()) && this.editor.isFocused) {
      const changedNodes = [
        ...Array.from(mutation.addedNodes),
        ...Array.from(mutation.removedNodes)
      ];
      if (changedNodes.every((node) => node.isContentEditable)) {
        return false;
      }
    }
    if (this.contentDOM === mutation.target && mutation.type === "attributes") {
      return true;
    }
    if (this.contentDOM.contains(mutation.target)) {
      return false;
    }
    return true;
  }
  updateAttributes(attributes) {
    this.editor.commands.command(({ tr: tr2 }) => {
      const pos = this.getPos();
      tr2.setNodeMarkup(pos, void 0, {
        ...this.node.attrs,
        ...attributes
      });
      return true;
    });
  }
  deleteNode() {
    const from2 = this.getPos();
    const to = from2 + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: from2, to });
  }
};
function markPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: ({ state, range, match, pasteEvent }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      let markEnd = range.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}
function escapeForRegEx(string) {
  return string.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style2 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property) {
        style3[property] = "";
        return style3;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect2 = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element2)) {
    scaleX = element2.offsetWidth > 0 ? round(clientRect2.width) / element2.offsetWidth || 1 : 1;
    scaleY = element2.offsetHeight > 0 ? round(clientRect2.height) / element2.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect2.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect2.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect2.width / scaleX;
  var height = clientRect2.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element2) {
  var clientRect2 = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect2.width - width) <= 1) {
    width = clientRect2.width;
  }
  if (Math.abs(clientRect2.height - height) <= 1) {
    height = clientRect2.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element2) {
  return ((isElement(element2) ? element2.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element2.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element2.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element2.parentNode || // DOM Element detected
    (isShadowRoot(element2) ? element2.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element2)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle2(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance18 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance18.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance18.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance18.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance18.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element2, strategy) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element2),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle2(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element2, strategy) {
  var rect = getBoundingClientRect(element2, false, strategy === "fixed");
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round(rect.width) / element2.offsetWidth || 1;
  var scaleY = round(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers2) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers2.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers2.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers2) {
  var orderedModifiers = order(modifiers2);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers2) {
  var merged = modifiers2.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance18 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance18.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance: instance18
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance18.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance18;
    }
    instance18.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect5 = _ref.effect;
        if (typeof effect5 === "function") {
          var cleanupFn = effect5({
            state,
            name,
            instance: instance18,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance18;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// node_modules/tippy.js/dist/tippy.esm.js
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
  return document.body;
};
function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
function getValueAtIndexOrReturn(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
  }
  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(void 0, args) : value;
}
function debounce2(fn2, ms) {
  if (ms === 0) {
    return fn2;
  }
  var timeout;
  return function(arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      fn2(arg);
    }, ms);
  };
}
function removeProperties(obj, keys2) {
  var clone = Object.assign({}, obj);
  keys2.forEach(function(key) {
    delete clone[key];
  });
  return clone;
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function(item, index) {
    return arr.indexOf(item) === index;
  });
}
function getBasePlacement2(placement) {
  return placement.split("-")[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function(acc, key) {
    if (obj[key] !== void 0) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement("div");
}
function isElement2(value) {
  return ["Element", "Fragment"].some(function(type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, "NodeList");
}
function isMouseEvent(value) {
  return isType(value, "MouseEvent");
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement2(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function(el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function(el) {
    if (el) {
      el.setAttribute("data-state", state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements), element2 = _normalizeToArray[0];
  return element2 != null && (_element$ownerDocumen = element2.ownerDocument) != null && _element$ownerDocumen.body ? element2.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX, clientY = event.clientY;
  return popperTreeData.every(function(_ref) {
    var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement2(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
    var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
    box[method](event, listener);
  });
}
function actualContains(parent, child) {
  var target = child;
  while (target) {
    var _target$getRootNode;
    if (parent.contains(target)) {
      return true;
    }
    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }
  return false;
}
var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
function onDocumentMouseMove() {
  var now2 = performance.now();
  if (now2 - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
  }
  lastMouseMoveTime = now2;
}
function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance18 = activeElement._tippy;
    if (activeElement.blur && !instance18.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener("blur", onWindowBlur);
}
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
var isIE11 = isBrowser ? (
  // @ts-ignore
  !!window.msCrypto
) : false;
function createMemoryLeakWarning(method) {
  var txt = method === "destroy" ? "n already-" : " ";
  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
}
function getDevMessage(message) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\u{1F477}\u200D This is a development-only message. It will be removed in production.\n  ");
}
function getFormattedMessage(message) {
  return [
    getDevMessage(message),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var visitedMessages;
if (true) {
  resetVisitedMessages();
}
function resetVisitedMessages() {
  visitedMessages = /* @__PURE__ */ new Set();
}
function warnWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console;
    visitedMessages.add(message);
    (_console = console).warn.apply(_console, getFormattedMessage(message));
  }
}
function errorWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console2;
    visitedMessages.add(message);
    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
  }
}
function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
  errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: "fade",
  arrow: true,
  content: "",
  inertia: false,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: TIPPY_DEFAULT_APPEND_TO,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {
  },
  onBeforeUpdate: function onBeforeUpdate() {
  },
  onCreate: function onCreate() {
  },
  onDestroy: function onDestroy2() {
  },
  onHidden: function onHidden() {
  },
  onHide: function onHide() {
  },
  onMount: function onMount2() {
  },
  onShow: function onShow() {
  },
  onShown: function onShown() {
  },
  onTrigger: function onTrigger() {
  },
  onUntrigger: function onUntrigger() {
  },
  onClickOutside: function onClickOutside() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: "mouseenter focus",
  triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps2(partialProps) {
  if (true) {
    validateProps(partialProps, []);
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps2 = plugins.reduce(function(acc, plugin) {
    var name = plugin.name, defaultValue = plugin.defaultValue;
    if (name) {
      var _name;
      acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps2);
}
function getDataAttributeProps(reference2, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function(acc, key) {
    var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === "content") {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props;
}
function evaluateProps(reference2, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference2])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = {
    expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
    content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
  };
  return out;
}
function validateProps(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }
  if (plugins === void 0) {
    plugins = [];
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(prop) {
    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop);
    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function(plugin) {
        return plugin.name === prop;
      }).length === 0;
    }
    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var innerHTML = function innerHTML2() {
  return "innerHTML";
};
function dangerouslySetInnerHTML(element2, html) {
  element2[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow3 = div();
  if (value === true) {
    arrow3.className = ARROW_CLASS;
  } else {
    arrow3.className = SVG_ARROW_CLASS;
    if (isElement2(value)) {
      arrow3.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow3, value);
    }
  }
  return arrow3;
}
function setContent2(content, props) {
  if (isElement2(props.content)) {
    dangerouslySetInnerHTML(content, "");
    content.appendChild(props.content);
  } else if (typeof props.content !== "function") {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper2) {
  var box = popper2.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box,
    content: boxChildren.find(function(node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function(node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function(node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render(instance18) {
  var popper2 = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute("data-state", "hidden");
  box.setAttribute("tabindex", "-1");
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute("data-state", "hidden");
  setContent2(content, instance18.props);
  popper2.appendChild(box);
  box.appendChild(content);
  onUpdate(instance18.props, instance18.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow3 = _getChildren.arrow;
    if (nextProps.theme) {
      box2.setAttribute("data-theme", nextProps.theme);
    } else {
      box2.removeAttribute("data-theme");
    }
    if (typeof nextProps.animation === "string") {
      box2.setAttribute("data-animation", nextProps.animation);
    } else {
      box2.removeAttribute("data-animation");
    }
    if (nextProps.inertia) {
      box2.setAttribute("data-inertia", "");
    } else {
      box2.removeAttribute("data-inertia");
    }
    box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
    if (nextProps.role) {
      box2.setAttribute("role", nextProps.role);
    } else {
      box2.removeAttribute("role");
    }
    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent2(content2, instance18.props);
    }
    if (nextProps.arrow) {
      if (!arrow3) {
        box2.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box2.removeChild(arrow3);
        box2.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow3) {
      box2.removeChild(arrow3);
    }
  }
  return {
    popper: popper2,
    onUpdate
  };
}
render.$$tippy = true;
var idCounter = 1;
var mouseMoveListeners = [];
var mountedInstances = [];
function createTippy(reference2, passedProps) {
  var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce2(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance18 = {
    // properties
    id,
    reference: reference2,
    popper: div(),
    popperInstance,
    props,
    state,
    plugins,
    // methods
    clearDelayTimeouts,
    setProps,
    setContent: setContent3,
    show,
    hide: hide2,
    hideWithInteractivity,
    enable,
    disable,
    unmount,
    destroy
  };
  if (!props.render) {
    if (true) {
      errorWhen(true, "render() function has not been supplied.");
    }
    return instance18;
  }
  var _props$render = props.render(instance18), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
  popper2.setAttribute("data-tippy-root", "");
  popper2.id = "tippy-" + instance18.id;
  instance18.popper = popper2;
  reference2._tippy = instance18;
  popper2._tippy = instance18;
  var pluginsHooks = plugins.map(function(plugin) {
    return plugin.fn(instance18);
  });
  var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook("onCreate", [instance18]);
  if (props.showOnCreate) {
    scheduleShow();
  }
  popper2.addEventListener("mouseenter", function() {
    if (instance18.props.interactive && instance18.state.isVisible) {
      instance18.clearDelayTimeouts();
    }
  });
  popper2.addEventListener("mouseleave", function() {
    if (instance18.props.interactive && instance18.props.trigger.indexOf("mouseenter") >= 0) {
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    }
  });
  return instance18;
  function getNormalizedTouchSettings() {
    var touch = instance18.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === "hold";
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;
    return !!((_instance$props$rende = instance18.props.render) != null && _instance$props$rende.$$tippy);
  }
  function getCurrentTarget() {
    return currentTarget || reference2;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper2);
  }
  function getDelay(isShow) {
    if (instance18.state.isMounted && !instance18.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
      return 0;
    }
    return getValueAtIndexOrReturn(instance18.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper2.style.pointerEvents = instance18.props.interactive && !fromHide ? "" : "none";
    popper2.style.zIndex = "" + instance18.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function(pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance18.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance18.props.aria;
    if (!aria.content) {
      return;
    }
    var attr2 = "aria-" + aria.content;
    var id2 = popper2.id;
    var nodes = normalizeToArray(instance18.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      var currentValue = node.getAttribute(attr2);
      if (instance18.state.isVisible) {
        node.setAttribute(attr2, currentValue ? currentValue + " " + id2 : id2);
      } else {
        var nextValue = currentValue && currentValue.replace(id2, "").trim();
        if (nextValue) {
          node.setAttribute(attr2, nextValue);
        } else {
          node.removeAttribute(attr2);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance18.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance18.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      if (instance18.props.interactive) {
        node.setAttribute("aria-expanded", instance18.state.isVisible && node === getCurrentTarget() ? "true" : "false");
      } else {
        node.removeAttribute("aria-expanded");
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === "mousedown") {
        return;
      }
    }
    var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
    if (instance18.props.interactive && actualContains(popper2, actualTarget)) {
      return;
    }
    if (normalizeToArray(instance18.props.triggerTarget || reference2).some(function(el) {
      return actualContains(el, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance18.state.isVisible && instance18.props.trigger.indexOf("click") >= 0) {
        return;
      }
    } else {
      invokeHook("onClickOutside", [instance18, event]);
    }
    if (instance18.props.hideOnClick === true) {
      instance18.clearDelayTimeouts();
      instance18.hide();
      didHideDueToDocumentMouseDown = true;
      setTimeout(function() {
        didHideDueToDocumentMouseDown = false;
      });
      if (!instance18.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc3 = getDocument();
    doc3.addEventListener("mousedown", onDocumentPress, true);
    doc3.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc3.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc3.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc3 = getDocument();
    doc3.removeEventListener("mousedown", onDocumentPress, true);
    doc3.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc3.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc3.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function() {
      if (!instance18.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, "remove", listener);
        callback();
      }
    }
    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(box, "remove", currentTransitionEndListener);
    updateTransitionEndListener(box, "add", listener);
    currentTransitionEndListener = listener;
  }
  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    var nodes = normalizeToArray(instance18.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node,
        eventType,
        handler,
        options
      });
    });
  }
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on("touchstart", onTrigger2, {
        passive: true
      });
      on("touchend", onMouseLeave, {
        passive: true
      });
    }
    splitBySpaces(instance18.props.trigger).forEach(function(eventType) {
      if (eventType === "manual") {
        return;
      }
      on(eventType, onTrigger2);
      switch (eventType) {
        case "mouseenter":
          on("mouseleave", onMouseLeave);
          break;
        case "focus":
          on(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
          break;
        case "focusin":
          on("focusout", onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners() {
    listeners.forEach(function(_ref) {
      var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  function onTrigger2(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance18.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance18.state.isVisible && isMouseEvent(event)) {
      mouseMoveListeners.forEach(function(listener) {
        return listener(event);
      });
    }
    if (event.type === "click" && (instance18.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance18.props.hideOnClick !== false && instance18.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === "click") {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
    if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
      var _instance$popperInsta;
      var instance19 = popper3._tippy;
      var state2 = (_instance$popperInsta = instance19.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state2) {
        return {
          popperRect: popper3.getBoundingClientRect(),
          popperState: state2,
          props
        };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance18.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance18.props.interactive) {
      instance18.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (instance18.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
      return;
    }
    if (instance18.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance18.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset2 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
    var arrow3 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference2;
    var tippyModifier = {
      name: "$$tippy",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function fn2(_ref2) {
        var state2 = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(attr2) {
            if (attr2 === "placement") {
              box.setAttribute("data-placement", state2.placement);
            } else {
              if (state2.attributes.popper["data-popper-" + attr2]) {
                box.setAttribute("data-" + attr2, "");
              } else {
                box.removeAttribute("data-" + attr2);
              }
            }
          });
          state2.attributes.popper = {};
        }
      }
    };
    var modifiers2 = [{
      name: "offset",
      options: {
        offset: offset2
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow3) {
      modifiers2.push({
        name: "arrow",
        options: {
          element: arrow3,
          padding: 3
        }
      });
    }
    modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance18.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
      placement,
      onFirstUpdate,
      modifiers: modifiers2
    }));
  }
  function destroyPopperInstance() {
    if (instance18.popperInstance) {
      instance18.popperInstance.destroy();
      instance18.popperInstance = null;
    }
  }
  function mount() {
    var appendTo = instance18.props.appendTo;
    var parentNode2;
    var node = getCurrentTarget();
    if (instance18.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
      parentNode2 = node.parentNode;
    } else {
      parentNode2 = invokeWithArgsOrReturn(appendTo, [node]);
    }
    if (!parentNode2.contains(popper2)) {
      parentNode2.appendChild(popper2);
    }
    instance18.state.isMounted = true;
    createPopperInstance();
    if (true) {
      warnWhen(instance18.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper2, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
    }
  }
  function getNestedPopperTree() {
    return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
  }
  function scheduleShow(event) {
    instance18.clearDelayTimeouts();
    if (event) {
      invokeHook("onTrigger", [instance18, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function() {
        instance18.show();
      }, delay);
    } else {
      instance18.show();
    }
  }
  function scheduleHide(event) {
    instance18.clearDelayTimeouts();
    invokeHook("onUntrigger", [instance18, event]);
    if (!instance18.state.isVisible) {
      removeDocumentPress();
      return;
    }
    if (instance18.props.trigger.indexOf("mouseenter") >= 0 && instance18.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function() {
        if (instance18.state.isVisible) {
          instance18.hide();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrame = requestAnimationFrame(function() {
        instance18.hide();
      });
    }
  }
  function enable() {
    instance18.state.isEnabled = true;
  }
  function disable() {
    instance18.hide();
    instance18.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps(partialProps) {
    if (true) {
      warnWhen(instance18.state.isDestroyed, createMemoryLeakWarning("setProps"));
    }
    if (instance18.state.isDestroyed) {
      return;
    }
    invokeHook("onBeforeUpdate", [instance18, partialProps]);
    removeListeners();
    var prevProps = instance18.props;
    var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
      ignoreAttributes: true
    }));
    instance18.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce2(onMouseMove, nextProps.interactiveDebounce);
    }
    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
        node.removeAttribute("aria-expanded");
      });
    } else if (nextProps.triggerTarget) {
      reference2.removeAttribute("aria-expanded");
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance18.popperInstance) {
      createPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook("onAfterUpdate", [instance18, partialProps]);
  }
  function setContent3(content) {
    instance18.setProps({
      content
    });
  }
  function show() {
    if (true) {
      warnWhen(instance18.state.isDestroyed, createMemoryLeakWarning("show"));
    }
    var isAlreadyVisible = instance18.state.isVisible;
    var isDestroyed = instance18.state.isDestroyed;
    var isDisabled = !instance18.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance18.props.touch;
    var duration = getValueAtIndexOrReturn(instance18.props.duration, 0, defaultProps.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    }
    if (getCurrentTarget().hasAttribute("disabled")) {
      return;
    }
    invokeHook("onShow", [instance18], false);
    if (instance18.props.onShow(instance18) === false) {
      return;
    }
    instance18.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "visible";
    }
    handleStyles();
    addDocumentPress();
    if (!instance18.state.isMounted) {
      popper2.style.transition = "none";
    }
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content], 0);
    }
    onFirstUpdate = function onFirstUpdate2() {
      var _instance$popperInsta2;
      if (!instance18.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true;
      void popper2.offsetHeight;
      popper2.style.transition = instance18.props.moveTransition;
      if (getIsDefaultRenderFn() && instance18.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], "visible");
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance18);
      (_instance$popperInsta2 = instance18.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook("onMount", [instance18]);
      if (instance18.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function() {
          instance18.state.isShown = true;
          invokeHook("onShown", [instance18]);
        });
      }
    };
    mount();
  }
  function hide2() {
    if (true) {
      warnWhen(instance18.state.isDestroyed, createMemoryLeakWarning("hide"));
    }
    var isAlreadyHidden = !instance18.state.isVisible;
    var isDestroyed = instance18.state.isDestroyed;
    var isDisabled = !instance18.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance18.props.duration, 1, defaultProps.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }
    invokeHook("onHide", [instance18], false);
    if (instance18.props.onHide(instance18) === false) {
      return;
    }
    instance18.state.isVisible = false;
    instance18.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "hidden";
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
      if (instance18.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], "hidden");
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance18.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance18.unmount);
      }
    } else {
      instance18.unmount();
    }
  }
  function hideWithInteractivity(event) {
    if (true) {
      warnWhen(instance18.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
    }
    getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount() {
    if (true) {
      warnWhen(instance18.state.isDestroyed, createMemoryLeakWarning("unmount"));
    }
    if (instance18.state.isVisible) {
      instance18.hide();
    }
    if (!instance18.state.isMounted) {
      return;
    }
    destroyPopperInstance();
    getNestedPopperTree().forEach(function(nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper2.parentNode) {
      popper2.parentNode.removeChild(popper2);
    }
    mountedInstances = mountedInstances.filter(function(i) {
      return i !== instance18;
    });
    instance18.state.isMounted = false;
    invokeHook("onHidden", [instance18]);
  }
  function destroy() {
    if (true) {
      warnWhen(instance18.state.isDestroyed, createMemoryLeakWarning("destroy"));
    }
    if (instance18.state.isDestroyed) {
      return;
    }
    instance18.clearDelayTimeouts();
    instance18.unmount();
    removeListeners();
    delete reference2._tippy;
    instance18.state.isDestroyed = true;
    invokeHook("onDestroy", [instance18]);
  }
}
function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  if (true) {
    validateTargets(targets);
    validateProps(optionalProps, plugins);
  }
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins
  });
  var elements = getArrayOfElements(targets);
  if (true) {
    var isSingleContentElement = isElement2(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var instances = elements.reduce(function(acc, reference2) {
    var instance18 = reference2 && createTippy(reference2, passedProps);
    if (instance18) {
      acc.push(instance18);
    }
    return acc;
  }, []);
  return isElement2(targets) ? instances[0] : instances;
}
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
var applyStylesModifier = Object.assign({}, applyStyles_default, {
  effect: function effect4(_ref) {
    var state = _ref.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
  }
});
tippy.setDefaultProps({
  render
});
var tippy_esm_default = tippy;

// node_modules/@tiptap/extension-bubble-menu/dist/index.js
var BubbleMenuView = class {
  constructor({ editor, element: element2, view, tippyOptions = {}, updateDelay = 250, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state, from: from2, to }) => {
      const { doc: doc3, selection } = state;
      const { empty: empty3 } = selection;
      const isEmptyTextBlock = !doc3.textBetween(from2, to).length && isTextSelection(state.selection);
      const isChildOfMenu = this.element.contains(document.activeElement);
      const hasEditorFocus = view2.hasFocus() || isChildOfMenu;
      if (!hasEditorFocus || empty3 || isEmptyTextBlock || !this.editor.isEditable) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.dragstartHandler = () => {
      this.hide();
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      this.hide();
    };
    this.tippyBlurHandler = (event) => {
      this.blurHandler({ event });
    };
    this.handleDebouncedUpdate = (view2, oldState) => {
      const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view2.state.selection));
      const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view2.state.doc));
      if (!selectionChanged && !docChanged) {
        return;
      }
      if (this.updateDebounceTimer) {
        clearTimeout(this.updateDebounceTimer);
      }
      this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(view2, selectionChanged, docChanged, oldState);
      }, this.updateDelay);
    };
    this.updateHandler = (view2, selectionChanged, docChanged, oldState) => {
      var _a, _b, _c;
      const { state, composing } = view2;
      const { selection } = state;
      const isSame = !selectionChanged && !docChanged;
      if (composing || isSame) {
        return;
      }
      this.createTooltip();
      const { ranges } = selection;
      const from2 = Math.min(...ranges.map((range) => range.$from.pos));
      const to = Math.max(...ranges.map((range) => range.$to.pos));
      const shouldShow2 = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {
        editor: this.editor,
        view: view2,
        state,
        oldState,
        from: from2,
        to
      });
      if (!shouldShow2) {
        this.hide();
        return;
      }
      (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
        getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => {
          if (isNodeSelection(state.selection)) {
            let node = view2.nodeDOM(from2);
            const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector("[data-node-view-wrapper]");
            if (nodeViewWrapper) {
              node = nodeViewWrapper.firstChild;
            }
            if (node) {
              return node.getBoundingClientRect();
            }
          }
          return posToDOMRect(view2, from2, to);
        })
      });
      this.show();
    };
    this.editor = editor;
    this.element = element2;
    this.view = view;
    this.updateDelay = updateDelay;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.addEventListener("dragstart", this.dragstartHandler);
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy_esm_default(editorElement, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    });
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
    }
  }
  update(view, oldState) {
    const { state } = view;
    const hasValidSelection = state.selection.$from.pos !== state.selection.$to.pos;
    if (this.updateDelay > 0 && hasValidSelection) {
      this.handleDebouncedUpdate(view, oldState);
      return;
    }
    const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));
    const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));
    this.updateHandler(view, selectionChanged, docChanged, oldState);
  }
  show() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
  }
  hide() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
  }
  destroy() {
    var _a, _b;
    if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {
      this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler);
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
};
var BubbleMenuPlugin = (options) => {
  return new Plugin({
    key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey,
    view: (view) => new BubbleMenuView({ view, ...options })
  });
};
var BubbleMenu = Extension.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      BubbleMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});

// resources/js/extensions/ClassExtension.js
var ClassExtension_default = Extension.create({
  name: "classExtension",
  addGlobalAttributes() {
    return [
      {
        types: [
          "heading",
          "paragraph",
          "link",
          "image",
          "listItem",
          "bulletList",
          "orderedList",
          "table",
          "tableHeader",
          "tableRow",
          "tableCell",
          "textStyle"
        ],
        attributes: {
          class: {
            default: null,
            parseHTML: (element2) => element2.getAttribute("class") ?? null,
            renderHTML: (attributes) => {
              if (!attributes.class) {
                return null;
              }
              return {
                class: attributes.class
              };
            }
          }
        }
      }
    ];
  }
});

// resources/js/extensions/CommandsExtension.js
var CommandsExtension_default = Extension.create({
  name: "commandsExtension",
  addCommands() {
    return {
      moveToEnd: () => ({ chain, state, dispatch }) => {
        if (state.selection.empty)
          return false;
        return chain().setTextSelection(state.selection.$to.pos).run();
      }
    };
  }
});

// resources/js/extensions/Grid/utils/createColumn.js
function createColumn(colType, colSpan, colContent = null) {
  if (colContent) {
    return colType.createChecked({ "data-col-span": colSpan }, colContent);
  }
  return colType.createAndFill({ "data-col-span": colSpan });
}

// resources/js/extensions/Grid/utils/getGridNodeTypes.js
function getGridNodeTypes(schema) {
  if (schema.cached.gridNodeTypes) {
    return schema.cached.gridNodeTypes;
  }
  const roles = {};
  Object.keys(schema.nodes).forEach((type) => {
    const nodeType = schema.nodes[type];
    if (nodeType.spec.gridRole) {
      roles[nodeType.spec.gridRole] = nodeType;
    }
  });
  schema.cached.gridNodeTypes = roles;
  return roles;
}

// resources/js/extensions/Grid/utils/createGrid.js
function createGrid(schema, colsCount, stackAt, asymmetric, leftSpan = null, rightSpan = null, colContent = null) {
  const { grid, column } = getGridNodeTypes(schema);
  const cols = [];
  if (asymmetric) {
    cols.push(createColumn(column, leftSpan, colContent));
    cols.push(createColumn(column, rightSpan, colContent));
  } else {
    for (let index = 0; index < colsCount; index += 1) {
      const col = createColumn(column, 1, colContent);
      if (col) {
        cols.push(col);
      }
    }
  }
  return grid.createChecked({ "data-columns": colsCount, "data-type": asymmetric ?? "responsive", "data-stack-at": stackAt }, cols);
}

// resources/js/extensions/Grid/Grid.js
var Grid_default = Node2.create({
  name: "grid",
  group: "block",
  defining: true,
  isolating: true,
  allowGapCursor: false,
  content: "gridColumn+",
  gridRole: "grid",
  addOptions() {
    return {
      HTMLAttributes: {
        class: "scribble-grid"
      }
    };
  },
  addAttributes() {
    return {
      "data-type": {
        default: "responsive",
        parseHTML: (element2) => element2.getAttribute("data-type")
      },
      "data-columns": {
        default: 2,
        parseHTML: (element2) => element2.getAttribute("data-columns")
      },
      "data-stack-at": {
        default: "md",
        parseHTML: (element2) => element2.getAttribute("data-stack-at")
      },
      "style": {
        default: null,
        parseHTML: (element2) => element2.getAttribute("style"),
        renderHTML: (attributes) => {
          return {
            style: `grid-template-columns: repeat(${attributes["data-columns"]}, 1fr);`
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "div",
        getAttrs: (node) => node.classList.contains("scribble-grid") && !node.classList.contains("-column") && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["div", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      insertGrid: ({ columns = 2, stack_at, asymmetric, left_span = null, right_span = null } = {}) => ({ tr: tr2, dispatch, editor }) => {
        const node = createGrid(editor.schema, columns, stack_at, asymmetric, left_span, right_span);
        if (dispatch) {
          const offset2 = tr2.selection.anchor + 1;
          tr2.replaceSelectionWith(node).scrollIntoView().setSelection(TextSelection.near(tr2.doc.resolve(offset2)));
        }
        return true;
      }
    };
  },
  extendNodeSchema(extension) {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      gridRole: callOrReturn(getExtensionField(extension, "gridRole", context))
    };
  }
});

// resources/js/extensions/Grid/GridColumn.js
var GridColumn_default = Node2.create({
  name: "gridColumn",
  content: "block+",
  gridRole: "column",
  isolating: true,
  addOptions() {
    return {
      HTMLAttributes: {
        class: "scribble-grid-column"
      }
    };
  },
  addAttributes() {
    return {
      "data-col-span": {
        default: 1,
        parseHTML: (element2) => element2.getAttribute("data-col-span"),
        renderHTML: (attributes) => {
          return {
            "data-col-span": attributes["data-col-span"] ?? 1
          };
        }
      },
      "style": {
        default: null,
        parseHTML: (element2) => element2.getAttribute("style"),
        renderHTML: (attributes) => {
          return {
            style: `grid-column: span ${attributes["data-col-span"] ?? 1};`
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "div",
        getAttrs: (node) => node.classList.contains("scribble-grid-column") && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["div", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  }
});

// resources/js/extensions/Details/Details.js
var Details_default = Node2.create({
  name: "details",
  content: "detailsSummary detailsContent",
  group: "block",
  defining: true,
  isolating: true,
  allowGapCursor: false,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return {};
  },
  parseHTML() {
    return [
      {
        tag: "details"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["details", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addNodeView() {
    return ({ HTMLAttributes }) => {
      const dom = document.createElement("div");
      const content = document.createElement("div");
      const attributes = mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {
        "data-type": this.name
      });
      Object.entries(attributes).forEach(([key, value]) => dom.setAttribute(key, value));
      return {
        dom,
        contentDOM: dom,
        ignoreMutation(mutation) {
          if (mutation.type === "selection") {
            return false;
          }
          return !dom.contains(mutation.target) || dom === mutation.target;
        },
        update: (updatedNode) => {
          return updatedNode.type === this.type;
        }
      };
    };
  },
  addCommands() {
    return {
      setDetails: () => ({ state, chain }) => {
        let _a;
        const { schema, selection } = state;
        const { $from, $to } = selection;
        const range = $from.blockRange($to);
        if (!range) {
          return false;
        }
        const slice2 = state.doc.slice(range.start, range.end);
        const match = schema.nodes.detailsContent.contentMatch.matchFragment(slice2.content);
        if (!match) {
          return false;
        }
        const content = ((_a = slice2.toJSON()) === null || _a === void 0 ? void 0 : _a.content) || [];
        return chain().insertContentAt({ from: range.start, to: range.end }, {
          type: this.name,
          content: [{ type: "detailsSummary" }, { type: "detailsContent", content }]
        }).setTextSelection(range.start + 2).run();
      },
      unsetDetails: () => ({ state, chain }) => {
        const { selection, schema } = state;
        const details = findParentNode((node) => node.type === this.type)(selection);
        if (!details) {
          return false;
        }
        const detailsSummaries = findChildren(details.node, (node) => node.type === schema.nodes.detailsSummary);
        const detailsContents = findChildren(details.node, (node) => node.type === schema.nodes.detailsContent);
        if (!detailsSummaries.length || !detailsContents.length) {
          return false;
        }
        const detailsSummary = detailsSummaries[0];
        const detailsContent = detailsContents[0];
        const from2 = details.pos;
        const $from = state.doc.resolve(from2);
        const to = from2 + details.node.nodeSize;
        const range = { from: from2, to };
        const content = detailsContent.node.content.toJSON() || [];
        const defaultTypeForSummary = $from.parent.type.contentMatch.defaultType;
        const summaryContent = defaultTypeForSummary === null || defaultTypeForSummary === void 0 ? void 0 : defaultTypeForSummary.create(null, detailsSummary.node.content).toJSON();
        const mergedContent = [summaryContent, ...content];
        return chain().insertContentAt(range, mergedContent).setTextSelection(from2 + 1).run();
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Backspace: () => {
        const { schema, selection } = this.editor.state;
        const { empty: empty3, $anchor } = selection;
        if (!empty3 || $anchor.parent.type !== schema.nodes.detailsSummary) {
          return false;
        }
        if ($anchor.parentOffset !== 0) {
          return this.editor.commands.command(({ tr: tr2 }) => {
            const from2 = $anchor.pos - 1;
            const to = $anchor.pos;
            tr2.delete(from2, to);
            return true;
          });
        }
        return this.editor.commands.unsetDetails();
      }
    };
  }
});

// resources/js/extensions/Details/DetailsSummary.js
var DetailsSummary_default = Node2.create({
  name: "detailsSummary",
  content: "text*",
  defining: true,
  selectable: false,
  isolating: true,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "summary"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["summary", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  }
});

// resources/js/extensions/Details/DetailsContent.js
var DetailsContent_default = Node2.create({
  name: "detailsContent",
  content: "block+",
  defining: true,
  selectable: false,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: `div[data-type="details-content"]`
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["div", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { "data-type": "details-content" }), 0];
  },
  addKeyboardShortcuts() {
    return {
      // allows double enter to exit content node
      Enter: ({ editor }) => {
        const { state, view } = editor;
        const { selection } = state;
        const { $from, empty: empty3 } = selection;
        const detailsContent = findParentNode((node2) => node2.type === this.type)(selection);
        if (!empty3 || !detailsContent || !detailsContent.node.childCount) {
          return false;
        }
        const fromIndex = $from.index(detailsContent.depth);
        const { childCount } = detailsContent.node;
        const isAtEnd = childCount === fromIndex + 1;
        if (!isAtEnd) {
          return false;
        }
        const defaultChildType = detailsContent.node.type.contentMatch.defaultType;
        const defaultChildNode = defaultChildType === null || defaultChildType === void 0 ? void 0 : defaultChildType.createAndFill();
        if (!defaultChildNode) {
          return false;
        }
        const $childPos = state.doc.resolve(detailsContent.pos + 1);
        const lastChildIndex = childCount - 1;
        const lastChildNode = detailsContent.node.child(lastChildIndex);
        const lastChildPos = $childPos.posAtIndex(lastChildIndex, detailsContent.depth);
        const lastChildNodeIsEmpty = lastChildNode.eq(defaultChildNode);
        if (!lastChildNodeIsEmpty) {
          return false;
        }
        const above = $from.node(-3);
        if (!above) {
          return false;
        }
        const after = $from.indexAfter(-3);
        const type = defaultBlockAt2(above.contentMatchAt(after));
        if (!type || !above.canReplaceWith(after, after, type)) {
          return false;
        }
        const node = type.createAndFill();
        if (!node) {
          return false;
        }
        const { tr: tr2 } = state;
        const pos = $from.after(-2);
        tr2.replaceWith(pos, pos, node);
        const $pos = tr2.doc.resolve(pos);
        const newSelection = Selection.near($pos, 1);
        tr2.setSelection(newSelection);
        const deleteFrom = lastChildPos;
        const deleteTo = lastChildPos + lastChildNode.nodeSize;
        tr2.delete(deleteFrom, deleteTo);
        tr2.scrollIntoView();
        view.dispatch(tr2);
        return true;
      }
    };
  }
});

// resources/js/extensions/IdExtension.js
var IdExtension_default = Extension.create({
  name: "idExtension",
  addGlobalAttributes() {
    return [
      {
        types: [
          "heading",
          "link"
        ],
        attributes: {
          id: {
            default: null,
            parseHTML: (element2) => element2.getAttribute("id") ?? null,
            renderHTML: (attributes) => {
              if (!attributes.id) {
                return null;
              }
              return {
                id: attributes.id
              };
            }
          }
        }
      }
    ];
  }
});

// node_modules/@tiptap/extension-image/dist/index.js
var inputRegex = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/;
var Image = Node2.create({
  name: "image",
  addOptions() {
    return {
      inline: false,
      allowBase64: false,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: true,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["img", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setImage: (options) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: options
        });
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: inputRegex,
        type: this.type,
        getAttributes: (match) => {
          const [, , alt, src, title] = match;
          return { src, alt, title };
        }
      })
    ];
  }
});

// node_modules/svelte-tiptap/dist/SvelteRenderer.js
var SvelteRenderer = class {
  constructor(component, { element: element2 }) {
    this.component = component;
    this.dom = element2;
    this.dom.classList.add("svelte-renderer");
  }
  updateProps(props) {
    this.component.$set(props);
  }
  destroy() {
    this.component.$destroy();
  }
};
var SvelteRenderer_default = SvelteRenderer;

// node_modules/svelte-tiptap/dist/context.js
var TIPTAP_NODE_VIEW = "TipTapNodeView";

// node_modules/svelte-tiptap/dist/SvelteNodeViewRenderer.js
var SvelteNodeView = class extends NodeView {
  mount() {
    const Component = this.component;
    const props = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      selected: false,
      extension: this.extension,
      getPos: () => this.getPos(),
      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),
      deleteNode: () => this.deleteNode()
    };
    this.contentDOMElement = this.node.isLeaf ? null : document.createElement(this.node.isInline ? "span" : "div");
    if (this.contentDOMElement) {
      this.contentDOMElement.style.whiteSpace = "inherit";
    }
    const context = /* @__PURE__ */ new Map();
    context.set(TIPTAP_NODE_VIEW, {
      onDragStart: this.onDragStart.bind(this)
    });
    const as = this.options.as ?? (this.node.isInline ? "span" : "div");
    const target = document.createElement(as);
    target.classList.add(`node-${this.node.type.name}`);
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);
    this.editor.on("selectionUpdate", this.handleSelectionUpdate);
    const svelteComponent = new Component({
      target,
      props,
      context
    });
    this.renderer = new SvelteRenderer_default(svelteComponent, {
      element: target
    });
    this.appendContendDom();
  }
  appendContendDom() {
    const contentElement = this.dom.querySelector("[data-node-view-content]");
    if (this.contentDOMElement && contentElement && !contentElement.contains(this.contentDOMElement)) {
      contentElement.appendChild(this.contentDOMElement);
    }
  }
  get dom() {
    if (!this.renderer.dom.firstElementChild?.hasAttribute("data-node-view-wrapper")) {
      throw Error("Please use the NodeViewWrapper component for your node view.");
    }
    return this.renderer.dom;
  }
  get contentDOM() {
    if (this.node.isLeaf) {
      return null;
    }
    return this.contentDOMElement;
  }
  handleSelectionUpdate() {
    const { from: from2, to } = this.editor.state.selection;
    if (from2 <= this.getPos() && to >= this.getPos() + this.node.nodeSize) {
      this.selectNode();
    } else {
      this.deselectNode();
    }
  }
  update(node, decorations) {
    const updateProps = () => {
      this.renderer.updateProps({ node, decorations });
    };
    if (typeof this.options.update === "function") {
      const oldNode = this.node;
      const oldDecorations = this.decorations;
      this.node = node;
      this.decorations = decorations;
      return this.options.update({
        oldNode,
        oldDecorations,
        newNode: node,
        newDecorations: decorations,
        updateProps: () => updateProps()
      });
    }
    if (node.type !== this.node.type) {
      return false;
    }
    if (node === this.node && this.decorations === decorations) {
      return true;
    }
    this.node = node;
    this.decorations = decorations;
    updateProps();
    return true;
  }
  selectNode() {
    this.renderer.updateProps({ selected: true });
  }
  deselectNode() {
    this.renderer.updateProps({ selected: false });
  }
  destroy() {
    this.renderer.destroy();
    this.editor.off("selectionUpdate", this.handleSelectionUpdate);
    this.contentDOMElement = null;
  }
};
var SvelteNodeViewRenderer = (component, options) => {
  return (props) => new SvelteNodeView(component, props, options);
};
var SvelteNodeViewRenderer_default = SvelteNodeViewRenderer;

// node_modules/svelte-tiptap/dist/NodeViewWrapper.svelte
function create_dynamic_element(ctx) {
  let svelte_element;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let svelte_element_levels = [
    { "data-node-view-wrapper": "" },
    { role: "none" },
    /*$$restProps*/
    ctx[3]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  return {
    c() {
      svelte_element = element(
        /*as*/
        ctx[0]
      );
      if (default_slot)
        default_slot.c();
      set_dynamic_element_data(
        /*as*/
        ctx[0]
      )(svelte_element, svelte_element_data);
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[6](svelte_element);
      current = true;
      if (!mounted) {
        dispose = listen(
          svelte_element,
          "dragstart",
          /*onDragStart*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_dynamic_element_data(
        /*as*/
        ctx2[0]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        { "data-node-view-wrapper": "" },
        { role: "none" },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[6](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment(ctx) {
  let previous_tag = (
    /*as*/
    ctx[0]
  );
  let svelte_element_anchor;
  let current;
  let svelte_element = (
    /*as*/
    ctx[0] && create_dynamic_element(ctx)
  );
  return {
    c() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*as*/
        ctx2[0]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*as*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*as*/
          ctx2[0]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*as*/
          ctx2[0];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*as*/
        ctx2[0];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(svelte_element, local);
      current = true;
    },
    o(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["as"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const { onDragStart } = getContext(TIPTAP_NODE_VIEW);
  let element2;
  let { as = "div" } = $$props;
  onMount(async () => {
    await tick();
    $$invalidate(1, element2.style.whiteSpace = "normal", element2);
  });
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("as" in $$new_props)
      $$invalidate(0, as = $$new_props.as);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  return [as, element2, onDragStart, $$restProps, $$scope, slots, svelte_element_binding];
}
var NodeViewWrapper = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { as: 0 });
  }
};
var NodeViewWrapper_default = NodeViewWrapper;

// resources/js/components/BlockActions.svelte
function create_fragment2(ctx) {
  let div2;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div2, "class", "scribble-block-actions");
      attr(div2, "contenteditable", "false");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var BlockActions = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
  }
};
var BlockActions_default = BlockActions;

// resources/js/components/DragHandle.svelte
function create_fragment3(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<svg fill="currentColor" width="800px" height="800px" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M7.375 3.67c0-.645-.56-1.17-1.25-1.17s-1.25.525-1.25 1.17c0 .646.56 1.17 1.25 1.17s1.25-.524 1.25-1.17zm0 8.66c0-.646-.56-1.17-1.25-1.17s-1.25.524-1.25 1.17c0 .645.56 1.17 1.25 1.17s1.25-.525 1.25-1.17zm-1.25-5.5c.69 0 1.25.525 1.25 1.17 0 .645-.56 1.17-1.25 1.17S4.875 8.645 4.875 8c0-.645.56-1.17 1.25-1.17zm5-3.16c0-.645-.56-1.17-1.25-1.17s-1.25.525-1.25 1.17c0 .646.56 1.17 1.25 1.17s1.25-.524 1.25-1.17zm-1.25 7.49c.69 0 1.25.524 1.25 1.17 0 .645-.56 1.17-1.25 1.17s-1.25-.525-1.25-1.17c0-.646.56-1.17 1.25-1.17zM11.125 8c0-.645-.56-1.17-1.25-1.17s-1.25.525-1.25 1.17c0 .645.56 1.17 1.25 1.17s1.25-.525 1.25-1.17z"></path></svg>`;
      attr(button, "data-drag-handle", "");
      attr(button, "type", "button");
      attr(button, "class", "scribble-block-action block-drag");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(function() {
          if (is_function(
            /*handleMenuOpen*/
            ctx[0]
          ))
            ctx[0].apply(this, arguments);
        })));
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { handleMenuOpen } = $$props;
  $$self.$$set = ($$props2) => {
    if ("handleMenuOpen" in $$props2)
      $$invalidate(0, handleMenuOpen = $$props2.handleMenuOpen);
  };
  return [handleMenuOpen];
}
var DragHandle = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { handleMenuOpen: 0 });
  }
};
var DragHandle_default = DragHandle;

// resources/js/utils.js
var uuid = () => {
  return ("10000000-1000-4000-8000" + -1e11).replace(
    /[018]/g,
    (c) => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
  );
};
var openScribbleModal = (component, args) => {
  document.getElementById("scribble-editor-loading-indicator").classList.remove("hidden");
  document.querySelector("#scribble-editor-loading-indicator .loader").classList.remove("hidden");
  window.Livewire.dispatch("openScribbleModal", { component, arguments: args });
};
var commandRunner = (editor, commands2, args = []) => {
  commands2.forEach((command2) => {
    editor.chain().focus()[command2.command](Object.keys(command2?.arguments).length > 0 ? command2.arguments : args).run();
  });
};
var replaceStatePath = (data, statePath) => {
  if (typeof data != "object")
    return;
  if (!data)
    return;
  for (const key in data) {
    if (["statePath"].includes(key)) {
      data[key] = statePath;
    } else {
      replaceStatePath(data[key], statePath);
    }
  }
};

// resources/js/components/BlockSettings.svelte
function create_fragment4(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.325.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 0 1 1.37.49l1.296 2.247a1.125 1.125 0 0 1-.26 1.431l-1.003.827c-.293.241-.438.613-.43.992a7.723 7.723 0 0 1 0 .255c-.008.378.137.75.43.991l1.004.827c.424.35.534.955.26 1.43l-1.298 2.247a1.125 1.125 0 0 1-1.369.491l-1.217-.456c-.355-.133-.75-.072-1.076.124a6.47 6.47 0 0 1-.22.128c-.331.183-.581.495-.644.869l-.213 1.281c-.09.543-.56.94-1.11.94h-2.594c-.55 0-1.019-.398-1.11-.94l-.213-1.281c-.062-.374-.312-.686-.644-.87a6.52 6.52 0 0 1-.22-.127c-.325-.196-.72-.257-1.076-.124l-1.217.456a1.125 1.125 0 0 1-1.369-.49l-1.297-2.247a1.125 1.125 0 0 1 .26-1.431l1.004-.827c.292-.24.437-.613.43-.991a6.932 6.932 0 0 1 0-.255c.007-.38-.138-.751-.43-.992l-1.004-.827a1.125 1.125 0 0 1-.26-1.43l1.297-2.247a1.125 1.125 0 0 1 1.37-.491l1.216.456c.356.133.751.072 1.076-.124.072-.044.146-.086.22-.128.332-.183.582-.495.644-.869l.214-1.28Z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg> <span class="grow">Impostazioni</span>`;
      attr(button, "type", "button");
      attr(button, "class", "scribble-block-action block-settings");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(function() {
          if (is_function(
            /*handleOpen*/
            ctx[0]
          ))
            ctx[0].apply(this, arguments);
        })));
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { handleOpen } = $$props;
  $$self.$$set = ($$props2) => {
    if ("handleOpen" in $$props2)
      $$invalidate(0, handleOpen = $$props2.handleOpen);
  };
  return [handleOpen];
}
var BlockSettings = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { handleOpen: 0 });
  }
};
var BlockSettings_default = BlockSettings;

// resources/js/components/RemoveBlock.svelte
function create_fragment5(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0"></path></svg> <span class="grow">Cancella</span>`;
      attr(button, "type", "button");
      attr(button, "class", "scribble-block-action block-remove delete");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(function() {
          if (is_function(
            /*handleRemove*/
            ctx[0]
          ))
            ctx[0].apply(this, arguments);
        })));
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { handleRemove } = $$props;
  $$self.$$set = ($$props2) => {
    if ("handleRemove" in $$props2)
      $$invalidate(0, handleRemove = $$props2.handleRemove);
  };
  return [handleRemove];
}
var RemoveBlock = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { handleRemove: 0 });
  }
};
var RemoveBlock_default = RemoveBlock;

// resources/js/components/DuplicateBlock.svelte
function create_fragment6(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg> <span class="grow">Duplica</span>`;
      attr(button, "type", "button");
      attr(button, "class", "scribble-block-action block-remove");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(function() {
          if (is_function(
            /*handleDuplicate*/
            ctx[0]
          ))
            ctx[0].apply(this, arguments);
        })));
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { handleDuplicate } = $$props;
  $$self.$$set = ($$props2) => {
    if ("handleDuplicate" in $$props2)
      $$invalidate(0, handleDuplicate = $$props2.handleDuplicate);
  };
  return [handleDuplicate];
}
var DuplicateBlock = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, { handleDuplicate: 0 });
  }
};
var DuplicateBlock_default = DuplicateBlock;

// resources/js/components/OptionsMenu.svelte
function create_if_block_2(ctx) {
  let blocksettings;
  let current;
  blocksettings = new BlockSettings_default({
    props: { handleOpen: (
      /*handleOpen*/
      ctx[4]
    ) }
  });
  return {
    c() {
      create_component(blocksettings.$$.fragment);
    },
    m(target, anchor) {
      mount_component(blocksettings, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(blocksettings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(blocksettings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(blocksettings, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let duplicateblock;
  let current;
  duplicateblock = new DuplicateBlock_default({
    props: {
      handleDuplicate: (
        /*handleDuplicate*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(duplicateblock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(duplicateblock, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(duplicateblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(duplicateblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(duplicateblock, detaching);
    }
  };
}
function create_if_block(ctx) {
  let removeblock;
  let current;
  removeblock = new RemoveBlock_default({
    props: { handleRemove: (
      /*handleRemove*/
      ctx[5]
    ) }
  });
  return {
    c() {
      create_component(removeblock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(removeblock, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(removeblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(removeblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(removeblock, detaching);
    }
  };
}
function create_fragment7(ctx) {
  let div2;
  let t0;
  let t1;
  let current;
  let if_block0 = (
    /*showSettings*/
    ctx[0] && create_if_block_2(ctx)
  );
  let if_block1 = (
    /*showDuplicate*/
    ctx[1] && create_if_block_1(ctx)
  );
  let if_block2 = (
    /*showRemove*/
    ctx[2] && create_if_block(ctx)
  );
  return {
    c() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      attr(div2, "class", "svelte-options-menu");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t0);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t1);
      if (if_block2)
        if_block2.m(div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*showSettings*/
        ctx2[0]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*showSettings*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*showDuplicate*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*showDuplicate*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*showRemove*/
        ctx2[2]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*showRemove*/
          4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { node } = $$props;
  let { editor } = $$props;
  let { onClose } = $$props;
  let { showSettings = true } = $$props;
  let { showDuplicate = true } = $$props;
  let { showRemove = true } = $$props;
  const handleDuplicate = () => {
    const { tr: tr2, doc: doc3 } = editor.state;
    const { selection } = tr2;
    const { $from, $to } = selection;
    const nodePos = $from.pos;
    const nodeSize2 = $to.pos - $from.pos;
    const content = $from.nodeAfter;
    const newPos = nodePos + nodeSize2;
    const nodeCopy = node.type.create({ ...node.attrs, id: uuid() }, node.content, node.marks);
    if (newPos <= doc3.content.size) {
      tr2.insert(newPos, nodeCopy);
      editor.view.dispatch(tr2);
    } else {
      console.error("Cannot duplicate after the last node of the document.");
    }
    if (onClose) {
      onClose();
    }
  };
  const handleOpen = () => {
    if (onClose) {
      onClose();
    }
    openScribbleModal(node.attrs.identifier, {
      update: true,
      statePath: editor.storage?.statePathExtension.statePath ?? null,
      blockId: node.attrs.id,
      data: node.attrs.values
    });
  };
  const handleRemove = () => {
    if (onClose) {
      onClose();
    }
    editor.commands.deleteSelection();
  };
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(6, node = $$props2.node);
    if ("editor" in $$props2)
      $$invalidate(7, editor = $$props2.editor);
    if ("onClose" in $$props2)
      $$invalidate(8, onClose = $$props2.onClose);
    if ("showSettings" in $$props2)
      $$invalidate(0, showSettings = $$props2.showSettings);
    if ("showDuplicate" in $$props2)
      $$invalidate(1, showDuplicate = $$props2.showDuplicate);
    if ("showRemove" in $$props2)
      $$invalidate(2, showRemove = $$props2.showRemove);
  };
  return [
    showSettings,
    showDuplicate,
    showRemove,
    handleDuplicate,
    handleOpen,
    handleRemove,
    node,
    editor,
    onClose
  ];
}
var OptionsMenu = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      node: 6,
      editor: 7,
      onClose: 8,
      showSettings: 0,
      showDuplicate: 1,
      showRemove: 2
    });
  }
};
var OptionsMenu_default = OptionsMenu;

// resources/js/components/MediaView.svelte
function create_default_slot_1(ctx) {
  let draghandle;
  let current;
  draghandle = new DragHandle_default({
    props: {
      handleMenuOpen: (
        /*handleMenuOpen*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(draghandle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(draghandle, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(draghandle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(draghandle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(draghandle, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let div2;
  let div1;
  let div0;
  let img;
  let img_src_value;
  let img_alt_value;
  let img_title_value;
  let img_width_value;
  let img_height_value;
  let img_loading_value;
  let div1_class_value;
  let t;
  let blockactions;
  let current;
  blockactions = new BlockActions_default({
    props: {
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      img = element("img");
      t = space();
      create_component(blockactions.$$.fragment);
      if (!src_url_equal(img.src, img_src_value = /*node*/
      ctx[0].attrs.src))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*node*/
      ctx[0].attrs.alt);
      attr(img, "title", img_title_value = /*node*/
      ctx[0].attrs?.title ?? null);
      attr(img, "width", img_width_value = /*node*/
      ctx[0].attrs.width);
      attr(img, "height", img_height_value = /*node*/
      ctx[0].attrs.height);
      attr(img, "loading", img_loading_value = /*node*/
      ctx[0].attrs.loading);
      attr(div0, "class", "p-8");
      attr(div1, "class", div1_class_value = "scribble-block-content " + /*selected*/
      (ctx[1] ? "ProseMirror-selectednode" : ""));
      attr(div2, "class", "scribble-block");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, img);
      append(div2, t);
      mount_component(blockactions, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*node*/
      1 && !src_url_equal(img.src, img_src_value = /*node*/
      ctx2[0].attrs.src)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*node*/
      1 && img_alt_value !== (img_alt_value = /*node*/
      ctx2[0].attrs.alt)) {
        attr(img, "alt", img_alt_value);
      }
      if (!current || dirty & /*node*/
      1 && img_title_value !== (img_title_value = /*node*/
      ctx2[0].attrs?.title ?? null)) {
        attr(img, "title", img_title_value);
      }
      if (!current || dirty & /*node*/
      1 && img_width_value !== (img_width_value = /*node*/
      ctx2[0].attrs.width)) {
        attr(img, "width", img_width_value);
      }
      if (!current || dirty & /*node*/
      1 && img_height_value !== (img_height_value = /*node*/
      ctx2[0].attrs.height)) {
        attr(img, "height", img_height_value);
      }
      if (!current || dirty & /*node*/
      1 && img_loading_value !== (img_loading_value = /*node*/
      ctx2[0].attrs.loading)) {
        attr(img, "loading", img_loading_value);
      }
      if (!current || dirty & /*selected*/
      2 && div1_class_value !== (div1_class_value = "scribble-block-content " + /*selected*/
      (ctx2[1] ? "ProseMirror-selectednode" : ""))) {
        attr(div1, "class", div1_class_value);
      }
      const blockactions_changes = {};
      if (dirty & /*$$scope*/
      256) {
        blockactions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      blockactions.$set(blockactions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(blockactions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(blockactions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(blockactions);
    }
  };
}
function create_fragment8(ctx) {
  let nodeviewwrapper;
  let current;
  nodeviewwrapper = new NodeViewWrapper_default({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(nodeviewwrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(nodeviewwrapper, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const nodeviewwrapper_changes = {};
      if (dirty & /*$$scope, selected, node*/
      259) {
        nodeviewwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      nodeviewwrapper.$set(nodeviewwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nodeviewwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nodeviewwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(nodeviewwrapper, detaching);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { editor } = $$props;
  let { node } = $$props;
  let { selected = false } = $$props;
  let { updateAttributes: updateAttributes2 } = $$props;
  let component;
  let popupInstance;
  const handleMenuOpen = (event) => {
    const clientRect2 = event.currentTarget.getBoundingClientRect();
    component = new OptionsMenu_default({
      target: document.createElement("div"),
      // Crea un elemento div per montare il componente Svelte
      props: {
        node,
        showSettings: false,
        editor,
        onClose: () => closeOptions()
      }
    });
    popupInstance = tippy_esm_default("body", {
      content: component.$$.root,
      getReferenceClientRect: () => clientRect2,
      allowHTML: true,
      interactive: true,
      trigger: "manual",
      placement: "left",
      showOnCreate: true,
      hideOnClick: true,
      theme: "scribble-options",
      arrow: true,
      zIndex: 9999,
      onHidden(instance18) {
        instance18.destroy();
      }
    });
  };
  const closeOptions = (event) => {
    if (Array.isArray(popupInstance)) {
      popupInstance.forEach((instance18) => instance18.hide());
    } else {
      popupInstance.hide();
    }
  };
  onMount(() => {
    window.addEventListener("updatedBlock", (e) => {
      if (e.detail.type === node.attrs.type && e.detail.statePath === editor.storage?.statePathExtension.statePath) {
        updateAttributes2({ values: e.detail.values });
      }
    });
  });
  $$self.$$set = ($$props2) => {
    if ("editor" in $$props2)
      $$invalidate(3, editor = $$props2.editor);
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
    if ("selected" in $$props2)
      $$invalidate(1, selected = $$props2.selected);
    if ("updateAttributes" in $$props2)
      $$invalidate(4, updateAttributes2 = $$props2.updateAttributes);
  };
  return [node, selected, handleMenuOpen, editor, updateAttributes2];
}
var MediaView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      editor: 3,
      node: 0,
      selected: 1,
      updateAttributes: 4
    });
  }
};
var MediaView_default = MediaView;

// resources/js/extensions/MediaExtension.js
var MediaExtension_default = Image.extend({
  selectable: true,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      },
      width: {
        default: null
      },
      height: {
        default: null
      },
      loading: {
        default: null
      },
      sizes: {
        default: null
      },
      srcset: {
        default: null
      }
    };
  },
  addCommands() {
    return {
      setMedia: (options) => ({ commands: commands2 }) => {
        const src = options?.url || options?.src;
        const imageTypes = ["jpg", "jpeg", "svg", "png", "webp"];
        const regex = /.*\.([a-zA-Z]*)\??/;
        const match = regex.exec(src);
        if (match !== null && imageTypes.includes(match[1])) {
          commands2.setImage({
            src,
            alt: options?.alt,
            title: options?.title,
            width: options?.width,
            height: options?.height,
            lazy: options?.lazy
          });
        } else {
          commands2.setDocument(options);
        }
      },
      setDocument: (options) => ({ chain }) => {
        return chain().focus().extendMarkRange("link").setLink({ href: options.src }).insertContent(options?.link_text).run();
      },
      setImage: (options) => ({ chain }) => {
        return chain().focus().insertContent({
          type: this.name,
          attrs: options
        }).createParagraphNear().run();
      }
    };
  },
  addNodeView() {
    return SvelteNodeViewRenderer_default(MediaView_default);
  }
});

// resources/js/extensions/MergeTag.js
var MergeTag_default = Node2.create({
  name: "mergeTag",
  group: "inline",
  inline: true,
  selectable: false,
  atom: true,
  addAttributes() {
    return {
      id: {
        default: null,
        parseHTML: (element2) => element2.getAttribute("data-id"),
        renderHTML: (attributes) => {
          if (!attributes.id) {
            return {};
          }
          return {
            "data-id": attributes.id
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `span[data-type='${this.name}']`
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "span",
      mergeAttributes(
        { "data-type": this.name },
        HTMLAttributes
      ),
      `{{ ${node.attrs.id} }}`
    ];
  },
  renderText({ node }) {
    return `{{ ${node.attrs.id} }}`;
  },
  addKeyboardShortcuts() {
    return {
      Backspace: () => this.editor.commands.command(({ tr: tr2, state }) => {
        let isMergeTag = false;
        const { selection } = state;
        const { empty: empty3, anchor } = selection;
        if (!empty3) {
          return false;
        }
        state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {
          if (node.type.name === this.name) {
            isMergeTag = true;
            tr2.insertText(
              "{{",
              pos,
              pos + node.nodeSize
            );
            return false;
          }
        });
        return isMergeTag;
      })
    };
  },
  addCommands() {
    return {
      insertMergeTag: (attributes) => ({ chain, state }) => {
        const currentChain = chain();
        if (![null, void 0].includes(attributes.coordinates?.pos)) {
          currentChain.insertContentAt(
            { from: attributes.coordinates.pos, to: attributes.coordinates.pos },
            [
              { type: this.name, attrs: { id: attributes.tag } },
              { type: "text", text: " " }
            ]
          );
          return currentChain;
        }
      }
    };
  }
});

// node_modules/@tiptap/suggestion/dist/index.js
function findSuggestionMatch(config) {
  var _a;
  const { char, allowSpaces, allowedPrefixes, startOfLine, $position } = config;
  const escapedChar = escapeForRegEx(char);
  const suffix = new RegExp(`\\s${escapedChar}$`);
  const prefix = startOfLine ? "^" : "";
  const regexp = allowSpaces ? new RegExp(`${prefix}${escapedChar}.*?(?=\\s${escapedChar}|$)`, "gm") : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\s${escapedChar}]*`, "gm");
  const text2 = ((_a = $position.nodeBefore) === null || _a === void 0 ? void 0 : _a.isText) && $position.nodeBefore.text;
  if (!text2) {
    return null;
  }
  const textFrom = $position.pos - text2.length;
  const match = Array.from(text2.matchAll(regexp)).pop();
  if (!match || match.input === void 0 || match.index === void 0) {
    return null;
  }
  const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);
  const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes === null || allowedPrefixes === void 0 ? void 0 : allowedPrefixes.join("")}\0]?$`).test(matchPrefix);
  if (allowedPrefixes !== null && !matchPrefixIsAllowed) {
    return null;
  }
  const from2 = textFrom + match.index;
  let to = from2 + match[0].length;
  if (allowSpaces && suffix.test(text2.slice(to - 1, to + 1))) {
    match[0] += " ";
    to += 1;
  }
  if (from2 < $position.pos && to >= $position.pos) {
    return {
      range: {
        from: from2,
        to
      },
      query: match[0].slice(char.length),
      text: match[0]
    };
  }
  return null;
}
var SuggestionPluginKey = new PluginKey("suggestion");
function Suggestion({ pluginKey = SuggestionPluginKey, editor, char = "@", allowSpaces = false, allowedPrefixes = [" "], startOfLine = false, decorationTag = "span", decorationClass = "suggestion", command: command2 = () => null, items = () => [], render: render2 = () => ({}), allow = () => true, findSuggestionMatch: findSuggestionMatch$1 = findSuggestionMatch }) {
  let props;
  const renderer = render2 === null || render2 === void 0 ? void 0 : render2();
  const plugin = new Plugin({
    key: pluginKey,
    view() {
      return {
        update: async (view, prevState) => {
          var _a, _b, _c, _d, _e, _f, _g;
          const prev = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);
          const next = (_b = this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state);
          const moved = prev.active && next.active && prev.range.from !== next.range.from;
          const started = !prev.active && next.active;
          const stopped = prev.active && !next.active;
          const changed = !started && !stopped && prev.query !== next.query;
          const handleStart = started || moved;
          const handleChange = changed && !moved;
          const handleExit = stopped || moved;
          if (!handleStart && !handleChange && !handleExit) {
            return;
          }
          const state = handleExit && !handleStart ? prev : next;
          const decorationNode = view.dom.querySelector(`[data-decoration-id="${state.decorationId}"]`);
          props = {
            editor,
            range: state.range,
            query: state.query,
            text: state.text,
            items: [],
            command: (commandProps) => {
              command2({
                editor,
                range: state.range,
                props: commandProps
              });
            },
            decorationNode,
            // virtual node for popper.js or tippy.js
            // this can be used for building popups without a DOM node
            clientRect: decorationNode ? () => {
              var _a2;
              const { decorationId } = (_a2 = this.key) === null || _a2 === void 0 ? void 0 : _a2.getState(editor.state);
              const currentDecorationNode = view.dom.querySelector(`[data-decoration-id="${decorationId}"]`);
              return (currentDecorationNode === null || currentDecorationNode === void 0 ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;
            } : null
          };
          if (handleStart) {
            (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeStart) === null || _c === void 0 ? void 0 : _c.call(renderer, props);
          }
          if (handleChange) {
            (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);
          }
          if (handleChange || handleStart) {
            props.items = await items({
              editor,
              query: state.query
            });
          }
          if (handleExit) {
            (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _e === void 0 ? void 0 : _e.call(renderer, props);
          }
          if (handleChange) {
            (_f = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _f === void 0 ? void 0 : _f.call(renderer, props);
          }
          if (handleStart) {
            (_g = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _g === void 0 ? void 0 : _g.call(renderer, props);
          }
        },
        destroy: () => {
          var _a;
          if (!props) {
            return;
          }
          (_a = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a === void 0 ? void 0 : _a.call(renderer, props);
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        const state = {
          active: false,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: false
        };
        return state;
      },
      // Apply changes to the plugin state from a view transaction.
      apply(transaction, prev, oldState, state) {
        const { isEditable } = editor;
        const { composing } = editor.view;
        const { selection } = transaction;
        const { empty: empty3, from: from2 } = selection;
        const next = { ...prev };
        next.composing = composing;
        if (isEditable && (empty3 || editor.view.composing)) {
          if ((from2 < prev.range.from || from2 > prev.range.to) && !composing && !prev.composing) {
            next.active = false;
          }
          const match = findSuggestionMatch$1({
            char,
            allowSpaces,
            allowedPrefixes,
            startOfLine,
            $position: selection.$from
          });
          const decorationId = `id_${Math.floor(Math.random() * 4294967295)}`;
          if (match && allow({ editor, state, range: match.range })) {
            next.active = true;
            next.decorationId = prev.decorationId ? prev.decorationId : decorationId;
            next.range = match.range;
            next.query = match.query;
            next.text = match.text;
          } else {
            next.active = false;
          }
        } else {
          next.active = false;
        }
        if (!next.active) {
          next.decorationId = null;
          next.range = { from: 0, to: 0 };
          next.query = null;
          next.text = null;
        }
        return next;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(view, event) {
        var _a;
        const { active, range } = plugin.getState(view.state);
        if (!active) {
          return false;
        }
        return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, { view, event, range })) || false;
      },
      // Setup decorator on the currently active suggestion.
      decorations(state) {
        const { active, range, decorationId } = plugin.getState(state);
        if (!active) {
          return null;
        }
        return DecorationSet.create(state.doc, [
          Decoration.inline(range.from, range.to, {
            nodeName: decorationTag,
            class: decorationClass,
            "data-decoration-id": decorationId
          })
        ]);
      }
    }
  });
  return plugin;
}

// resources/js/components/MergeTagsList.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  child_ctx[16] = i;
  return child_ctx;
}
function create_if_block_12(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*items*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*selectedIndex, selectItem, items*/
      11) {
        each_value = ensure_array_like(
          /*items*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block(ctx) {
  let button;
  let span;
  let t0_value = (
    /*item*/
    ctx[14] + ""
  );
  let t0;
  let t1;
  let button_class_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[8](
        /*i*/
        ctx[16]
      )
    );
  }
  return {
    c() {
      button = element("button");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      attr(span, "class", "text");
      attr(button, "class", button_class_value = /*i*/
      ctx[16] === /*selectedIndex*/
      ctx[1] ? "active-option" : "");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      append(span, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*items*/
      1 && t0_value !== (t0_value = /*item*/
      ctx[14] + ""))
        set_data(t0, t0_value);
      if (dirty & /*selectedIndex*/
      2 && button_class_value !== (button_class_value = /*i*/
      ctx[16] === /*selectedIndex*/
      ctx[1] ? "active-option" : "")) {
        attr(button, "class", button_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block2(ctx) {
  let div2;
  return {
    c() {
      div2 = element("div");
      div2.textContent = "No merge tags set";
      attr(div2, "class", "no-blocks");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_fragment9(ctx) {
  let div1;
  let div0;
  let t;
  let if_block0 = (
    /*items*/
    ctx[0].length && create_if_block_12(ctx)
  );
  let if_block1 = !/*items*/
  ctx[0].length && create_if_block2(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "group");
      attr(div1, "class", "scribble-merge-tags");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t);
      if (if_block1)
        if_block1.m(div0, null);
      ctx[9](div1);
    },
    p(ctx2, [dirty]) {
      if (
        /*items*/
        ctx2[0].length
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          if_block0.m(div0, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!/*items*/
      ctx2[0].length) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block2(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[9](null);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { items } = $$props;
  let { editor } = $$props;
  let { range } = $$props;
  let selectedIndex = 0;
  let dropdown;
  const resetIndex = () => $$invalidate(1, selectedIndex = 0);
  const onKeyDown = ({ event }) => {
    if (event.key === "ArrowUp") {
      upHandler();
      return true;
    }
    if (event.key === "ArrowDown") {
      downHandler();
      return true;
    }
    if (event.key === "Enter") {
      enterHandler();
      return true;
    }
    return false;
  };
  const upHandler = () => {
    $$invalidate(1, selectedIndex = (selectedIndex + items.length - 1) % items.length);
    scrollToSelect();
  };
  const downHandler = () => {
    $$invalidate(1, selectedIndex = (selectedIndex + 1) % items.length);
    scrollToSelect();
  };
  const enterHandler = () => {
    selectItem(selectedIndex);
  };
  const selectItem = (index) => {
    const item = items[index];
    if (item) {
      const nodeAfter = editor.view.state.selection.$to.nodeAfter;
      const overrideSpace = nodeAfter?.text?.startsWith(" ");
      if (overrideSpace) {
        $$invalidate(4, range.to += 1, range);
      }
      editor.chain().focus().insertContentAt(range, [{ type: "mergeTag", attrs: { id: item } }, { type: "text", text: " " }]).run();
      window.getSelection()?.collapseToEnd();
    }
  };
  const scrollToSelect = () => {
    setTimeout(
      () => {
        dropdown.querySelector(".active-option").scrollIntoView({
          behavior: "smooth",
          block: "nearest",
          inline: "end"
        });
      },
      0
    );
  };
  const click_handler = (i) => selectItem(i);
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dropdown = $$value;
      $$invalidate(2, dropdown);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("editor" in $$props2)
      $$invalidate(5, editor = $$props2.editor);
    if ("range" in $$props2)
      $$invalidate(4, range = $$props2.range);
  };
  return [
    items,
    selectedIndex,
    dropdown,
    selectItem,
    range,
    editor,
    resetIndex,
    onKeyDown,
    click_handler,
    div1_binding
  ];
}
var MergeTagsList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      items: 0,
      editor: 5,
      range: 4,
      resetIndex: 6,
      onKeyDown: 7
    });
  }
  get resetIndex() {
    return this.$$.ctx[6];
  }
  get onKeyDown() {
    return this.$$.ctx[7];
  }
};
var MergeTagsList_default = MergeTagsList;

// resources/js/extensions/MergeTagsExtension.js
var MergeTagsExtension_default = Extension.create({
  name: "mergeTagsExtension",
  addOptions() {
    return {
      tags: {
        default: []
      },
      statePath: {
        default: null
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      Suggestion({
        editor: this.editor,
        char: "{{",
        command: ({ editor, range, props }) => {
          props.command({ editor, range });
        },
        startOfLine: false,
        pluginKey: new PluginKey("mergeTagsExtension"),
        items: ({ query }) => {
          return this.options.tags.filter((item) => item.toLowerCase().includes(query.toLowerCase()));
        },
        render: () => {
          let component;
          let popup;
          return {
            onStart: (props) => {
              if (!props.clientRect) {
                return;
              }
              const element2 = document.createElement("div");
              component = new MergeTagsList_default({
                target: element2,
                props: {
                  items: props.items,
                  editor: props.editor,
                  range: props.range,
                  statePath: this.options.statePath
                }
              });
              popup = tippy_esm_default("body", {
                getReferenceClientRect: props.clientRect,
                appendTo: () => document.body,
                content: component.$$.root,
                showOnCreate: true,
                interactive: true,
                trigger: "manual",
                placement: "bottom-start",
                theme: "scribble-panel",
                arrow: false,
                zIndex: 40
              });
            },
            onUpdate(props) {
              component.$set({
                items: props.items,
                editor: props.editor,
                range: props.range
              });
              component.resetIndex();
              if (!props.clientRect) {
                return;
              }
              popup[0].setProps({
                getReferenceClientRect: props.clientRect
              });
            },
            onKeyDown(props) {
              if (props.event.key === "Escape") {
                popup[0].hide();
                return true;
              }
              return component.onKeyDown(props);
            },
            onExit() {
              popup[0].destroy();
              component.$destroy();
            }
          };
        }
      })
    ];
  }
});

// node_modules/@tiptap/extension-placeholder/dist/index.js
var Placeholder = Extension.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something \u2026",
      showOnlyWhenEditable: true,
      considerAnyAsEmpty: false,
      showOnlyCurrent: true,
      includeChildren: false
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("placeholder"),
        props: {
          decorations: ({ doc: doc3, selection }) => {
            var _a;
            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;
            const { anchor } = selection;
            const decorations = [];
            if (!active) {
              return null;
            }
            const { firstChild } = doc3.content;
            const isLeaf = firstChild && firstChild.type.isLeaf;
            const isAtom = firstChild && firstChild.isAtom;
            const isValidNode = this.options.considerAnyAsEmpty ? true : firstChild && firstChild.type.name === ((_a = doc3.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.name);
            const isEmptyDoc = doc3.content.childCount <= 1 && firstChild && isValidNode && (firstChild.nodeSize <= 2 && (!isLeaf || !isAtom));
            doc3.descendants((node, pos) => {
              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;
              const isEmpty = !node.isLeaf && !node.childCount;
              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {
                const classes = [this.options.emptyNodeClass];
                if (isEmptyDoc) {
                  classes.push(this.options.emptyEditorClass);
                }
                const decoration = Decoration.node(pos, pos + node.nodeSize, {
                  class: classes.join(" "),
                  "data-placeholder": typeof this.options.placeholder === "function" ? this.options.placeholder({
                    editor: this.editor,
                    node,
                    pos,
                    hasAnchor
                  }) : this.options.placeholder
                });
                decorations.push(decoration);
              }
              return this.options.includeChildren;
            });
            return DecorationSet.create(doc3, decorations);
          }
        }
      })
    ];
  }
});

// node_modules/@tiptap/extension-blockquote/dist/index.js
var inputRegex2 = /^\s*>\s$/;
var Blockquote = Node2.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: true,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: commands2 }) => {
        return commands2.wrapIn(this.name);
      },
      toggleBlockquote: () => ({ commands: commands2 }) => {
        return commands2.toggleWrap(this.name);
      },
      unsetBlockquote: () => ({ commands: commands2 }) => {
        return commands2.lift(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex2,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-bold/dist/index.js
var starInputRegex = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/;
var starPasteRegex = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g;
var underscoreInputRegex = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/;
var underscorePasteRegex = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g;
var Bold = Mark2.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node) => node.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleBold: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetBold: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-bullet-list/dist/index.js
var ListItem = Node2.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});
var TextStyle = Mark2.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (element2) => {
          const hasStyles = element2.hasAttribute("style");
          if (!hasStyles) {
            return false;
          }
          return {};
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
        const attributes = getMarkAttributes(state, this.type);
        const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
        if (hasStyles) {
          return true;
        }
        return commands2.unsetMark(this.name);
      }
    };
  }
});
var inputRegex3 = /^\s*([-+*])\s$/;
var BulletList = Node2.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: commands2, chain }) => {
        if (this.options.keepAttributes) {
          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItem.name, this.editor.getAttributes(TextStyle.name)).run();
        }
        return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: inputRegex3,
      type: this.type
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: inputRegex3,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: () => {
          return this.editor.getAttributes(TextStyle.name);
        },
        editor: this.editor
      });
    }
    return [
      inputRule
    ];
  }
});

// node_modules/@tiptap/extension-code/dist/index.js
var inputRegex4 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/;
var pasteRegex = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g;
var Code = Mark2.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: true,
  exitable: true,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleCode: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetCode: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex4,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-code-block/dist/index.js
var backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
var tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
var CodeBlock = Node2.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: true,
      exitOnArrowDown: true,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: true,
  defining: true,
  addAttributes() {
    return {
      language: {
        default: null,
        parseHTML: (element2) => {
          var _a;
          const { languageClassPrefix } = this.options;
          const classNames = [...((_a = element2.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []];
          const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
          const language = languages[0];
          if (!language) {
            return null;
          }
          return language;
        },
        rendered: false
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "pre",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      [
        "code",
        {
          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.setNode(this.name, attributes);
      },
      toggleCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: empty3, $anchor } = this.editor.state.selection;
        const isAtStart = $anchor.pos === 1;
        if (!empty3 || $anchor.parent.type.name !== this.name) {
          return false;
        }
        if (isAtStart || !$anchor.parent.textContent.length) {
          return this.editor.commands.clearNodes();
        }
        return false;
      },
      // exit node on triple enter
      Enter: ({ editor }) => {
        if (!this.options.exitOnTripleEnter) {
          return false;
        }
        const { state } = editor;
        const { selection } = state;
        const { $from, empty: empty3 } = selection;
        if (!empty3 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
        if (!isAtEnd || !endsWithDoubleNewline) {
          return false;
        }
        return editor.chain().command(({ tr: tr2 }) => {
          tr2.delete($from.pos - 2, $from.pos);
          return true;
        }).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor }) => {
        if (!this.options.exitOnArrowDown) {
          return false;
        }
        const { state } = editor;
        const { selection, doc: doc3 } = state;
        const { $from, empty: empty3 } = selection;
        if (!empty3 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        if (!isAtEnd) {
          return false;
        }
        const after = $from.after();
        if (after === void 0) {
          return false;
        }
        const nodeAfter = doc3.nodeAt(after);
        if (nodeAfter) {
          return false;
        }
        return editor.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      textblockTypeInputRule({
        find: backtickInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      }),
      textblockTypeInputRule({
        find: tildeInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Plugin({
        key: new PluginKey("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (view, event) => {
            if (!event.clipboardData) {
              return false;
            }
            if (this.editor.isActive(this.type.name)) {
              return false;
            }
            const text2 = event.clipboardData.getData("text/plain");
            const vscode = event.clipboardData.getData("vscode-editor-data");
            const vscodeData = vscode ? JSON.parse(vscode) : void 0;
            const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
            if (!text2 || !language) {
              return false;
            }
            const { tr: tr2 } = view.state;
            tr2.replaceSelectionWith(this.type.create({ language }));
            tr2.setSelection(TextSelection.near(tr2.doc.resolve(Math.max(0, tr2.selection.from - 2))));
            tr2.insertText(text2.replace(/\r\n?/g, "\n"));
            tr2.setMeta("paste", true);
            view.dispatch(tr2);
            return true;
          }
        }
      })
    ];
  }
});

// node_modules/@tiptap/extension-document/dist/index.js
var Document = Node2.create({
  name: "doc",
  topNode: true,
  content: "block+"
});

// node_modules/prosemirror-dropcursor/dist/index.js
function dropCursor(options = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options);
    }
  });
}
var DropCursorView = class {
  constructor(editorView, options) {
    var _a;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;
    this.color = options.color === false ? void 0 : options.color || "black";
    this.class = options.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
      let handler = (e) => {
        this[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  destroy() {
    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos);
    let isBlock = !$pos.parent.inlineContent, rect;
    if (isBlock) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter;
      if (before || after) {
        let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
        if (node) {
          let nodeRect = node.getBoundingClientRect();
          let top2 = before ? nodeRect.bottom : nodeRect.top;
          if (before && after)
            top2 = (top2 + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          rect = { left: nodeRect.left, right: nodeRect.right, top: top2 - this.width / 2, bottom: top2 + this.width / 2 };
        }
      }
    }
    if (!rect) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect2 = parent.getBoundingClientRect();
      parentLeft = rect2.left - parent.scrollLeft;
      parentTop = rect2.top - parent.scrollTop;
    }
    this.element.style.left = rect.left - parentLeft + "px";
    this.element.style.top = rect.top - parentTop + "px";
    this.element.style.width = rect.right - rect.left + "px";
    this.element.style.height = rect.bottom - rect.top + "px";
  }
  scheduleRemoval(timeout) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.setCursor(null), timeout);
  }
  dragover(event) {
    if (!this.editorView.editable)
      return;
    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node && node.type.spec.disableDropCursor;
    let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      let target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point != null)
          target = point;
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  }
};

// node_modules/@tiptap/extension-dropcursor/dist/index.js
var Dropcursor = Extension.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      dropCursor(this.options)
    ];
  }
});

// node_modules/prosemirror-gapcursor/dist/index.js
var GapCursor = class _GapCursor extends Selection {
  /**
  Create a gap cursor.
  */
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc3, mapping) {
    let $pos = doc3.resolve(mapping.map(this.head));
    return _GapCursor.valid($pos) ? new _GapCursor($pos) : Selection.near($pos);
  }
  content() {
    return Slice.empty;
  }
  eq(other) {
    return other instanceof _GapCursor && other.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new _GapCursor(doc3.resolve(json.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  /**
  @internal
  */
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    let override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search:
      for (; ; ) {
        if (!mustMove && _GapCursor.valid($pos))
          return $pos;
        let pos = $pos.pos, next = null;
        for (let d = $pos.depth; ; d--) {
          let parent = $pos.node(d);
          if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
            next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
            break;
          } else if (d == 0) {
            return null;
          }
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (_GapCursor.valid($cur))
            return $cur;
        }
        for (; ; ) {
          let inside = dir > 0 ? next.firstChild : next.lastChild;
          if (!inside) {
            if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
              $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
              mustMove = false;
              continue search;
            }
            break;
          }
          next = inside;
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (_GapCursor.valid($cur))
            return $cur;
        }
        return null;
      }
  }
};
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);
var GapBookmark = class _GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new _GapBookmark(mapping.map(this.pos));
  }
  resolve(doc3) {
    let $pos = doc3.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
};
function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index = $pos.index(d), parent = $pos.node(d);
    if (index == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index = $pos.indexAfter(d), parent = $pos.node(d);
    if (index == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown,
      handleDOMEvents: { beforeinput }
    }
  });
}
var handleKeyDown = keydownHandler({
  "ArrowLeft": arrow2("horiz", -1),
  "ArrowRight": arrow2("horiz", 1),
  "ArrowUp": arrow2("vert", -1),
  "ArrowDown": arrow2("vert", 1)
});
function arrow2(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert2 = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert2)
    return false;
  let frag = Fragment.empty;
  for (let i = insert2.length - 1; i >= 0; i--)
    frag = Fragment.from(insert2[i].createAndFill(null, frag));
  let tr2 = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr2.setSelection(TextSelection.near(tr2.doc.resolve($from.pos + 1)));
  view.dispatch(tr2);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}

// node_modules/@tiptap/extension-gapcursor/dist/index.js
var Gapcursor = Extension.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      gapCursor()
    ];
  },
  extendNodeSchema(extension) {
    var _a;
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      allowGapCursor: (_a = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) !== null && _a !== void 0 ? _a : null
    };
  }
});

// node_modules/@tiptap/extension-hard-break/dist/index.js
var HardBreak = Node2.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: true,
      HTMLAttributes: {}
    };
  },
  inline: true,
  group: "inline",
  selectable: false,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  renderText() {
    return "\n";
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: commands2, chain, state, editor }) => {
        return commands2.first([
          () => commands2.exitCode(),
          () => commands2.command(() => {
            const { selection, storedMarks } = state;
            if (selection.$from.parent.type.spec.isolating) {
              return false;
            }
            const { keepMarks } = this.options;
            const { splittableMarks } = editor.extensionManager;
            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            return chain().insertContent({ type: this.name }).command(({ tr: tr2, dispatch }) => {
              if (dispatch && marks && keepMarks) {
                const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                tr2.ensureMarks(filteredMarks);
              }
              return true;
            }).run();
          })
        ]);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
});

// node_modules/@tiptap/extension-heading/dist/index.js
var Heading = Node2.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderHTML({ node, HTMLAttributes }) {
    const hasLevel = this.options.levels.includes(node.attrs.level);
    const level = hasLevel ? node.attrs.level : this.options.levels[0];
    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.setNode(this.name, attributes);
      },
      toggleHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((items, level) => ({
      ...items,
      ...{
        [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
      }
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule({
        find: new RegExp(`^(#{1,${level}})\\s$`),
        type: this.type,
        getAttributes: {
          level
        }
      });
    });
  }
});

// node_modules/rope-sequence/dist/index.js
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append2(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  if (from2 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach2(f, from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  if (from2 <= to) {
    this.forEachInner(f, from2, to, 0);
  } else {
    this.forEachInvertedInner(f, from2, to, 0);
  }
};
RopeSequence.prototype.map = function map(f, from2, to) {
  if (from2 === void 0)
    from2 = 0;
  if (to === void 0)
    to = this.length;
  var result = [];
  this.forEach(function(elt, i) {
    return result.push(f(elt, i));
  }, from2, to);
  return result;
};
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3)
    Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from2, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    for (var i = from2; i < to; i++) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    for (var i = from2 - 1; i >= to; i--) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ function(RopeSequence3) {
  function Append2(left2, right2) {
    RopeSequence3.call(this);
    this.left = left2;
    this.right = right2;
    this.length = left2.length + right2.length;
    this.depth = Math.max(left2.depth, right2.depth) + 1;
  }
  if (RopeSequence3)
    Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start2) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start2 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start2 + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start2) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from2, to);
    }
    if (from2 >= leftLen) {
      return this.right.slice(from2 - leftLen, to - leftLen);
    }
    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
var dist_default2 = RopeSequence;

// node_modules/prosemirror-history/dist/index.js
var max_empty_items = 500;
var Branch = class _Branch {
  constructor(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(state, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end2 = this.items.length;
    for (; ; end2--) {
      let next = this.items.get(end2 - 1);
      if (next.selection) {
        --end2;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end2, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform = state.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item, i) => {
      if (!item.step) {
        if (!remap) {
          remap = this.remapping(end2, i + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item(item.map));
        let step = item.step.map(remap.slice(mapFrom)), map2;
        if (step && transform.maybeStep(step).doc) {
          map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item(map2, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new _Branch(this.items.slice(0, end2).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  }
  // Create a new branch with the given transform added.
  addTransform(transform, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i = 0; i < transform.steps.length; i++) {
      let step = transform.steps[i].invert(transform.docs[i]);
      let item = new Item(transform.mapping.maps[i], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new _Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from2, to) {
    let maps = new Mapping();
    this.items.forEach((item, i) => {
      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
      maps.appendMap(item.map, mirrorPos);
    }, from2, to);
    return maps;
  }
  addMaps(array) {
    if (this.eventCount == 0)
      return this;
    return new _Branch(this.items.append(array.map((map2) => new Item(map2))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start2 = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item) => {
      if (item.selection)
        eventCount--;
    }, start2);
    let iRebased = rebasedCount;
    this.items.forEach((item) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map2 = mapping.maps[pos];
      if (item.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item(map2, step, selection));
      } else {
        rebasedItems.push(new Item(map2));
      }
    }, start2);
    let newMaps = [];
    for (let i = rebasedCount; i < newUntil; i++)
      newMaps.push(new Item(mapping.maps[i]));
    let items = this.items.slice(0, start2).append(newMaps).append(rebasedItems);
    let branch = new _Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count = 0;
    this.items.forEach((item) => {
      if (!item.step)
        count++;
    });
    return count;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items = [], events = 0;
    this.items.forEach((item, i) => {
      if (i >= upto) {
        items.push(item);
        if (item.selection)
          events++;
      } else if (item.step) {
        let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
        if (step) {
          let selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events++;
          let newItem = new Item(map2.invert(), step, selection), merged, last = items.length - 1;
          if (merged = items.length && items[last].merge(newItem))
            items[last] = merged;
          else
            items.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new _Branch(dist_default2.from(items.reverse()), events);
  }
};
Branch.empty = new Branch(dist_default2.empty, 0);
function cutOffEvents(items, n) {
  let cutPoint;
  items.forEach((item, i) => {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
var Item = class _Item {
  constructor(map2, step, selection, mirrorOffset) {
    this.map = map2;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new _Item(step.getMap().invert(), step, this.selection);
    }
  }
};
var HistoryState = class {
  constructor(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  }
};
var DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state, tr2, options) {
  let historyTr = tr2.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr2.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
  let appended = tr2.getMeta("appendedTransaction");
  if (tr2.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr2, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr2.mapping.maps[tr2.steps.length - 1]), history2.prevTime, history2.prevComposition);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr2, void 0, options, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
  } else if (tr2.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr2.getMeta("composition");
    let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr2.time || 0) - options.newGroupDelay || !isAdjacentTo(tr2, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr2.mapping) : rangesFor(tr2.mapping.maps[tr2.steps.length - 1]);
    return new HistoryState(history2.done.addTransform(tr2, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr2.time, composition == null ? history2.prevComposition : composition);
  } else if (rebased = tr2.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr2, rebased), history2.undone.rebased(tr2, rebased), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  } else {
    return new HistoryState(history2.done.addMaps(tr2.mapping.maps), history2.undone.addMaps(tr2.mapping.maps), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start2, end2) => {
    for (let i = 0; i < prevRanges.length; i += 2)
      if (start2 <= prevRanges[i + 1] && end2 >= prevRanges[i])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(map2) {
  let result = [];
  map2.forEach((_from, _to, from2, to) => result.push(from2, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i = 0; i < ranges.length; i += 2) {
    let from2 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
    if (from2 <= to)
      result.push(from2, to);
  }
  return result;
}
function histTransaction(history2, state, dispatch, redo2) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop)
    return;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist }).scrollIntoView());
}
var cachedPreserveItems = false;
var cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  let plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i = 0; i < plugins.length; i++)
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
var historyKey = new PluginKey("history");
var closeHistoryKey = new PluginKey("closeHistory");
function history(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(tr2, hist, state) {
        return applyTransaction(hist, state, tr2, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e) {
          let inputType = e.inputType;
          let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
var undo = (state, dispatch) => {
  let hist = historyKey.getState(state);
  if (!hist || hist.done.eventCount == 0)
    return false;
  if (dispatch)
    histTransaction(hist, state, dispatch, false);
  return true;
};
var redo = (state, dispatch) => {
  let hist = historyKey.getState(state);
  if (!hist || hist.undone.eventCount == 0)
    return false;
  if (dispatch)
    histTransaction(hist, state, dispatch, true);
  return true;
};

// node_modules/@tiptap/extension-history/dist/index.js
var History = Extension.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state, dispatch }) => {
        return undo(state, dispatch);
      },
      redo: () => ({ state, dispatch }) => {
        return redo(state, dispatch);
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      history(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-\u044F": () => this.editor.commands.undo(),
      "Shift-Mod-\u044F": () => this.editor.commands.redo()
    };
  }
});

// node_modules/@tiptap/extension-horizontal-rule/dist/index.js
var HorizontalRule = Node2.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain, state }) => {
        const { $to: $originTo } = state.selection;
        const currentChain = chain();
        if ($originTo.parentOffset === 0) {
          currentChain.insertContentAt(Math.max($originTo.pos - 2, 0), { type: this.name });
        } else {
          currentChain.insertContent({ type: this.name });
        }
        return currentChain.command(({ tr: tr2, dispatch }) => {
          var _a;
          if (dispatch) {
            const { $to } = tr2.selection;
            const posAfter = $to.end();
            if ($to.nodeAfter) {
              if ($to.nodeAfter.isTextblock) {
                tr2.setSelection(TextSelection.create(tr2.doc, $to.pos + 1));
              } else if ($to.nodeAfter.isBlock) {
                tr2.setSelection(NodeSelection.create(tr2.doc, $to.pos));
              } else {
                tr2.setSelection(TextSelection.create(tr2.doc, $to.pos));
              }
            } else {
              const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();
              if (node) {
                tr2.insert(posAfter, node);
                tr2.setSelection(TextSelection.create(tr2.doc, posAfter + 1));
              }
            }
            tr2.scrollIntoView();
          }
          return true;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-italic/dist/index.js
var starInputRegex2 = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/;
var starPasteRegex2 = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g;
var underscoreInputRegex2 = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/;
var underscorePasteRegex2 = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g;
var Italic = Mark2.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node) => node.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleItalic: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex2,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex2,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex2,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex2,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-list-item/dist/index.js
var ListItem2 = Node2.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});

// node_modules/@tiptap/extension-ordered-list/dist/index.js
var ListItem3 = Node2.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});
var TextStyle2 = Mark2.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (element2) => {
          const hasStyles = element2.hasAttribute("style");
          if (!hasStyles) {
            return false;
          }
          return {};
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
        const attributes = getMarkAttributes(state, this.type);
        const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
        if (hasStyles) {
          return true;
        }
        return commands2.unsetMark(this.name);
      }
    };
  }
});
var inputRegex5 = /^(\d+)\.\s$/;
var OrderedList = Node2.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (element2) => {
          return element2.hasAttribute("start") ? parseInt(element2.getAttribute("start") || "", 10) : 1;
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    const { start: start2, ...attributesWithoutStart } = HTMLAttributes;
    return start2 === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: commands2, chain }) => {
        if (this.options.keepAttributes) {
          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItem3.name, this.editor.getAttributes(TextStyle2.name)).run();
        }
        return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: inputRegex5,
      type: this.type,
      getAttributes: (match) => ({ start: +match[1] }),
      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: inputRegex5,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: (match) => ({ start: +match[1], ...this.editor.getAttributes(TextStyle2.name) }),
        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],
        editor: this.editor
      });
    }
    return [
      inputRule
    ];
  }
});

// node_modules/@tiptap/extension-paragraph/dist/index.js
var Paragraph = Node2.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: commands2 }) => {
        return commands2.setNode(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});

// node_modules/@tiptap/extension-strike/dist/index.js
var inputRegex6 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/;
var pasteRegex2 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g;
var Strike = Mark2.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("line-through") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleStrike: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetStrike: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    const shortcuts = {};
    if (isMacOS()) {
      shortcuts["Mod-Shift-s"] = () => this.editor.commands.toggleStrike();
    } else {
      shortcuts["Ctrl-Shift-s"] = () => this.editor.commands.toggleStrike();
    }
    return shortcuts;
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex6,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex2,
        type: this.type
      })
    ];
  }
});

// node_modules/@tiptap/extension-text/dist/index.js
var Text = Node2.create({
  name: "text",
  group: "inline"
});

// node_modules/@tiptap/starter-kit/dist/index.js
var StarterKit = Extension.create({
  name: "starterKit",
  addExtensions() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    const extensions2 = [];
    if (this.options.blockquote !== false) {
      extensions2.push(Blockquote.configure((_a = this.options) === null || _a === void 0 ? void 0 : _a.blockquote));
    }
    if (this.options.bold !== false) {
      extensions2.push(Bold.configure((_b = this.options) === null || _b === void 0 ? void 0 : _b.bold));
    }
    if (this.options.bulletList !== false) {
      extensions2.push(BulletList.configure((_c = this.options) === null || _c === void 0 ? void 0 : _c.bulletList));
    }
    if (this.options.code !== false) {
      extensions2.push(Code.configure((_d = this.options) === null || _d === void 0 ? void 0 : _d.code));
    }
    if (this.options.codeBlock !== false) {
      extensions2.push(CodeBlock.configure((_e = this.options) === null || _e === void 0 ? void 0 : _e.codeBlock));
    }
    if (this.options.document !== false) {
      extensions2.push(Document.configure((_f = this.options) === null || _f === void 0 ? void 0 : _f.document));
    }
    if (this.options.dropcursor !== false) {
      extensions2.push(Dropcursor.configure((_g = this.options) === null || _g === void 0 ? void 0 : _g.dropcursor));
    }
    if (this.options.gapcursor !== false) {
      extensions2.push(Gapcursor.configure((_h = this.options) === null || _h === void 0 ? void 0 : _h.gapcursor));
    }
    if (this.options.hardBreak !== false) {
      extensions2.push(HardBreak.configure((_j = this.options) === null || _j === void 0 ? void 0 : _j.hardBreak));
    }
    if (this.options.heading !== false) {
      extensions2.push(Heading.configure((_k = this.options) === null || _k === void 0 ? void 0 : _k.heading));
    }
    if (this.options.history !== false) {
      extensions2.push(History.configure((_l = this.options) === null || _l === void 0 ? void 0 : _l.history));
    }
    if (this.options.horizontalRule !== false) {
      extensions2.push(HorizontalRule.configure((_m = this.options) === null || _m === void 0 ? void 0 : _m.horizontalRule));
    }
    if (this.options.italic !== false) {
      extensions2.push(Italic.configure((_o = this.options) === null || _o === void 0 ? void 0 : _o.italic));
    }
    if (this.options.listItem !== false) {
      extensions2.push(ListItem2.configure((_p = this.options) === null || _p === void 0 ? void 0 : _p.listItem));
    }
    if (this.options.orderedList !== false) {
      extensions2.push(OrderedList.configure((_q = this.options) === null || _q === void 0 ? void 0 : _q.orderedList));
    }
    if (this.options.paragraph !== false) {
      extensions2.push(Paragraph.configure((_r = this.options) === null || _r === void 0 ? void 0 : _r.paragraph));
    }
    if (this.options.strike !== false) {
      extensions2.push(Strike.configure((_s = this.options) === null || _s === void 0 ? void 0 : _s.strike));
    }
    if (this.options.text !== false) {
      extensions2.push(Text.configure((_t = this.options) === null || _t === void 0 ? void 0 : _t.text));
    }
    return extensions2;
  }
});

// resources/js/extensions/StatePathExtension.js
var StatePathExtension_default = Extension.create({
  name: "statePathExtension",
  addOptions() {
    return {
      statePath: null
    };
  },
  addStorage() {
    return {
      statePath: null
    };
  },
  onCreate() {
    this.storage.statePath = this.options.statePath;
  }
});

// resources/js/components/ScribbleBlock.svelte
function create_else_block(ctx) {
  let div2;
  return {
    c() {
      div2 = element("div");
      div2.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;
      attr(div2, "class", "loading-block");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_if_block3(ctx) {
  let html_tag;
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(
        /*view*/
        ctx[2],
        target,
        anchor
      );
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*view*/
      4)
        html_tag.p(
          /*view*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_default_slot_12(ctx) {
  let draghandle;
  let current;
  draghandle = new DragHandle_default({
    props: {
      handleMenuOpen: (
        /*handleMenuOpen*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(draghandle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(draghandle, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(draghandle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(draghandle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(draghandle, detaching);
    }
  };
}
function create_default_slot2(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let t;
  let blockactions;
  let current;
  function select_block_type(ctx2, dirty) {
    if (
      /*view*/
      ctx2[2]
    )
      return create_if_block3;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  blockactions = new BlockActions_default({
    props: {
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if_block.c();
      t = space();
      create_component(blockactions.$$.fragment);
      attr(div0, "class", div0_class_value = "scribble-block-content " + /*selected*/
      (ctx[0] ? "ProseMirror-selectednode" : ""));
      attr(div1, "class", "scribble-block");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if_block.m(div0, null);
      ctx[8](div0);
      append(div1, t);
      mount_component(blockactions, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div0, null);
        }
      }
      if (!current || dirty & /*selected*/
      1 && div0_class_value !== (div0_class_value = "scribble-block-content " + /*selected*/
      (ctx2[0] ? "ProseMirror-selectednode" : ""))) {
        attr(div0, "class", div0_class_value);
      }
      const blockactions_changes = {};
      if (dirty & /*$$scope*/
      4096) {
        blockactions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      blockactions.$set(blockactions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(blockactions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(blockactions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if_block.d();
      ctx[8](null);
      destroy_component(blockactions);
    }
  };
}
function create_fragment10(ctx) {
  let nodeviewwrapper;
  let current;
  nodeviewwrapper = new NodeViewWrapper_default({
    props: {
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(nodeviewwrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(nodeviewwrapper, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const nodeviewwrapper_changes = {};
      if (dirty & /*$$scope, selected, wrapper, view*/
      4103) {
        nodeviewwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      nodeviewwrapper.$set(nodeviewwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nodeviewwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nodeviewwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(nodeviewwrapper, detaching);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let wrapper;
  let getView;
  let { editor } = $$props;
  let { node } = $$props;
  let { selected = false } = $$props;
  let { updateAttributes: updateAttributes2 } = $$props;
  let view = null;
  let component;
  let popupInstance;
  const handleMenuOpen = (event) => {
    const clientRect2 = event.currentTarget.getBoundingClientRect();
    $$invalidate(7, component = new OptionsMenu_default({
      target: document.createElement("div"),
      // Crea un elemento div per montare il componente Svelte
      props: {
        node,
        editor,
        onClose: () => closeOptions()
      }
    }));
    popupInstance = tippy_esm_default("body", {
      content: component.$$.root,
      getReferenceClientRect: () => clientRect2,
      allowHTML: true,
      interactive: true,
      trigger: "manual",
      placement: "left",
      showOnCreate: true,
      hideOnClick: true,
      theme: "scribble-options",
      arrow: true,
      zIndex: 9999,
      onHidden(instance18) {
        instance18.destroy();
      }
    });
  };
  const closeOptions = (event) => {
    if (Array.isArray(popupInstance)) {
      popupInstance.forEach((instance18) => instance18.hide());
    } else {
      popupInstance.hide();
    }
  };
  onMount(() => {
    getView();
    window.addEventListener("updatedBlock", (e) => {
      if (e.detail.identifier === node.attrs.identifier && e.detail.statePath === editor.storage?.statePathExtension.statePath && e.detail.blockId === node.attrs.id) {
        updateAttributes2({ values: e.detail.values });
        getView();
      }
    });
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapper = $$value;
      $$invalidate(1, wrapper);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("editor" in $$props2)
      $$invalidate(4, editor = $$props2.editor);
    if ("node" in $$props2)
      $$invalidate(5, node = $$props2.node);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
    if ("updateAttributes" in $$props2)
      $$invalidate(6, updateAttributes2 = $$props2.updateAttributes);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*node, wrapper, updateAttributes*/
    98) {
      $:
        getView = () => {
          const component2 = document.querySelector("#scribble-renderer").getAttribute("wire:id");
          console.log(node.attrs.values);
          window.Livewire.find(component2).call("getView", node.attrs.identifier, node.attrs.values).then((e) => {
            $$invalidate(2, view = e);
          }).then(() => {
            wrapper.addEventListener("change", (e) => {
              let name = e.target.getAttribute("id").replace("data.", "");
              let value = e.target.value;
              updateAttributes2({
                values: { ...node.attrs.values, [name]: value }
              });
            });
          });
        };
    }
  };
  $:
    $$invalidate(1, wrapper = null);
  return [
    selected,
    wrapper,
    view,
    handleMenuOpen,
    editor,
    node,
    updateAttributes2,
    component,
    div0_binding
  ];
}
var ScribbleBlock = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      editor: 4,
      node: 5,
      selected: 0,
      updateAttributes: 6
    });
  }
};
var ScribbleBlock_default = ScribbleBlock;

// resources/js/extensions/ScribbleBlock.js
var ScribbleBlock_default2 = Node2.create({
  name: "scribbleBlock",
  isBlock: true,
  inline: false,
  group: "block",
  draggable: true,
  defining: true,
  selectable: true,
  addStorage() {
    return {
      statePath: null
    };
  },
  addAttributes() {
    return {
      id: {
        default: null
      },
      type: {
        default: "block"
      },
      identifier: {
        default: null
      },
      values: {
        default: {}
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "scribble-block",
        getAttrs: (dom) => {
          return JSON.parse(dom.innerHTML);
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["scribble-block", JSON.stringify(HTMLAttributes)];
  },
  addCommands() {
    return {
      setScribbleBlock: (options) => ({ tr: tr2, state }) => {
        openScribbleModal(options.identifier, { ...options });
        return true;
      },
      insertScribbleBlock: (options) => {
        return ({ tr: tr2, dispatch, commands: commands2 }) => {
          const { selection } = tr2;
          const node = this.type.create({
            ...{ id: uuid() },
            ...options
          });
          if (dispatch) {
            tr2.replaceRangeWith(selection.from - selection.$anchor.parentOffset, selection.to, node);
            commands2.setNodeSelection(tr2.mapping.map(tr2.steps[tr2.steps.length - 1].from), 1);
          }
          return true;
        };
      }
    };
  },
  addNodeView() {
    return SvelteNodeViewRenderer_default(ScribbleBlock_default);
  }
});

// resources/js/components/CommandsList.svelte
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  return child_ctx;
}
function create_if_block_13(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(Object.keys(
    /*groups*/
    ctx[3]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*groups, Object, selectedIndex, selectItem*/
      26) {
        each_value = ensure_array_like(Object.keys(
          /*groups*/
          ctx2[3]
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let div2;
  let t_value = (
    /*group*/
    ctx[17] + ""
  );
  let t;
  return {
    c() {
      div2 = element("div");
      t = text(t_value);
      attr(div2, "class", "group-title");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*groups*/
      8 && t_value !== (t_value = /*group*/
      ctx2[17] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_if_block_22(ctx) {
  let span;
  let t_value = (
    /*item*/
    ctx[20].description + ""
  );
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "description");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*groups*/
      8 && t_value !== (t_value = /*item*/
      ctx2[20].description + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_each_block_1(ctx) {
  let button;
  let span0;
  let raw_value = (
    /*item*/
    ctx[20].icon + ""
  );
  let t0;
  let span2;
  let span1;
  let t1_value = (
    /*item*/
    ctx[20].label + ""
  );
  let t1;
  let t2;
  let t3;
  let button_class_value;
  let mounted;
  let dispose;
  let if_block = (
    /*item*/
    ctx[20].description && create_if_block_22(ctx)
  );
  function click_handler() {
    return (
      /*click_handler*/
      ctx[10](
        /*item*/
        ctx[20]
      )
    );
  }
  return {
    c() {
      button = element("button");
      span0 = element("span");
      t0 = space();
      span2 = element("span");
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      attr(span0, "class", "icon");
      attr(span1, "class", "label");
      attr(span2, "class", "text");
      attr(button, "class", button_class_value = /*item*/
      ctx[20].index === /*selectedIndex*/
      ctx[1] ? "active-option" : "");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span0);
      span0.innerHTML = raw_value;
      append(button, t0);
      append(button, span2);
      append(span2, span1);
      append(span1, t1);
      append(span2, t2);
      if (if_block)
        if_block.m(span2, null);
      append(button, t3);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*groups*/
      8 && raw_value !== (raw_value = /*item*/
      ctx[20].icon + ""))
        span0.innerHTML = raw_value;
      ;
      if (dirty & /*groups*/
      8 && t1_value !== (t1_value = /*item*/
      ctx[20].label + ""))
        set_data(t1, t1_value);
      if (
        /*item*/
        ctx[20].description
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_22(ctx);
          if_block.c();
          if_block.m(span2, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*groups, selectedIndex*/
      10 && button_class_value !== (button_class_value = /*item*/
      ctx[20].index === /*selectedIndex*/
      ctx[1] ? "active-option" : "")) {
        attr(button, "class", button_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_each_block2(ctx) {
  let t;
  let each_1_anchor;
  let if_block = (
    /*group*/
    ctx[17] && create_if_block_3(ctx)
  );
  let each_value_1 = ensure_array_like(
    /*groups*/
    ctx[3][
      /*group*/
      ctx[17]
    ]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*group*/
        ctx2[17]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*groups, Object, selectedIndex, selectItem*/
      26) {
        each_value_1 = ensure_array_like(
          /*groups*/
          ctx2[3][
            /*group*/
            ctx2[17]
          ]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t);
        detach(each_1_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block4(ctx) {
  let div2;
  return {
    c() {
      div2 = element("div");
      div2.textContent = "No blocks found";
      attr(div2, "class", "no-blocks");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_fragment11(ctx) {
  let div1;
  let div0;
  let t;
  let if_block0 = (
    /*items*/
    ctx[0].length && create_if_block_13(ctx)
  );
  let if_block1 = !/*items*/
  ctx[0].length && create_if_block4(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "group");
      attr(div1, "class", "scribble-suggestions");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t);
      if (if_block1)
        if_block1.m(div0, null);
      ctx[11](div1);
    },
    p(ctx2, [dirty]) {
      if (
        /*items*/
        ctx2[0].length
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_13(ctx2);
          if_block0.c();
          if_block0.m(div0, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!/*items*/
      ctx2[0].length) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block4(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[11](null);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { items } = $$props;
  let { editor } = $$props;
  let { range } = $$props;
  let { statePath } = $$props;
  let selectedIndex = 0;
  let dropdown;
  let groups;
  const getGroups = (array) => {
    let map2 = array.map((e, i) => {
      e.index = i;
      return e;
    });
    $$invalidate(3, groups = map2.reduce(
      function(r2, a) {
        r2[a.group] = r2[a.group] || [];
        r2[a.group].push(a);
        return r2;
      },
      /* @__PURE__ */ Object.create(null)
    ));
  };
  const resetIndex = () => $$invalidate(1, selectedIndex = 0);
  const onKeyDown = ({ event }) => {
    if (event.key === "ArrowUp") {
      upHandler();
      return true;
    }
    if (event.key === "ArrowDown") {
      downHandler();
      return true;
    }
    if (event.key === "Enter") {
      enterHandler();
      return true;
    }
    return false;
  };
  const upHandler = () => {
    $$invalidate(1, selectedIndex = (selectedIndex + items.length - 1) % items.length);
    scrollToSelect();
  };
  const downHandler = () => {
    $$invalidate(1, selectedIndex = (selectedIndex + 1) % items.length);
    scrollToSelect();
  };
  const enterHandler = () => {
    selectItem(selectedIndex);
  };
  const selectItem = (index) => {
    const item = items[index];
    if (item) {
      editor.commands.deleteRange(range);
      switch (item.type) {
        case "command":
          commandRunner(editor, item.commands);
          break;
        case "event":
          replaceStatePath(item.event.data, statePath);
          window.Livewire.dispatch(item.event.name, item.event.data);
          return;
        case "modal":
          openScribbleModal(item.options, {
            statePath,
            identifier: item.identifier,
            data: editor.getAttributes(item.extension)
          });
          break;
        case "static":
          editor.chain().insertScribbleBlock({
            identifier: item.identifier,
            type: item.type,
            statePath,
            blockId: item.blockId,
            values: {}
          }).focus().run();
          break;
        default:
          editor.commands.setScribbleBlock({
            identifier: item.identifier,
            statePath,
            blockId: item.blockId
          });
      }
    }
  };
  const scrollToSelect = () => {
    setTimeout(
      () => {
        dropdown.querySelector(".active-option").scrollIntoView({
          behavior: "smooth",
          block: "nearest",
          inline: "end"
        });
      },
      0
    );
  };
  const click_handler = (item) => selectItem(item.index);
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dropdown = $$value;
      $$invalidate(2, dropdown);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("editor" in $$props2)
      $$invalidate(5, editor = $$props2.editor);
    if ("range" in $$props2)
      $$invalidate(6, range = $$props2.range);
    if ("statePath" in $$props2)
      $$invalidate(7, statePath = $$props2.statePath);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*items*/
    1) {
      $:
        getGroups(items);
    }
  };
  return [
    items,
    selectedIndex,
    dropdown,
    groups,
    selectItem,
    editor,
    range,
    statePath,
    resetIndex,
    onKeyDown,
    click_handler,
    div1_binding
  ];
}
var CommandsList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment11, safe_not_equal, {
      items: 0,
      editor: 5,
      range: 6,
      statePath: 7,
      resetIndex: 8,
      onKeyDown: 9
    });
  }
  get resetIndex() {
    return this.$$.ctx[8];
  }
  get onKeyDown() {
    return this.$$.ctx[9];
  }
};
var CommandsList_default = CommandsList;

// resources/js/extensions/SlashExtension.js
var SlashExtension_default = Extension.create({
  name: "slashExtension",
  addOptions() {
    return {
      tools: {
        default: []
      },
      statePath: {
        default: null
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      Suggestion({
        editor: this.editor,
        char: "/",
        command: ({ editor, range, props }) => {
          props.command({ editor, range });
        },
        startOfLine: true,
        pluginKey: new PluginKey("slashExtension"),
        items: ({ query }) => {
          return this.options.tools.filter((item) => item.label.toLowerCase().includes(query.toLowerCase()));
        },
        render: () => {
          let component;
          let popup;
          return {
            onStart: (props) => {
              if (!props.clientRect) {
                return;
              }
              const element2 = document.createElement("div");
              component = new CommandsList_default({
                target: element2,
                props: {
                  items: props.items,
                  editor: props.editor,
                  range: props.range,
                  statePath: this.options.statePath
                }
              });
              popup = tippy_esm_default("body", {
                getReferenceClientRect: props.clientRect,
                appendTo: () => document.body,
                content: component.$$.root,
                showOnCreate: true,
                interactive: true,
                trigger: "manual",
                placement: "bottom-start",
                theme: "scribble-panel",
                arrow: false,
                zIndex: 40
              });
            },
            onUpdate(props) {
              component.$set({
                items: props.items,
                editor: props.editor,
                range: props.range
              });
              component.resetIndex();
              if (!props.clientRect) {
                return;
              }
              popup[0].setProps({
                getReferenceClientRect: props.clientRect
              });
            },
            onKeyDown(props) {
              if (props.event.key === "Escape") {
                popup[0].hide();
                return true;
              }
              return component.onKeyDown(props);
            },
            onExit() {
              popup[0].destroy();
              component.$destroy();
            }
          };
        }
      })
    ];
  }
});

// node_modules/@tiptap/extension-subscript/dist/index.js
var Subscript = Mark2.create({
  name: "subscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sub"
      },
      {
        style: "vertical-align",
        getAttrs(value) {
          if (value !== "sub") {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["sub", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setSubscript: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleSubscript: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetSubscript: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-,": () => this.editor.commands.toggleSubscript()
    };
  }
});

// node_modules/@tiptap/extension-superscript/dist/index.js
var Superscript = Mark2.create({
  name: "superscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sup"
      },
      {
        style: "vertical-align",
        getAttrs(value) {
          if (value !== "super") {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["sup", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setSuperscript: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleSuperscript: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetSuperscript: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-.": () => this.editor.commands.toggleSuperscript()
    };
  }
});

// resources/js/extensions/TextAlignExtension.js
var TextAlignExtension_default = Extension.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["start", "center", "end", "justify"],
      defaultAlignment: "start"
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (element2) => element2.style.textAlign || this.options.defaultAlignment,
            renderHTML: (attributes) => {
              if (attributes.textAlign === this.options.defaultAlignment) {
                return {};
              }
              return { style: `text-align: ${attributes.textAlign}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (alignment) => ({ commands: commands2 }) => {
        if (!this.options.alignments.includes(alignment)) {
          return false;
        }
        return this.options.types.every((type) => commands2.updateAttributes(type, { textAlign: alignment }));
      },
      unsetTextAlign: () => ({ commands: commands2 }) => {
        return this.options.types.every((type) => commands2.resetAttributes(type, "textAlign"));
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("start"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("end"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
});

// node_modules/@tiptap/extension-text-style/dist/index.js
var TextStyle3 = Mark2.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (element2) => {
          const hasStyles = element2.hasAttribute("style");
          if (!hasStyles) {
            return false;
          }
          return {};
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
        const attributes = getMarkAttributes(state, this.type);
        const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
        if (hasStyles) {
          return true;
        }
        return commands2.unsetMark(this.name);
      }
    };
  }
});

// node_modules/@tiptap/extension-underline/dist/index.js
var Underline = Mark2.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("underline") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleUnderline: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetUnderline: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e)
    n += e;
  else if ("object" == typeof e)
    if (Array.isArray(e)) {
      var o = e.length;
      for (t = 0; t < o; t++)
        e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else
      for (f in e)
        e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++)
    (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_default = clsx;

// resources/js/components/Button.svelte
function create_if_block5(ctx) {
  let button;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(button, "type", "button");
      attr(button, "class", button_class_value = clsx_default(`scribble-button scribble-${/*key*/
      ctx[1]}`, { "active": (
        /*active*/
        ctx[2]
      ) }));
      toggle_class(
        button,
        "active",
        /*active*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*key, active*/
      6 && button_class_value !== (button_class_value = clsx_default(`scribble-button scribble-${/*key*/
      ctx2[1]}`, { "active": (
        /*active*/
        ctx2[2]
      ) }))) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & /*key, active, active*/
      6) {
        toggle_class(
          button,
          "active",
          /*active*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment12(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*editor*/
    ctx[0] && !/*hidden*/
    ctx[3] && create_if_block5(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*editor*/
        ctx2[0] && !/*hidden*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*editor, hidden*/
          9) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { editor } = $$props;
  let { key } = $$props;
  let { active = false } = $$props;
  let { hidden } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("editor" in $$props2)
      $$invalidate(0, editor = $$props2.editor);
    if ("key" in $$props2)
      $$invalidate(1, key = $$props2.key);
    if ("active" in $$props2)
      $$invalidate(2, active = $$props2.active);
    if ("hidden" in $$props2)
      $$invalidate(3, hidden = $$props2.hidden);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [editor, key, active, hidden, $$scope, slots, click_handler];
}
var Button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance12, create_fragment12, safe_not_equal, { editor: 0, key: 1, active: 2, hidden: 3 });
  }
};
var Button_default = Button;

// resources/js/components/Controls.svelte
function create_if_block6(ctx) {
  let div1;
  let div0;
  let button0;
  let t0;
  let button1;
  let t1;
  let button2;
  let t2;
  let button3;
  let t3;
  let button4;
  let current;
  button0 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[0]
      ),
      key: "undo",
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*click_handler*/
    ctx[3]
  );
  button1 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[0]
      ),
      key: "redo",
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*click_handler_1*/
    ctx[4]
  );
  button2 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[0]
      ),
      key: "clear",
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  button2.$on(
    "click",
    /*click_handler_2*/
    ctx[5]
  );
  button3 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[0]
      ),
      key: "enter-fullscreen",
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    }
  });
  button3.$on(
    "click",
    /*toggleFullscreen*/
    ctx[1]
  );
  button4 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[0]
      ),
      key: "exit-fullscreen",
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    }
  });
  button4.$on(
    "click",
    /*toggleFullscreen*/
    ctx[1]
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(button0.$$.fragment);
      t0 = space();
      create_component(button1.$$.fragment);
      t1 = space();
      create_component(button2.$$.fragment);
      t2 = space();
      create_component(button3.$$.fragment);
      t3 = space();
      create_component(button4.$$.fragment);
      attr(div0, "class", "scribble-controls-panel");
      attr(div1, "class", "scribble-controls");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(button0, div0, null);
      append(div0, t0);
      mount_component(button1, div0, null);
      append(div0, t1);
      mount_component(button2, div0, null);
      append(div0, t2);
      mount_component(button3, div0, null);
      append(div0, t3);
      mount_component(button4, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*editor*/
      1)
        button0_changes.editor = /*editor*/
        ctx2[0];
      if (dirty & /*$$scope*/
      64) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*editor*/
      1)
        button1_changes.editor = /*editor*/
        ctx2[0];
      if (dirty & /*$$scope*/
      64) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*editor*/
      1)
        button2_changes.editor = /*editor*/
        ctx2[0];
      if (dirty & /*$$scope*/
      64) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
      const button3_changes = {};
      if (dirty & /*editor*/
      1)
        button3_changes.editor = /*editor*/
        ctx2[0];
      if (dirty & /*$$scope*/
      64) {
        button3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button3.$set(button3_changes);
      const button4_changes = {};
      if (dirty & /*editor*/
      1)
        button4_changes.editor = /*editor*/
        ctx2[0];
      if (dirty & /*$$scope*/
      64) {
        button4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button4.$set(button4_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      transition_in(button4.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      transition_out(button4.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(button2);
      destroy_component(button3);
      destroy_component(button4);
    }
  };
}
function create_default_slot_4(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill", "none");
      attr(path, "stroke", "currentColor");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "32");
      attr(path, "d", "M240 424v-96c116.4 0 159.39 33.76 208 96c0-119.23-39.57-240-208-240V88L64 256Z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "32");
      attr(svg, "height", "32");
      attr(svg, "viewBox", "0 0 512 512");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_default_slot_3(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill", "none");
      attr(path, "stroke", "currentColor");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "32");
      attr(path, "d", "M448 256L272 88v96C103.57 184 64 304.77 64 424c48.61-62.24 91.6-96 208-96v96Z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "32");
      attr(svg, "height", "32");
      attr(svg, "viewBox", "0 0 512 512");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_default_slot_2(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M13.9999 18.9967H20.9999V20.9967H11.9999L8.00229 20.9992L1.51457 14.5115C1.12405 14.1209 1.12405 13.4878 1.51457 13.0972L12.1212 2.49065C12.5117 2.10012 13.1449 2.10012 13.5354 2.49065L21.3136 10.2688C21.7041 10.6593 21.7041 11.2925 21.3136 11.683L13.9999 18.9967ZM15.6567 14.5115L19.1922 10.9759L12.8283 4.61197L9.29275 8.1475L15.6567 14.5115Z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_default_slot_13(ctx) {
  let svg;
  let path0;
  let path1;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "fill", "none");
      attr(path0, "d", "M0 0h24v24H0z");
      attr(path1, "d", "M20 3h2v6h-2V5h-4V3h4zM4 3h4v2H4v4H2V3h2zm16 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_default_slot3(ctx) {
  let svg;
  let path0;
  let path1;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "fill", "none");
      attr(path0, "d", "M0 0h24v24H0z");
      attr(path1, "d", "M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_fragment13(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*editor*/
    ctx[0] && create_if_block6(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*editor*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*editor*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let { editor } = $$props;
  let { statePath } = $$props;
  const toggleFullscreen = () => {
    window.dispatchEvent(new CustomEvent("toggle-fullscreen", { detail: { statePath } }));
    editor.commands.focus();
  };
  const click_handler = () => editor.chain().focus().undo().run();
  const click_handler_1 = () => editor.chain().focus().redo().run();
  const click_handler_2 = () => editor.chain().focus().clearContent(true).run();
  $$self.$$set = ($$props2) => {
    if ("editor" in $$props2)
      $$invalidate(0, editor = $$props2.editor);
    if ("statePath" in $$props2)
      $$invalidate(2, statePath = $$props2.statePath);
  };
  return [
    editor,
    toggleFullscreen,
    statePath,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
var Controls = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance13, create_fragment13, safe_not_equal, { editor: 0, statePath: 2 });
  }
};
var Controls_default = Controls;

// resources/js/components/BubbleMenu.svelte
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function create_if_block7(ctx) {
  let div2;
  let show_if;
  let show_if_1;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_14, create_if_block_4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*isActive*/
    2)
      show_if = null;
    if (dirty & /*isActive*/
    2)
      show_if_1 = null;
    if (show_if == null)
      show_if = !!!/*isActive*/
      ctx2[1]("link");
    if (show_if)
      return 0;
    if (show_if_1 == null)
      show_if_1 = !!/*isActive*/
      ctx2[1]("link");
    if (show_if_1)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      attr(div2, "class", "scribble-bubble-menu");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div2, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_if_block_4(ctx) {
  let span;
  let t0_value = (
    /*editor*/
    (ctx[0].getAttributes("link").title ?? /*editor*/
    ctx[0].getAttributes("link").href) + ""
  );
  let t0;
  let t1;
  let button0;
  let t2;
  let button1;
  let current;
  button0 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[0]
      ),
      key: "editLink",
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*click_handler_1*/
    ctx[5]
  );
  button1 = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[0]
      ),
      key: "unsetLink",
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*click_handler_2*/
    ctx[6]
  );
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      create_component(button0.$$.fragment);
      t2 = space();
      create_component(button1.$$.fragment);
      attr(span, "class", "link-preview");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
      mount_component(button0, target, anchor);
      insert(target, t2, anchor);
      mount_component(button1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*editor*/
      1) && t0_value !== (t0_value = /*editor*/
      (ctx2[0].getAttributes("link").title ?? /*editor*/
      ctx2[0].getAttributes("link").href) + ""))
        set_data(t0, t0_value);
      const button0_changes = {};
      if (dirty & /*editor*/
      1)
        button0_changes.editor = /*editor*/
        ctx2[0];
      if (dirty & /*$$scope*/
      4096) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*editor*/
      1)
        button1_changes.editor = /*editor*/
        ctx2[0];
      if (dirty & /*$$scope*/
      4096) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t1);
        detach(t2);
      }
      destroy_component(button0, detaching);
      destroy_component(button1, detaching);
    }
  };
}
function create_if_block_14(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*tools*/
    ctx[2].length && create_if_block_23(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*tools*/
        ctx2[2].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*tools*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_23(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_default_slot_22(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M6.41421 15.89L16.5563 5.74786L15.1421 4.33365L5 14.4758V15.89H6.41421ZM7.24264 17.89H3V13.6474L14.435 2.21233C14.8256 1.8218 15.4587 1.8218 15.8492 2.21233L18.6777 5.04075C19.0682 5.43128 19.0682 6.06444 18.6777 6.45497L7.24264 17.89ZM3 19.89H21V21.89H3V19.89Z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_default_slot_14(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M17 17H22V19H19V22H17V17ZM7 7H2V5H5V2H7V7ZM18.364 15.5355L16.9497 14.1213L18.364 12.7071C20.3166 10.7545 20.3166 7.58866 18.364 5.63604C16.4113 3.68342 13.2455 3.68342 11.2929 5.63604L9.87868 7.05025L8.46447 5.63604L9.87868 4.22183C12.6123 1.48816 17.0445 1.48816 19.7782 4.22183C22.5118 6.9555 22.5118 11.3877 19.7782 14.1213L18.364 15.5355ZM15.5355 18.364L14.1213 19.7782C11.3877 22.5118 6.9555 22.5118 4.22183 19.7782C1.48816 17.0445 1.48816 12.6123 4.22183 9.87868L5.63604 8.46447L7.05025 9.87868L5.63604 11.2929C3.68342 13.2455 3.68342 16.4113 5.63604 18.364C7.58866 20.3166 10.7545 20.3166 12.7071 18.364L14.1213 16.9497L15.5355 18.364ZM14.8284 7.75736L16.2426 9.17157L9.17157 16.2426L7.75736 14.8284L14.8284 7.75736Z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_23(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*tools*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*tools, editor, isActive, handleToolClick*/
      15) {
        each_value = ensure_array_like(
          /*tools*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block2(ctx) {
  let button;
  let current;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[4](
        /*tool*/
        ctx[9]
      )
    );
  }
  button = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[0]
      ),
      key: (
        /*tool*/
        ctx[9].extension
      ),
      active: (
        /*isActive*/
        ctx[1](
          /*tool*/
          ctx[9].active.extension,
          /*tool*/
          ctx[9].active.attrs
        )
      ),
      hidden: (
        /*tool*/
        ctx[9].isHidden
      ),
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & /*editor*/
      1)
        button_changes.editor = /*editor*/
        ctx[0];
      if (dirty & /*tools*/
      4)
        button_changes.key = /*tool*/
        ctx[9].extension;
      if (dirty & /*isActive, tools*/
      6)
        button_changes.active = /*isActive*/
        ctx[1](
          /*tool*/
          ctx[9].active.extension,
          /*tool*/
          ctx[9].active.attrs
        );
      if (dirty & /*tools*/
      4)
        button_changes.hidden = /*tool*/
        ctx[9].isHidden;
      if (dirty & /*$$scope, tools*/
      4100) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_if_block_32(ctx) {
  let div2;
  return {
    c() {
      div2 = element("div");
      attr(div2, "class", "divider");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_default_slot4(ctx) {
  let html_tag;
  let raw_value = (
    /*tool*/
    ctx[9].icon + ""
  );
  let t;
  return {
    c() {
      html_tag = new HtmlTag(false);
      t = space();
      html_tag.a = t;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*tools*/
      4 && raw_value !== (raw_value = /*tool*/
      ctx2[9].icon + ""))
        html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        html_tag.d();
        detach(t);
      }
    }
  };
}
function create_each_block3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_32, create_else_block2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*tool*/
      ctx2[9].type === "divider"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_fragment14(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*editor*/
    ctx[0] && create_if_block7(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*editor*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*editor*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance14($$self, $$props, $$invalidate) {
  let { editor } = $$props;
  let { isActive: isActive2 } = $$props;
  let { tools } = $$props;
  let { handleToolClick } = $$props;
  let groups = {};
  const getGroups = (array) => {
    let map2 = array.map((e, i) => {
      e.index = i;
      return e;
    });
    groups = map2.reduce(
      function(r2, a) {
        r2[a.group] = r2[a.group] || [];
        r2[a.group].push(a);
        return r2;
      },
      /* @__PURE__ */ Object.create(null)
    );
  };
  const click_handler = (tool) => handleToolClick(tool);
  const click_handler_1 = () => handleToolClick(tools.find((item) => item.extension === "link"), true);
  const click_handler_2 = () => editor.chain().focus().extendMarkRange("link").unsetLink().selectTextblockEnd().run();
  $$self.$$set = ($$props2) => {
    if ("editor" in $$props2)
      $$invalidate(0, editor = $$props2.editor);
    if ("isActive" in $$props2)
      $$invalidate(1, isActive2 = $$props2.isActive);
    if ("tools" in $$props2)
      $$invalidate(2, tools = $$props2.tools);
    if ("handleToolClick" in $$props2)
      $$invalidate(3, handleToolClick = $$props2.handleToolClick);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*tools*/
    4) {
      $:
        getGroups(tools);
    }
  };
  return [
    editor,
    isActive2,
    tools,
    handleToolClick,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
var BubbleMenu2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      editor: 0,
      isActive: 1,
      tools: 2,
      handleToolClick: 3
    });
  }
};
var BubbleMenu_default2 = BubbleMenu2;

// resources/js/components/Toolbar.svelte
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_if_block8(ctx) {
  let div2;
  let current;
  let if_block = (
    /*tools*/
    ctx[2].length && create_if_block_15(ctx)
  );
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      attr(div2, "class", "scribble-toolbar");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block)
        if_block.m(div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*tools*/
        ctx2[2].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*tools*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_15(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_15(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*tools*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*tools, editor, isActive, handleToolClick*/
      15) {
        each_value = ensure_array_like(
          /*tools*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block3(ctx) {
  let button;
  let current;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[4](
        /*tool*/
        ctx[7]
      )
    );
  }
  button = new Button_default({
    props: {
      editor: (
        /*editor*/
        ctx[0]
      ),
      key: (
        /*tool*/
        ctx[7].extension
      ),
      active: (
        /*isActive*/
        ctx[1](
          /*tool*/
          ctx[7].active.extension,
          /*tool*/
          ctx[7].active.attrs
        )
      ),
      hidden: (
        /*tool*/
        ctx[7].isHidden
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & /*editor*/
      1)
        button_changes.editor = /*editor*/
        ctx[0];
      if (dirty & /*tools*/
      4)
        button_changes.key = /*tool*/
        ctx[7].extension;
      if (dirty & /*isActive, tools*/
      6)
        button_changes.active = /*isActive*/
        ctx[1](
          /*tool*/
          ctx[7].active.extension,
          /*tool*/
          ctx[7].active.attrs
        );
      if (dirty & /*tools*/
      4)
        button_changes.hidden = /*tool*/
        ctx[7].isHidden;
      if (dirty & /*$$scope, tools*/
      1028) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_if_block_24(ctx) {
  let div2;
  return {
    c() {
      div2 = element("div");
      attr(div2, "class", "divider");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_default_slot5(ctx) {
  let html_tag;
  let raw_value = (
    /*tool*/
    ctx[7].icon + ""
  );
  let t;
  return {
    c() {
      html_tag = new HtmlTag(false);
      t = space();
      html_tag.a = t;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*tools*/
      4 && raw_value !== (raw_value = /*tool*/
      ctx2[7].icon + ""))
        html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        html_tag.d();
        detach(t);
      }
    }
  };
}
function create_each_block4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_24, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tool*/
      ctx2[7].type === "divider"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_fragment15(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*editor*/
    ctx[0] && /*tools*/
    ctx[2] && /*tools*/
    ctx[2].length > 0 && create_if_block8(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*editor*/
        ctx2[0] && /*tools*/
        ctx2[2] && /*tools*/
        ctx2[2].length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*editor, tools*/
          5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance15($$self, $$props, $$invalidate) {
  let { editor } = $$props;
  let { isActive: isActive2 } = $$props;
  let { tools } = $$props;
  let { handleToolClick } = $$props;
  let groups = {};
  const getGroups = (array) => {
    let map2 = array.map((e, i) => {
      e.index = i;
      return e;
    });
    groups = map2.reduce(
      function(r2, a) {
        r2[a.group] = r2[a.group] || [];
        r2[a.group].push(a);
        return r2;
      },
      /* @__PURE__ */ Object.create(null)
    );
  };
  const click_handler = (tool) => handleToolClick(tool);
  $$self.$$set = ($$props2) => {
    if ("editor" in $$props2)
      $$invalidate(0, editor = $$props2.editor);
    if ("isActive" in $$props2)
      $$invalidate(1, isActive2 = $$props2.isActive);
    if ("tools" in $$props2)
      $$invalidate(2, tools = $$props2.tools);
    if ("handleToolClick" in $$props2)
      $$invalidate(3, handleToolClick = $$props2.handleToolClick);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*tools*/
    4) {
      $:
        getGroups(tools);
    }
  };
  return [editor, isActive2, tools, handleToolClick, click_handler];
}
var Toolbar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance15, create_fragment15, safe_not_equal, {
      editor: 0,
      isActive: 1,
      tools: 2,
      handleToolClick: 3
    });
  }
};
var Toolbar_default = Toolbar;

// node_modules/@tiptap/extension-highlight/dist/index.js
var inputRegex7 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/;
var pasteRegex3 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g;
var Highlight = Mark2.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: false,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    if (!this.options.multicolor) {
      return {};
    }
    return {
      color: {
        default: null,
        parseHTML: (element2) => element2.getAttribute("data-color") || element2.style.backgroundColor,
        renderHTML: (attributes) => {
          if (!attributes.color) {
            return {};
          }
          return {
            "data-color": attributes.color,
            style: `background-color: ${attributes.color}; color: inherit`
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["mark", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHighlight: (attributes) => ({ commands: commands2 }) => {
        return commands2.setMark(this.name, attributes);
      },
      toggleHighlight: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name, attributes);
      },
      unsetHighlight: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex7,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex3,
        type: this.type
      })
    ];
  }
});

// node_modules/linkifyjs/dist/linkify.es.js
var encodedTlds = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5m\xF6gensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
var encodedUtlds = "\u03B5\u03BB1\u03C52\u0431\u04331\u0435\u043B3\u0434\u0435\u0442\u04384\u0435\u044E2\u043A\u0430\u0442\u043E\u043B\u0438\u043A6\u043E\u043C3\u043C\u043A\u04342\u043E\u043D1\u0441\u043A\u0432\u04306\u043E\u043D\u043B\u0430\u0439\u043D5\u0440\u04333\u0440\u0443\u04412\u04442\u0441\u0430\u0439\u04423\u0440\u04313\u0443\u043A\u04403\u049B\u0430\u04373\u0570\u0561\u05753\u05D9\u05E9\u05E8\u05D0\u05DC5\u05E7\u05D5\u05DD3\u0627\u0628\u0648\u0638\u0628\u064A5\u0631\u0627\u0645\u0643\u06485\u0644\u0627\u0631\u062F\u06464\u0628\u062D\u0631\u064A\u06465\u062C\u0632\u0627\u0626\u06315\u0633\u0639\u0648\u062F\u064A\u06296\u0639\u0644\u064A\u0627\u06465\u0645\u063A\u0631\u06285\u0645\u0627\u0631\u0627\u062A5\u06CC\u0631\u0627\u06465\u0628\u0627\u0631\u062A2\u0632\u0627\u06314\u064A\u062A\u06433\u06BE\u0627\u0631\u062A5\u062A\u0648\u0646\u06334\u0633\u0648\u062F\u0627\u06463\u0631\u064A\u06295\u0634\u0628\u0643\u06294\u0639\u0631\u0627\u06422\u06282\u0645\u0627\u06464\u0641\u0644\u0633\u0637\u064A\u06466\u0642\u0637\u06313\u0643\u0627\u062B\u0648\u0644\u064A\u06436\u0648\u06453\u0645\u0635\u06312\u0644\u064A\u0633\u064A\u06275\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u06277\u0642\u06394\u0647\u0645\u0631\u0627\u06475\u067E\u0627\u06A9\u0633\u062A\u0627\u06467\u0680\u0627\u0631\u062A4\u0915\u0949\u092E3\u0928\u0947\u091F3\u092D\u093E\u0930\u09240\u092E\u094D3\u094B\u09245\u0938\u0902\u0917\u0920\u09285\u09AC\u09BE\u0982\u09B2\u09BE5\u09AD\u09BE\u09B0\u09A42\u09F0\u09A44\u0A2D\u0A3E\u0A30\u0A244\u0AAD\u0ABE\u0AB0\u0AA44\u0B2D\u0B3E\u0B30\u0B244\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE6\u0BB2\u0B99\u0BCD\u0B95\u0BC86\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD11\u0C2D\u0C3E\u0C30\u0C24\u0C4D5\u0CAD\u0CBE\u0CB0\u0CA44\u0D2D\u0D3E\u0D30\u0D24\u0D025\u0DBD\u0D82\u0D9A\u0DCF4\u0E04\u0E2D\u0E213\u0E44\u0E17\u0E223\u0EA5\u0EB2\u0EA73\u10D2\u10D42\u307F\u3093\u306A3\u30A2\u30DE\u30BE\u30F34\u30AF\u30E9\u30A6\u30C94\u30B0\u30FC\u30B0\u30EB4\u30B3\u30E02\u30B9\u30C8\u30A23\u30BB\u30FC\u30EB3\u30D5\u30A1\u30C3\u30B7\u30E7\u30F36\u30DD\u30A4\u30F3\u30C84\u4E16\u754C2\u4E2D\u4FE11\u56FD1\u570B1\u6587\u7F513\u4E9A\u9A6C\u900A3\u4F01\u4E1A2\u4F5B\u5C712\u4FE1\u606F2\u5065\u5EB72\u516B\u53662\u516C\u53F81\u76CA2\u53F0\u6E7E1\u70632\u5546\u57CE1\u5E971\u68072\u5609\u91CC0\u5927\u9152\u5E975\u5728\u7EBF2\u5927\u62FF2\u5929\u4E3B\u65593\u5A31\u4E502\u5BB6\u96FB2\u5E7F\u4E1C2\u5FAE\u535A2\u6148\u55842\u6211\u7231\u4F603\u624B\u673A2\u62DB\u80582\u653F\u52A11\u5E9C2\u65B0\u52A0\u57612\u95FB2\u65F6\u5C1A2\u66F8\u7C4D2\u673A\u67842\u6DE1\u9A6C\u95213\u6E38\u620F2\u6FB3\u95802\u70B9\u770B2\u79FB\u52A82\u7EC4\u7EC7\u673A\u67844\u7F51\u57401\u5E971\u7AD91\u7EDC2\u8054\u901A2\u8C37\u6B4C2\u8D2D\u72692\u901A\u8CA92\u96C6\u56E22\u96FB\u8A0A\u76C8\u79D14\u98DE\u5229\u6D663\u98DF\u54C12\u9910\u53852\u9999\u683C\u91CC\u62C93\u6E2F2\uB2F7\uB1371\uCEF42\uC0BC\uC1312\uD55C\uAD6D2";
var assign2 = (target, properties) => {
  for (const key in properties) {
    target[key] = properties[key];
  }
  return target;
};
var numeric = "numeric";
var ascii = "ascii";
var alpha = "alpha";
var asciinumeric = "asciinumeric";
var alphanumeric = "alphanumeric";
var domain = "domain";
var emoji = "emoji";
var scheme = "scheme";
var slashscheme = "slashscheme";
var whitespace = "whitespace";
function registerGroup(name, groups) {
  if (!(name in groups)) {
    groups[name] = [];
  }
  return groups[name];
}
function addToGroups(t, flags, groups) {
  if (flags[numeric]) {
    flags[asciinumeric] = true;
    flags[alphanumeric] = true;
  }
  if (flags[ascii]) {
    flags[asciinumeric] = true;
    flags[alpha] = true;
  }
  if (flags[asciinumeric]) {
    flags[alphanumeric] = true;
  }
  if (flags[alpha]) {
    flags[alphanumeric] = true;
  }
  if (flags[alphanumeric]) {
    flags[domain] = true;
  }
  if (flags[emoji]) {
    flags[domain] = true;
  }
  for (const k in flags) {
    const group = registerGroup(k, groups);
    if (group.indexOf(t) < 0) {
      group.push(t);
    }
  }
}
function flagsForToken(t, groups) {
  const result = {};
  for (const c in groups) {
    if (groups[c].indexOf(t) >= 0) {
      result[c] = true;
    }
  }
  return result;
}
function State(token) {
  if (token === void 0) {
    token = null;
  }
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token;
}
State.groups = {};
State.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(input) {
    const state = this;
    const nextState = state.j[input];
    if (nextState) {
      return nextState;
    }
    for (let i = 0; i < state.jr.length; i++) {
      const regex = state.jr[i][0];
      const nextState2 = state.jr[i][1];
      if (nextState2 && regex.test(input)) {
        return nextState2;
      }
    }
    return state.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(input, exactOnly) {
    if (exactOnly === void 0) {
      exactOnly = false;
    }
    return exactOnly ? input in this.j : !!this.go(input);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(inputs, next, flags, groups) {
    for (let i = 0; i < inputs.length; i++) {
      this.tt(inputs[i], next, flags, groups);
    }
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(regexp, next, flags, groups) {
    groups = groups || State.groups;
    let nextState;
    if (next && next.j) {
      nextState = next;
    } else {
      nextState = new State(next);
      if (flags && groups) {
        addToGroups(next, flags, groups);
      }
    }
    this.jr.push([regexp, nextState]);
    return nextState;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(input, next, flags, groups) {
    let state = this;
    const len = input.length;
    if (!len) {
      return state;
    }
    for (let i = 0; i < len - 1; i++) {
      state = state.tt(input[i]);
    }
    return state.tt(input[len - 1], next, flags, groups);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(input, next, flags, groups) {
    groups = groups || State.groups;
    const state = this;
    if (next && next.j) {
      state.j[input] = next;
      return next;
    }
    const t = next;
    let nextState, templateState = state.go(input);
    if (templateState) {
      nextState = new State();
      assign2(nextState.j, templateState.j);
      nextState.jr.push.apply(nextState.jr, templateState.jr);
      nextState.jd = templateState.jd;
      nextState.t = templateState.t;
    } else {
      nextState = new State();
    }
    if (t) {
      if (groups) {
        if (nextState.t && typeof nextState.t === "string") {
          const allFlags = assign2(flagsForToken(nextState.t, groups), flags);
          addToGroups(t, allFlags, groups);
        } else if (flags) {
          addToGroups(t, flags, groups);
        }
      }
      nextState.t = t;
    }
    state.j[input] = nextState;
    return nextState;
  }
};
var ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);
var tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);
var ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);
var tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);
var WORD = "WORD";
var UWORD = "UWORD";
var LOCALHOST = "LOCALHOST";
var TLD = "TLD";
var UTLD = "UTLD";
var SCHEME = "SCHEME";
var SLASH_SCHEME = "SLASH_SCHEME";
var NUM = "NUM";
var WS = "WS";
var NL$1 = "NL";
var OPENBRACE = "OPENBRACE";
var CLOSEBRACE = "CLOSEBRACE";
var OPENBRACKET = "OPENBRACKET";
var CLOSEBRACKET = "CLOSEBRACKET";
var OPENPAREN = "OPENPAREN";
var CLOSEPAREN = "CLOSEPAREN";
var OPENANGLEBRACKET = "OPENANGLEBRACKET";
var CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
var FULLWIDTHLEFTPAREN = "FULLWIDTHLEFTPAREN";
var FULLWIDTHRIGHTPAREN = "FULLWIDTHRIGHTPAREN";
var LEFTCORNERBRACKET = "LEFTCORNERBRACKET";
var RIGHTCORNERBRACKET = "RIGHTCORNERBRACKET";
var LEFTWHITECORNERBRACKET = "LEFTWHITECORNERBRACKET";
var RIGHTWHITECORNERBRACKET = "RIGHTWHITECORNERBRACKET";
var FULLWIDTHLESSTHAN = "FULLWIDTHLESSTHAN";
var FULLWIDTHGREATERTHAN = "FULLWIDTHGREATERTHAN";
var AMPERSAND = "AMPERSAND";
var APOSTROPHE = "APOSTROPHE";
var ASTERISK = "ASTERISK";
var AT = "AT";
var BACKSLASH = "BACKSLASH";
var BACKTICK = "BACKTICK";
var CARET = "CARET";
var COLON = "COLON";
var COMMA = "COMMA";
var DOLLAR = "DOLLAR";
var DOT = "DOT";
var EQUALS = "EQUALS";
var EXCLAMATION = "EXCLAMATION";
var HYPHEN = "HYPHEN";
var PERCENT = "PERCENT";
var PIPE = "PIPE";
var PLUS = "PLUS";
var POUND = "POUND";
var QUERY = "QUERY";
var QUOTE = "QUOTE";
var SEMI = "SEMI";
var SLASH = "SLASH";
var TILDE = "TILDE";
var UNDERSCORE = "UNDERSCORE";
var EMOJI$1 = "EMOJI";
var SYM = "SYM";
var tk = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WORD,
  UWORD,
  LOCALHOST,
  TLD,
  UTLD,
  SCHEME,
  SLASH_SCHEME,
  NUM,
  WS,
  NL: NL$1,
  OPENBRACE,
  CLOSEBRACE,
  OPENBRACKET,
  CLOSEBRACKET,
  OPENPAREN,
  CLOSEPAREN,
  OPENANGLEBRACKET,
  CLOSEANGLEBRACKET,
  FULLWIDTHLEFTPAREN,
  FULLWIDTHRIGHTPAREN,
  LEFTCORNERBRACKET,
  RIGHTCORNERBRACKET,
  LEFTWHITECORNERBRACKET,
  RIGHTWHITECORNERBRACKET,
  FULLWIDTHLESSTHAN,
  FULLWIDTHGREATERTHAN,
  AMPERSAND,
  APOSTROPHE,
  ASTERISK,
  AT,
  BACKSLASH,
  BACKTICK,
  CARET,
  COLON,
  COMMA,
  DOLLAR,
  DOT,
  EQUALS,
  EXCLAMATION,
  HYPHEN,
  PERCENT,
  PIPE,
  PLUS,
  POUND,
  QUERY,
  QUOTE,
  SEMI,
  SLASH,
  TILDE,
  UNDERSCORE,
  EMOJI: EMOJI$1,
  SYM
});
var ASCII_LETTER = /[a-z]/;
var LETTER = /\p{L}/u;
var EMOJI = /\p{Emoji}/u;
var DIGIT = /\d/;
var SPACE = /\s/;
var NL = "\n";
var EMOJI_VARIATION = "\uFE0F";
var EMOJI_JOINER = "\u200D";
var tlds = null;
var utlds = null;
function init$2(customSchemes) {
  if (customSchemes === void 0) {
    customSchemes = [];
  }
  const groups = {};
  State.groups = groups;
  const Start = new State();
  if (tlds == null) {
    tlds = decodeTlds(encodedTlds);
  }
  if (utlds == null) {
    utlds = decodeTlds(encodedUtlds);
  }
  tt(Start, "'", APOSTROPHE);
  tt(Start, "{", OPENBRACE);
  tt(Start, "}", CLOSEBRACE);
  tt(Start, "[", OPENBRACKET);
  tt(Start, "]", CLOSEBRACKET);
  tt(Start, "(", OPENPAREN);
  tt(Start, ")", CLOSEPAREN);
  tt(Start, "<", OPENANGLEBRACKET);
  tt(Start, ">", CLOSEANGLEBRACKET);
  tt(Start, "\uFF08", FULLWIDTHLEFTPAREN);
  tt(Start, "\uFF09", FULLWIDTHRIGHTPAREN);
  tt(Start, "\u300C", LEFTCORNERBRACKET);
  tt(Start, "\u300D", RIGHTCORNERBRACKET);
  tt(Start, "\u300E", LEFTWHITECORNERBRACKET);
  tt(Start, "\u300F", RIGHTWHITECORNERBRACKET);
  tt(Start, "\uFF1C", FULLWIDTHLESSTHAN);
  tt(Start, "\uFF1E", FULLWIDTHGREATERTHAN);
  tt(Start, "&", AMPERSAND);
  tt(Start, "*", ASTERISK);
  tt(Start, "@", AT);
  tt(Start, "`", BACKTICK);
  tt(Start, "^", CARET);
  tt(Start, ":", COLON);
  tt(Start, ",", COMMA);
  tt(Start, "$", DOLLAR);
  tt(Start, ".", DOT);
  tt(Start, "=", EQUALS);
  tt(Start, "!", EXCLAMATION);
  tt(Start, "-", HYPHEN);
  tt(Start, "%", PERCENT);
  tt(Start, "|", PIPE);
  tt(Start, "+", PLUS);
  tt(Start, "#", POUND);
  tt(Start, "?", QUERY);
  tt(Start, '"', QUOTE);
  tt(Start, "/", SLASH);
  tt(Start, ";", SEMI);
  tt(Start, "~", TILDE);
  tt(Start, "_", UNDERSCORE);
  tt(Start, "\\", BACKSLASH);
  const Num = tr(Start, DIGIT, NUM, {
    [numeric]: true
  });
  tr(Num, DIGIT, Num);
  const Word = tr(Start, ASCII_LETTER, WORD, {
    [ascii]: true
  });
  tr(Word, ASCII_LETTER, Word);
  const UWord = tr(Start, LETTER, UWORD, {
    [alpha]: true
  });
  tr(UWord, ASCII_LETTER);
  tr(UWord, LETTER, UWord);
  const Ws = tr(Start, SPACE, WS, {
    [whitespace]: true
  });
  tt(Start, NL, NL$1, {
    [whitespace]: true
  });
  tt(Ws, NL);
  tr(Ws, SPACE, Ws);
  const Emoji = tr(Start, EMOJI, EMOJI$1, {
    [emoji]: true
  });
  tr(Emoji, EMOJI, Emoji);
  tt(Emoji, EMOJI_VARIATION, Emoji);
  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);
  tr(EmojiJoiner, EMOJI, Emoji);
  const wordjr = [[ASCII_LETTER, Word]];
  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];
  for (let i = 0; i < tlds.length; i++) {
    fastts(Start, tlds[i], TLD, WORD, wordjr);
  }
  for (let i = 0; i < utlds.length; i++) {
    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);
  }
  addToGroups(TLD, {
    tld: true,
    ascii: true
  }, groups);
  addToGroups(UTLD, {
    utld: true,
    alpha: true
  }, groups);
  fastts(Start, "file", SCHEME, WORD, wordjr);
  fastts(Start, "mailto", SCHEME, WORD, wordjr);
  fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
  addToGroups(SCHEME, {
    scheme: true,
    ascii: true
  }, groups);
  addToGroups(SLASH_SCHEME, {
    slashscheme: true,
    ascii: true
  }, groups);
  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);
  for (let i = 0; i < customSchemes.length; i++) {
    const sch = customSchemes[i][0];
    const optionalSlashSlash = customSchemes[i][1];
    const flags = optionalSlashSlash ? {
      [scheme]: true
    } : {
      [slashscheme]: true
    };
    if (sch.indexOf("-") >= 0) {
      flags[domain] = true;
    } else if (!ASCII_LETTER.test(sch)) {
      flags[numeric] = true;
    } else if (DIGIT.test(sch)) {
      flags[asciinumeric] = true;
    } else {
      flags[ascii] = true;
    }
    ts(Start, sch, sch, flags);
  }
  ts(Start, "localhost", LOCALHOST, {
    ascii: true
  });
  Start.jd = new State(SYM);
  return {
    start: Start,
    tokens: assign2({
      groups
    }, tk)
  };
}
function run$12(start2, str) {
  const iterable = stringToArray(str.replace(/[A-Z]/g, (c) => c.toLowerCase()));
  const charCount = iterable.length;
  const tokens = [];
  let cursor = 0;
  let charCursor = 0;
  while (charCursor < charCount) {
    let state = start2;
    let nextState = null;
    let tokenLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    let charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      // token type/name
      v: str.slice(cursor - tokenLength, cursor),
      // string value
      s: cursor - tokenLength,
      // start index
      e: cursor
      // end index (excluding)
    });
  }
  return tokens;
}
function stringToArray(str) {
  const result = [];
  const len = str.length;
  let index = 0;
  while (index < len) {
    let first2 = str.charCodeAt(index);
    let second;
    let char = first2 < 55296 || first2 > 56319 || index + 1 === len || (second = str.charCodeAt(index + 1)) < 56320 || second > 57343 ? str[index] : str.slice(index, index + 2);
    result.push(char);
    index += char.length;
  }
  return result;
}
function fastts(state, input, t, defaultt, jr) {
  let next;
  const len = input.length;
  for (let i = 0; i < len - 1; i++) {
    const char = input[i];
    if (state.j[char]) {
      next = state.j[char];
    } else {
      next = new State(defaultt);
      next.jr = jr.slice();
      state.j[char] = next;
    }
    state = next;
  }
  next = new State(t);
  next.jr = jr.slice();
  state.j[input[len - 1]] = next;
  return next;
}
function decodeTlds(encoded) {
  const words = [];
  const stack = [];
  let i = 0;
  let digits = "0123456789";
  while (i < encoded.length) {
    let popDigitCount = 0;
    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {
      popDigitCount++;
    }
    if (popDigitCount > 0) {
      words.push(stack.join(""));
      for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {
        stack.pop();
      }
      i += popDigitCount;
    } else {
      stack.push(encoded[i]);
      i++;
    }
  }
  return words;
}
var defaults = {
  defaultProtocol: "http",
  events: null,
  format: noop2,
  formatHref: noop2,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: Infinity,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Options(opts, defaultRender) {
  if (defaultRender === void 0) {
    defaultRender = null;
  }
  let o = assign2({}, defaults);
  if (opts) {
    o = assign2(o, opts instanceof Options ? opts.o : opts);
  }
  const ignoredTags = o.ignoreTags;
  const uppercaseIgnoredTags = [];
  for (let i = 0; i < ignoredTags.length; i++) {
    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());
  }
  this.o = o;
  if (defaultRender) {
    this.defaultRender = defaultRender;
  }
  this.ignoreTags = uppercaseIgnoredTags;
}
Options.prototype = {
  o: defaults,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(ir) {
    return ir;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(token) {
    return this.get("validate", token.toString(), token);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(key, operator, token) {
    const isCallable = operator != null;
    let option = this.o[key];
    if (!option) {
      return option;
    }
    if (typeof option === "object") {
      option = token.t in option ? option[token.t] : defaults[key];
      if (typeof option === "function" && isCallable) {
        option = option(operator, token);
      }
    } else if (typeof option === "function" && isCallable) {
      option = option(operator, token.t, token);
    }
    return option;
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(key, operator, token) {
    let obj = this.o[key];
    if (typeof obj === "function" && operator != null) {
      obj = obj(operator, token.t, token);
    }
    return obj;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(token) {
    const ir = token.render(this);
    const renderFn = this.get("render", null, token) || this.defaultRender;
    return renderFn(ir, token.t, token);
  }
};
function noop2(val) {
  return val;
}
function MultiToken(value, tokens) {
  this.t = "token";
  this.v = value;
  this.tk = tokens;
}
MultiToken.prototype = {
  isLink: false,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
  */
  toHref(scheme2) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(options) {
    const val = this.toString();
    const truncate = options.get("truncate", val, this);
    const formatted = options.get("format", val, this);
    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "\u2026" : formatted;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(options) {
    return options.get("formatHref", this.toHref(options.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(protocol) {
    if (protocol === void 0) {
      protocol = defaults.defaultProtocol;
    }
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(options) {
    return {
      type: this.t,
      value: this.toFormattedString(options),
      isLink: this.isLink,
      href: this.toFormattedHref(options),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(options) {
    return options.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(options) {
    const token = this;
    const href = this.toHref(options.get("defaultProtocol"));
    const formattedHref = options.get("formatHref", href, this);
    const tagName = options.get("tagName", href, token);
    const content = this.toFormattedString(options);
    const attributes = {};
    const className = options.get("className", href, token);
    const target = options.get("target", href, token);
    const rel = options.get("rel", href, token);
    const attrs = options.getObj("attributes", href, token);
    const eventListeners = options.getObj("events", href, token);
    attributes.href = formattedHref;
    if (className) {
      attributes.class = className;
    }
    if (target) {
      attributes.target = target;
    }
    if (rel) {
      attributes.rel = rel;
    }
    if (attrs) {
      assign2(attributes, attrs);
    }
    return {
      tagName,
      attributes,
      content,
      eventListeners
    };
  }
};
function createTokenClass(type, props) {
  class Token extends MultiToken {
    constructor(value, tokens) {
      super(value, tokens);
      this.t = type;
    }
  }
  for (const p in props) {
    Token.prototype[p] = props[p];
  }
  Token.t = type;
  return Token;
}
var Email = createTokenClass("email", {
  isLink: true,
  toHref() {
    return "mailto:" + this.toString();
  }
});
var Text2 = createTokenClass("text");
var Nl = createTokenClass("nl");
var Url = createTokenClass("url", {
  isLink: true,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(scheme2) {
    if (scheme2 === void 0) {
      scheme2 = defaults.defaultProtocol;
    }
    return this.hasProtocol() ? this.v : `${scheme2}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const tokens = this.tk;
    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
  }
});
var makeState = (arg) => new State(arg);
function init$1(_ref) {
  let {
    groups
  } = _ref;
  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
  const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];
  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
  const Start = makeState();
  const Localpart = tt(Start, TILDE);
  ta(Localpart, localpartAccepting, Localpart);
  ta(Localpart, groups.domain, Localpart);
  const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
  ta(Start, groups.domain, Domain);
  ta(Start, groups.scheme, Scheme);
  ta(Start, groups.slashscheme, SlashScheme);
  ta(Domain, localpartAccepting, Localpart);
  ta(Domain, groups.domain, Domain);
  const LocalpartAt = tt(Domain, AT);
  tt(Localpart, AT, LocalpartAt);
  tt(Scheme, AT, LocalpartAt);
  tt(SlashScheme, AT, LocalpartAt);
  const LocalpartDot = tt(Localpart, DOT);
  ta(LocalpartDot, localpartAccepting, Localpart);
  ta(LocalpartDot, groups.domain, Localpart);
  const EmailDomain = makeState();
  ta(LocalpartAt, groups.domain, EmailDomain);
  ta(EmailDomain, groups.domain, EmailDomain);
  const EmailDomainDot = tt(EmailDomain, DOT);
  ta(EmailDomainDot, groups.domain, EmailDomain);
  const Email$1 = makeState(Email);
  ta(EmailDomainDot, groups.tld, Email$1);
  ta(EmailDomainDot, groups.utld, Email$1);
  tt(LocalpartAt, LOCALHOST, Email$1);
  const EmailDomainHyphen = tt(EmailDomain, HYPHEN);
  ta(EmailDomainHyphen, groups.domain, EmailDomain);
  ta(Email$1, groups.domain, EmailDomain);
  tt(Email$1, DOT, EmailDomainDot);
  tt(Email$1, HYPHEN, EmailDomainHyphen);
  const EmailColon = tt(Email$1, COLON);
  ta(EmailColon, groups.numeric, Email);
  const DomainHyphen = tt(Domain, HYPHEN);
  const DomainDot = tt(Domain, DOT);
  ta(DomainHyphen, groups.domain, Domain);
  ta(DomainDot, localpartAccepting, Localpart);
  ta(DomainDot, groups.domain, Domain);
  const DomainDotTld = makeState(Url);
  ta(DomainDot, groups.tld, DomainDotTld);
  ta(DomainDot, groups.utld, DomainDotTld);
  ta(DomainDotTld, groups.domain, Domain);
  ta(DomainDotTld, localpartAccepting, Localpart);
  tt(DomainDotTld, DOT, DomainDot);
  tt(DomainDotTld, HYPHEN, DomainHyphen);
  tt(DomainDotTld, AT, LocalpartAt);
  const DomainDotTldColon = tt(DomainDotTld, COLON);
  const DomainDotTldColonPort = makeState(Url);
  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
  const Url$1 = makeState(Url);
  const UrlNonaccept = makeState();
  ta(Url$1, qsAccepting, Url$1);
  ta(Url$1, qsNonAccepting, UrlNonaccept);
  ta(UrlNonaccept, qsAccepting, Url$1);
  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);
  tt(DomainDotTld, SLASH, Url$1);
  tt(DomainDotTldColonPort, SLASH, Url$1);
  const SchemeColon = tt(Scheme, COLON);
  const SlashSchemeColon = tt(SlashScheme, COLON);
  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH);
  const UriPrefix = tt(SlashSchemeColonSlash, SLASH);
  ta(Scheme, groups.domain, Domain);
  tt(Scheme, DOT, DomainDot);
  tt(Scheme, HYPHEN, DomainHyphen);
  ta(SlashScheme, groups.domain, Domain);
  tt(SlashScheme, DOT, DomainDot);
  tt(SlashScheme, HYPHEN, DomainHyphen);
  ta(SchemeColon, groups.domain, Url$1);
  tt(SchemeColon, SLASH, Url$1);
  ta(UriPrefix, groups.domain, Url$1);
  ta(UriPrefix, qsAccepting, Url$1);
  tt(UriPrefix, SLASH, Url$1);
  const bracketPairs = [
    [OPENBRACE, CLOSEBRACE],
    // {}
    [OPENBRACKET, CLOSEBRACKET],
    // []
    [OPENPAREN, CLOSEPAREN],
    // ()
    [OPENANGLEBRACKET, CLOSEANGLEBRACKET],
    // <>
    [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],
    // （）
    [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],
    // 「」
    [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],
    // 『』
    [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN]
    // ＜＞
  ];
  for (let i = 0; i < bracketPairs.length; i++) {
    const [OPEN, CLOSE] = bracketPairs[i];
    const UrlOpen = tt(Url$1, OPEN);
    tt(UrlNonaccept, OPEN, UrlOpen);
    tt(UrlOpen, CLOSE, Url$1);
    const UrlOpenQ = makeState(Url);
    ta(UrlOpen, qsAccepting, UrlOpenQ);
    const UrlOpenSyms = makeState();
    ta(UrlOpen, qsNonAccepting);
    ta(UrlOpenQ, qsAccepting, UrlOpenQ);
    ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);
    ta(UrlOpenSyms, qsAccepting, UrlOpenQ);
    ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);
    tt(UrlOpenQ, CLOSE, Url$1);
    tt(UrlOpenSyms, CLOSE, Url$1);
  }
  tt(Start, LOCALHOST, DomainDotTld);
  tt(Start, NL$1, Nl);
  return {
    start: Start,
    tokens: tk
  };
}
function run3(start2, input, tokens) {
  let len = tokens.length;
  let cursor = 0;
  let multis = [];
  let textTokens = [];
  while (cursor < len) {
    let state = start2;
    let secondState = null;
    let nextState = null;
    let multiLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      cursor -= multiLength;
      if (cursor < len) {
        textTokens.push(tokens[cursor]);
        cursor++;
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(initMultiToken(Text2, input, textTokens));
        textTokens = [];
      }
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;
      const Multi = latestAccepting.t;
      const subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(initMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(initMultiToken(Text2, input, textTokens));
  }
  return multis;
}
function initMultiToken(Multi, input, tokens) {
  const startIdx = tokens[0].s;
  const endIdx = tokens[tokens.length - 1].e;
  const value = input.slice(startIdx, endIdx);
  return new Multi(value, tokens);
}
var warn = typeof console !== "undefined" && console && console.warn || (() => {
});
var warnAdvice = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
var INIT = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: false
};
function reset() {
  State.groups = {};
  INIT.scanner = null;
  INIT.parser = null;
  INIT.tokenQueue = [];
  INIT.pluginQueue = [];
  INIT.customSchemes = [];
  INIT.initialized = false;
}
function registerCustomProtocol(scheme2, optionalSlashSlash) {
  if (optionalSlashSlash === void 0) {
    optionalSlashSlash = false;
  }
  if (INIT.initialized) {
    warn(`linkifyjs: already initialized - will not register custom scheme "${scheme2}" ${warnAdvice}`);
  }
  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme2)) {
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  }
  INIT.customSchemes.push([scheme2, optionalSlashSlash]);
}
function init2() {
  INIT.scanner = init$2(INIT.customSchemes);
  for (let i = 0; i < INIT.tokenQueue.length; i++) {
    INIT.tokenQueue[i][1]({
      scanner: INIT.scanner
    });
  }
  INIT.parser = init$1(INIT.scanner.tokens);
  for (let i = 0; i < INIT.pluginQueue.length; i++) {
    INIT.pluginQueue[i][1]({
      scanner: INIT.scanner,
      parser: INIT.parser
    });
  }
  INIT.initialized = true;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init2();
  }
  return run3(INIT.parser.start, str, run$12(INIT.scanner.start, str));
}
function find(str, type, opts) {
  if (type === void 0) {
    type = null;
  }
  if (opts === void 0) {
    opts = null;
  }
  if (type && typeof type === "object") {
    if (opts) {
      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);
    }
    opts = type;
    type = null;
  }
  const options = new Options(opts);
  const tokens = tokenize(str);
  const filtered = [];
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (token.isLink && (!type || token.t === type) && options.check(token)) {
      filtered.push(token.toFormattedObject(options));
    }
  }
  return filtered;
}

// node_modules/@tiptap/extension-link/dist/index.js
function autolink(options) {
  return new Plugin({
    key: new PluginKey("autolink"),
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
      const preventAutolink = transactions.some((transaction) => transaction.getMeta("preventAutolink"));
      if (!docChanges || preventAutolink) {
        return;
      }
      const { tr: tr2 } = newState;
      const transform = combineTransactionSteps(oldState.doc, [...transactions]);
      const changes = getChangedRanges(transform);
      changes.forEach(({ newRange }) => {
        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, (node) => node.isTextblock);
        let textBlock;
        let textBeforeWhitespace;
        if (nodesInChangedRanges.length > 1) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, " ");
        } else if (nodesInChangedRanges.length && newState.doc.textBetween(newRange.from, newRange.to, " ", " ").endsWith(" ")) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
        }
        if (textBlock && textBeforeWhitespace) {
          const wordsBeforeWhitespace = textBeforeWhitespace.split(" ").filter((s) => s !== "");
          if (wordsBeforeWhitespace.length <= 0) {
            return false;
          }
          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
          if (!lastWordBeforeSpace) {
            return false;
          }
          find(lastWordBeforeSpace).filter((link) => link.isLink).map((link) => ({
            ...link,
            from: lastWordAndBlockOffset + link.start + 1,
            to: lastWordAndBlockOffset + link.end + 1
          })).filter((link) => {
            if (!newState.schema.marks.code) {
              return true;
            }
            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);
          }).filter((link) => {
            if (options.validate) {
              return options.validate(link.value);
            }
            return true;
          }).forEach((link) => {
            if (getMarksBetween(link.from, link.to, newState.doc).some((item) => item.mark.type === options.type)) {
              return;
            }
            tr2.addMark(link.from, link.to, options.type.create({
              href: link.href
            }));
          });
        }
      });
      if (!tr2.steps.length) {
        return;
      }
      return tr2;
    }
  });
}
function clickHandler(options) {
  return new Plugin({
    key: new PluginKey("handleClickLink"),
    props: {
      handleClick: (view, pos, event) => {
        var _a, _b;
        if (event.button !== 0) {
          return false;
        }
        let a = event.target;
        const els = [];
        while (a.nodeName !== "DIV") {
          els.push(a);
          a = a.parentNode;
        }
        if (!els.find((value) => value.nodeName === "A")) {
          return false;
        }
        const attrs = getAttributes(view.state, options.type.name);
        const link = event.target;
        const href = (_a = link === null || link === void 0 ? void 0 : link.href) !== null && _a !== void 0 ? _a : attrs.href;
        const target = (_b = link === null || link === void 0 ? void 0 : link.target) !== null && _b !== void 0 ? _b : attrs.target;
        if (link && href) {
          window.open(href, target);
          return true;
        }
        return false;
      }
    }
  });
}
function pasteHandler(options) {
  return new Plugin({
    key: new PluginKey("handlePasteLink"),
    props: {
      handlePaste: (view, event, slice2) => {
        const { state } = view;
        const { selection } = state;
        const { empty: empty3 } = selection;
        if (empty3) {
          return false;
        }
        let textContent = "";
        slice2.content.forEach((node) => {
          textContent += node.textContent;
        });
        const link = find(textContent).find((item) => item.isLink && item.value === textContent);
        if (!textContent || !link) {
          return false;
        }
        options.editor.commands.setMark(options.type, {
          href: link.href
        });
        return true;
      }
    }
  });
}
var Link = Mark2.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  onCreate() {
    this.options.protocols.forEach((protocol) => {
      if (typeof protocol === "string") {
        registerCustomProtocol(protocol);
        return;
      }
      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);
    });
  },
  onDestroy() {
    reset();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: true,
      linkOnPaste: true,
      autolink: true,
      protocols: [],
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      validate: void 0
    };
  },
  addAttributes() {
    return {
      href: {
        default: null
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [{ tag: 'a[href]:not([href *= "javascript:" i])' }];
  },
  renderHTML({ HTMLAttributes }) {
    var _a;
    if ((_a = HTMLAttributes.href) === null || _a === void 0 ? void 0 : _a.startsWith("javascript:")) {
      return ["a", mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: "" }), 0];
    }
    return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setLink: (attributes) => ({ chain }) => {
        return chain().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
      },
      toggleLink: (attributes) => ({ chain }) => {
        return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      },
      unsetLink: () => ({ chain }) => {
        return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      }
    };
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: (text2, event) => {
          var _a;
          const html = (_a = event === null || event === void 0 ? void 0 : event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
          const foundLinks = [];
          if (html) {
            const dom = new DOMParser().parseFromString(html, "text/html");
            const anchors = dom.querySelectorAll("a");
            if (anchors.length) {
              [...anchors].forEach((anchor) => foundLinks.push({
                text: anchor.innerText,
                data: {
                  href: anchor.getAttribute("href")
                },
                // get the index of the anchor inside the text
                // and add the length of the anchor text
                index: dom.body.innerText.indexOf(anchor.innerText) + anchor.innerText.length
              }));
            }
          }
          if (text2) {
            const links = find(text2).filter((item) => item.isLink);
            if (links.length) {
              links.forEach((link) => foundLinks.push({
                text: link.value,
                data: {
                  href: link.href
                },
                index: link.start
              }));
            }
          }
          return foundLinks;
        },
        type: this.type,
        getAttributes: (match) => {
          var _a;
          return {
            href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const plugins = [];
    if (this.options.autolink) {
      plugins.push(autolink({
        type: this.type,
        validate: this.options.validate
      }));
    }
    if (this.options.openOnClick) {
      plugins.push(clickHandler({
        type: this.type
      }));
    }
    if (this.options.linkOnPaste) {
      plugins.push(pasteHandler({
        editor: this.editor,
        type: this.type
      }));
    }
    return plugins;
  }
});

// resources/js/extensions/LinkCustom.js
var LinkCustom_default = Link.extend({
  inclusive: false,
  addOptions() {
    return {
      openOnClick: false,
      linkOnPaste: true,
      autolink: false,
      protocols: [],
      HTMLAttributes: {},
      validate: void 0
    };
  },
  addAttributes() {
    return {
      href: {
        default: null
      },
      model_id: {
        default: null
      },
      model_type: {
        default: null
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      title: {
        default: null
      },
      rel: {
        default: null
      }
    };
  }
});

// resources/js/extensions/Embed.js
var Embed_default = Extension.create({
  name: "Embed"
  //   addPasteRules() {
  //     return [
  //       {
  //         find: /^(https?:\/\/)?(www\.youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]+)$/g,
  //         handler: ({ match, commands }) => {
  //           const url = match[0];
  //           const options = {
  //             identifier: 'embed',
  //             values: {
  //                 embed: url
  //              },
  //           };
  //           commands.insertScribbleBlock(options);
  //         }
  //       },
  //     ];
  //   }
});

// resources/js/extensions/oEmbedExtension.js
var oEmbedExtension_default = Extension.create({
  name: "oEmbedExtension",
  addCommands() {
    return {
      setOembedContent: (options) => ({ commands: commands2 }) => {
        return commands2.insertContent(`<div class="oembed">${options.html}</div>`);
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("handlePaste"),
        props: {
          handlePaste(view, event) {
            const text2 = event.clipboardData.getData("text/plain");
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            const match = urlRegex.exec(text2);
            if (match) {
              event.preventDefault();
              const url = match[0];
              const handler = async () => {
                try {
                  const response = await fetch("/oembed-check", {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                      "X-CSRF-TOKEN": document.querySelector('meta[name="csrf-token"]').getAttribute("content")
                    },
                    body: JSON.stringify({ url })
                  });
                  const data = await response.json();
                  if (data.isValid) {
                    view.dispatch(view.state.tr.replaceSelectionWith(
                      view.state.schema.nodes.scribbleBlock.createAndFill({ identifier: "embed", values: { url } })
                      // Assumendo che "oEmbed" sia il tipo di nodo definito nel tuo schema
                    ));
                    console.log("Block inserted successfully with fetch data");
                  } else {
                    console.log("URL non \xE8 un embed");
                  }
                } catch (error) {
                  console.error("Fetch error:", error);
                }
              };
              handler();
              return true;
            }
            return false;
          }
        }
      })
    ];
  }
});

// resources/js/components/oEmbedView.svelte
function create_default_slot_15(ctx) {
  let draghandle;
  let current;
  draghandle = new DragHandle_default({
    props: {
      handleMenuOpen: (
        /*handleMenuOpen*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(draghandle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(draghandle, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(draghandle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(draghandle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(draghandle, detaching);
    }
  };
}
function create_default_slot6(ctx) {
  let div2;
  let div1;
  let div0;
  let t0_value = (
    /*node*/
    ctx[0].attrs.url + ""
  );
  let t0;
  let div1_class_value;
  let t1;
  let blockactions;
  let current;
  blockactions = new BlockActions_default({
    props: {
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      create_component(blockactions.$$.fragment);
      attr(div0, "class", "p-8");
      attr(div1, "class", div1_class_value = "scribble-block-content " + /*selected*/
      (ctx[1] ? "ProseMirror-selectednode" : ""));
      attr(div2, "class", "scribble-block");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, t0);
      append(div2, t1);
      mount_component(blockactions, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*node*/
      1) && t0_value !== (t0_value = /*node*/
      ctx2[0].attrs.url + ""))
        set_data(t0, t0_value);
      if (!current || dirty & /*selected*/
      2 && div1_class_value !== (div1_class_value = "scribble-block-content " + /*selected*/
      (ctx2[1] ? "ProseMirror-selectednode" : ""))) {
        attr(div1, "class", div1_class_value);
      }
      const blockactions_changes = {};
      if (dirty & /*$$scope*/
      256) {
        blockactions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      blockactions.$set(blockactions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(blockactions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(blockactions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(blockactions);
    }
  };
}
function create_fragment16(ctx) {
  let nodeviewwrapper;
  let current;
  nodeviewwrapper = new NodeViewWrapper_default({
    props: {
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(nodeviewwrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(nodeviewwrapper, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const nodeviewwrapper_changes = {};
      if (dirty & /*$$scope, selected, node*/
      259) {
        nodeviewwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      nodeviewwrapper.$set(nodeviewwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nodeviewwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nodeviewwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(nodeviewwrapper, detaching);
    }
  };
}
function instance16($$self, $$props, $$invalidate) {
  let { editor } = $$props;
  let { node } = $$props;
  let { selected = false } = $$props;
  let { updateAttributes: updateAttributes2 } = $$props;
  let component;
  let popupInstance;
  const handleMenuOpen = (event) => {
    const clientRect2 = event.currentTarget.getBoundingClientRect();
    component = new OptionsMenu_default({
      target: document.createElement("div"),
      // Crea un elemento div per montare il componente Svelte
      props: {
        node,
        showSettings: false,
        editor,
        onClose: () => closeOptions()
      }
    });
    popupInstance = tippy_esm_default("body", {
      content: component.$$.root,
      getReferenceClientRect: () => clientRect2,
      allowHTML: true,
      interactive: true,
      trigger: "manual",
      placement: "left",
      showOnCreate: true,
      hideOnClick: true,
      theme: "scribble-options",
      arrow: true,
      zIndex: 9999,
      onHidden(instance18) {
        instance18.destroy();
      }
    });
  };
  const closeOptions = (event) => {
    if (Array.isArray(popupInstance)) {
      popupInstance.forEach((instance18) => instance18.hide());
    } else {
      popupInstance.hide();
    }
  };
  onMount(() => {
    window.addEventListener("updatedBlock", (e) => {
      if (e.detail.type === node.attrs.type && e.detail.statePath === editor.storage?.statePathExtension.statePath) {
        updateAttributes2({ values: e.detail.values });
      }
    });
  });
  $$self.$$set = ($$props2) => {
    if ("editor" in $$props2)
      $$invalidate(3, editor = $$props2.editor);
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
    if ("selected" in $$props2)
      $$invalidate(1, selected = $$props2.selected);
    if ("updateAttributes" in $$props2)
      $$invalidate(4, updateAttributes2 = $$props2.updateAttributes);
  };
  return [node, selected, handleMenuOpen, editor, updateAttributes2];
}
var OEmbedView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance16, create_fragment16, safe_not_equal, {
      editor: 3,
      node: 0,
      selected: 1,
      updateAttributes: 4
    });
  }
};
var oEmbedView_default = OEmbedView;

// resources/js/extensions/oEmbed.js
var oEmbed_default = Node2.create({
  name: "oEmbed",
  isBlock: true,
  inline: false,
  group: "block",
  draggable: true,
  defining: true,
  selectable: true,
  addAttributes() {
    return {
      url: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "oEmbed",
        getAttrs: (dom) => {
          return JSON.parse(dom.innerHTML);
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["oEmbed", JSON.stringify(HTMLAttributes)];
  },
  addNodeView() {
    return SvelteNodeViewRenderer_default(oEmbedView_default);
  }
});

// resources/js/Scribble.svelte
function create_fragment17(ctx) {
  let div2;
  let controls;
  let t0;
  let toolbar;
  let t1;
  let div0;
  let t2;
  let div1;
  let bubblemenu;
  let current;
  controls = new Controls_default({
    props: {
      editor: (
        /*editor*/
        ctx[3]
      ),
      statePath: (
        /*statePath*/
        ctx[0]
      )
    }
  });
  toolbar = new Toolbar_default({
    props: {
      editor: (
        /*editor*/
        ctx[3]
      ),
      tools: (
        /*toolbarTools*/
        ctx[2]
      ),
      handleToolClick: (
        /*handleToolClick*/
        ctx[7]
      ),
      isActive: (
        /*isActive*/
        ctx[6]
      )
    }
  });
  bubblemenu = new BubbleMenu_default2({
    props: {
      editor: (
        /*editor*/
        ctx[3]
      ),
      tools: (
        /*bubbleTools*/
        ctx[1]
      ),
      handleToolClick: (
        /*handleToolClick*/
        ctx[7]
      ),
      isActive: (
        /*isActive*/
        ctx[6]
      )
    }
  });
  return {
    c() {
      div2 = element("div");
      create_component(controls.$$.fragment);
      t0 = space();
      create_component(toolbar.$$.fragment);
      t1 = space();
      div0 = element("div");
      t2 = space();
      div1 = element("div");
      create_component(bubblemenu.$$.fragment);
      attr(div0, "class", "scribble-editor");
      attr(div2, "class", "scribble-editor-wrapper");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(controls, div2, null);
      append(div2, t0);
      mount_component(toolbar, div2, null);
      append(div2, t1);
      append(div2, div0);
      ctx[12](div0);
      append(div2, t2);
      append(div2, div1);
      mount_component(bubblemenu, div1, null);
      ctx[13](div1);
      current = true;
    },
    p(ctx2, [dirty]) {
      const controls_changes = {};
      if (dirty & /*editor*/
      8)
        controls_changes.editor = /*editor*/
        ctx2[3];
      if (dirty & /*statePath*/
      1)
        controls_changes.statePath = /*statePath*/
        ctx2[0];
      controls.$set(controls_changes);
      const toolbar_changes = {};
      if (dirty & /*editor*/
      8)
        toolbar_changes.editor = /*editor*/
        ctx2[3];
      if (dirty & /*toolbarTools*/
      4)
        toolbar_changes.tools = /*toolbarTools*/
        ctx2[2];
      if (dirty & /*isActive*/
      64)
        toolbar_changes.isActive = /*isActive*/
        ctx2[6];
      toolbar.$set(toolbar_changes);
      const bubblemenu_changes = {};
      if (dirty & /*editor*/
      8)
        bubblemenu_changes.editor = /*editor*/
        ctx2[3];
      if (dirty & /*bubbleTools*/
      2)
        bubblemenu_changes.tools = /*bubbleTools*/
        ctx2[1];
      if (dirty & /*isActive*/
      64)
        bubblemenu_changes.isActive = /*isActive*/
        ctx2[6];
      bubblemenu.$set(bubblemenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(controls.$$.fragment, local);
      transition_in(toolbar.$$.fragment, local);
      transition_in(bubblemenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(controls.$$.fragment, local);
      transition_out(toolbar.$$.fragment, local);
      transition_out(bubblemenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(controls);
      destroy_component(toolbar);
      ctx[12](null);
      destroy_component(bubblemenu);
      ctx[13](null);
    }
  };
}
function instance17($$self, $$props, $$invalidate) {
  let isActive2;
  let editor;
  let element2;
  let bubbleMenuElement;
  let tools;
  let { content } = $$props;
  let { statePath } = $$props;
  let { placeholder } = $$props;
  let { bubbleTools } = $$props;
  let { suggestionTools } = $$props;
  let { toolbarTools } = $$props;
  let { mergeTags } = $$props;
  onMount(() => {
    let customExtensions = window?.scribbleExtensions || [];
    let extensions2 = [
      StatePathExtension_default.configure({ statePath }),
      StarterKit,
      ClassExtension_default,
      CommandsExtension_default,
      IdExtension_default,
      Grid_default,
      LinkCustom_default,
      Embed_default,
      Highlight,
      oEmbedExtension_default,
      GridColumn_default,
      Details_default,
      DetailsContent_default,
      DetailsSummary_default,
      ScribbleBlock_default2,
      Subscript,
      Superscript,
      oEmbed_default,
      MediaExtension_default,
      Underline,
      TextAlignExtension_default.configure({ types: ["heading", "paragraph"] }),
      TextStyle3,
      BubbleMenu.configure({
        element: bubbleMenuElement,
        tippyOptions: {
          maxWidth: "none",
          placement: "bottom-start",
          theme: "scribble-bubble",
          interactive: true
        },
        shouldShow: ({ editor: editor2, from: from2, to }) => {
          if (from2 === to && editor2.isActive("link")) {
            return true;
          }
          if (from2 !== to && editor2.isActive("link")) {
            return true;
          }
          return from2 !== to && !(bubbleTools.filter((tool) => !tool.isHidden).length === 0 || editor2.isActive("image") || editor2.isActive("scribbleBlock") || editor2.isActive("slashExtension"));
        }
      }),
      ...customExtensions
    ];
    if (suggestionTools?.length) {
      extensions2.push(SlashExtension_default.configure({ tools: suggestionTools, statePath }));
      extensions2.push(Placeholder.configure({
        placeholder,
        emptyEditorClass: "is-editor-empty"
      }));
    }
    if (mergeTags?.length) {
      extensions2.push(MergeTag_default.configure({ mergeTags }));
      extensions2.push(MergeTagsExtension_default.configure({ tags: mergeTags, statePath }));
    }
    $$invalidate(3, editor = new Editor({
      content,
      element: element2,
      extensions: extensions2,
      onFocus: () => {
        window.dispatchEvent(new CustomEvent("focusScribbleComponent", { detail: { statePath } }));
      },
      onTransaction: () => {
        $$invalidate(3, editor);
      },
      onUpdate({ editor: editor2 }) {
        window.dispatchEvent(new CustomEvent(
          "updatedEditor",
          {
            detail: { statePath, content: editor2.getJSON() }
          }
        ));
      }
    }));
  });
  onDestroy(() => {
    editor.destroy();
  });
  tools = Array.from(/* @__PURE__ */ new Set([...bubbleTools.flat(), ...suggestionTools.flat(), ...toolbarTools.flat()]));
  let jsonObject = tools.map(JSON.stringify);
  let uniqueSet = new Set(jsonObject);
  tools = Array.from(uniqueSet).map(JSON.parse);
  window.addEventListener(`insert-content`, (data) => {
    if (data.detail.statePath !== statePath) {
      return;
    }
    if (data.detail.type === "media") {
      data.detail.media.forEach((item) => editor.chain().setMedia(item).focus().run());
    }
  });
  tools.forEach((tool) => {
    if (tool.options) {
      window.addEventListener(`handle-${tool.identifier}`, (data) => {
        if (data.detail.statePath !== statePath) {
          return;
        }
        if (tool.type === "block" || tool.type === "static") {
          if (data.detail.context === "insert") {
            editor.chain().insertScribbleBlock({
              identifier: tool.identifier,
              type: tool.type,
              blockId: data.detail.blockId,
              values: data.detail.values
            }).focus().run();
          } else {
            window.dispatchEvent(new CustomEvent(
              "updatedBlock",
              {
                detail: {
                  statePath,
                  identifier: tool.identifier,
                  type: tool.type,
                  blockId: data.detail.blockId,
                  values: data.detail.values
                }
              }
            ));
          }
          return;
        }
        commandRunner(editor, tool.commands, data.detail.values);
      });
    }
  });
  const handleToolClick = (tool, update2 = false) => {
    switch (tool.type) {
      case "command":
        commandRunner(editor, tool.commands);
        return;
      case "event":
        replaceStatePath(tool.event.data, statePath);
        window.Livewire.dispatch(tool.event.name, tool.event.data);
        return;
      case "modal":
        openScribbleModal(tool.identifier, {
          statePath,
          update: update2,
          identifier: tool.identifier,
          data: editor.getAttributes(tool.extension)
        });
        return;
      case "static":
        editor.chain().insertScribbleBlock({
          identifier: tool.identifier,
          type: tool.type,
          values: {}
        }).focus().run();
        return;
      default:
        editor.commands.setScribbleBlock({
          statePath,
          identifier: tool.identifier,
          type: tool.type
        });
    }
  };
  window.addEventListener("updateContent", (e) => {
    if (e.detail.statePath === statePath) {
      editor.chain().setContent(e.detail.newContent).run();
    }
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(4, element2);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      bubbleMenuElement = $$value;
      $$invalidate(5, bubbleMenuElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("content" in $$props2)
      $$invalidate(8, content = $$props2.content);
    if ("statePath" in $$props2)
      $$invalidate(0, statePath = $$props2.statePath);
    if ("placeholder" in $$props2)
      $$invalidate(9, placeholder = $$props2.placeholder);
    if ("bubbleTools" in $$props2)
      $$invalidate(1, bubbleTools = $$props2.bubbleTools);
    if ("suggestionTools" in $$props2)
      $$invalidate(10, suggestionTools = $$props2.suggestionTools);
    if ("toolbarTools" in $$props2)
      $$invalidate(2, toolbarTools = $$props2.toolbarTools);
    if ("mergeTags" in $$props2)
      $$invalidate(11, mergeTags = $$props2.mergeTags);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*editor*/
    8) {
      $:
        $$invalidate(6, isActive2 = (name, attrs = {}) => editor.isActive(name, attrs));
    }
  };
  return [
    statePath,
    bubbleTools,
    toolbarTools,
    editor,
    element2,
    bubbleMenuElement,
    isActive2,
    handleToolClick,
    content,
    placeholder,
    suggestionTools,
    mergeTags,
    div0_binding,
    div1_binding
  ];
}
var Scribble = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance17, create_fragment17, safe_not_equal, {
      content: 8,
      statePath: 0,
      placeholder: 9,
      bubbleTools: 1,
      suggestionTools: 10,
      toolbarTools: 2,
      mergeTags: 11
    });
  }
};
var Scribble_default = Scribble;

// resources/js/index.js
function scribble(bubbleTools, suggestionTools, toolbarTools, mergeTags, state, statePath, placeholder) {
  return {
    bubbleTools,
    suggestionTools,
    toolbarTools,
    mergeTags,
    state,
    statePath,
    placeholder: placeholder ?? "digita '/' per aggiungere un blocco",
    fullscreen: false,
    updatedFromEditor: false,
    isFocused: false,
    init() {
      const _this = this;
      new Scribble_default({
        target: _this.$root,
        props: {
          bubbleTools: _this.bubbleTools,
          suggestionTools: _this.suggestionTools,
          toolbarTools: _this.toolbarTools,
          mergeTags: _this.mergeTags,
          content: _this.state,
          statePath: _this.statePath,
          placeholder: _this.placeholder
        }
      });
      this.$watch("state", (newState, oldState) => {
        if (!_this.updatedFromEditor && JSON.stringify(newState) !== JSON.stringify(oldState)) {
          window.dispatchEvent(new CustomEvent("updateContent", {
            detail: {
              statePath,
              newContent: newState
            }
          }));
          _this.updatedFromEditor = false;
        }
      });
      window.addEventListener("updatedEditor", (e) => {
        if (e.detail.statePath === _this.statePath) {
          _this.updatedFromEditor = true;
          _this.state = e.detail.content;
        }
      });
      window.addEventListener("focusScribbleComponent", (e) => {
        if (e.detail.statePath === _this.statePath) {
          _this.isFocused = true;
        }
      });
    },
    toggleFullscreen(event) {
      if (event.detail.statePath !== this.statePath)
        return;
      this.fullscreen = !this.fullscreen;
    }
  };
}
export {
  scribble as default
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC91dGlscy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2dsb2JhbHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9SZXNpemVPYnNlcnZlclNpbmdsZXRvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2RvbS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2xpZmVjeWNsZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3NjaGVkdWxlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3RyYW5zaXRpb25zLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZWFjaC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL3NwcmVhZC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9zaGFyZWQvYm9vbGVhbl9hdHRyaWJ1dGVzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvQ29tcG9uZW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3NoYXJlZC92ZXJzaW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZGlzY2xvc2UtdmVyc2lvbi9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb3JkZXJlZG1hcC9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1tb2RlbC9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci10cmFuc2Zvcm0vZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itc3RhdGUvZGlzdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itdmlldy9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy93M2Mta2V5bmFtZS9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Ita2V5bWFwL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWNvbW1hbmRzL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXNjaGVtYS1saXN0L2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9jcmVhdGVDaGFpbmFibGVTdGF0ZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9Db21tYW5kTWFuYWdlci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9FdmVudEVtaXR0ZXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRFeHRlbnNpb25GaWVsZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL3NwbGl0RXh0ZW5zaW9ucy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE5vZGVUeXBlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9tZXJnZUF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRSZW5kZXJlZEF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzRnVuY3Rpb24udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2NhbGxPclJldHVybi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNFbXB0eU9iamVjdC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvZnJvbVN0cmluZy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2luamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZUJ5TmFtZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzRXh0ZW5zaW9uUnVsZXNFbmFibGVkLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzUmVnRXhwLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL0lucHV0UnVsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNOdW1iZXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvUGFzdGVSdWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9maW5kRHVwbGljYXRlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9FeHRlbnNpb25NYW5hZ2VyLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc1BsYWluT2JqZWN0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9tZXJnZURlZXAudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvRXh0ZW5zaW9uLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0VGV4dEJldHdlZW4udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2V4dGVuc2lvbnMvY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvYmx1ci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9jbGVhckNvbnRlbnQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvY2xlYXJOb2Rlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9jb21tYW5kLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2NyZWF0ZVBhcmFncmFwaE5lYXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvY3V0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2RlbGV0ZUN1cnJlbnROb2RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2RlbGV0ZU5vZGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvZGVsZXRlUmFuZ2UudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvZGVsZXRlU2VsZWN0aW9uLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2VudGVyLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2V4aXRDb2RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9vYmplY3RJbmNsdWRlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE1hcmtSYW5nZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE1hcmtUeXBlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2V4dGVuZE1hcmtSYW5nZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9maXJzdC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzVGV4dFNlbGVjdGlvbi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvbWluTWF4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvcmVzb2x2ZUZvY3VzUG9zaXRpb24udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzaU9TLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2ZvY3VzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2ZvckVhY2gudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvaW5zZXJ0Q29udGVudC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvZWxlbWVudEZyb21TdHJpbmcudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9jcmVhdGVOb2RlRnJvbUNvbnRlbnQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9zZWxlY3Rpb25Ub0luc2VydGlvbkVuZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9pbnNlcnRDb250ZW50QXQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvam9pbi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9qb2luSXRlbUJhY2t3YXJkLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2pvaW5JdGVtRm9yd2FyZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9qb2luVGV4dGJsb2NrQmFja3dhcmQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvam9pblRleHRibG9ja0ZvcndhcmQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzTWFjT1MudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMva2V5Ym9hcmRTaG9ydGN1dC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzTm9kZUFjdGl2ZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9saWZ0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2xpZnRFbXB0eUJsb2NrLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2xpZnRMaXN0SXRlbS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9uZXdsaW5lSW5Db2RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2RlbGV0ZVByb3BzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3Jlc2V0QXR0cmlidXRlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zY3JvbGxJbnRvVmlldy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZWxlY3RBbGwudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2VsZWN0Tm9kZUJhY2t3YXJkLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdE5vZGVGb3J3YXJkLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdFBhcmVudE5vZGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2VsZWN0VGV4dGJsb2NrRW5kLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdFRleHRibG9ja1N0YXJ0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY3JlYXRlRG9jdW1lbnQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2V0Q29udGVudC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE1hcmtBdHRyaWJ1dGVzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY29tYmluZVRyYW5zYWN0aW9uU3RlcHMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9kZWZhdWx0QmxvY2tBdC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2ZpbmRDaGlsZHJlbi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2ZpbmRDaGlsZHJlbkluUmFuZ2UudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9maW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1Bvcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2ZpbmRQYXJlbnROb2RlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0SFRNTEZyb21GcmFnbWVudC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFNjaGVtYS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dlbmVyYXRlSFRNTC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dlbmVyYXRlSlNPTi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFRleHQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZW5lcmF0ZVRleHQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXROb2RlQXR0cmlidXRlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldEF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL3JlbW92ZUR1cGxpY2F0ZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRDaGFuZ2VkUmFuZ2VzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0RGVidWdKU09OLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0TWFya3NCZXR3ZWVuLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0Tm9kZUF0UG9zaXRpb24udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRTcGxpdHRlZEF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc01hcmtBY3RpdmUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0FjdGl2ZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzQXRFbmRPZk5vZGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0F0U3RhcnRPZk5vZGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0xpc3QudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc05vZGVFbXB0eS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzTm9kZVNlbGVjdGlvbi50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL3Bvc1RvRE9NUmVjdC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZXRNYXJrLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NldE1ldGEudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2V0Tm9kZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZXROb2RlU2VsZWN0aW9uLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NldFRleHRTZWxlY3Rpb24udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2lua0xpc3RJdGVtLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NwbGl0QmxvY2sudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc3BsaXRMaXN0SXRlbS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy90b2dnbGVMaXN0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3RvZ2dsZU1hcmsudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdG9nZ2xlTm9kZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy90b2dnbGVXcmFwLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3VuZG9JbnB1dFJ1bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdW5zZXRBbGxNYXJrcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy91bnNldE1hcmsudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdXBkYXRlQXR0cmlidXRlcy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy93cmFwSW4udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvd3JhcEluTGlzdC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2NvbW1hbmRzLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2V4dGVuc2lvbnMvZWRpdGFibGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvZXh0ZW5zaW9ucy9mb2N1c0V2ZW50cy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2tleW1hcC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL3RhYmluZGV4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL05vZGVQb3MudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvc3R5bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2NyZWF0ZVN0eWxlVGFnLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL0VkaXRvci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9pbnB1dFJ1bGVzL21hcmtJbnB1dFJ1bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaW5wdXRSdWxlcy9ub2RlSW5wdXRSdWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2lucHV0UnVsZXMvdGV4dGJsb2NrVHlwZUlucHV0UnVsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9pbnB1dFJ1bGVzL3RleHRJbnB1dFJ1bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaW5wdXRSdWxlcy93cmFwcGluZ0lucHV0UnVsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9NYXJrLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL05vZGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzQW5kcm9pZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9Ob2RlVmlldy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9wYXN0ZVJ1bGVzL21hcmtQYXN0ZVJ1bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2VzY2FwZUZvclJlZ0V4LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc1N0cmluZy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9wYXN0ZVJ1bGVzL25vZGVQYXN0ZVJ1bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvcGFzdGVSdWxlcy90ZXh0UGFzdGVSdWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL1RyYWNrZXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlTmFtZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcHBseVN0eWxlcy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tYXRoLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdXNlckFnZW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzTGF5b3V0Vmlld3BvcnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvY29udGFpbnMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1RhYmxlRWxlbWVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0UGFyZW50Tm9kZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy93aXRoaW4uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9leHBhbmRUb0hhc2hNYXAuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXJyb3cuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRWYXJpYXRpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbEJhclguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50UmVjdC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRTY3JvbGxQYXJlbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9mbGlwLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2hpZGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvb2Zmc2V0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRBbHRBeGlzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRIVE1MRWxlbWVudFNjcm9sbC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9vcmRlck1vZGlmaWVycy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VCeU5hbWUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9jcmVhdGVQb3BwZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy9jb25zdGFudHMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy91dGlscy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL2RvbS11dGlscy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL2JpbmRHbG9iYWxFdmVudExpc3RlbmVycy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL2Jyb3dzZXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy92YWxpZGF0aW9uLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvcHJvcHMudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy90ZW1wbGF0ZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL2NyZWF0ZVRpcHB5LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvaW5kZXgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL3NyYy9hZGRvbnMvY3JlYXRlU2luZ2xldG9uLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvYWRkb25zL2RlbGVnYXRlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvcGx1Z2lucy9hbmltYXRlRmlsbC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL3BsdWdpbnMvZm9sbG93Q3Vyc29yLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9zcmMvcGx1Z2lucy9pbmxpbmVQb3NpdGlvbmluZy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvc3JjL3BsdWdpbnMvc3RpY2t5LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy90aXBweS5qcy9idWlsZC9iYXNlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1idWJibGUtbWVudS9zcmMvYnViYmxlLW1lbnUtcGx1Z2luLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1idWJibGUtbWVudS9zcmMvYnViYmxlLW1lbnUudHMiLCAiLi4vanMvZXh0ZW5zaW9ucy9DbGFzc0V4dGVuc2lvbi5qcyIsICIuLi9qcy9leHRlbnNpb25zL0NvbW1hbmRzRXh0ZW5zaW9uLmpzIiwgIi4uL2pzL2V4dGVuc2lvbnMvR3JpZC91dGlscy9jcmVhdGVDb2x1bW4uanMiLCAiLi4vanMvZXh0ZW5zaW9ucy9HcmlkL3V0aWxzL2dldEdyaWROb2RlVHlwZXMuanMiLCAiLi4vanMvZXh0ZW5zaW9ucy9HcmlkL3V0aWxzL2NyZWF0ZUdyaWQuanMiLCAiLi4vanMvZXh0ZW5zaW9ucy9HcmlkL0dyaWQuanMiLCAiLi4vanMvZXh0ZW5zaW9ucy9HcmlkL0dyaWRDb2x1bW4uanMiLCAiLi4vanMvZXh0ZW5zaW9ucy9EZXRhaWxzL0RldGFpbHMuanMiLCAiLi4vanMvZXh0ZW5zaW9ucy9EZXRhaWxzL0RldGFpbHNTdW1tYXJ5LmpzIiwgIi4uL2pzL2V4dGVuc2lvbnMvRGV0YWlscy9EZXRhaWxzQ29udGVudC5qcyIsICIuLi9qcy9leHRlbnNpb25zL0lkRXh0ZW5zaW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1pbWFnZS9zcmMvaW1hZ2UudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS10aXB0YXAvZGlzdC9TdmVsdGVSZW5kZXJlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXRpcHRhcC9kaXN0L2NvbnRleHQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS10aXB0YXAvZGlzdC9TdmVsdGVOb2RlVmlld1JlbmRlcmVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtdGlwdGFwL2Rpc3QvTm9kZVZpZXdXcmFwcGVyLnN2ZWx0ZSIsICIuLi9qcy9jb21wb25lbnRzL0Jsb2NrQWN0aW9ucy5zdmVsdGUiLCAiLi4vanMvY29tcG9uZW50cy9EcmFnSGFuZGxlLnN2ZWx0ZSIsICIuLi9qcy91dGlscy5qcyIsICIuLi9qcy9jb21wb25lbnRzL0Jsb2NrU2V0dGluZ3Muc3ZlbHRlIiwgIi4uL2pzL2NvbXBvbmVudHMvUmVtb3ZlQmxvY2suc3ZlbHRlIiwgIi4uL2pzL2NvbXBvbmVudHMvRHVwbGljYXRlQmxvY2suc3ZlbHRlIiwgIi4uL2pzL2NvbXBvbmVudHMvT3B0aW9uc01lbnUuc3ZlbHRlIiwgIi4uL2pzL2NvbXBvbmVudHMvTWVkaWFWaWV3LnN2ZWx0ZSIsICIuLi9qcy9leHRlbnNpb25zL01lZGlhRXh0ZW5zaW9uLmpzIiwgIi4uL2pzL2V4dGVuc2lvbnMvTWVyZ2VUYWcuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvc3VnZ2VzdGlvbi9zcmMvZmluZFN1Z2dlc3Rpb25NYXRjaC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdWdnZXN0aW9uL3NyYy9zdWdnZXN0aW9uLnRzIiwgIi4uL2pzL2NvbXBvbmVudHMvTWVyZ2VUYWdzTGlzdC5zdmVsdGUiLCAiLi4vanMvZXh0ZW5zaW9ucy9NZXJnZVRhZ3NFeHRlbnNpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXBsYWNlaG9sZGVyL3NyYy9wbGFjZWhvbGRlci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZS9zcmMvYmxvY2txdW90ZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYm9sZC9zcmMvYm9sZC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC1pdGVtL3NyYy9saXN0LWl0ZW0udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXRleHQtc3R5bGUvc3JjL3RleHQtc3R5bGUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJ1bGxldC1saXN0L3NyYy9idWxsZXQtbGlzdC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS9zcmMvY29kZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS1ibG9jay9zcmMvY29kZS1ibG9jay50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZG9jdW1lbnQvc3JjL2RvY3VtZW50LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1kcm9wY3Vyc29yL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWRyb3BjdXJzb3Ivc3JjL2Ryb3BjdXJzb3IudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWdhcGN1cnNvci9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1nYXBjdXJzb3Ivc3JjL2dhcGN1cnNvci50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVhay9zcmMvaGFyZC1icmVhay50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGVhZGluZy9zcmMvaGVhZGluZy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcm9wZS1zZXF1ZW5jZS9kaXN0L2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1oaXN0b3J5L2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhpc3Rvcnkvc3JjL2hpc3RvcnkudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhvcml6b250YWwtcnVsZS9zcmMvaG9yaXpvbnRhbC1ydWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1pdGFsaWMvc3JjL2l0YWxpYy50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC1pdGVtL3NyYy9saXN0LWl0ZW0udHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3QtaXRlbS9zcmMvbGlzdC1pdGVtLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10ZXh0LXN0eWxlL3NyYy90ZXh0LXN0eWxlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1vcmRlcmVkLWxpc3Qvc3JjL29yZGVyZWQtbGlzdC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoL3NyYy9wYXJhZ3JhcGgudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXN0cmlrZS9zcmMvc3RyaWtlLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10ZXh0L3NyYy90ZXh0LnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3N0YXJ0ZXIta2l0L3NyYy9zdGFydGVyLWtpdC50cyIsICIuLi9qcy9leHRlbnNpb25zL1N0YXRlUGF0aEV4dGVuc2lvbi5qcyIsICIuLi9qcy9jb21wb25lbnRzL1NjcmliYmxlQmxvY2suc3ZlbHRlIiwgIi4uL2pzL2V4dGVuc2lvbnMvU2NyaWJibGVCbG9jay5qcyIsICIuLi9qcy9jb21wb25lbnRzL0NvbW1hbmRzTGlzdC5zdmVsdGUiLCAiLi4vanMvZXh0ZW5zaW9ucy9TbGFzaEV4dGVuc2lvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tc3Vic2NyaXB0L3NyYy9zdWJzY3JpcHQudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXN1cGVyc2NyaXB0L3NyYy9zdXBlcnNjcmlwdC50cyIsICIuLi9qcy9leHRlbnNpb25zL1RleHRBbGlnbkV4dGVuc2lvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC1zdHlsZS9zcmMvdGV4dC1zdHlsZS50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdW5kZXJsaW5lL3NyYy91bmRlcmxpbmUudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm1qcyIsICIuLi9qcy9jb21wb25lbnRzL0J1dHRvbi5zdmVsdGUiLCAiLi4vanMvY29tcG9uZW50cy9Db250cm9scy5zdmVsdGUiLCAiLi4vanMvY29tcG9uZW50cy9CdWJibGVNZW51LnN2ZWx0ZSIsICIuLi9qcy9jb21wb25lbnRzL1Rvb2xiYXIuc3ZlbHRlIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1oaWdobGlnaHQvc3JjL2hpZ2hsaWdodC50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvbGlua2lmeWpzL2Rpc3QvbGlua2lmeS5lcy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGluay9zcmMvaGVscGVycy9hdXRvbGluay50cyIsICIuLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGluay9zcmMvaGVscGVycy9jbGlja0hhbmRsZXIudHMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpbmsvc3JjL2hlbHBlcnMvcGFzdGVIYW5kbGVyLnRzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saW5rL3NyYy9saW5rLnRzIiwgIi4uL2pzL2V4dGVuc2lvbnMvTGlua0N1c3RvbS5qcyIsICIuLi9qcy9leHRlbnNpb25zL0VtYmVkLmpzIiwgIi4uL2pzL2V4dGVuc2lvbnMvb0VtYmVkRXh0ZW5zaW9uLmpzIiwgIi4uL2pzL2NvbXBvbmVudHMvb0VtYmVkVmlldy5zdmVsdGUiLCAiLi4vanMvZXh0ZW5zaW9ucy9vRW1iZWQuanMiLCAiLi4vanMvU2NyaWJibGUuc3ZlbHRlIiwgIi4uL2pzL2luZGV4LmpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydCBjb25zdCBpZGVudGl0eSA9ICh4KSA9PiB4O1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUgU1xuICogQHBhcmFtIHtUfSB0YXJcbiAqIEBwYXJhbSB7U30gc3JjXG4gKiBAcmV0dXJucyB7VCAmIFN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24odGFyLCBzcmMpIHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRmb3IgKGNvbnN0IGsgaW4gc3JjKSB0YXJba10gPSBzcmNba107XG5cdHJldHVybiAvKiogQHR5cGUge1QgJiBTfSAqLyAodGFyKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVuL2lzLXByb21pc2UvYmxvYi9tYXN0ZXIvaW5kZXguanNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIE1JVCBMaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVuL2lzLXByb21pc2UvYmxvYi9tYXN0ZXIvTElDRU5TRVxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBQcm9taXNlTGlrZTxhbnk+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcHJvbWlzZSh2YWx1ZSkge1xuXHRyZXR1cm4gKFxuXHRcdCEhdmFsdWUgJiZcblx0XHQodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpICYmXG5cdFx0dHlwZW9mICgvKiogQHR5cGUge2FueX0gKi8gKHZhbHVlKS50aGVuKSA9PT0gJ2Z1bmN0aW9uJ1xuXHQpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX2xvY2F0aW9uKGVsZW1lbnQsIGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhcikge1xuXHRlbGVtZW50Ll9fc3ZlbHRlX21ldGEgPSB7XG5cdFx0bG9jOiB7IGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhciB9XG5cdH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydW4oZm4pIHtcblx0cmV0dXJuIGZuKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBibGFua19vYmplY3QoKSB7XG5cdHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gZm5zXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bl9hbGwoZm5zKSB7XG5cdGZucy5mb3JFYWNoKHJ1bik7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHRoaW5nXG4gKiBAcmV0dXJucyB7dGhpbmcgaXMgRnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19mdW5jdGlvbih0aGluZykge1xuXHRyZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKiogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZV9ub3RfZXF1YWwoYSwgYikge1xuXHRyZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYiB8fCAoYSAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHx8IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nO1xufVxuXG5sZXQgc3JjX3VybF9lcXVhbF9hbmNob3I7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRfc3JjXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNyY191cmxfZXF1YWwoZWxlbWVudF9zcmMsIHVybCkge1xuXHRpZiAoZWxlbWVudF9zcmMgPT09IHVybCkgcmV0dXJuIHRydWU7XG5cdGlmICghc3JjX3VybF9lcXVhbF9hbmNob3IpIHtcblx0XHRzcmNfdXJsX2VxdWFsX2FuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblx0fVxuXHQvLyBUaGlzIGlzIGFjdHVhbGx5IGZhc3RlciB0aGFuIGRvaW5nIFVSTCguLikuaHJlZlxuXHRzcmNfdXJsX2VxdWFsX2FuY2hvci5ocmVmID0gdXJsO1xuXHRyZXR1cm4gZWxlbWVudF9zcmMgPT09IHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWY7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gc3Jjc2V0ICovXG5mdW5jdGlvbiBzcGxpdF9zcmNzZXQoc3Jjc2V0KSB7XG5cdHJldHVybiBzcmNzZXQuc3BsaXQoJywnKS5tYXAoKHNyYykgPT4gc3JjLnRyaW0oKS5zcGxpdCgnICcpLmZpbHRlcihCb29sZWFuKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MU291cmNlRWxlbWVudCB8IEhUTUxJbWFnZUVsZW1lbnR9IGVsZW1lbnRfc3Jjc2V0XG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IHNyY3NldFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcmNzZXRfdXJsX2VxdWFsKGVsZW1lbnRfc3Jjc2V0LCBzcmNzZXQpIHtcblx0Y29uc3QgZWxlbWVudF91cmxzID0gc3BsaXRfc3Jjc2V0KGVsZW1lbnRfc3Jjc2V0LnNyY3NldCk7XG5cdGNvbnN0IHVybHMgPSBzcGxpdF9zcmNzZXQoc3Jjc2V0IHx8ICcnKTtcblxuXHRyZXR1cm4gKFxuXHRcdHVybHMubGVuZ3RoID09PSBlbGVtZW50X3VybHMubGVuZ3RoICYmXG5cdFx0dXJscy5ldmVyeShcblx0XHRcdChbdXJsLCB3aWR0aF0sIGkpID0+XG5cdFx0XHRcdHdpZHRoID09PSBlbGVtZW50X3VybHNbaV1bMV0gJiZcblx0XHRcdFx0Ly8gV2UgbmVlZCB0byB0ZXN0IGJvdGggd2F5cyBiZWNhdXNlIFZpdGUgd2lsbCBjcmVhdGUgYW4gYSBmdWxsIFVSTCB3aXRoXG5cdFx0XHRcdC8vIGBuZXcgVVJMKGFzc2V0LCBpbXBvcnQubWV0YS51cmwpLmhyZWZgIGZvciB0aGUgY2xpZW50IHdoZW4gYGJhc2U6ICcuLydgLCBhbmQgdGhlXG5cdFx0XHRcdC8vIHJlbGF0aXZlIFVSTHMgaW5zaWRlIHNyY3NldCBhcmUgbm90IGF1dG9tYXRpY2FsbHkgcmVzb2x2ZWQgdG8gYWJzb2x1dGUgVVJMcyBieVxuXHRcdFx0XHQvLyBicm93c2VycyAoaW4gY29udHJhc3QgdG8gaW1nLnNyYykuIFRoaXMgbWVhbnMgYm90aCBTU1IgYW5kIERPTSBjb2RlIGNvdWxkXG5cdFx0XHRcdC8vIGNvbnRhaW4gcmVsYXRpdmUgb3IgYWJzb2x1dGUgVVJMcy5cblx0XHRcdFx0KHNyY191cmxfZXF1YWwoZWxlbWVudF91cmxzW2ldWzBdLCB1cmwpIHx8IHNyY191cmxfZXF1YWwodXJsLCBlbGVtZW50X3VybHNbaV1bMF0pKVxuXHRcdClcblx0KTtcbn1cblxuLyoqIEByZXR1cm5zIHtib29sZWFufSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vdF9lcXVhbChhLCBiKSB7XG5cdHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiO1xufVxuXG4vKiogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gaXNfZW1wdHkob2JqKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX3N0b3JlKHN0b3JlLCBuYW1lKSB7XG5cdGlmIChzdG9yZSAhPSBudWxsICYmIHR5cGVvZiBzdG9yZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYCcke25hbWV9JyBpcyBub3QgYSBzdG9yZSB3aXRoIGEgJ3N1YnNjcmliZScgbWV0aG9kYCk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnNjcmliZShzdG9yZSwgLi4uY2FsbGJhY2tzKSB7XG5cdGlmIChzdG9yZSA9PSBudWxsKSB7XG5cdFx0Zm9yIChjb25zdCBjYWxsYmFjayBvZiBjYWxsYmFja3MpIHtcblx0XHRcdGNhbGxiYWNrKHVuZGVmaW5lZCk7XG5cdFx0fVxuXHRcdHJldHVybiBub29wO1xuXHR9XG5cdGNvbnN0IHVuc3ViID0gc3RvcmUuc3Vic2NyaWJlKC4uLmNhbGxiYWNrcyk7XG5cdHJldHVybiB1bnN1Yi51bnN1YnNjcmliZSA/ICgpID0+IHVuc3ViLnVuc3Vic2NyaWJlKCkgOiB1bnN1Yjtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgZnJvbSBhIHN0b3JlIGJ5IHN1YnNjcmliaW5nIGFuZCBpbW1lZGlhdGVseSB1bnN1YnNjcmliaW5nLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1zdG9yZSNnZXRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vc3RvcmUvcHVibGljLmpzJykuUmVhZGFibGU8VD59IHN0b3JlXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9zdG9yZV92YWx1ZShzdG9yZSkge1xuXHRsZXQgdmFsdWU7XG5cdHN1YnNjcmliZShzdG9yZSwgKF8pID0+ICh2YWx1ZSA9IF8pKSgpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wb25lbnRfc3Vic2NyaWJlKGNvbXBvbmVudCwgc3RvcmUsIGNhbGxiYWNrKSB7XG5cdGNvbXBvbmVudC4kJC5vbl9kZXN0cm95LnB1c2goc3Vic2NyaWJlKHN0b3JlLCBjYWxsYmFjaykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX3Nsb3QoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbikge1xuXHRpZiAoZGVmaW5pdGlvbikge1xuXHRcdGNvbnN0IHNsb3RfY3R4ID0gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKTtcblx0XHRyZXR1cm4gZGVmaW5pdGlvblswXShzbG90X2N0eCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG5cdHJldHVybiBkZWZpbml0aW9uWzFdICYmIGZuID8gYXNzaWduKCQkc2NvcGUuY3R4LnNsaWNlKCksIGRlZmluaXRpb25bMV0oZm4oY3R4KSkpIDogJCRzY29wZS5jdHg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfc2xvdF9jaGFuZ2VzKGRlZmluaXRpb24sICQkc2NvcGUsIGRpcnR5LCBmbikge1xuXHRpZiAoZGVmaW5pdGlvblsyXSAmJiBmbikge1xuXHRcdGNvbnN0IGxldHMgPSBkZWZpbml0aW9uWzJdKGZuKGRpcnR5KSk7XG5cdFx0aWYgKCQkc2NvcGUuZGlydHkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGxldHM7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgbGV0cyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGNvbnN0IG1lcmdlZCA9IFtdO1xuXHRcdFx0Y29uc3QgbGVuID0gTWF0aC5tYXgoJCRzY29wZS5kaXJ0eS5sZW5ndGgsIGxldHMubGVuZ3RoKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcblx0XHRcdFx0bWVyZ2VkW2ldID0gJCRzY29wZS5kaXJ0eVtpXSB8IGxldHNbaV07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWVyZ2VkO1xuXHRcdH1cblx0XHRyZXR1cm4gJCRzY29wZS5kaXJ0eSB8IGxldHM7XG5cdH1cblx0cmV0dXJuICQkc2NvcGUuZGlydHk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfc2xvdF9iYXNlKFxuXHRzbG90LFxuXHRzbG90X2RlZmluaXRpb24sXG5cdGN0eCxcblx0JCRzY29wZSxcblx0c2xvdF9jaGFuZ2VzLFxuXHRnZXRfc2xvdF9jb250ZXh0X2ZuXG4pIHtcblx0aWYgKHNsb3RfY2hhbmdlcykge1xuXHRcdGNvbnN0IHNsb3RfY29udGV4dCA9IGdldF9zbG90X2NvbnRleHQoc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGdldF9zbG90X2NvbnRleHRfZm4pO1xuXHRcdHNsb3QucChzbG90X2NvbnRleHQsIHNsb3RfY2hhbmdlcyk7XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9zbG90KFxuXHRzbG90LFxuXHRzbG90X2RlZmluaXRpb24sXG5cdGN0eCxcblx0JCRzY29wZSxcblx0ZGlydHksXG5cdGdldF9zbG90X2NoYW5nZXNfZm4sXG5cdGdldF9zbG90X2NvbnRleHRfZm5cbikge1xuXHRjb25zdCBzbG90X2NoYW5nZXMgPSBnZXRfc2xvdF9jaGFuZ2VzKHNsb3RfZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4pO1xuXHR1cGRhdGVfc2xvdF9iYXNlKHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBzbG90X2NoYW5nZXMsIGdldF9zbG90X2NvbnRleHRfZm4pO1xufVxuXG4vKiogQHJldHVybnMge2FueVtdIHwgLTF9ICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2FsbF9kaXJ0eV9mcm9tX3Njb3BlKCQkc2NvcGUpIHtcblx0aWYgKCQkc2NvcGUuY3R4Lmxlbmd0aCA+IDMyKSB7XG5cdFx0Y29uc3QgZGlydHkgPSBbXTtcblx0XHRjb25zdCBsZW5ndGggPSAkJHNjb3BlLmN0eC5sZW5ndGggLyAzMjtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRkaXJ0eVtpXSA9IC0xO1xuXHRcdH1cblx0XHRyZXR1cm4gZGlydHk7XG5cdH1cblx0cmV0dXJuIC0xO1xufVxuXG4vKiogQHJldHVybnMge3t9fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMocHJvcHMpIHtcblx0Y29uc3QgcmVzdWx0ID0ge307XG5cdGZvciAoY29uc3QgayBpbiBwcm9wcykgaWYgKGtbMF0gIT09ICckJykgcmVzdWx0W2tdID0gcHJvcHNba107XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBAcmV0dXJucyB7e319ICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZV9yZXN0X3Byb3BzKHByb3BzLCBrZXlzKSB7XG5cdGNvbnN0IHJlc3QgPSB7fTtcblx0a2V5cyA9IG5ldyBTZXQoa2V5cyk7XG5cdGZvciAoY29uc3QgayBpbiBwcm9wcykgaWYgKCFrZXlzLmhhcyhrKSAmJiBrWzBdICE9PSAnJCcpIHJlc3Rba10gPSBwcm9wc1trXTtcblx0cmV0dXJuIHJlc3Q7XG59XG5cbi8qKiBAcmV0dXJucyB7e319ICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZV9zbG90cyhzbG90cykge1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0Zm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcblx0XHRyZXN1bHRba2V5XSA9IHRydWU7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIEByZXR1cm5zIHsodGhpczogYW55LCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbmNlKGZuKSB7XG5cdGxldCByYW4gPSBmYWxzZTtcblx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0aWYgKHJhbikgcmV0dXJuO1xuXHRcdHJhbiA9IHRydWU7XG5cdFx0Zm4uY2FsbCh0aGlzLCAuLi5hcmdzKTtcblx0fTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG51bGxfdG9fZW1wdHkodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0X3N0b3JlX3ZhbHVlKHN0b3JlLCByZXQsIHZhbHVlKSB7XG5cdHN0b3JlLnNldCh2YWx1ZSk7XG5cdHJldHVybiByZXQ7XG59XG5cbmV4cG9ydCBjb25zdCBoYXNfcHJvcCA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuXG5leHBvcnQgZnVuY3Rpb24gYWN0aW9uX2Rlc3Ryb3llcihhY3Rpb25fcmVzdWx0KSB7XG5cdHJldHVybiBhY3Rpb25fcmVzdWx0ICYmIGlzX2Z1bmN0aW9uKGFjdGlvbl9yZXN1bHQuZGVzdHJveSkgPyBhY3Rpb25fcmVzdWx0LmRlc3Ryb3kgOiBub29wO1xufVxuXG4vKiogQHBhcmFtIHtudW1iZXIgfCBzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7W251bWJlciwgc3RyaW5nXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0X2Nzc191bml0KHZhbHVlKSB7XG5cdGNvbnN0IHNwbGl0ID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5tYXRjaCgvXlxccyooLT9bXFxkLl0rKShbXlxcc10qKVxccyokLyk7XG5cdHJldHVybiBzcGxpdCA/IFtwYXJzZUZsb2F0KHNwbGl0WzFdKSwgc3BsaXRbMl0gfHwgJ3B4J10gOiBbLyoqIEB0eXBlIHtudW1iZXJ9ICovICh2YWx1ZSksICdweCddO1xufVxuXG5leHBvcnQgY29uc3QgY29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMgPSBbJycsIHRydWUsIDEsICd0cnVlJywgJ2NvbnRlbnRlZGl0YWJsZSddO1xuIiwgIi8qKiBAdHlwZSB7dHlwZW9mIGdsb2JhbFRoaXN9ICovXG5leHBvcnQgY29uc3QgZ2xvYmFscyA9XG5cdHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG5cdFx0PyB3aW5kb3dcblx0XHQ6IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xuXHRcdD8gZ2xvYmFsVGhpc1xuXHRcdDogLy8gQHRzLWlnbm9yZSBOb2RlIHR5cGluZ3MgaGF2ZSB0aGlzXG5cdFx0ICBnbG9iYWw7XG4iLCAiaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4vZ2xvYmFscy5qcyc7XG5cbi8qKlxuICogUmVzaXplIG9ic2VydmVyIHNpbmdsZXRvbi5cbiAqIE9uZSBsaXN0ZW5lciBwZXIgZWxlbWVudCBvbmx5IVxuICogaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9nL2JsaW5rLWRldi9jL3o2aWVuT05VYjVBL20vRjUtVmNVWnRCQUFKXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbiB7XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHR5cGUge1dlYWtNYXA8RWxlbWVudCwgaW1wb3J0KCcuL3ByaXZhdGUuanMnKS5MaXN0ZW5lcj59XG5cdCAqL1xuXHRfbGlzdGVuZXJzID0gJ1dlYWtNYXAnIGluIGdsb2JhbHMgPyBuZXcgV2Vha01hcCgpIDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAdHlwZSB7UmVzaXplT2JzZXJ2ZXJ9XG5cdCAqL1xuXHRfb2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtSZXNpemVPYnNlcnZlck9wdGlvbnN9ICovXG5cdG9wdGlvbnM7XG5cblx0LyoqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJPcHRpb25zfSBvcHRpb25zICovXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuTGlzdGVuZXJ9IGxpc3RlbmVyXG5cdCAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuXHQgKi9cblx0b2JzZXJ2ZShlbGVtZW50LCBsaXN0ZW5lcikge1xuXHRcdHRoaXMuX2xpc3RlbmVycy5zZXQoZWxlbWVudCwgbGlzdGVuZXIpO1xuXHRcdHRoaXMuX2dldE9ic2VydmVyKCkub2JzZXJ2ZShlbGVtZW50LCB0aGlzLm9wdGlvbnMpO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHR0aGlzLl9saXN0ZW5lcnMuZGVsZXRlKGVsZW1lbnQpO1xuXHRcdFx0dGhpcy5fb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpOyAvLyB0aGlzIGxpbmUgY2FuIHByb2JhYmx5IGJlIHJlbW92ZWRcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0T2JzZXJ2ZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMuX29ic2VydmVyID8/XG5cdFx0XHQodGhpcy5fb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcblx0XHRcdFx0Zm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG5cdFx0XHRcdFx0UmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24uZW50cmllcy5zZXQoZW50cnkudGFyZ2V0LCBlbnRyeSk7XG5cdFx0XHRcdFx0dGhpcy5fbGlzdGVuZXJzLmdldChlbnRyeS50YXJnZXQpPy4oZW50cnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KSlcblx0XHQpO1xuXHR9XG59XG5cbi8vIE5lZWRzIHRvIGJlIHdyaXR0ZW4gbGlrZSB0aGlzIHRvIHBhc3MgdGhlIHRyZWUtc2hha2UtdGVzdFxuUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24uZW50cmllcyA9ICdXZWFrTWFwJyBpbiBnbG9iYWxzID8gbmV3IFdlYWtNYXAoKSA6IHVuZGVmaW5lZDtcbiIsICJpbXBvcnQgeyBjb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcywgaGFzX3Byb3AgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24gfSBmcm9tICcuL1Jlc2l6ZU9ic2VydmVyU2luZ2xldG9uLmpzJztcblxuLy8gVHJhY2sgd2hpY2ggbm9kZXMgYXJlIGNsYWltZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVW5jbGFpbWVkIG5vZGVzIGNhbiB0aGVuIGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NXG4vLyBhdCB0aGUgZW5kIG9mIGh5ZHJhdGlvbiB3aXRob3V0IHRvdWNoaW5nIHRoZSByZW1haW5pbmcgbm9kZXMuXG5sZXQgaXNfaHlkcmF0aW5nID0gZmFsc2U7XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydF9oeWRyYXRpbmcoKSB7XG5cdGlzX2h5ZHJhdGluZyA9IHRydWU7XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmRfaHlkcmF0aW5nKCkge1xuXHRpc19oeWRyYXRpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93XG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaFxuICogQHBhcmFtIHsoaW5kZXg6IG51bWJlcikgPT4gbnVtYmVyfSBrZXlcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gdXBwZXJfYm91bmQobG93LCBoaWdoLCBrZXksIHZhbHVlKSB7XG5cdC8vIFJldHVybiBmaXJzdCBpbmRleCBvZiB2YWx1ZSBsYXJnZXIgdGhhbiBpbnB1dCB2YWx1ZSBpbiB0aGUgcmFuZ2UgW2xvdywgaGlnaClcblx0d2hpbGUgKGxvdyA8IGhpZ2gpIHtcblx0XHRjb25zdCBtaWQgPSBsb3cgKyAoKGhpZ2ggLSBsb3cpID4+IDEpO1xuXHRcdGlmIChrZXkobWlkKSA8PSB2YWx1ZSkge1xuXHRcdFx0bG93ID0gbWlkICsgMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGlnaCA9IG1pZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGxvdztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGVFeH0gdGFyZ2V0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gaW5pdF9oeWRyYXRlKHRhcmdldCkge1xuXHRpZiAodGFyZ2V0Lmh5ZHJhdGVfaW5pdCkgcmV0dXJuO1xuXHR0YXJnZXQuaHlkcmF0ZV9pbml0ID0gdHJ1ZTtcblx0Ly8gV2Uga25vdyB0aGF0IGFsbCBjaGlsZHJlbiBoYXZlIGNsYWltX29yZGVyIHZhbHVlcyBzaW5jZSB0aGUgdW5jbGFpbWVkIGhhdmUgYmVlbiBkZXRhY2hlZCBpZiB0YXJnZXQgaXMgbm90IDxoZWFkPlxuXG5cdGxldCBjaGlsZHJlbiA9IC8qKiBAdHlwZSB7QXJyYXlMaWtlPE5vZGVFeDI+fSAqLyAodGFyZ2V0LmNoaWxkTm9kZXMpO1xuXHQvLyBJZiB0YXJnZXQgaXMgPGhlYWQ+LCB0aGVyZSBtYXkgYmUgY2hpbGRyZW4gd2l0aG91dCBjbGFpbV9vcmRlclxuXHRpZiAodGFyZ2V0Lm5vZGVOYW1lID09PSAnSEVBRCcpIHtcblx0XHRjb25zdCBteV9jaGlsZHJlbiA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IG5vZGUgPSBjaGlsZHJlbltpXTtcblx0XHRcdGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bXlfY2hpbGRyZW4ucHVzaChub2RlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y2hpbGRyZW4gPSBteV9jaGlsZHJlbjtcblx0fVxuXHQvKlxuXHQgKiBSZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5LlxuXHQgKiBXZSBjYW4gcmVvcmRlciBjbGFpbWVkIGNoaWxkcmVuIG9wdGltYWxseSBieSBmaW5kaW5nIHRoZSBsb25nZXN0IHN1YnNlcXVlbmNlIG9mXG5cdCAqIG5vZGVzIHRoYXQgYXJlIGFscmVhZHkgY2xhaW1lZCBpbiBvcmRlciBhbmQgb25seSBtb3ZpbmcgdGhlIHJlc3QuIFRoZSBsb25nZXN0XG5cdCAqIHN1YnNlcXVlbmNlIG9mIG5vZGVzIHRoYXQgYXJlIGNsYWltZWQgaW4gb3JkZXIgY2FuIGJlIGZvdW5kIGJ5XG5cdCAqIGNvbXB1dGluZyB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIC5jbGFpbV9vcmRlciB2YWx1ZXMuXG5cdCAqXG5cdCAqIFRoaXMgYWxnb3JpdGhtIGlzIG9wdGltYWwgaW4gZ2VuZXJhdGluZyB0aGUgbGVhc3QgYW1vdW50IG9mIHJlb3JkZXIgb3BlcmF0aW9uc1xuXHQgKiBwb3NzaWJsZS5cblx0ICpcblx0ICogUHJvb2Y6XG5cdCAqIFdlIGtub3cgdGhhdCwgZ2l2ZW4gYSBzZXQgb2YgcmVvcmRlcmluZyBvcGVyYXRpb25zLCB0aGUgbm9kZXMgdGhhdCBkbyBub3QgbW92ZVxuXHQgKiBhbHdheXMgZm9ybSBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLCBzaW5jZSB0aGV5IGRvIG5vdCBtb3ZlIGFtb25nIGVhY2ggb3RoZXJcblx0ICogbWVhbmluZyB0aGF0IHRoZXkgbXVzdCBiZSBhbHJlYWR5IG9yZGVyZWQgYW1vbmcgZWFjaCBvdGhlci4gVGh1cywgdGhlIG1heGltYWxcblx0ICogc2V0IG9mIG5vZGVzIHRoYXQgZG8gbm90IG1vdmUgZm9ybSBhIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZS5cblx0ICovXG5cdC8vIENvbXB1dGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlXG5cdC8vIG06IHN1YnNlcXVlbmNlIGxlbmd0aCBqID0+IGluZGV4IGsgb2Ygc21hbGxlc3QgdmFsdWUgdGhhdCBlbmRzIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgbGVuZ3RoIGpcblx0Y29uc3QgbSA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCArIDEpO1xuXHQvLyBQcmVkZWNlc3NvciBpbmRpY2VzICsgMVxuXHRjb25zdCBwID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoKTtcblx0bVswXSA9IC0xO1xuXHRsZXQgbG9uZ2VzdCA9IDA7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBjdXJyZW50ID0gY2hpbGRyZW5baV0uY2xhaW1fb3JkZXI7XG5cdFx0Ly8gRmluZCB0aGUgbGFyZ2VzdCBzdWJzZXF1ZW5jZSBsZW5ndGggc3VjaCB0aGF0IGl0IGVuZHMgaW4gYSB2YWx1ZSBsZXNzIHRoYW4gb3VyIGN1cnJlbnQgdmFsdWVcblx0XHQvLyB1cHBlcl9ib3VuZCByZXR1cm5zIGZpcnN0IGdyZWF0ZXIgdmFsdWUsIHNvIHdlIHN1YnRyYWN0IG9uZVxuXHRcdC8vIHdpdGggZmFzdCBwYXRoIGZvciB3aGVuIHdlIGFyZSBvbiB0aGUgY3VycmVudCBsb25nZXN0IHN1YnNlcXVlbmNlXG5cdFx0Y29uc3Qgc2VxX2xlbiA9XG5cdFx0XHQobG9uZ2VzdCA+IDAgJiYgY2hpbGRyZW5bbVtsb25nZXN0XV0uY2xhaW1fb3JkZXIgPD0gY3VycmVudFxuXHRcdFx0XHQ/IGxvbmdlc3QgKyAxXG5cdFx0XHRcdDogdXBwZXJfYm91bmQoMSwgbG9uZ2VzdCwgKGlkeCkgPT4gY2hpbGRyZW5bbVtpZHhdXS5jbGFpbV9vcmRlciwgY3VycmVudCkpIC0gMTtcblx0XHRwW2ldID0gbVtzZXFfbGVuXSArIDE7XG5cdFx0Y29uc3QgbmV3X2xlbiA9IHNlcV9sZW4gKyAxO1xuXHRcdC8vIFdlIGNhbiBndWFyYW50ZWUgdGhhdCBjdXJyZW50IGlzIHRoZSBzbWFsbGVzdCB2YWx1ZS4gT3RoZXJ3aXNlLCB3ZSB3b3VsZCBoYXZlIGdlbmVyYXRlZCBhIGxvbmdlciBzZXF1ZW5jZS5cblx0XHRtW25ld19sZW5dID0gaTtcblx0XHRsb25nZXN0ID0gTWF0aC5tYXgobmV3X2xlbiwgbG9uZ2VzdCk7XG5cdH1cblx0Ly8gVGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBub2RlcyAoaW5pdGlhbGx5IHJldmVyc2VkKVxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7Tm9kZUV4MltdfVxuXHQgKi9cblx0Y29uc3QgbGlzID0gW107XG5cdC8vIFRoZSByZXN0IG9mIHRoZSBub2Rlcywgbm9kZXMgdGhhdCB3aWxsIGJlIG1vdmVkXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtOb2RlRXgyW119XG5cdCAqL1xuXHRjb25zdCB0b19tb3ZlID0gW107XG5cdGxldCBsYXN0ID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTtcblx0Zm9yIChsZXQgY3VyID0gbVtsb25nZXN0XSArIDE7IGN1ciAhPSAwOyBjdXIgPSBwW2N1ciAtIDFdKSB7XG5cdFx0bGlzLnB1c2goY2hpbGRyZW5bY3VyIC0gMV0pO1xuXHRcdGZvciAoOyBsYXN0ID49IGN1cjsgbGFzdC0tKSB7XG5cdFx0XHR0b19tb3ZlLnB1c2goY2hpbGRyZW5bbGFzdF0pO1xuXHRcdH1cblx0XHRsYXN0LS07XG5cdH1cblx0Zm9yICg7IGxhc3QgPj0gMDsgbGFzdC0tKSB7XG5cdFx0dG9fbW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcblx0fVxuXHRsaXMucmV2ZXJzZSgpO1xuXHQvLyBXZSBzb3J0IHRoZSBub2RlcyBiZWluZyBtb3ZlZCB0byBndWFyYW50ZWUgdGhhdCB0aGVpciBpbnNlcnRpb24gb3JkZXIgbWF0Y2hlcyB0aGUgY2xhaW0gb3JkZXJcblx0dG9fbW92ZS5zb3J0KChhLCBiKSA9PiBhLmNsYWltX29yZGVyIC0gYi5jbGFpbV9vcmRlcik7XG5cdC8vIEZpbmFsbHksIHdlIG1vdmUgdGhlIG5vZGVzXG5cdGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHRvX21vdmUubGVuZ3RoOyBpKyspIHtcblx0XHR3aGlsZSAoaiA8IGxpcy5sZW5ndGggJiYgdG9fbW92ZVtpXS5jbGFpbV9vcmRlciA+PSBsaXNbal0uY2xhaW1fb3JkZXIpIHtcblx0XHRcdGorKztcblx0XHR9XG5cdFx0Y29uc3QgYW5jaG9yID0gaiA8IGxpcy5sZW5ndGggPyBsaXNbal0gOiBudWxsO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUodG9fbW92ZVtpXSwgYW5jaG9yKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kKHRhcmdldCwgbm9kZSkge1xuXHR0YXJnZXQuYXBwZW5kQ2hpbGQobm9kZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZV9zaGVldF9pZFxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRfc3R5bGVzKHRhcmdldCwgc3R5bGVfc2hlZXRfaWQsIHN0eWxlcykge1xuXHRjb25zdCBhcHBlbmRfc3R5bGVzX3RvID0gZ2V0X3Jvb3RfZm9yX3N0eWxlKHRhcmdldCk7XG5cdGlmICghYXBwZW5kX3N0eWxlc190by5nZXRFbGVtZW50QnlJZChzdHlsZV9zaGVldF9pZCkpIHtcblx0XHRjb25zdCBzdHlsZSA9IGVsZW1lbnQoJ3N0eWxlJyk7XG5cdFx0c3R5bGUuaWQgPSBzdHlsZV9zaGVldF9pZDtcblx0XHRzdHlsZS50ZXh0Q29udGVudCA9IHN0eWxlcztcblx0XHRhcHBlbmRfc3R5bGVzaGVldChhcHBlbmRfc3R5bGVzX3RvLCBzdHlsZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHtTaGFkb3dSb290IHwgRG9jdW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSkge1xuXHRpZiAoIW5vZGUpIHJldHVybiBkb2N1bWVudDtcblx0Y29uc3Qgcm9vdCA9IG5vZGUuZ2V0Um9vdE5vZGUgPyBub2RlLmdldFJvb3ROb2RlKCkgOiBub2RlLm93bmVyRG9jdW1lbnQ7XG5cdGlmIChyb290ICYmIC8qKiBAdHlwZSB7U2hhZG93Um9vdH0gKi8gKHJvb3QpLmhvc3QpIHtcblx0XHRyZXR1cm4gLyoqIEB0eXBlIHtTaGFkb3dSb290fSAqLyAocm9vdCk7XG5cdH1cblx0cmV0dXJuIG5vZGUub3duZXJEb2N1bWVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHtDU1NTdHlsZVNoZWV0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQobm9kZSkge1xuXHRjb25zdCBzdHlsZV9lbGVtZW50ID0gZWxlbWVudCgnc3R5bGUnKTtcblx0Ly8gRm9yIHRyYW5zaXRpb25zIHRvIHdvcmsgd2l0aG91dCAnc3R5bGUtc3JjOiB1bnNhZmUtaW5saW5lJyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSxcblx0Ly8gdGhlc2UgZW1wdHkgdGFncyBuZWVkIHRvIGJlIGFsbG93ZWQgd2l0aCBhIGhhc2ggYXMgYSB3b3JrYXJvdW5kIHVudGlsIHdlIG1vdmUgdG8gdGhlIFdlYiBBbmltYXRpb25zIEFQSS5cblx0Ly8gVXNpbmcgdGhlIGhhc2ggZm9yIHRoZSBlbXB0eSBzdHJpbmcgKGZvciBhbiBlbXB0eSB0YWcpIHdvcmtzIGluIGFsbCBicm93c2VycyBleGNlcHQgU2FmYXJpLlxuXHQvLyBTbyBhcyBhIHdvcmthcm91bmQgZm9yIHRoZSB3b3JrYXJvdW5kLCB3aGVuIHdlIGFwcGVuZCBlbXB0eSBzdHlsZSB0YWdzIHdlIHNldCB0aGVpciBjb250ZW50IHRvIC8qIGVtcHR5ICovLlxuXHQvLyBUaGUgaGFzaCAnc2hhMjU2LTlPbE5PMERORWVhVnpITDRSWndDTHNCSEE4V0JROHRvQnAvNEY1WFYybmM9JyB3aWxsIHRoZW4gd29yayBldmVuIGluIFNhZmFyaS5cblx0c3R5bGVfZWxlbWVudC50ZXh0Q29udGVudCA9ICcvKiBlbXB0eSAqLyc7XG5cdGFwcGVuZF9zdHlsZXNoZWV0KGdldF9yb290X2Zvcl9zdHlsZShub2RlKSwgc3R5bGVfZWxlbWVudCk7XG5cdHJldHVybiBzdHlsZV9lbGVtZW50LnNoZWV0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2hhZG93Um9vdCB8IERvY3VtZW50fSBub2RlXG4gKiBAcGFyYW0ge0hUTUxTdHlsZUVsZW1lbnR9IHN0eWxlXG4gKiBAcmV0dXJucyB7Q1NTU3R5bGVTaGVldH1cbiAqL1xuZnVuY3Rpb24gYXBwZW5kX3N0eWxlc2hlZXQobm9kZSwgc3R5bGUpIHtcblx0YXBwZW5kKC8qKiBAdHlwZSB7RG9jdW1lbnR9ICovIChub2RlKS5oZWFkIHx8IG5vZGUsIHN0eWxlKTtcblx0cmV0dXJuIHN0eWxlLnNoZWV0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZUV4fSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZUV4fSBub2RlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKSB7XG5cdGlmIChpc19oeWRyYXRpbmcpIHtcblx0XHRpbml0X2h5ZHJhdGUodGFyZ2V0KTtcblx0XHRpZiAoXG5cdFx0XHR0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHQodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgIT09IG51bGwgJiYgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQucGFyZW50Tm9kZSAhPT0gdGFyZ2V0KVxuXHRcdCkge1xuXHRcdFx0dGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSB0YXJnZXQuZmlyc3RDaGlsZDtcblx0XHR9XG5cdFx0Ly8gU2tpcCBub2RlcyBvZiB1bmRlZmluZWQgb3JkZXJpbmdcblx0XHR3aGlsZSAodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgIT09IG51bGwgJiYgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQuY2xhaW1fb3JkZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5uZXh0U2libGluZztcblx0XHR9XG5cdFx0aWYgKG5vZGUgIT09IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGluc2VydCBpZiB0aGUgb3JkZXJpbmcgb2YgdGhpcyBub2RlIHNob3VsZCBiZSBtb2RpZmllZCBvciB0aGUgcGFyZW50IG5vZGUgaXMgbm90IHRhcmdldFxuXHRcdFx0aWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCB8fCBub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCkge1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSBub2RlLm5leHRTaWJsaW5nO1xuXHRcdH1cblx0fSBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9PSBudWxsKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtOb2RlfSBbYW5jaG9yXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcblx0dGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBhbmNob3IgfHwgbnVsbCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlRXh9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlRXh9IG5vZGVcbiAqIEBwYXJhbSB7Tm9kZUV4fSBbYW5jaG9yXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG5cdGlmIChpc19oeWRyYXRpbmcgJiYgIWFuY2hvcikge1xuXHRcdGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKTtcblx0fSBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9IGFuY2hvcikge1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGFjaChub2RlKSB7XG5cdGlmIChub2RlLnBhcmVudE5vZGUpIHtcblx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2VhY2goaXRlcmF0aW9ucywgZGV0YWNoaW5nKSB7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGlmIChpdGVyYXRpb25zW2ldKSBpdGVyYXRpb25zW2ldLmQoZGV0YWNoaW5nKTtcblx0fVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7a2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwfSBLXG4gKiBAcGFyYW0ge0t9IG5hbWVcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFRhZ05hbWVNYXBbS119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50KG5hbWUpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXB9IEtcbiAqIEBwYXJhbSB7S30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGlzXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnRUYWdOYW1lTWFwW0tdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudF9pcyhuYW1lLCBpcykge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lLCB7IGlzIH0pO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUge2tleW9mIFR9IEtcbiAqIEBwYXJhbSB7VH0gb2JqXG4gKiBAcGFyYW0ge0tbXX0gZXhjbHVkZVxuICogQHJldHVybnMge1BpY2s8VCwgRXhjbHVkZTxrZXlvZiBULCBLPj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzKG9iaiwgZXhjbHVkZSkge1xuXHRjb25zdCB0YXJnZXQgPSAvKiogQHR5cGUge1BpY2s8VCwgRXhjbHVkZTxrZXlvZiBULCBLPj59ICovICh7fSk7XG5cdGZvciAoY29uc3QgayBpbiBvYmopIHtcblx0XHRpZiAoXG5cdFx0XHRoYXNfcHJvcChvYmosIGspICYmXG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRleGNsdWRlLmluZGV4T2YoaykgPT09IC0xXG5cdFx0KSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHR0YXJnZXRba10gPSBvYmpba107XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcH0gS1xuICogQHBhcmFtIHtLfSBuYW1lXG4gKiBAcmV0dXJucyB7U1ZHRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN2Z19lbGVtZW50KG5hbWUpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICogQHJldHVybnMge1RleHR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0KGRhdGEpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtUZXh0fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwYWNlKCkge1xuXHRyZXR1cm4gdGV4dCgnICcpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtUZXh0fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5KCkge1xuXHRyZXR1cm4gdGV4dCgnJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEByZXR1cm5zIHtDb21tZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbWVudChjb250ZW50KSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KGNvbnRlbnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0fSBoYW5kbGVyXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyB8IEV2ZW50TGlzdGVuZXJPcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG5cdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG5cdHJldHVybiAoKSA9PiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHsoZXZlbnQ6IGFueSkgPT4gYW55fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnRfZGVmYXVsdChmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHsoZXZlbnQ6IGFueSkgPT4gYW55fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BfcHJvcGFnYXRpb24oZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiBhbnl9ICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcF9pbW1lZGlhdGVfcHJvcGFnYXRpb24oZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiB2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGYoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzKSBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IHZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdHJ1c3RlZChmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGlmIChldmVudC5pc1RydXN0ZWQpIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG5cdGlmICh2YWx1ZSA9PSBudWxsKSBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuXHRlbHNlIGlmIChub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpICE9PSB2YWx1ZSkgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG59XG4vKipcbiAqIExpc3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBhbHdheXMgYmUgc2V0IHRocm91Z2ggdGhlIGF0dHIgbWV0aG9kLFxuICogYmVjYXVzZSB1cGRhdGluZyB0aGVtIHRocm91Z2ggdGhlIHByb3BlcnR5IHNldHRlciBkb2Vzbid0IHdvcmsgcmVsaWFibHkuXG4gKiBJbiB0aGUgZXhhbXBsZSBvZiBgd2lkdGhgL2BoZWlnaHRgLCB0aGUgcHJvYmxlbSBpcyB0aGF0IHRoZSBzZXR0ZXIgb25seVxuICogYWNjZXB0cyBudW1lcmljIHZhbHVlcywgYnV0IHRoZSBhdHRyaWJ1dGUgY2FuIGFsc28gYmUgc2V0IHRvIGEgc3RyaW5nIGxpa2UgYDUwJWAuXG4gKiBJZiB0aGlzIGxpc3QgYmVjb21lcyB0b28gYmlnLCByZXRoaW5rIHRoaXMgYXBwcm9hY2guXG4gKi9cbmNvbnN0IGFsd2F5c19zZXRfdGhyb3VnaF9zZXRfYXR0cmlidXRlID0gWyd3aWR0aCcsICdoZWlnaHQnXTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7eyBbeDogc3RyaW5nXTogc3RyaW5nIH19IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuXHQvLyBAdHMtaWdub3JlXG5cdGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobm9kZS5fX3Byb3RvX18pO1xuXHRmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0aWYgKGF0dHJpYnV0ZXNba2V5XSA9PSBudWxsKSB7XG5cdFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG5cdFx0XHRub2RlLnN0eWxlLmNzc1RleHQgPSBhdHRyaWJ1dGVzW2tleV07XG5cdFx0fSBlbHNlIGlmIChrZXkgPT09ICdfX3ZhbHVlJykge1xuXHRcdFx0LyoqIEB0eXBlIHthbnl9ICovIChub2RlKS52YWx1ZSA9IG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0ZGVzY3JpcHRvcnNba2V5XSAmJlxuXHRcdFx0ZGVzY3JpcHRvcnNba2V5XS5zZXQgJiZcblx0XHRcdGFsd2F5c19zZXRfdGhyb3VnaF9zZXRfYXR0cmlidXRlLmluZGV4T2Yoa2V5KSA9PT0gLTFcblx0XHQpIHtcblx0XHRcdG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXR0cihub2RlLCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBub2RlXG4gKiBAcGFyYW0ge3sgW3g6IHN0cmluZ106IHN0cmluZyB9fSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9zdmdfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG5cdGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcblx0XHRhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IGRhdGFfbWFwXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhX21hcChub2RlLCBkYXRhX21hcCkge1xuXHRPYmplY3Qua2V5cyhkYXRhX21hcCkuZm9yRWFjaCgoa2V5KSA9PiB7XG5cdFx0c2V0X2N1c3RvbV9lbGVtZW50X2RhdGEobm9kZSwga2V5LCBkYXRhX21hcFtrZXldKTtcblx0fSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEobm9kZSwgcHJvcCwgdmFsdWUpIHtcblx0Y29uc3QgbG93ZXIgPSBwcm9wLnRvTG93ZXJDYXNlKCk7IC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIGV4aXN0aW5nIGJlaGF2aW9yIHdlIGRvIGxvd2VyY2FzZSBmaXJzdFxuXHRpZiAobG93ZXIgaW4gbm9kZSkge1xuXHRcdG5vZGVbbG93ZXJdID0gdHlwZW9mIG5vZGVbbG93ZXJdID09PSAnYm9vbGVhbicgJiYgdmFsdWUgPT09ICcnID8gdHJ1ZSA6IHZhbHVlO1xuXHR9IGVsc2UgaWYgKHByb3AgaW4gbm9kZSkge1xuXHRcdG5vZGVbcHJvcF0gPSB0eXBlb2Ygbm9kZVtwcm9wXSA9PT0gJ2Jvb2xlYW4nICYmIHZhbHVlID09PSAnJyA/IHRydWUgOiB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHRhdHRyKG5vZGUsIHByb3AsIHZhbHVlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9keW5hbWljX2VsZW1lbnRfZGF0YSh0YWcpIHtcblx0cmV0dXJuIC8tLy50ZXN0KHRhZykgPyBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YV9tYXAgOiBzZXRfYXR0cmlidXRlcztcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHhsaW5rX2F0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuXHRub2RlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9zdmVsdGVfZGF0YXNldChub2RlKSB7XG5cdHJldHVybiBub2RlLmRhdGFzZXQuc3ZlbHRlSDtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dW5rbm93bltdfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGdyb3VwLCBfX3ZhbHVlLCBjaGVja2VkKSB7XG5cdGNvbnN0IHZhbHVlID0gbmV3IFNldCgpO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGdyb3VwW2ldLmNoZWNrZWQpIHZhbHVlLmFkZChncm91cFtpXS5fX3ZhbHVlKTtcblx0fVxuXHRpZiAoIWNoZWNrZWQpIHtcblx0XHR2YWx1ZS5kZWxldGUoX192YWx1ZSk7XG5cdH1cblx0cmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudFtdfSBncm91cFxuICogQHJldHVybnMge3sgcCguLi5pbnB1dHM6IEhUTUxJbnB1dEVsZW1lbnRbXSk6IHZvaWQ7IHIoKTogdm9pZDsgfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRfYmluZGluZ19ncm91cChncm91cCkge1xuXHQvKipcblx0ICogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnRbXX0gKi9cblx0bGV0IF9pbnB1dHM7XG5cdHJldHVybiB7XG5cdFx0LyogcHVzaCAqLyBwKC4uLmlucHV0cykge1xuXHRcdFx0X2lucHV0cyA9IGlucHV0cztcblx0XHRcdF9pbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IGdyb3VwLnB1c2goaW5wdXQpKTtcblx0XHR9LFxuXHRcdC8qIHJlbW92ZSAqLyByKCkge1xuXHRcdFx0X2lucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gZ3JvdXAuc3BsaWNlKGdyb3VwLmluZGV4T2YoaW5wdXQpLCAxKSk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXNcbiAqIEByZXR1cm5zIHt7IHUobmV3X2luZGV4ZXM6IG51bWJlcltdKTogdm9pZDsgcCguLi5pbnB1dHM6IEhUTUxJbnB1dEVsZW1lbnRbXSk6IHZvaWQ7IHI6ICgpID0+IHZvaWQ7IH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0X2JpbmRpbmdfZ3JvdXBfZHluYW1pYyhncm91cCwgaW5kZXhlcykge1xuXHQvKipcblx0ICogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnRbXX0gKi9cblx0bGV0IF9ncm91cCA9IGdldF9iaW5kaW5nX2dyb3VwKGdyb3VwKTtcblxuXHQvKipcblx0ICogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnRbXX0gKi9cblx0bGV0IF9pbnB1dHM7XG5cblx0ZnVuY3Rpb24gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGdyb3VwID0gZ3JvdXBbaW5kZXhlc1tpXV0gPSBncm91cFtpbmRleGVzW2ldXSB8fCBbXTtcblx0XHR9XG5cdFx0cmV0dXJuIGdyb3VwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBwdXNoKCkge1xuXHRcdF9pbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IF9ncm91cC5wdXNoKGlucHV0KSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIHJlbW92ZSgpIHtcblx0XHRfaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiBfZ3JvdXAuc3BsaWNlKF9ncm91cC5pbmRleE9mKGlucHV0KSwgMSkpO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0LyogdXBkYXRlICovIHUobmV3X2luZGV4ZXMpIHtcblx0XHRcdGluZGV4ZXMgPSBuZXdfaW5kZXhlcztcblx0XHRcdGNvbnN0IG5ld19ncm91cCA9IGdldF9iaW5kaW5nX2dyb3VwKGdyb3VwKTtcblx0XHRcdGlmIChuZXdfZ3JvdXAgIT09IF9ncm91cCkge1xuXHRcdFx0XHRyZW1vdmUoKTtcblx0XHRcdFx0X2dyb3VwID0gbmV3X2dyb3VwO1xuXHRcdFx0XHRwdXNoKCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKiBwdXNoICovIHAoLi4uaW5wdXRzKSB7XG5cdFx0XHRfaW5wdXRzID0gaW5wdXRzO1xuXHRcdFx0cHVzaCgpO1xuXHRcdH0sXG5cdFx0LyogcmVtb3ZlICovIHI6IHJlbW92ZVxuXHR9O1xufVxuXG4vKiogQHJldHVybnMge251bWJlcn0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b19udW1iZXIodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09PSAnJyA/IG51bGwgOiArdmFsdWU7XG59XG5cbi8qKiBAcmV0dXJucyB7YW55W119ICovXG5leHBvcnQgZnVuY3Rpb24gdGltZV9yYW5nZXNfdG9fYXJyYXkocmFuZ2VzKSB7XG5cdGNvbnN0IGFycmF5ID0gW107XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0YXJyYXkucHVzaCh7IHN0YXJ0OiByYW5nZXMuc3RhcnQoaSksIGVuZDogcmFuZ2VzLmVuZChpKSB9KTtcblx0fVxuXHRyZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7Q2hpbGROb2RlW119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGlsZHJlbihlbGVtZW50KSB7XG5cdHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGROb2Rlcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBpbml0X2NsYWltX2luZm8obm9kZXMpIHtcblx0aWYgKG5vZGVzLmNsYWltX2luZm8gPT09IHVuZGVmaW5lZCkge1xuXHRcdG5vZGVzLmNsYWltX2luZm8gPSB7IGxhc3RfaW5kZXg6IDAsIHRvdGFsX2NsYWltZWQ6IDAgfTtcblx0fVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7Q2hpbGROb2RlRXh9IFJcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcGFyYW0geyhub2RlOiBDaGlsZE5vZGVFeCkgPT4gbm9kZSBpcyBSfSBwcmVkaWNhdGVcbiAqIEBwYXJhbSB7KG5vZGU6IENoaWxkTm9kZUV4KSA9PiBDaGlsZE5vZGVFeCB8IHVuZGVmaW5lZH0gcHJvY2Vzc19ub2RlXG4gKiBAcGFyYW0geygpID0+IFJ9IGNyZWF0ZV9ub2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRvbnRfdXBkYXRlX2xhc3RfaW5kZXhcbiAqIEByZXR1cm5zIHtSfVxuICovXG5mdW5jdGlvbiBjbGFpbV9ub2RlKG5vZGVzLCBwcmVkaWNhdGUsIHByb2Nlc3Nfbm9kZSwgY3JlYXRlX25vZGUsIGRvbnRfdXBkYXRlX2xhc3RfaW5kZXggPSBmYWxzZSkge1xuXHQvLyBUcnkgdG8gZmluZCBub2RlcyBpbiBhbiBvcmRlciBzdWNoIHRoYXQgd2UgbGVuZ3RoZW4gdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuXHRpbml0X2NsYWltX2luZm8obm9kZXMpO1xuXHRjb25zdCByZXN1bHRfbm9kZSA9ICgoKSA9PiB7XG5cdFx0Ly8gV2UgZmlyc3QgdHJ5IHRvIGZpbmQgYW4gZWxlbWVudCBhZnRlciB0aGUgcHJldmlvdXMgb25lXG5cdFx0Zm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBub2RlID0gbm9kZXNbaV07XG5cdFx0XHRpZiAocHJlZGljYXRlKG5vZGUpKSB7XG5cdFx0XHRcdGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc19ub2RlKG5vZGUpO1xuXHRcdFx0XHRpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdG5vZGVzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRub2Rlc1tpXSA9IHJlcGxhY2VtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghZG9udF91cGRhdGVfbGFzdF9pbmRleCkge1xuXHRcdFx0XHRcdG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIE90aGVyd2lzZSwgd2UgdHJ5IHRvIGZpbmQgb25lIGJlZm9yZVxuXHRcdC8vIFdlIGl0ZXJhdGUgaW4gcmV2ZXJzZSBzbyB0aGF0IHdlIGRvbid0IGdvIHRvbyBmYXIgYmFja1xuXHRcdGZvciAobGV0IGkgPSBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0Y29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXHRcdFx0aWYgKHByZWRpY2F0ZShub2RlKSkge1xuXHRcdFx0XHRjb25zdCByZXBsYWNlbWVudCA9IHByb2Nlc3Nfbm9kZShub2RlKTtcblx0XHRcdFx0aWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRub2Rlcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bm9kZXNbaV0gPSByZXBsYWNlbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWRvbnRfdXBkYXRlX2xhc3RfaW5kZXgpIHtcblx0XHRcdFx0XHRub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvLyBTaW5jZSB3ZSBzcGxpY2VkIGJlZm9yZSB0aGUgbGFzdF9pbmRleCwgd2UgZGVjcmVhc2UgaXRcblx0XHRcdFx0XHRub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gSWYgd2UgY2FuJ3QgZmluZCBhbnkgbWF0Y2hpbmcgbm9kZSwgd2UgY3JlYXRlIGEgbmV3IG9uZVxuXHRcdHJldHVybiBjcmVhdGVfbm9kZSgpO1xuXHR9KSgpO1xuXHRyZXN1bHRfbm9kZS5jbGFpbV9vcmRlciA9IG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZDtcblx0bm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkICs9IDE7XG5cdHJldHVybiByZXN1bHRfbm9kZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7eyBba2V5OiBzdHJpbmddOiBib29sZWFuIH19IGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7KG5hbWU6IHN0cmluZykgPT4gRWxlbWVudCB8IFNWR0VsZW1lbnR9IGNyZWF0ZV9lbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudCB8IFNWR0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgY3JlYXRlX2VsZW1lbnQpIHtcblx0cmV0dXJuIGNsYWltX25vZGUoXG5cdFx0bm9kZXMsXG5cdFx0LyoqIEByZXR1cm5zIHtub2RlIGlzIEVsZW1lbnQgfCBTVkdFbGVtZW50fSAqL1xuXHRcdChub2RlKSA9PiBub2RlLm5vZGVOYW1lID09PSBuYW1lLFxuXHRcdC8qKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgKi9cblx0XHQobm9kZSkgPT4ge1xuXHRcdFx0Y29uc3QgcmVtb3ZlID0gW107XG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBub2RlLmF0dHJpYnV0ZXNbal07XG5cdFx0XHRcdGlmICghYXR0cmlidXRlc1thdHRyaWJ1dGUubmFtZV0pIHtcblx0XHRcdFx0XHRyZW1vdmUucHVzaChhdHRyaWJ1dGUubmFtZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlbW92ZS5mb3JFYWNoKCh2KSA9PiBub2RlLnJlbW92ZUF0dHJpYnV0ZSh2KSk7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH0sXG5cdFx0KCkgPT4gY3JlYXRlX2VsZW1lbnQobmFtZSlcblx0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7eyBba2V5OiBzdHJpbmddOiBib29sZWFuIH19IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHtFbGVtZW50IHwgU1ZHRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcblx0cmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgZWxlbWVudCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3sgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9fSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7RWxlbWVudCB8IFNWR0VsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV9zdmdfZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcykge1xuXHRyZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBzdmdfZWxlbWVudCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEByZXR1cm5zIHtUZXh0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fdGV4dChub2RlcywgZGF0YSkge1xuXHRyZXR1cm4gY2xhaW1fbm9kZShcblx0XHRub2Rlcyxcblx0XHQvKiogQHJldHVybnMge25vZGUgaXMgVGV4dH0gKi9cblx0XHQobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMyxcblx0XHQvKiogQHBhcmFtIHtUZXh0fSBub2RlICovXG5cdFx0KG5vZGUpID0+IHtcblx0XHRcdGNvbnN0IGRhdGFfc3RyID0gJycgKyBkYXRhO1xuXHRcdFx0aWYgKG5vZGUuZGF0YS5zdGFydHNXaXRoKGRhdGFfc3RyKSkge1xuXHRcdFx0XHRpZiAobm9kZS5kYXRhLmxlbmd0aCAhPT0gZGF0YV9zdHIubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUuc3BsaXRUZXh0KGRhdGFfc3RyLmxlbmd0aCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUuZGF0YSA9IGRhdGFfc3RyO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0KCkgPT4gdGV4dChkYXRhKSxcblx0XHR0cnVlIC8vIFRleHQgbm9kZXMgc2hvdWxkIG5vdCB1cGRhdGUgbGFzdCBpbmRleCBzaW5jZSBpdCBpcyBsaWtlbHkgbm90IHdvcnRoIGl0IHRvIGVsaW1pbmF0ZSBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIGFjdHVhbCBlbGVtZW50c1xuXHQpO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHtUZXh0fSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX3NwYWNlKG5vZGVzKSB7XG5cdHJldHVybiBjbGFpbV90ZXh0KG5vZGVzLCAnICcpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcmV0dXJucyB7Q29tbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX2NvbW1lbnQobm9kZXMsIGRhdGEpIHtcblx0cmV0dXJuIGNsYWltX25vZGUoXG5cdFx0bm9kZXMsXG5cdFx0LyoqIEByZXR1cm5zIHtub2RlIGlzIENvbW1lbnR9ICovXG5cdFx0KG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDgsXG5cdFx0LyoqIEBwYXJhbSB7Q29tbWVudH0gbm9kZSAqL1xuXHRcdChub2RlKSA9PiB7XG5cdFx0XHRub2RlLmRhdGEgPSAnJyArIGRhdGE7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH0sXG5cdFx0KCkgPT4gY29tbWVudChkYXRhKSxcblx0XHR0cnVlXG5cdCk7XG59XG5cbmZ1bmN0aW9uIGdldF9jb21tZW50X2lkeChub2RlcywgdGV4dCwgc3RhcnQpIHtcblx0Zm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRjb25zdCBub2RlID0gbm9kZXNbaV07XG5cdFx0aWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogY29tbWVudCBub2RlICovICYmIG5vZGUudGV4dENvbnRlbnQudHJpbSgpID09PSB0ZXh0KSB7XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfc3ZnXG4gKiBAcmV0dXJucyB7SHRtbFRhZ0h5ZHJhdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX2h0bWxfdGFnKG5vZGVzLCBpc19zdmcpIHtcblx0Ly8gZmluZCBodG1sIG9wZW5pbmcgdGFnXG5cdGNvbnN0IHN0YXJ0X2luZGV4ID0gZ2V0X2NvbW1lbnRfaWR4KG5vZGVzLCAnSFRNTF9UQUdfU1RBUlQnLCAwKTtcblx0Y29uc3QgZW5kX2luZGV4ID0gZ2V0X2NvbW1lbnRfaWR4KG5vZGVzLCAnSFRNTF9UQUdfRU5EJywgc3RhcnRfaW5kZXggKyAxKTtcblx0aWYgKHN0YXJ0X2luZGV4ID09PSAtMSB8fCBlbmRfaW5kZXggPT09IC0xKSB7XG5cdFx0cmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKGlzX3N2Zyk7XG5cdH1cblxuXHRpbml0X2NsYWltX2luZm8obm9kZXMpO1xuXHRjb25zdCBodG1sX3RhZ19ub2RlcyA9IG5vZGVzLnNwbGljZShzdGFydF9pbmRleCwgZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKTtcblx0ZGV0YWNoKGh0bWxfdGFnX25vZGVzWzBdKTtcblx0ZGV0YWNoKGh0bWxfdGFnX25vZGVzW2h0bWxfdGFnX25vZGVzLmxlbmd0aCAtIDFdKTtcblx0Y29uc3QgY2xhaW1lZF9ub2RlcyA9IGh0bWxfdGFnX25vZGVzLnNsaWNlKDEsIGh0bWxfdGFnX25vZGVzLmxlbmd0aCAtIDEpO1xuXHRpZiAoY2xhaW1lZF9ub2Rlcy5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24oaXNfc3ZnKTtcblx0fVxuXHRmb3IgKGNvbnN0IG4gb2YgY2xhaW1lZF9ub2Rlcykge1xuXHRcdG4uY2xhaW1fb3JkZXIgPSBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQ7XG5cdFx0bm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkICs9IDE7XG5cdH1cblx0cmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKGlzX3N2ZywgY2xhaW1lZF9ub2Rlcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUZXh0fSB0ZXh0XG4gKiBAcGFyYW0ge3Vua25vd259IGRhdGFcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2RhdGEodGV4dCwgZGF0YSkge1xuXHRkYXRhID0gJycgKyBkYXRhO1xuXHRpZiAodGV4dC5kYXRhID09PSBkYXRhKSByZXR1cm47XG5cdHRleHQuZGF0YSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoZGF0YSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUZXh0fSB0ZXh0XG4gKiBAcGFyYW0ge3Vua25vd259IGRhdGFcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2RhdGFfY29udGVudGVkaXRhYmxlKHRleHQsIGRhdGEpIHtcblx0ZGF0YSA9ICcnICsgZGF0YTtcblx0aWYgKHRleHQud2hvbGVUZXh0ID09PSBkYXRhKSByZXR1cm47XG5cdHRleHQuZGF0YSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoZGF0YSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUZXh0fSB0ZXh0XG4gKiBAcGFyYW0ge3Vua25vd259IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyX3ZhbHVlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kYXRhX21heWJlX2NvbnRlbnRlZGl0YWJsZSh0ZXh0LCBkYXRhLCBhdHRyX3ZhbHVlKSB7XG5cdGlmICh+Y29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMuaW5kZXhPZihhdHRyX3ZhbHVlKSkge1xuXHRcdHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZSh0ZXh0LCBkYXRhKTtcblx0fSBlbHNlIHtcblx0XHRzZXRfZGF0YSh0ZXh0LCBkYXRhKTtcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9pbnB1dF92YWx1ZShpbnB1dCwgdmFsdWUpIHtcblx0aW5wdXQudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaW5wdXRfdHlwZShpbnB1dCwgdHlwZSkge1xuXHR0cnkge1xuXHRcdGlucHV0LnR5cGUgPSB0eXBlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gZG8gbm90aGluZ1xuXHR9XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3N0eWxlKG5vZGUsIGtleSwgdmFsdWUsIGltcG9ydGFudCkge1xuXHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdG5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcblx0fSBlbHNlIHtcblx0XHRub2RlLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUsIGltcG9ydGFudCA/ICdpbXBvcnRhbnQnIDogJycpO1xuXHR9XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlLCBtb3VudGluZykge1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0Y29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG5cdFx0aWYgKG9wdGlvbi5fX3ZhbHVlID09PSB2YWx1ZSkge1xuXHRcdFx0b3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblx0aWYgKCFtb3VudGluZyB8fCB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0c2VsZWN0LnNlbGVjdGVkSW5kZXggPSAtMTsgLy8gbm8gb3B0aW9uIHNob3VsZCBiZSBzZWxlY3RlZFxuXHR9XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0X29wdGlvbnMoc2VsZWN0LCB2YWx1ZSkge1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0Y29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG5cdFx0b3B0aW9uLnNlbGVjdGVkID0gfnZhbHVlLmluZGV4T2Yob3B0aW9uLl9fdmFsdWUpO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RfdmFsdWUoc2VsZWN0KSB7XG5cdGNvbnN0IHNlbGVjdGVkX29wdGlvbiA9IHNlbGVjdC5xdWVyeVNlbGVjdG9yKCc6Y2hlY2tlZCcpO1xuXHRyZXR1cm4gc2VsZWN0ZWRfb3B0aW9uICYmIHNlbGVjdGVkX29wdGlvbi5fX3ZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0X211bHRpcGxlX3ZhbHVlKHNlbGVjdCkge1xuXHRyZXR1cm4gW10ubWFwLmNhbGwoc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoJzpjaGVja2VkJyksIChvcHRpb24pID0+IG9wdGlvbi5fX3ZhbHVlKTtcbn1cbi8vIHVuZm9ydHVuYXRlbHkgdGhpcyBjYW4ndCBiZSBhIGNvbnN0YW50IGFzIHRoYXQgd291bGRuJ3QgYmUgdHJlZS1zaGFrZWFibGVcbi8vIHNvIHdlIGNhY2hlIHRoZSByZXN1bHQgaW5zdGVhZFxuXG4vKipcbiAqIEB0eXBlIHtib29sZWFufSAqL1xubGV0IGNyb3Nzb3JpZ2luO1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2Nyb3Nzb3JpZ2luKCkge1xuXHRpZiAoY3Jvc3NvcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuXHRcdGNyb3Nzb3JpZ2luID0gZmFsc2U7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGFyZW50KSB7XG5cdFx0XHRcdHZvaWQgd2luZG93LnBhcmVudC5kb2N1bWVudDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y3Jvc3NvcmlnaW4gPSB0cnVlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gY3Jvc3NvcmlnaW47XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeygpID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfaWZyYW1lX3Jlc2l6ZV9saXN0ZW5lcihub2RlLCBmbikge1xuXHRjb25zdCBjb21wdXRlZF9zdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGlmIChjb21wdXRlZF9zdHlsZS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcblx0XHRub2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcblx0fVxuXHRjb25zdCBpZnJhbWUgPSBlbGVtZW50KCdpZnJhbWUnKTtcblx0aWZyYW1lLnNldEF0dHJpYnV0ZShcblx0XHQnc3R5bGUnLFxuXHRcdCdkaXNwbGF5OiBibG9jazsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7ICcgK1xuXHRcdFx0J292ZXJmbG93OiBoaWRkZW47IGJvcmRlcjogMDsgb3BhY2l0eTogMDsgcG9pbnRlci1ldmVudHM6IG5vbmU7IHotaW5kZXg6IC0xOydcblx0KTtcblx0aWZyYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXHRpZnJhbWUudGFiSW5kZXggPSAtMTtcblx0Y29uc3QgY3Jvc3NvcmlnaW4gPSBpc19jcm9zc29yaWdpbigpO1xuXG5cdC8qKlxuXHQgKiBAdHlwZSB7KCkgPT4gdm9pZH1cblx0ICovXG5cdGxldCB1bnN1YnNjcmliZTtcblx0aWYgKGNyb3Nzb3JpZ2luKSB7XG5cdFx0aWZyYW1lLnNyYyA9IFwiZGF0YTp0ZXh0L2h0bWwsPHNjcmlwdD5vbnJlc2l6ZT1mdW5jdGlvbigpe3BhcmVudC5wb3N0TWVzc2FnZSgwLCcqJyl9PC9zY3JpcHQ+XCI7XG5cdFx0dW5zdWJzY3JpYmUgPSBsaXN0ZW4oXG5cdFx0XHR3aW5kb3csXG5cdFx0XHQnbWVzc2FnZScsXG5cdFx0XHQvKiogQHBhcmFtIHtNZXNzYWdlRXZlbnR9IGV2ZW50ICovIChldmVudCkgPT4ge1xuXHRcdFx0XHRpZiAoZXZlbnQuc291cmNlID09PSBpZnJhbWUuY29udGVudFdpbmRvdykgZm4oKTtcblx0XHRcdH1cblx0XHQpO1xuXHR9IGVsc2Uge1xuXHRcdGlmcmFtZS5zcmMgPSAnYWJvdXQ6YmxhbmsnO1xuXHRcdGlmcmFtZS5vbmxvYWQgPSAoKSA9PiB7XG5cdFx0XHR1bnN1YnNjcmliZSA9IGxpc3RlbihpZnJhbWUuY29udGVudFdpbmRvdywgJ3Jlc2l6ZScsIGZuKTtcblx0XHRcdC8vIG1ha2Ugc3VyZSBhbiBpbml0aWFsIHJlc2l6ZSBldmVudCBpcyBmaXJlZCBfYWZ0ZXJfIHRoZSBpZnJhbWUgaXMgbG9hZGVkICh3aGljaCBpcyBhc3luY2hyb25vdXMpXG5cdFx0XHQvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvNDIzM1xuXHRcdFx0Zm4oKTtcblx0XHR9O1xuXHR9XG5cdGFwcGVuZChub2RlLCBpZnJhbWUpO1xuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmIChjcm9zc29yaWdpbikge1xuXHRcdFx0dW5zdWJzY3JpYmUoKTtcblx0XHR9IGVsc2UgaWYgKHVuc3Vic2NyaWJlICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG5cdFx0XHR1bnN1YnNjcmliZSgpO1xuXHRcdH1cblx0XHRkZXRhY2goaWZyYW1lKTtcblx0fTtcbn1cbmV4cG9ydCBjb25zdCByZXNpemVfb2JzZXJ2ZXJfY29udGVudF9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uKHtcblx0Ym94OiAnY29udGVudC1ib3gnXG59KTtcbmV4cG9ydCBjb25zdCByZXNpemVfb2JzZXJ2ZXJfYm9yZGVyX2JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24oe1xuXHRib3g6ICdib3JkZXItYm94J1xufSk7XG5leHBvcnQgY29uc3QgcmVzaXplX29ic2VydmVyX2RldmljZV9waXhlbF9jb250ZW50X2JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24oXG5cdHsgYm94OiAnZGV2aWNlLXBpeGVsLWNvbnRlbnQtYm94JyB9XG4pO1xuZXhwb3J0IHsgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24gfTtcblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVfY2xhc3MoZWxlbWVudCwgbmFtZSwgdG9nZ2xlKSB7XG5cdC8vIFRoZSBgISFgIGlzIHJlcXVpcmVkIGJlY2F1c2UgYW4gYHVuZGVmaW5lZGAgZmxhZyBtZWFucyBmbGlwcGluZyB0aGUgY3VycmVudCBzdGF0ZS5cblx0ZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKG5hbWUsICEhdG9nZ2xlKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7VH0gW2RldGFpbF1cbiAqIEBwYXJhbSB7eyBidWJibGVzPzogYm9vbGVhbiwgY2FuY2VsYWJsZT86IGJvb2xlYW4gfX0gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7Q3VzdG9tRXZlbnQ8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdXN0b21fZXZlbnQodHlwZSwgZGV0YWlsLCB7IGJ1YmJsZXMgPSBmYWxzZSwgY2FuY2VsYWJsZSA9IGZhbHNlIH0gPSB7fSkge1xuXHRyZXR1cm4gbmV3IEN1c3RvbUV2ZW50KHR5cGUsIHsgZGV0YWlsLCBidWJibGVzLCBjYW5jZWxhYmxlIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcmV0dXJucyB7Q2hpbGROb2RlQXJyYXl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeV9zZWxlY3Rvcl9hbGwoc2VsZWN0b3IsIHBhcmVudCA9IGRvY3VtZW50LmJvZHkpIHtcblx0cmV0dXJuIEFycmF5LmZyb20ocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZUlkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBoZWFkXG4gKiBAcmV0dXJucyB7YW55W119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZWFkX3NlbGVjdG9yKG5vZGVJZCwgaGVhZCkge1xuXHRjb25zdCByZXN1bHQgPSBbXTtcblx0bGV0IHN0YXJ0ZWQgPSAwO1xuXHRmb3IgKGNvbnN0IG5vZGUgb2YgaGVhZC5jaGlsZE5vZGVzKSB7XG5cdFx0aWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogY29tbWVudCBub2RlICovKSB7XG5cdFx0XHRjb25zdCBjb21tZW50ID0gbm9kZS50ZXh0Q29udGVudC50cmltKCk7XG5cdFx0XHRpZiAoY29tbWVudCA9PT0gYEhFQURfJHtub2RlSWR9X0VORGApIHtcblx0XHRcdFx0c3RhcnRlZCAtPSAxO1xuXHRcdFx0XHRyZXN1bHQucHVzaChub2RlKTtcblx0XHRcdH0gZWxzZSBpZiAoY29tbWVudCA9PT0gYEhFQURfJHtub2RlSWR9X1NUQVJUYCkge1xuXHRcdFx0XHRzdGFydGVkICs9IDE7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKG5vZGUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoc3RhcnRlZCA+IDApIHtcblx0XHRcdHJlc3VsdC5wdXNoKG5vZGUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuLyoqICovXG5leHBvcnQgY2xhc3MgSHRtbFRhZyB7XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKi9cblx0aXNfc3ZnID0gZmFsc2U7XG5cdC8qKiBwYXJlbnQgZm9yIGNyZWF0aW5nIG5vZGUgKi9cblx0ZSA9IHVuZGVmaW5lZDtcblx0LyoqIGh0bWwgdGFnIG5vZGVzICovXG5cdG4gPSB1bmRlZmluZWQ7XG5cdC8qKiB0YXJnZXQgKi9cblx0dCA9IHVuZGVmaW5lZDtcblx0LyoqIGFuY2hvciAqL1xuXHRhID0gdW5kZWZpbmVkO1xuXHRjb25zdHJ1Y3Rvcihpc19zdmcgPSBmYWxzZSkge1xuXHRcdHRoaXMuaXNfc3ZnID0gaXNfc3ZnO1xuXHRcdHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRjKGh0bWwpIHtcblx0XHR0aGlzLmgoaHRtbCk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnR9IHRhcmdldFxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgU1ZHRWxlbWVudH0gYW5jaG9yXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0bShodG1sLCB0YXJnZXQsIGFuY2hvciA9IG51bGwpIHtcblx0XHRpZiAoIXRoaXMuZSkge1xuXHRcdFx0aWYgKHRoaXMuaXNfc3ZnKVxuXHRcdFx0XHR0aGlzLmUgPSBzdmdfZWxlbWVudCgvKiogQHR5cGUge2tleW9mIFNWR0VsZW1lbnRUYWdOYW1lTWFwfSAqLyAodGFyZ2V0Lm5vZGVOYW1lKSk7XG5cdFx0XHQvKiogIzczNjQgIHRhcmdldCBmb3IgPHRlbXBsYXRlPiBtYXkgYmUgcHJvdmlkZWQgYXMgI2RvY3VtZW50LWZyYWdtZW50KDExKSAqLyBlbHNlXG5cdFx0XHRcdHRoaXMuZSA9IGVsZW1lbnQoXG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXB9ICovIChcblx0XHRcdFx0XHRcdHRhcmdldC5ub2RlVHlwZSA9PT0gMTEgPyAnVEVNUExBVEUnIDogdGFyZ2V0Lm5vZGVOYW1lXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpO1xuXHRcdFx0dGhpcy50ID1cblx0XHRcdFx0dGFyZ2V0LnRhZ05hbWUgIT09ICdURU1QTEFURSdcblx0XHRcdFx0XHQ/IHRhcmdldFxuXHRcdFx0XHRcdDogLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50fSAqLyAodGFyZ2V0KS5jb250ZW50O1xuXHRcdFx0dGhpcy5jKGh0bWwpO1xuXHRcdH1cblx0XHR0aGlzLmkoYW5jaG9yKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGgoaHRtbCkge1xuXHRcdHRoaXMuZS5pbm5lckhUTUwgPSBodG1sO1xuXHRcdHRoaXMubiA9IEFycmF5LmZyb20oXG5cdFx0XHR0aGlzLmUubm9kZU5hbWUgPT09ICdURU1QTEFURScgPyB0aGlzLmUuY29udGVudC5jaGlsZE5vZGVzIDogdGhpcy5lLmNoaWxkTm9kZXNcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRpKGFuY2hvcikge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRpbnNlcnQodGhpcy50LCB0aGlzLm5baV0sIGFuY2hvcik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0cChodG1sKSB7XG5cdFx0dGhpcy5kKCk7XG5cdFx0dGhpcy5oKGh0bWwpO1xuXHRcdHRoaXMuaSh0aGlzLmEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRkKCkge1xuXHRcdHRoaXMubi5mb3JFYWNoKGRldGFjaCk7XG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIEh0bWxUYWdIeWRyYXRpb24gZXh0ZW5kcyBIdG1sVGFnIHtcblx0LyoqIEB0eXBlIHtFbGVtZW50W119IGh5ZHJhdGlvbiBjbGFpbWVkIG5vZGVzICovXG5cdGwgPSB1bmRlZmluZWQ7XG5cblx0Y29uc3RydWN0b3IoaXNfc3ZnID0gZmFsc2UsIGNsYWltZWRfbm9kZXMpIHtcblx0XHRzdXBlcihpc19zdmcpO1xuXHRcdHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG5cdFx0dGhpcy5sID0gY2xhaW1lZF9ub2Rlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGMoaHRtbCkge1xuXHRcdGlmICh0aGlzLmwpIHtcblx0XHRcdHRoaXMubiA9IHRoaXMubDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3VwZXIuYyhodG1sKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGkoYW5jaG9yKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdGluc2VydF9oeWRyYXRpb24odGhpcy50LCB0aGlzLm5baV0sIGFuY2hvcik7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOYW1lZE5vZGVNYXB9IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHt7fX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dHJpYnV0ZV90b19vYmplY3QoYXR0cmlidXRlcykge1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0Zm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xuXHRcdHJlc3VsdFthdHRyaWJ1dGUubmFtZV0gPSBhdHRyaWJ1dGUudmFsdWU7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgZXNjYXBlZCA9IHtcblx0J1wiJzogJyZxdW90OycsXG5cdCcmJzogJyZhbXA7Jyxcblx0JzwnOiAnJmx0Oydcbn07XG5cbmNvbnN0IHJlZ2V4X2F0dHJpYnV0ZV9jaGFyYWN0ZXJzX3RvX2VzY2FwZSA9IC9bXCImPF0vZztcblxuLyoqXG4gKiBOb3RlIHRoYXQgdGhlIGF0dHJpYnV0ZSBpdHNlbGYgc2hvdWxkIGJlIHN1cnJvdW5kZWQgaW4gZG91YmxlIHF1b3Rlc1xuICogQHBhcmFtIHthbnl9IGF0dHJpYnV0ZVxuICovXG5mdW5jdGlvbiBlc2NhcGVfYXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuXHRyZXR1cm4gU3RyaW5nKGF0dHJpYnV0ZSkucmVwbGFjZShyZWdleF9hdHRyaWJ1dGVfY2hhcmFjdGVyc190b19lc2NhcGUsIChtYXRjaCkgPT4gZXNjYXBlZFttYXRjaF0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gYXR0cmlidXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5X3NwcmVhZChhdHRyaWJ1dGVzKSB7XG5cdGxldCBzdHIgPSAnICc7XG5cdGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcblx0XHRpZiAoYXR0cmlidXRlc1trZXldICE9IG51bGwpIHtcblx0XHRcdHN0ciArPSBgJHtrZXl9PVwiJHtlc2NhcGVfYXR0cmlidXRlKGF0dHJpYnV0ZXNba2V5XSl9XCIgYDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHt7fX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHMoZWxlbWVudCkge1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0ZWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2goXG5cdFx0LyoqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSAqLyAobm9kZSkgPT4ge1xuXHRcdFx0cmVzdWx0W25vZGUuc2xvdCB8fCAnZGVmYXVsdCddID0gdHJ1ZTtcblx0XHR9XG5cdCk7XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3Rfc3ZlbHRlX2NvbXBvbmVudChjb21wb25lbnQsIHByb3BzKSB7XG5cdHJldHVybiBuZXcgY29tcG9uZW50KHByb3BzKTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7Tm9kZSAmIHtcbiAqIFx0Y2xhaW1fb3JkZXI/OiBudW1iZXI7XG4gKiBcdGh5ZHJhdGVfaW5pdD86IHRydWU7XG4gKiBcdGFjdHVhbF9lbmRfY2hpbGQ/OiBOb2RlRXg7XG4gKiBcdGNoaWxkTm9kZXM6IE5vZGVMaXN0T2Y8Tm9kZUV4PjtcbiAqIH19IE5vZGVFeFxuICovXG5cbi8qKiBAdHlwZWRlZiB7Q2hpbGROb2RlICYgTm9kZUV4fSBDaGlsZE5vZGVFeCAqL1xuXG4vKiogQHR5cGVkZWYge05vZGVFeCAmIHsgY2xhaW1fb3JkZXI6IG51bWJlciB9fSBOb2RlRXgyICovXG5cbi8qKlxuICogQHR5cGVkZWYge0NoaWxkTm9kZUV4W10gJiB7XG4gKiBcdGNsYWltX2luZm8/OiB7XG4gKiBcdFx0bGFzdF9pbmRleDogbnVtYmVyO1xuICogXHRcdHRvdGFsX2NsYWltZWQ6IG51bWJlcjtcbiAqIFx0fTtcbiAqIH19IENoaWxkTm9kZUFycmF5XG4gKi9cbiIsICJpbXBvcnQgeyBjdXN0b21fZXZlbnQgfSBmcm9tICcuL2RvbS5qcyc7XG5cbmV4cG9ydCBsZXQgY3VycmVudF9jb21wb25lbnQ7XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KSB7XG5cdGN1cnJlbnRfY29tcG9uZW50ID0gY29tcG9uZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkge1xuXHRpZiAoIWN1cnJlbnRfY29tcG9uZW50KSB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGNhbGxlZCBvdXRzaWRlIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbicpO1xuXHRyZXR1cm4gY3VycmVudF9jb21wb25lbnQ7XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVwZGF0ZWQgYWZ0ZXIgYW55IHN0YXRlIGNoYW5nZS5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgcnVucyB3aWxsIGJlIGJlZm9yZSB0aGUgaW5pdGlhbCBgb25Nb3VudGBcbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjYmVmb3JldXBkYXRlXG4gKiBAcGFyYW0geygpID0+IGFueX0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmVmb3JlVXBkYXRlKGZuKSB7XG5cdGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmJlZm9yZV91cGRhdGUucHVzaChmbik7XG59XG5cbi8qKlxuICogVGhlIGBvbk1vdW50YCBmdW5jdGlvbiBzY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gYXMgc29vbiBhcyB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgdG8gdGhlIERPTS5cbiAqIEl0IG11c3QgYmUgY2FsbGVkIGR1cmluZyB0aGUgY29tcG9uZW50J3MgaW5pdGlhbGlzYXRpb24gKGJ1dCBkb2Vzbid0IG5lZWQgdG8gbGl2ZSAqaW5zaWRlKiB0aGUgY29tcG9uZW50O1xuICogaXQgY2FuIGJlIGNhbGxlZCBmcm9tIGFuIGV4dGVybmFsIG1vZHVsZSkuXG4gKlxuICogSWYgYSBmdW5jdGlvbiBpcyByZXR1cm5lZCBfc3luY2hyb25vdXNseV8gZnJvbSBgb25Nb3VudGAsIGl0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gKlxuICogYG9uTW91bnRgIGRvZXMgbm90IHJ1biBpbnNpZGUgYSBbc2VydmVyLXNpZGUgY29tcG9uZW50XShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcyNydW4tdGltZS1zZXJ2ZXItc2lkZS1jb21wb25lbnQtYXBpKS5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjb25tb3VudFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gaW1wb3J0KCcuL3ByaXZhdGUuanMnKS5Ob3RGdW5jdGlvbjxUPiB8IFByb21pc2U8aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5Ob3RGdW5jdGlvbjxUPj4gfCAoKCkgPT4gYW55KX0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gb25Nb3VudChmbikge1xuXHRnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9tb3VudC5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiB1cGRhdGVkLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBydW5zIHdpbGwgYmUgYWZ0ZXIgdGhlIGluaXRpYWwgYG9uTW91bnRgXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI2FmdGVydXBkYXRlXG4gKiBAcGFyYW0geygpID0+IGFueX0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWZ0ZXJVcGRhdGUoZm4pIHtcblx0Z2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuYWZ0ZXJfdXBkYXRlLnB1c2goZm4pO1xufVxuXG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gKlxuICogT3V0IG9mIGBvbk1vdW50YCwgYGJlZm9yZVVwZGF0ZWAsIGBhZnRlclVwZGF0ZWAgYW5kIGBvbkRlc3Ryb3lgLCB0aGlzIGlzIHRoZVxuICogb25seSBvbmUgdGhhdCBydW5zIGluc2lkZSBhIHNlcnZlci1zaWRlIGNvbXBvbmVudC5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjb25kZXN0cm95XG4gKiBAcGFyYW0geygpID0+IGFueX0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gb25EZXN0cm95KGZuKSB7XG5cdGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX2Rlc3Ryb3kucHVzaChmbik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBldmVudCBkaXNwYXRjaGVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGlzcGF0Y2ggW2NvbXBvbmVudCBldmVudHNdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3RlbXBsYXRlLXN5bnRheC1jb21wb25lbnQtZGlyZWN0aXZlcy1vbi1ldmVudG5hbWUpLlxuICogRXZlbnQgZGlzcGF0Y2hlcnMgYXJlIGZ1bmN0aW9ucyB0aGF0IGNhbiB0YWtlIHR3byBhcmd1bWVudHM6IGBuYW1lYCBhbmQgYGRldGFpbGAuXG4gKlxuICogQ29tcG9uZW50IGV2ZW50cyBjcmVhdGVkIHdpdGggYGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcmAgY3JlYXRlIGFcbiAqIFtDdXN0b21FdmVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50KS5cbiAqIFRoZXNlIGV2ZW50cyBkbyBub3QgW2J1YmJsZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9MZWFybi9KYXZhU2NyaXB0L0J1aWxkaW5nX2Jsb2Nrcy9FdmVudHMjRXZlbnRfYnViYmxpbmdfYW5kX2NhcHR1cmUpLlxuICogVGhlIGBkZXRhaWxgIGFyZ3VtZW50IGNvcnJlc3BvbmRzIHRvIHRoZSBbQ3VzdG9tRXZlbnQuZGV0YWlsXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvZGV0YWlsKVxuICogcHJvcGVydHkgYW5kIGNhbiBjb250YWluIGFueSB0eXBlIG9mIGRhdGEuXG4gKlxuICogVGhlIGV2ZW50IGRpc3BhdGNoZXIgY2FuIGJlIHR5cGVkIHRvIG5hcnJvdyB0aGUgYWxsb3dlZCBldmVudCBuYW1lcyBhbmQgdGhlIHR5cGUgb2YgdGhlIGBkZXRhaWxgIGFyZ3VtZW50OlxuICogYGBgdHNcbiAqIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyPHtcbiAqICBsb2FkZWQ6IG5ldmVyOyAvLyBkb2VzIG5vdCB0YWtlIGEgZGV0YWlsIGFyZ3VtZW50XG4gKiAgY2hhbmdlOiBzdHJpbmc7IC8vIHRha2VzIGEgZGV0YWlsIGFyZ3VtZW50IG9mIHR5cGUgc3RyaW5nLCB3aGljaCBpcyByZXF1aXJlZFxuICogIG9wdGlvbmFsOiBudW1iZXIgfCBudWxsOyAvLyB0YWtlcyBhbiBvcHRpb25hbCBkZXRhaWwgYXJndW1lbnQgb2YgdHlwZSBudW1iZXJcbiAqIH0+KCk7XG4gKiBgYGBcbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjY3JlYXRlZXZlbnRkaXNwYXRjaGVyXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtFdmVudE1hcD1hbnldXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLkV2ZW50RGlzcGF0Y2hlcjxFdmVudE1hcD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFdmVudERpc3BhdGNoZXIoKSB7XG5cdGNvbnN0IGNvbXBvbmVudCA9IGdldF9jdXJyZW50X2NvbXBvbmVudCgpO1xuXHRyZXR1cm4gKHR5cGUsIGRldGFpbCwgeyBjYW5jZWxhYmxlID0gZmFsc2UgfSA9IHt9KSA9PiB7XG5cdFx0Y29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1t0eXBlXTtcblx0XHRpZiAoY2FsbGJhY2tzKSB7XG5cdFx0XHQvLyBUT0RPIGFyZSB0aGVyZSBzaXR1YXRpb25zIHdoZXJlIGV2ZW50cyBjb3VsZCBiZSBkaXNwYXRjaGVkXG5cdFx0XHQvLyBpbiBhIHNlcnZlciAobm9uLURPTSkgZW52aXJvbm1lbnQ/XG5cdFx0XHRjb25zdCBldmVudCA9IGN1c3RvbV9ldmVudCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHR5cGUpLCBkZXRhaWwsIHsgY2FuY2VsYWJsZSB9KTtcblx0XHRcdGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goKGZuKSA9PiB7XG5cdFx0XHRcdGZuLmNhbGwoY29tcG9uZW50LCBldmVudCk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG59XG5cbi8qKlxuICogQXNzb2NpYXRlcyBhbiBhcmJpdHJhcnkgYGNvbnRleHRgIG9iamVjdCB3aXRoIHRoZSBjdXJyZW50IGNvbXBvbmVudCBhbmQgdGhlIHNwZWNpZmllZCBga2V5YFxuICogYW5kIHJldHVybnMgdGhhdCBvYmplY3QuIFRoZSBjb250ZXh0IGlzIHRoZW4gYXZhaWxhYmxlIHRvIGNoaWxkcmVuIG9mIHRoZSBjb21wb25lbnRcbiAqIChpbmNsdWRpbmcgc2xvdHRlZCBjb250ZW50KSB3aXRoIGBnZXRDb250ZXh0YC5cbiAqXG4gKiBMaWtlIGxpZmVjeWNsZSBmdW5jdGlvbnMsIHRoaXMgbXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjc2V0Y29udGV4dFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEBwYXJhbSB7VH0gY29udGV4dFxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb250ZXh0KGtleSwgY29udGV4dCkge1xuXHRnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LnNldChrZXksIGNvbnRleHQpO1xuXHRyZXR1cm4gY29udGV4dDtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGNvbnRleHQgdGhhdCBiZWxvbmdzIHRvIHRoZSBjbG9zZXN0IHBhcmVudCBjb21wb25lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGBrZXlgLlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjZ2V0Y29udGV4dFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udGV4dChrZXkpIHtcblx0cmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSB3aG9sZSBjb250ZXh0IG1hcCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uIFVzZWZ1bCwgZm9yIGV4YW1wbGUsIGlmIHlvdVxuICogcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBjb21wb25lbnQgYW5kIHdhbnQgdG8gcGFzcyB0aGUgZXhpc3RpbmcgY29udGV4dCB0byBpdC5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUjZ2V0YWxsY29udGV4dHNcbiAqIEB0ZW1wbGF0ZSB7TWFwPGFueSwgYW55Pn0gW1Q9TWFwPGFueSwgYW55Pl1cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsQ29udGV4dHMoKSB7XG5cdHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0O1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gYGtleWAgaGFzIGJlZW4gc2V0IGluIHRoZSBjb250ZXh0IG9mIGEgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlI2hhc2NvbnRleHRcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzQ29udGV4dChrZXkpIHtcblx0cmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuaGFzKGtleSk7XG59XG5cbi8vIFRPRE8gZmlndXJlIG91dCBpZiB3ZSBzdGlsbCB3YW50IHRvIHN1cHBvcnRcbi8vIHNob3J0aGFuZCBldmVudHMsIG9yIGlmIHdlIHdhbnQgdG8gaW1wbGVtZW50XG4vLyBhIHJlYWwgYnViYmxpbmcgbWVjaGFuaXNtXG4vKipcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqIEBwYXJhbSBldmVudFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWJibGUoY29tcG9uZW50LCBldmVudCkge1xuXHRjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW2V2ZW50LnR5cGVdO1xuXHRpZiAoY2FsbGJhY2tzKSB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goKGZuKSA9PiBmbi5jYWxsKHRoaXMsIGV2ZW50KSk7XG5cdH1cbn1cbiIsICJpbXBvcnQgeyBydW5fYWxsIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBjdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnLi9saWZlY3ljbGUuanMnO1xuXG5leHBvcnQgY29uc3QgZGlydHlfY29tcG9uZW50cyA9IFtdO1xuZXhwb3J0IGNvbnN0IGludHJvcyA9IHsgZW5hYmxlZDogZmFsc2UgfTtcbmV4cG9ydCBjb25zdCBiaW5kaW5nX2NhbGxiYWNrcyA9IFtdO1xuXG5sZXQgcmVuZGVyX2NhbGxiYWNrcyA9IFtdO1xuXG5jb25zdCBmbHVzaF9jYWxsYmFja3MgPSBbXTtcblxuY29uc3QgcmVzb2x2ZWRfcHJvbWlzZSA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKTtcblxubGV0IHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjaGVkdWxlX3VwZGF0ZSgpIHtcblx0aWYgKCF1cGRhdGVfc2NoZWR1bGVkKSB7XG5cdFx0dXBkYXRlX3NjaGVkdWxlZCA9IHRydWU7XG5cdFx0cmVzb2x2ZWRfcHJvbWlzZS50aGVuKGZsdXNoKTtcblx0fVxufVxuXG4vKiogQHJldHVybnMge1Byb21pc2U8dm9pZD59ICovXG5leHBvcnQgZnVuY3Rpb24gdGljaygpIHtcblx0c2NoZWR1bGVfdXBkYXRlKCk7XG5cdHJldHVybiByZXNvbHZlZF9wcm9taXNlO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX3JlbmRlcl9jYWxsYmFjayhmbikge1xuXHRyZW5kZXJfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX2ZsdXNoX2NhbGxiYWNrKGZuKSB7XG5cdGZsdXNoX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cblxuLy8gZmx1c2goKSBjYWxscyBjYWxsYmFja3MgaW4gdGhpcyBvcmRlcjpcbi8vIDEuIEFsbCBiZWZvcmVVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW5cbi8vIDIuIEFsbCBiaW5kOnRoaXMgY2FsbGJhY2tzLCBpbiByZXZlcnNlIG9yZGVyOiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cy5cbi8vIDMuIEFsbCBhZnRlclVwZGF0ZSBjYWxsYmFja3MsIGluIG9yZGVyOiBwYXJlbnRzIGJlZm9yZSBjaGlsZHJlbi4gRVhDRVBUXG4vLyAgICBmb3IgYWZ0ZXJVcGRhdGVzIGNhbGxlZCBkdXJpbmcgdGhlIGluaXRpYWwgb25Nb3VudCwgd2hpY2ggYXJlIGNhbGxlZCBpblxuLy8gICAgcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyBTaW5jZSBjYWxsYmFja3MgbWlnaHQgdXBkYXRlIGNvbXBvbmVudCB2YWx1ZXMsIHdoaWNoIGNvdWxkIHRyaWdnZXIgYW5vdGhlclxuLy8gY2FsbCB0byBmbHVzaCgpLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGd1YXJkIGFnYWluc3QgdGhpczpcbi8vIDEuIER1cmluZyBiZWZvcmVVcGRhdGUsIGFueSB1cGRhdGVkIGNvbXBvbmVudHMgd2lsbCBiZSBhZGRlZCB0byB0aGVcbi8vICAgIGRpcnR5X2NvbXBvbmVudHMgYXJyYXkgYW5kIHdpbGwgY2F1c2UgYSByZWVudHJhbnQgY2FsbCB0byBmbHVzaCgpLiBCZWNhdXNlXG4vLyAgICB0aGUgZmx1c2ggaW5kZXggaXMga2VwdCBvdXRzaWRlIHRoZSBmdW5jdGlvbiwgdGhlIHJlZW50cmFudCBjYWxsIHdpbGwgcGlja1xuLy8gICAgdXAgd2hlcmUgdGhlIGVhcmxpZXIgY2FsbCBsZWZ0IG9mZiBhbmQgZ28gdGhyb3VnaCBhbGwgZGlydHkgY29tcG9uZW50cy4gVGhlXG4vLyAgICBjdXJyZW50X2NvbXBvbmVudCB2YWx1ZSBpcyBzYXZlZCBhbmQgcmVzdG9yZWQgc28gdGhhdCB0aGUgcmVlbnRyYW50IGNhbGwgd2lsbFxuLy8gICAgbm90IGludGVyZmVyZSB3aXRoIHRoZSBcInBhcmVudFwiIGZsdXNoKCkgY2FsbC5cbi8vIDIuIGJpbmQ6dGhpcyBjYWxsYmFja3MgY2Fubm90IHRyaWdnZXIgbmV3IGZsdXNoKCkgY2FsbHMuXG4vLyAzLiBEdXJpbmcgYWZ0ZXJVcGRhdGUsIGFueSB1cGRhdGVkIGNvbXBvbmVudHMgd2lsbCBOT1QgaGF2ZSB0aGVpciBhZnRlclVwZGF0ZVxuLy8gICAgY2FsbGJhY2sgY2FsbGVkIGEgc2Vjb25kIHRpbWU7IHRoZSBzZWVuX2NhbGxiYWNrcyBzZXQsIG91dHNpZGUgdGhlIGZsdXNoKClcbi8vICAgIGZ1bmN0aW9uLCBndWFyYW50ZWVzIHRoaXMgYmVoYXZpb3IuXG5jb25zdCBzZWVuX2NhbGxiYWNrcyA9IG5ldyBTZXQoKTtcblxubGV0IGZsdXNoaWR4ID0gMDsgLy8gRG8gKm5vdCogbW92ZSB0aGlzIGluc2lkZSB0aGUgZmx1c2goKSBmdW5jdGlvblxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZmx1c2goKSB7XG5cdC8vIERvIG5vdCByZWVudGVyIGZsdXNoIHdoaWxlIGRpcnR5IGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGFzIHRoaXMgY2FuXG5cdC8vIHJlc3VsdCBpbiBhbiBpbmZpbml0ZSBsb29wLiBJbnN0ZWFkLCBsZXQgdGhlIGlubmVyIGZsdXNoIGhhbmRsZSBpdC5cblx0Ly8gUmVlbnRyYW5jeSBpcyBvayBhZnRlcndhcmRzIGZvciBiaW5kaW5ncyBldGMuXG5cdGlmIChmbHVzaGlkeCAhPT0gMCkge1xuXHRcdHJldHVybjtcblx0fVxuXHRjb25zdCBzYXZlZF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcblx0ZG8ge1xuXHRcdC8vIGZpcnN0LCBjYWxsIGJlZm9yZVVwZGF0ZSBmdW5jdGlvbnNcblx0XHQvLyBhbmQgdXBkYXRlIGNvbXBvbmVudHNcblx0XHR0cnkge1xuXHRcdFx0d2hpbGUgKGZsdXNoaWR4IDwgZGlydHlfY29tcG9uZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0Y29uc3QgY29tcG9uZW50ID0gZGlydHlfY29tcG9uZW50c1tmbHVzaGlkeF07XG5cdFx0XHRcdGZsdXNoaWR4Kys7XG5cdFx0XHRcdHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuXHRcdFx0XHR1cGRhdGUoY29tcG9uZW50LiQkKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHQvLyByZXNldCBkaXJ0eSBzdGF0ZSB0byBub3QgZW5kIHVwIGluIGEgZGVhZGxvY2tlZCBzdGF0ZSBhbmQgdGhlbiByZXRocm93XG5cdFx0XHRkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG5cdFx0XHRmbHVzaGlkeCA9IDA7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblx0XHRzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG5cdFx0ZGlydHlfY29tcG9uZW50cy5sZW5ndGggPSAwO1xuXHRcdGZsdXNoaWR4ID0gMDtcblx0XHR3aGlsZSAoYmluZGluZ19jYWxsYmFja3MubGVuZ3RoKSBiaW5kaW5nX2NhbGxiYWNrcy5wb3AoKSgpO1xuXHRcdC8vIHRoZW4sIG9uY2UgY29tcG9uZW50cyBhcmUgdXBkYXRlZCwgY2FsbFxuXHRcdC8vIGFmdGVyVXBkYXRlIGZ1bmN0aW9ucy4gVGhpcyBtYXkgY2F1c2Vcblx0XHQvLyBzdWJzZXF1ZW50IHVwZGF0ZXMuLi5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdGNvbnN0IGNhbGxiYWNrID0gcmVuZGVyX2NhbGxiYWNrc1tpXTtcblx0XHRcdGlmICghc2Vlbl9jYWxsYmFja3MuaGFzKGNhbGxiYWNrKSkge1xuXHRcdFx0XHQvLyAuLi5zbyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGxvb3BzXG5cdFx0XHRcdHNlZW5fY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoID0gMDtcblx0fSB3aGlsZSAoZGlydHlfY29tcG9uZW50cy5sZW5ndGgpO1xuXHR3aGlsZSAoZmx1c2hfY2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdGZsdXNoX2NhbGxiYWNrcy5wb3AoKSgpO1xuXHR9XG5cdHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcblx0c2Vlbl9jYWxsYmFja3MuY2xlYXIoKTtcblx0c2V0X2N1cnJlbnRfY29tcG9uZW50KHNhdmVkX2NvbXBvbmVudCk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmZ1bmN0aW9uIHVwZGF0ZSgkJCkge1xuXHRpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcblx0XHQkJC51cGRhdGUoKTtcblx0XHRydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuXHRcdGNvbnN0IGRpcnR5ID0gJCQuZGlydHk7XG5cdFx0JCQuZGlydHkgPSBbLTFdO1xuXHRcdCQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LnAoJCQuY3R4LCBkaXJ0eSk7XG5cdFx0JCQuYWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG5cdH1cbn1cblxuLyoqXG4gKiBVc2VmdWwgZm9yIGV4YW1wbGUgdG8gZXhlY3V0ZSByZW1haW5pbmcgYGFmdGVyVXBkYXRlYCBjYWxsYmFja3MgYmVmb3JlIGV4ZWN1dGluZyBgZGVzdHJveWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uW119IGZuc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaF9yZW5kZXJfY2FsbGJhY2tzKGZucykge1xuXHRjb25zdCBmaWx0ZXJlZCA9IFtdO1xuXHRjb25zdCB0YXJnZXRzID0gW107XG5cdHJlbmRlcl9jYWxsYmFja3MuZm9yRWFjaCgoYykgPT4gKGZucy5pbmRleE9mKGMpID09PSAtMSA/IGZpbHRlcmVkLnB1c2goYykgOiB0YXJnZXRzLnB1c2goYykpKTtcblx0dGFyZ2V0cy5mb3JFYWNoKChjKSA9PiBjKCkpO1xuXHRyZW5kZXJfY2FsbGJhY2tzID0gZmlsdGVyZWQ7XG59XG4iLCAiaW1wb3J0IHsgaWRlbnRpdHkgYXMgbGluZWFyLCBpc19mdW5jdGlvbiwgbm9vcCwgcnVuX2FsbCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgbm93IH0gZnJvbSAnLi9lbnZpcm9ubWVudC5qcyc7XG5pbXBvcnQgeyBsb29wIH0gZnJvbSAnLi9sb29wLmpzJztcbmltcG9ydCB7IGNyZWF0ZV9ydWxlLCBkZWxldGVfcnVsZSB9IGZyb20gJy4vc3R5bGVfbWFuYWdlci5qcyc7XG5pbXBvcnQgeyBjdXN0b21fZXZlbnQgfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyBhZGRfcmVuZGVyX2NhbGxiYWNrIH0gZnJvbSAnLi9zY2hlZHVsZXIuanMnO1xuXG4vKipcbiAqIEB0eXBlIHtQcm9taXNlPHZvaWQ+IHwgbnVsbH1cbiAqL1xubGV0IHByb21pc2U7XG5cbi8qKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmZ1bmN0aW9uIHdhaXQoKSB7XG5cdGlmICghcHJvbWlzZSkge1xuXHRcdHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcblx0XHRwcm9taXNlLnRoZW4oKCkgPT4ge1xuXHRcdFx0cHJvbWlzZSA9IG51bGw7XG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIHByb21pc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0lOVFJPIHwgT1VUUk8gfCBib29sZWFufSBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7J3N0YXJ0JyB8ICdlbmQnfSBraW5kXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZGlzcGF0Y2gobm9kZSwgZGlyZWN0aW9uLCBraW5kKSB7XG5cdG5vZGUuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQoYCR7ZGlyZWN0aW9uID8gJ2ludHJvJyA6ICdvdXRybyd9JHtraW5kfWApKTtcbn1cblxuY29uc3Qgb3V0cm9pbmcgPSBuZXcgU2V0KCk7XG5cbi8qKlxuICogQHR5cGUge091dHJvfVxuICovXG5sZXQgb3V0cm9zO1xuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwX291dHJvcygpIHtcblx0b3V0cm9zID0ge1xuXHRcdHI6IDAsXG5cdFx0YzogW10sXG5cdFx0cDogb3V0cm9zIC8vIHBhcmVudCBncm91cFxuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrX291dHJvcygpIHtcblx0aWYgKCFvdXRyb3Mucikge1xuXHRcdHJ1bl9hbGwob3V0cm9zLmMpO1xuXHR9XG5cdG91dHJvcyA9IG91dHJvcy5wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5GcmFnbWVudH0gYmxvY2tcbiAqIEBwYXJhbSB7MCB8IDF9IFtsb2NhbF1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNpdGlvbl9pbihibG9jaywgbG9jYWwpIHtcblx0aWYgKGJsb2NrICYmIGJsb2NrLmkpIHtcblx0XHRvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuXHRcdGJsb2NrLmkobG9jYWwpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLkZyYWdtZW50fSBibG9ja1xuICogQHBhcmFtIHswIHwgMX0gbG9jYWxcbiAqIEBwYXJhbSB7MCB8IDF9IFtkZXRhY2hdXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja11cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNpdGlvbl9vdXQoYmxvY2ssIGxvY2FsLCBkZXRhY2gsIGNhbGxiYWNrKSB7XG5cdGlmIChibG9jayAmJiBibG9jay5vKSB7XG5cdFx0aWYgKG91dHJvaW5nLmhhcyhibG9jaykpIHJldHVybjtcblx0XHRvdXRyb2luZy5hZGQoYmxvY2spO1xuXHRcdG91dHJvcy5jLnB1c2goKCkgPT4ge1xuXHRcdFx0b3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcblx0XHRcdGlmIChjYWxsYmFjaykge1xuXHRcdFx0XHRpZiAoZGV0YWNoKSBibG9jay5kKDEpO1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGJsb2NrLm8obG9jYWwpO1xuXHR9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG5cdFx0Y2FsbGJhY2soKTtcblx0fVxufVxuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoJy4uL3RyYW5zaXRpb24vcHVibGljLmpzJykuVHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuY29uc3QgbnVsbF90cmFuc2l0aW9uID0geyBkdXJhdGlvbjogMCB9O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHtUcmFuc2l0aW9uRm59IGZuXG4gKiBAcGFyYW0ge2FueX0gcGFyYW1zXG4gKiBAcmV0dXJucyB7eyBzdGFydCgpOiB2b2lkOyBpbnZhbGlkYXRlKCk6IHZvaWQ7IGVuZCgpOiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2luX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuXHQvKipcblx0ICogQHR5cGUge1RyYW5zaXRpb25PcHRpb25zfSAqL1xuXHRjb25zdCBvcHRpb25zID0geyBkaXJlY3Rpb246ICdpbicgfTtcblx0bGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcywgb3B0aW9ucyk7XG5cdGxldCBydW5uaW5nID0gZmFsc2U7XG5cdGxldCBhbmltYXRpb25fbmFtZTtcblx0bGV0IHRhc2s7XG5cdGxldCB1aWQgPSAwO1xuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gY2xlYW51cCgpIHtcblx0XHRpZiAoYW5pbWF0aW9uX25hbWUpIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gZ28oKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0ZGVsYXkgPSAwLFxuXHRcdFx0ZHVyYXRpb24gPSAzMDAsXG5cdFx0XHRlYXNpbmcgPSBsaW5lYXIsXG5cdFx0XHR0aWNrID0gbm9vcCxcblx0XHRcdGNzc1xuXHRcdH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuXHRcdGlmIChjc3MpIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcywgdWlkKyspO1xuXHRcdHRpY2soMCwgMSk7XG5cdFx0Y29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG5cdFx0Y29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG5cdFx0aWYgKHRhc2spIHRhc2suYWJvcnQoKTtcblx0XHRydW5uaW5nID0gdHJ1ZTtcblx0XHRhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIHRydWUsICdzdGFydCcpKTtcblx0XHR0YXNrID0gbG9vcCgobm93KSA9PiB7XG5cdFx0XHRpZiAocnVubmluZykge1xuXHRcdFx0XHRpZiAobm93ID49IGVuZF90aW1lKSB7XG5cdFx0XHRcdFx0dGljaygxLCAwKTtcblx0XHRcdFx0XHRkaXNwYXRjaChub2RlLCB0cnVlLCAnZW5kJyk7XG5cdFx0XHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0XHRcdHJldHVybiAocnVubmluZyA9IGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcblx0XHRcdFx0XHRjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0XHR0aWNrKHQsIDEgLSB0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJ1bm5pbmc7XG5cdFx0fSk7XG5cdH1cblx0bGV0IHN0YXJ0ZWQgPSBmYWxzZTtcblx0cmV0dXJuIHtcblx0XHRzdGFydCgpIHtcblx0XHRcdGlmIChzdGFydGVkKSByZXR1cm47XG5cdFx0XHRzdGFydGVkID0gdHJ1ZTtcblx0XHRcdGRlbGV0ZV9ydWxlKG5vZGUpO1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcblx0XHRcdFx0Y29uZmlnID0gY29uZmlnKG9wdGlvbnMpO1xuXHRcdFx0XHR3YWl0KCkudGhlbihnbyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRnbygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aW52YWxpZGF0ZSgpIHtcblx0XHRcdHN0YXJ0ZWQgPSBmYWxzZTtcblx0XHR9LFxuXHRcdGVuZCgpIHtcblx0XHRcdGlmIChydW5uaW5nKSB7XG5cdFx0XHRcdGNsZWFudXAoKTtcblx0XHRcdFx0cnVubmluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7VHJhbnNpdGlvbkZufSBmblxuICogQHBhcmFtIHthbnl9IHBhcmFtc1xuICogQHJldHVybnMge3sgZW5kKHJlc2V0OiBhbnkpOiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX291dF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcblx0LyoqIEB0eXBlIHtUcmFuc2l0aW9uT3B0aW9uc30gKi9cblx0Y29uc3Qgb3B0aW9ucyA9IHsgZGlyZWN0aW9uOiAnb3V0JyB9O1xuXHRsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zLCBvcHRpb25zKTtcblx0bGV0IHJ1bm5pbmcgPSB0cnVlO1xuXHRsZXQgYW5pbWF0aW9uX25hbWU7XG5cdGNvbnN0IGdyb3VwID0gb3V0cm9zO1xuXHRncm91cC5yICs9IDE7XG5cdC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblx0bGV0IG9yaWdpbmFsX2luZXJ0X3ZhbHVlO1xuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gZ28oKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0ZGVsYXkgPSAwLFxuXHRcdFx0ZHVyYXRpb24gPSAzMDAsXG5cdFx0XHRlYXNpbmcgPSBsaW5lYXIsXG5cdFx0XHR0aWNrID0gbm9vcCxcblx0XHRcdGNzc1xuXHRcdH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuXG5cdFx0aWYgKGNzcykgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAxLCAwLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcblxuXHRcdGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuXHRcdGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuXHRcdGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdzdGFydCcpKTtcblxuXHRcdGlmICgnaW5lcnQnIGluIG5vZGUpIHtcblx0XHRcdG9yaWdpbmFsX2luZXJ0X3ZhbHVlID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKG5vZGUpLmluZXJ0O1xuXHRcdFx0bm9kZS5pbmVydCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0bG9vcCgobm93KSA9PiB7XG5cdFx0XHRpZiAocnVubmluZykge1xuXHRcdFx0XHRpZiAobm93ID49IGVuZF90aW1lKSB7XG5cdFx0XHRcdFx0dGljaygwLCAxKTtcblx0XHRcdFx0XHRkaXNwYXRjaChub2RlLCBmYWxzZSwgJ2VuZCcpO1xuXHRcdFx0XHRcdGlmICghLS1ncm91cC5yKSB7XG5cdFx0XHRcdFx0XHQvLyB0aGlzIHdpbGwgcmVzdWx0IGluIGBlbmQoKWAgYmVpbmcgY2FsbGVkLFxuXHRcdFx0XHRcdFx0Ly8gc28gd2UgZG9uJ3QgbmVlZCB0byBjbGVhbiB1cCBoZXJlXG5cdFx0XHRcdFx0XHRydW5fYWxsKGdyb3VwLmMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG5cdFx0XHRcdFx0Y29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG5cdFx0XHRcdFx0dGljaygxIC0gdCwgdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBydW5uaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcblx0XHR3YWl0KCkudGhlbigoKSA9PiB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRjb25maWcgPSBjb25maWcob3B0aW9ucyk7XG5cdFx0XHRnbygpO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdGdvKCk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGVuZChyZXNldCkge1xuXHRcdFx0aWYgKHJlc2V0ICYmICdpbmVydCcgaW4gbm9kZSkge1xuXHRcdFx0XHRub2RlLmluZXJ0ID0gb3JpZ2luYWxfaW5lcnRfdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAocmVzZXQgJiYgY29uZmlnLnRpY2spIHtcblx0XHRcdFx0Y29uZmlnLnRpY2soMSwgMCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAocnVubmluZykge1xuXHRcdFx0XHRpZiAoYW5pbWF0aW9uX25hbWUpIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcblx0XHRcdFx0cnVubmluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7VHJhbnNpdGlvbkZufSBmblxuICogQHBhcmFtIHthbnl9IHBhcmFtc1xuICogQHBhcmFtIHtib29sZWFufSBpbnRyb1xuICogQHJldHVybnMge3sgcnVuKGI6IDAgfCAxKTogdm9pZDsgZW5kKCk6IHZvaWQ7IH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMsIGludHJvKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7VHJhbnNpdGlvbk9wdGlvbnN9ICovXG5cdGNvbnN0IG9wdGlvbnMgPSB7IGRpcmVjdGlvbjogJ2JvdGgnIH07XG5cdGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMsIG9wdGlvbnMpO1xuXHRsZXQgdCA9IGludHJvID8gMCA6IDE7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtQcm9ncmFtIHwgbnVsbH0gKi9cblx0bGV0IHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHtQZW5kaW5nUHJvZ3JhbSB8IG51bGx9ICovXG5cdGxldCBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuXHRsZXQgYW5pbWF0aW9uX25hbWUgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblx0bGV0IG9yaWdpbmFsX2luZXJ0X3ZhbHVlO1xuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gY2xlYXJfYW5pbWF0aW9uKCkge1xuXHRcdGlmIChhbmltYXRpb25fbmFtZSkgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7UGVuZGluZ1Byb2dyYW19IHByb2dyYW1cblx0ICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXG5cdCAqIEByZXR1cm5zIHtQcm9ncmFtfVxuXHQgKi9cblx0ZnVuY3Rpb24gaW5pdChwcm9ncmFtLCBkdXJhdGlvbikge1xuXHRcdGNvbnN0IGQgPSAvKiogQHR5cGUge1Byb2dyYW1bJ2QnXX0gKi8gKHByb2dyYW0uYiAtIHQpO1xuXHRcdGR1cmF0aW9uICo9IE1hdGguYWJzKGQpO1xuXHRcdHJldHVybiB7XG5cdFx0XHRhOiB0LFxuXHRcdFx0YjogcHJvZ3JhbS5iLFxuXHRcdFx0ZCxcblx0XHRcdGR1cmF0aW9uLFxuXHRcdFx0c3RhcnQ6IHByb2dyYW0uc3RhcnQsXG5cdFx0XHRlbmQ6IHByb2dyYW0uc3RhcnQgKyBkdXJhdGlvbixcblx0XHRcdGdyb3VwOiBwcm9ncmFtLmdyb3VwXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0lOVFJPIHwgT1VUUk99IGJcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRmdW5jdGlvbiBnbyhiKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0ZGVsYXkgPSAwLFxuXHRcdFx0ZHVyYXRpb24gPSAzMDAsXG5cdFx0XHRlYXNpbmcgPSBsaW5lYXIsXG5cdFx0XHR0aWNrID0gbm9vcCxcblx0XHRcdGNzc1xuXHRcdH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1BlbmRpbmdQcm9ncmFtfSAqL1xuXHRcdGNvbnN0IHByb2dyYW0gPSB7XG5cdFx0XHRzdGFydDogbm93KCkgKyBkZWxheSxcblx0XHRcdGJcblx0XHR9O1xuXG5cdFx0aWYgKCFiKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuXHRcdFx0cHJvZ3JhbS5ncm91cCA9IG91dHJvcztcblx0XHRcdG91dHJvcy5yICs9IDE7XG5cdFx0fVxuXG5cdFx0aWYgKCdpbmVydCcgaW4gbm9kZSkge1xuXHRcdFx0aWYgKGIpIHtcblx0XHRcdFx0aWYgKG9yaWdpbmFsX2luZXJ0X3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvLyBhYm9ydGVkL3JldmVyc2VkIG91dHJvIFx1MjAxNCByZXN0b3JlIHByZXZpb3VzIGluZXJ0IHZhbHVlXG5cdFx0XHRcdFx0bm9kZS5pbmVydCA9IG9yaWdpbmFsX2luZXJ0X3ZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcmlnaW5hbF9pbmVydF92YWx1ZSA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChub2RlKS5pbmVydDtcblx0XHRcdFx0bm9kZS5pbmVydCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pIHtcblx0XHRcdHBlbmRpbmdfcHJvZ3JhbSA9IHByb2dyYW07XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGlmIHRoaXMgaXMgYW4gaW50cm8sIGFuZCB0aGVyZSdzIGEgZGVsYXksIHdlIG5lZWQgdG8gZG9cblx0XHRcdC8vIGFuIGluaXRpYWwgdGljayBhbmQvb3IgYXBwbHkgQ1NTIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuXHRcdFx0aWYgKGNzcykge1xuXHRcdFx0XHRjbGVhcl9hbmltYXRpb24oKTtcblx0XHRcdFx0YW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCB0LCBiLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcblx0XHRcdH1cblx0XHRcdGlmIChiKSB0aWNrKDAsIDEpO1xuXHRcdFx0cnVubmluZ19wcm9ncmFtID0gaW5pdChwcm9ncmFtLCBkdXJhdGlvbik7XG5cdFx0XHRhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGIsICdzdGFydCcpKTtcblx0XHRcdGxvb3AoKG5vdykgPT4ge1xuXHRcdFx0XHRpZiAocGVuZGluZ19wcm9ncmFtICYmIG5vdyA+IHBlbmRpbmdfcHJvZ3JhbS5zdGFydCkge1xuXHRcdFx0XHRcdHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocGVuZGluZ19wcm9ncmFtLCBkdXJhdGlvbik7XG5cdFx0XHRcdFx0cGVuZGluZ19wcm9ncmFtID0gbnVsbDtcblx0XHRcdFx0XHRkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ3N0YXJ0Jyk7XG5cdFx0XHRcdFx0aWYgKGNzcykge1xuXHRcdFx0XHRcdFx0Y2xlYXJfYW5pbWF0aW9uKCk7XG5cdFx0XHRcdFx0XHRhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKFxuXHRcdFx0XHRcdFx0XHRub2RlLFxuXHRcdFx0XHRcdFx0XHR0LFxuXHRcdFx0XHRcdFx0XHRydW5uaW5nX3Byb2dyYW0uYixcblx0XHRcdFx0XHRcdFx0cnVubmluZ19wcm9ncmFtLmR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRlYXNpbmcsXG5cdFx0XHRcdFx0XHRcdGNvbmZpZy5jc3Ncblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChydW5uaW5nX3Byb2dyYW0pIHtcblx0XHRcdFx0XHRpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5lbmQpIHtcblx0XHRcdFx0XHRcdHRpY2soKHQgPSBydW5uaW5nX3Byb2dyYW0uYiksIDEgLSB0KTtcblx0XHRcdFx0XHRcdGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnZW5kJyk7XG5cdFx0XHRcdFx0XHRpZiAoIXBlbmRpbmdfcHJvZ3JhbSkge1xuXHRcdFx0XHRcdFx0XHQvLyB3ZSdyZSBkb25lXG5cdFx0XHRcdFx0XHRcdGlmIChydW5uaW5nX3Byb2dyYW0uYikge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGludHJvIFx1MjAxNCB3ZSBjYW4gdGlkeSB1cCBpbW1lZGlhdGVseVxuXHRcdFx0XHRcdFx0XHRcdGNsZWFyX2FuaW1hdGlvbigpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIG91dHJvIFx1MjAxNCBuZWVkcyB0byBiZSBjb29yZGluYXRlZFxuXHRcdFx0XHRcdFx0XHRcdGlmICghLS1ydW5uaW5nX3Byb2dyYW0uZ3JvdXAucikgcnVuX2FsbChydW5uaW5nX3Byb2dyYW0uZ3JvdXAuYyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLnN0YXJ0KSB7XG5cdFx0XHRcdFx0XHRjb25zdCBwID0gbm93IC0gcnVubmluZ19wcm9ncmFtLnN0YXJ0O1xuXHRcdFx0XHRcdFx0dCA9IHJ1bm5pbmdfcHJvZ3JhbS5hICsgcnVubmluZ19wcm9ncmFtLmQgKiBlYXNpbmcocCAvIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbik7XG5cdFx0XHRcdFx0XHR0aWNrKHQsIDEgLSB0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICEhKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB7XG5cdFx0cnVuKGIpIHtcblx0XHRcdGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG5cdFx0XHRcdHdhaXQoKS50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRjb25zdCBvcHRzID0geyBkaXJlY3Rpb246IGIgPyAnaW4nIDogJ291dCcgfTtcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0Y29uZmlnID0gY29uZmlnKG9wdHMpO1xuXHRcdFx0XHRcdGdvKGIpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdvKGIpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZW5kKCkge1xuXHRcdFx0Y2xlYXJfYW5pbWF0aW9uKCk7XG5cdFx0XHRydW5uaW5nX3Byb2dyYW0gPSBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqIEB0eXBlZGVmIHsxfSBJTlRSTyAqL1xuLyoqIEB0eXBlZGVmIHswfSBPVVRSTyAqL1xuLyoqIEB0eXBlZGVmIHt7IGRpcmVjdGlvbjogJ2luJyB8ICdvdXQnIHwgJ2JvdGgnIH19IFRyYW5zaXRpb25PcHRpb25zICovXG4vKiogQHR5cGVkZWYgeyhub2RlOiBFbGVtZW50LCBwYXJhbXM6IGFueSwgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMpID0+IGltcG9ydCgnLi4vdHJhbnNpdGlvbi9wdWJsaWMuanMnKS5UcmFuc2l0aW9uQ29uZmlnfSBUcmFuc2l0aW9uRm4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPdXRyb1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb25bXX0gY1xuICogQHByb3BlcnR5IHtPYmplY3R9IHBcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBlbmRpbmdQcm9ncmFtXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RhcnRcbiAqIEBwcm9wZXJ0eSB7SU5UUk98T1VUUk99IGJcbiAqIEBwcm9wZXJ0eSB7T3V0cm99IFtncm91cF1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFByb2dyYW1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhXG4gKiBAcHJvcGVydHkge0lOVFJPfE9VVFJPfSBiXG4gKiBAcHJvcGVydHkgezF8LTF9IGRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZW5kXG4gKiBAcHJvcGVydHkge091dHJvfSBbZ3JvdXBdXG4gKi9cbiIsICJpbXBvcnQgeyB0cmFuc2l0aW9uX2luLCB0cmFuc2l0aW9uX291dCB9IGZyb20gJy4vdHJhbnNpdGlvbnMuanMnO1xuaW1wb3J0IHsgcnVuX2FsbCB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG4vLyBnZW5lcmFsIGVhY2ggZnVuY3Rpb25zOlxuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlX2FycmF5X2xpa2UoYXJyYXlfbGlrZV9vcl9pdGVyYXRvcikge1xuXHRyZXR1cm4gYXJyYXlfbGlrZV9vcl9pdGVyYXRvcj8ubGVuZ3RoICE9PSB1bmRlZmluZWRcblx0XHQ/IGFycmF5X2xpa2Vfb3JfaXRlcmF0b3Jcblx0XHQ6IEFycmF5LmZyb20oYXJyYXlfbGlrZV9vcl9pdGVyYXRvcik7XG59XG5cbi8vIGtleWVkIGVhY2ggZnVuY3Rpb25zOlxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG5cdGJsb2NrLmQoMSk7XG5cdGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcblx0dHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcblx0XHRsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG5cdH0pO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZml4X2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcblx0YmxvY2suZigpO1xuXHRkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG5cdGJsb2NrLmYoKTtcblx0b3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5cbi8qKiBAcmV0dXJucyB7YW55W119ICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX2tleWVkX2VhY2goXG5cdG9sZF9ibG9ja3MsXG5cdGRpcnR5LFxuXHRnZXRfa2V5LFxuXHRkeW5hbWljLFxuXHRjdHgsXG5cdGxpc3QsXG5cdGxvb2t1cCxcblx0bm9kZSxcblx0ZGVzdHJveSxcblx0Y3JlYXRlX2VhY2hfYmxvY2ssXG5cdG5leHQsXG5cdGdldF9jb250ZXh0XG4pIHtcblx0bGV0IG8gPSBvbGRfYmxvY2tzLmxlbmd0aDtcblx0bGV0IG4gPSBsaXN0Lmxlbmd0aDtcblx0bGV0IGkgPSBvO1xuXHRjb25zdCBvbGRfaW5kZXhlcyA9IHt9O1xuXHR3aGlsZSAoaS0tKSBvbGRfaW5kZXhlc1tvbGRfYmxvY2tzW2ldLmtleV0gPSBpO1xuXHRjb25zdCBuZXdfYmxvY2tzID0gW107XG5cdGNvbnN0IG5ld19sb29rdXAgPSBuZXcgTWFwKCk7XG5cdGNvbnN0IGRlbHRhcyA9IG5ldyBNYXAoKTtcblx0Y29uc3QgdXBkYXRlcyA9IFtdO1xuXHRpID0gbjtcblx0d2hpbGUgKGktLSkge1xuXHRcdGNvbnN0IGNoaWxkX2N0eCA9IGdldF9jb250ZXh0KGN0eCwgbGlzdCwgaSk7XG5cdFx0Y29uc3Qga2V5ID0gZ2V0X2tleShjaGlsZF9jdHgpO1xuXHRcdGxldCBibG9jayA9IGxvb2t1cC5nZXQoa2V5KTtcblx0XHRpZiAoIWJsb2NrKSB7XG5cdFx0XHRibG9jayA9IGNyZWF0ZV9lYWNoX2Jsb2NrKGtleSwgY2hpbGRfY3R4KTtcblx0XHRcdGJsb2NrLmMoKTtcblx0XHR9IGVsc2UgaWYgKGR5bmFtaWMpIHtcblx0XHRcdC8vIGRlZmVyIHVwZGF0ZXMgdW50aWwgYWxsIHRoZSBET00gc2h1ZmZsaW5nIGlzIGRvbmVcblx0XHRcdHVwZGF0ZXMucHVzaCgoKSA9PiBibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpKTtcblx0XHR9XG5cdFx0bmV3X2xvb2t1cC5zZXQoa2V5LCAobmV3X2Jsb2Nrc1tpXSA9IGJsb2NrKSk7XG5cdFx0aWYgKGtleSBpbiBvbGRfaW5kZXhlcykgZGVsdGFzLnNldChrZXksIE1hdGguYWJzKGkgLSBvbGRfaW5kZXhlc1trZXldKSk7XG5cdH1cblx0Y29uc3Qgd2lsbF9tb3ZlID0gbmV3IFNldCgpO1xuXHRjb25zdCBkaWRfbW92ZSA9IG5ldyBTZXQoKTtcblx0LyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuXHRmdW5jdGlvbiBpbnNlcnQoYmxvY2spIHtcblx0XHR0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcblx0XHRibG9jay5tKG5vZGUsIG5leHQpO1xuXHRcdGxvb2t1cC5zZXQoYmxvY2sua2V5LCBibG9jayk7XG5cdFx0bmV4dCA9IGJsb2NrLmZpcnN0O1xuXHRcdG4tLTtcblx0fVxuXHR3aGlsZSAobyAmJiBuKSB7XG5cdFx0Y29uc3QgbmV3X2Jsb2NrID0gbmV3X2Jsb2Nrc1tuIC0gMV07XG5cdFx0Y29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvIC0gMV07XG5cdFx0Y29uc3QgbmV3X2tleSA9IG5ld19ibG9jay5rZXk7XG5cdFx0Y29uc3Qgb2xkX2tleSA9IG9sZF9ibG9jay5rZXk7XG5cdFx0aWYgKG5ld19ibG9jayA9PT0gb2xkX2Jsb2NrKSB7XG5cdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRuZXh0ID0gbmV3X2Jsb2NrLmZpcnN0O1xuXHRcdFx0by0tO1xuXHRcdFx0bi0tO1xuXHRcdH0gZWxzZSBpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9rZXkpKSB7XG5cdFx0XHQvLyByZW1vdmUgb2xkIGJsb2NrXG5cdFx0XHRkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcblx0XHRcdG8tLTtcblx0XHR9IGVsc2UgaWYgKCFsb29rdXAuaGFzKG5ld19rZXkpIHx8IHdpbGxfbW92ZS5oYXMobmV3X2tleSkpIHtcblx0XHRcdGluc2VydChuZXdfYmxvY2spO1xuXHRcdH0gZWxzZSBpZiAoZGlkX21vdmUuaGFzKG9sZF9rZXkpKSB7XG5cdFx0XHRvLS07XG5cdFx0fSBlbHNlIGlmIChkZWx0YXMuZ2V0KG5ld19rZXkpID4gZGVsdGFzLmdldChvbGRfa2V5KSkge1xuXHRcdFx0ZGlkX21vdmUuYWRkKG5ld19rZXkpO1xuXHRcdFx0aW5zZXJ0KG5ld19ibG9jayk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbGxfbW92ZS5hZGQob2xkX2tleSk7XG5cdFx0XHRvLS07XG5cdFx0fVxuXHR9XG5cdHdoaWxlIChvLS0pIHtcblx0XHRjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW29dO1xuXHRcdGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2Jsb2NrLmtleSkpIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuXHR9XG5cdHdoaWxlIChuKSBpbnNlcnQobmV3X2Jsb2Nrc1tuIC0gMV0pO1xuXHRydW5fYWxsKHVwZGF0ZXMpO1xuXHRyZXR1cm4gbmV3X2Jsb2Nrcztcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX2VhY2hfa2V5cyhjdHgsIGxpc3QsIGdldF9jb250ZXh0LCBnZXRfa2V5KSB7XG5cdGNvbnN0IGtleXMgPSBuZXcgTWFwKCk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGtleSA9IGdldF9rZXkoZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKSk7XG5cdFx0aWYgKGtleXMuaGFzKGtleSkpIHtcblx0XHRcdGxldCB2YWx1ZSA9ICcnO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFsdWUgPSBgd2l0aCB2YWx1ZSAnJHtTdHJpbmcoa2V5KX0nIGA7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdC8vIGNhbid0IHN0cmluZ2lmeVxuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRgQ2Fubm90IGhhdmUgZHVwbGljYXRlIGtleXMgaW4gYSBrZXllZCBlYWNoOiBLZXlzIGF0IGluZGV4ICR7a2V5cy5nZXQoXG5cdFx0XHRcdFx0a2V5XG5cdFx0XHRcdCl9IGFuZCAke2l9ICR7dmFsdWV9YXJlIGR1cGxpY2F0ZXNgXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRrZXlzLnNldChrZXksIGkpO1xuXHR9XG59XG4iLCAiLyoqIEByZXR1cm5zIHt7fX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfc3ByZWFkX3VwZGF0ZShsZXZlbHMsIHVwZGF0ZXMpIHtcblx0Y29uc3QgdXBkYXRlID0ge307XG5cdGNvbnN0IHRvX251bGxfb3V0ID0ge307XG5cdGNvbnN0IGFjY291bnRlZF9mb3IgPSB7ICQkc2NvcGU6IDEgfTtcblx0bGV0IGkgPSBsZXZlbHMubGVuZ3RoO1xuXHR3aGlsZSAoaS0tKSB7XG5cdFx0Y29uc3QgbyA9IGxldmVsc1tpXTtcblx0XHRjb25zdCBuID0gdXBkYXRlc1tpXTtcblx0XHRpZiAobikge1xuXHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gbykge1xuXHRcdFx0XHRpZiAoIShrZXkgaW4gbikpIHRvX251bGxfb3V0W2tleV0gPSAxO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gbikge1xuXHRcdFx0XHRpZiAoIWFjY291bnRlZF9mb3Jba2V5XSkge1xuXHRcdFx0XHRcdHVwZGF0ZVtrZXldID0gbltrZXldO1xuXHRcdFx0XHRcdGFjY291bnRlZF9mb3Jba2V5XSA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxldmVsc1tpXSA9IG47XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoY29uc3Qga2V5IGluIG8pIHtcblx0XHRcdFx0YWNjb3VudGVkX2ZvcltrZXldID0gMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Zm9yIChjb25zdCBrZXkgaW4gdG9fbnVsbF9vdXQpIHtcblx0XHRpZiAoIShrZXkgaW4gdXBkYXRlKSkgdXBkYXRlW2tleV0gPSB1bmRlZmluZWQ7XG5cdH1cblx0cmV0dXJuIHVwZGF0ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldF9zcHJlYWRfb2JqZWN0KHNwcmVhZF9wcm9wcykge1xuXHRyZXR1cm4gdHlwZW9mIHNwcmVhZF9wcm9wcyA9PT0gJ29iamVjdCcgJiYgc3ByZWFkX3Byb3BzICE9PSBudWxsID8gc3ByZWFkX3Byb3BzIDoge307XG59XG4iLCAiY29uc3QgX2Jvb2xlYW5fYXR0cmlidXRlcyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG5cdCdhbGxvd2Z1bGxzY3JlZW4nLFxuXHQnYWxsb3dwYXltZW50cmVxdWVzdCcsXG5cdCdhc3luYycsXG5cdCdhdXRvZm9jdXMnLFxuXHQnYXV0b3BsYXknLFxuXHQnY2hlY2tlZCcsXG5cdCdjb250cm9scycsXG5cdCdkZWZhdWx0Jyxcblx0J2RlZmVyJyxcblx0J2Rpc2FibGVkJyxcblx0J2Zvcm1ub3ZhbGlkYXRlJyxcblx0J2hpZGRlbicsXG5cdCdpbmVydCcsXG5cdCdpc21hcCcsXG5cdCdsb29wJyxcblx0J211bHRpcGxlJyxcblx0J211dGVkJyxcblx0J25vbW9kdWxlJyxcblx0J25vdmFsaWRhdGUnLFxuXHQnb3BlbicsXG5cdCdwbGF5c2lubGluZScsXG5cdCdyZWFkb25seScsXG5cdCdyZXF1aXJlZCcsXG5cdCdyZXZlcnNlZCcsXG5cdCdzZWxlY3RlZCdcbl0pO1xuXG4vKipcbiAqIExpc3Qgb2YgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMgKGUuZy4gYDxpbnB1dCBkaXNhYmxlZD5gKS5cbiAqIFNvdXJjZTogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sXG4gKlxuICogQHR5cGUge1NldDxzdHJpbmc+fVxuICovXG5leHBvcnQgY29uc3QgYm9vbGVhbl9hdHRyaWJ1dGVzID0gbmV3IFNldChbLi4uX2Jvb2xlYW5fYXR0cmlidXRlc10pO1xuXG4vKiogQHR5cGVkZWYge3R5cGVvZiBfYm9vbGVhbl9hdHRyaWJ1dGVzW251bWJlcl19IEJvb2xlYW5BdHRyaWJ1dGVzICovXG4iLCAiaW1wb3J0IHtcblx0YWRkX3JlbmRlcl9jYWxsYmFjayxcblx0Zmx1c2gsXG5cdGZsdXNoX3JlbmRlcl9jYWxsYmFja3MsXG5cdHNjaGVkdWxlX3VwZGF0ZSxcblx0ZGlydHlfY29tcG9uZW50c1xufSBmcm9tICcuL3NjaGVkdWxlci5qcyc7XG5pbXBvcnQgeyBjdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnLi9saWZlY3ljbGUuanMnO1xuaW1wb3J0IHsgYmxhbmtfb2JqZWN0LCBpc19lbXB0eSwgaXNfZnVuY3Rpb24sIHJ1biwgcnVuX2FsbCwgbm9vcCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHtcblx0Y2hpbGRyZW4sXG5cdGRldGFjaCxcblx0c3RhcnRfaHlkcmF0aW5nLFxuXHRlbmRfaHlkcmF0aW5nLFxuXHRnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzLFxuXHRpbnNlcnQsXG5cdGVsZW1lbnQsXG5cdGF0dHJcbn0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgdHJhbnNpdGlvbl9pbiB9IGZyb20gJy4vdHJhbnNpdGlvbnMuanMnO1xuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gYmluZChjb21wb25lbnQsIG5hbWUsIGNhbGxiYWNrKSB7XG5cdGNvbnN0IGluZGV4ID0gY29tcG9uZW50LiQkLnByb3BzW25hbWVdO1xuXHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuXHRcdGNvbXBvbmVudC4kJC5ib3VuZFtpbmRleF0gPSBjYWxsYmFjaztcblx0XHRjYWxsYmFjayhjb21wb25lbnQuJCQuY3R4W2luZGV4XSk7XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9jb21wb25lbnQoYmxvY2spIHtcblx0YmxvY2sgJiYgYmxvY2suYygpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fY29tcG9uZW50KGJsb2NrLCBwYXJlbnRfbm9kZXMpIHtcblx0YmxvY2sgJiYgYmxvY2subChwYXJlbnRfbm9kZXMpO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gbW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgdGFyZ2V0LCBhbmNob3IpIHtcblx0Y29uc3QgeyBmcmFnbWVudCwgYWZ0ZXJfdXBkYXRlIH0gPSBjb21wb25lbnQuJCQ7XG5cdGZyYWdtZW50ICYmIGZyYWdtZW50Lm0odGFyZ2V0LCBhbmNob3IpO1xuXHQvLyBvbk1vdW50IGhhcHBlbnMgYmVmb3JlIHRoZSBpbml0aWFsIGFmdGVyVXBkYXRlXG5cdGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4ge1xuXHRcdGNvbnN0IG5ld19vbl9kZXN0cm95ID0gY29tcG9uZW50LiQkLm9uX21vdW50Lm1hcChydW4pLmZpbHRlcihpc19mdW5jdGlvbik7XG5cdFx0Ly8gaWYgdGhlIGNvbXBvbmVudCB3YXMgZGVzdHJveWVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gaXQgd2lsbCB1cGRhdGUgdGhlIGAkJC5vbl9kZXN0cm95YCByZWZlcmVuY2UgdG8gYG51bGxgLlxuXHRcdC8vIHRoZSBkZXN0cnVjdHVyZWQgb25fZGVzdHJveSBtYXkgc3RpbGwgcmVmZXJlbmNlIHRvIHRoZSBvbGQgYXJyYXlcblx0XHRpZiAoY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kpIHtcblx0XHRcdGNvbXBvbmVudC4kJC5vbl9kZXN0cm95LnB1c2goLi4ubmV3X29uX2Rlc3Ryb3kpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBFZGdlIGNhc2UgLSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseSxcblx0XHRcdC8vIG1vc3QgbGlrZWx5IGFzIGEgcmVzdWx0IG9mIGEgYmluZGluZyBpbml0aWFsaXNpbmdcblx0XHRcdHJ1bl9hbGwobmV3X29uX2Rlc3Ryb3kpO1xuXHRcdH1cblx0XHRjb21wb25lbnQuJCQub25fbW91bnQgPSBbXTtcblx0fSk7XG5cdGFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveV9jb21wb25lbnQoY29tcG9uZW50LCBkZXRhY2hpbmcpIHtcblx0Y29uc3QgJCQgPSBjb21wb25lbnQuJCQ7XG5cdGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuXHRcdGZsdXNoX3JlbmRlcl9jYWxsYmFja3MoJCQuYWZ0ZXJfdXBkYXRlKTtcblx0XHRydW5fYWxsKCQkLm9uX2Rlc3Ryb3kpO1xuXHRcdCQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmQoZGV0YWNoaW5nKTtcblx0XHQvLyBUT0RPIG51bGwgb3V0IG90aGVyIHJlZnMsIGluY2x1ZGluZyBjb21wb25lbnQuJCQgKGJ1dCBuZWVkIHRvXG5cdFx0Ly8gcHJlc2VydmUgZmluYWwgc3RhdGU/KVxuXHRcdCQkLm9uX2Rlc3Ryb3kgPSAkJC5mcmFnbWVudCA9IG51bGw7XG5cdFx0JCQuY3R4ID0gW107XG5cdH1cbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZnVuY3Rpb24gbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpIHtcblx0aWYgKGNvbXBvbmVudC4kJC5kaXJ0eVswXSA9PT0gLTEpIHtcblx0XHRkaXJ0eV9jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcblx0XHRzY2hlZHVsZV91cGRhdGUoKTtcblx0XHRjb21wb25lbnQuJCQuZGlydHkuZmlsbCgwKTtcblx0fVxuXHRjb21wb25lbnQuJCQuZGlydHlbKGkgLyAzMSkgfCAwXSB8PSAxIDw8IGkgJSAzMTtcbn1cblxuLy8gVE9ETzogRG9jdW1lbnQgdGhlIG90aGVyIHBhcmFtc1xuLyoqXG4gKiBAcGFyYW0ge1N2ZWx0ZUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5Db21wb25lbnRDb25zdHJ1Y3Rvck9wdGlvbnN9IG9wdGlvbnNcbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi91dGlscy5qcycpWydub3RfZXF1YWwnXX0gbm90X2VxdWFsIFVzZWQgdG8gY29tcGFyZSBwcm9wcyBhbmQgc3RhdGUgdmFsdWVzLlxuICogQHBhcmFtIHsodGFyZ2V0OiBFbGVtZW50IHwgU2hhZG93Um9vdCkgPT4gdm9pZH0gW2FwcGVuZF9zdHlsZXNdIEZ1bmN0aW9uIHRoYXQgYXBwZW5kcyBzdHlsZXMgdG8gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaXMgZmlyc3QgaW5pdGlhbGlzZWQuXG4gKiBUaGlzIHdpbGwgYmUgdGhlIGBhZGRfY3NzYCBmdW5jdGlvbiBmcm9tIHRoZSBjb21waWxlZCBjb21wb25lbnQuXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0KFxuXHRjb21wb25lbnQsXG5cdG9wdGlvbnMsXG5cdGluc3RhbmNlLFxuXHRjcmVhdGVfZnJhZ21lbnQsXG5cdG5vdF9lcXVhbCxcblx0cHJvcHMsXG5cdGFwcGVuZF9zdHlsZXMgPSBudWxsLFxuXHRkaXJ0eSA9IFstMV1cbikge1xuXHRjb25zdCBwYXJlbnRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG5cdHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuVCQkfSAqL1xuXHRjb25zdCAkJCA9IChjb21wb25lbnQuJCQgPSB7XG5cdFx0ZnJhZ21lbnQ6IG51bGwsXG5cdFx0Y3R4OiBbXSxcblx0XHQvLyBzdGF0ZVxuXHRcdHByb3BzLFxuXHRcdHVwZGF0ZTogbm9vcCxcblx0XHRub3RfZXF1YWwsXG5cdFx0Ym91bmQ6IGJsYW5rX29iamVjdCgpLFxuXHRcdC8vIGxpZmVjeWNsZVxuXHRcdG9uX21vdW50OiBbXSxcblx0XHRvbl9kZXN0cm95OiBbXSxcblx0XHRvbl9kaXNjb25uZWN0OiBbXSxcblx0XHRiZWZvcmVfdXBkYXRlOiBbXSxcblx0XHRhZnRlcl91cGRhdGU6IFtdLFxuXHRcdGNvbnRleHQ6IG5ldyBNYXAob3B0aW9ucy5jb250ZXh0IHx8IChwYXJlbnRfY29tcG9uZW50ID8gcGFyZW50X2NvbXBvbmVudC4kJC5jb250ZXh0IDogW10pKSxcblx0XHQvLyBldmVyeXRoaW5nIGVsc2Vcblx0XHRjYWxsYmFja3M6IGJsYW5rX29iamVjdCgpLFxuXHRcdGRpcnR5LFxuXHRcdHNraXBfYm91bmQ6IGZhbHNlLFxuXHRcdHJvb3Q6IG9wdGlvbnMudGFyZ2V0IHx8IHBhcmVudF9jb21wb25lbnQuJCQucm9vdFxuXHR9KTtcblx0YXBwZW5kX3N0eWxlcyAmJiBhcHBlbmRfc3R5bGVzKCQkLnJvb3QpO1xuXHRsZXQgcmVhZHkgPSBmYWxzZTtcblx0JCQuY3R4ID0gaW5zdGFuY2Vcblx0XHQ/IGluc3RhbmNlKGNvbXBvbmVudCwgb3B0aW9ucy5wcm9wcyB8fCB7fSwgKGksIHJldCwgLi4ucmVzdCkgPT4ge1xuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHJlc3QubGVuZ3RoID8gcmVzdFswXSA6IHJldDtcblx0XHRcdFx0aWYgKCQkLmN0eCAmJiBub3RfZXF1YWwoJCQuY3R4W2ldLCAoJCQuY3R4W2ldID0gdmFsdWUpKSkge1xuXHRcdFx0XHRcdGlmICghJCQuc2tpcF9ib3VuZCAmJiAkJC5ib3VuZFtpXSkgJCQuYm91bmRbaV0odmFsdWUpO1xuXHRcdFx0XHRcdGlmIChyZWFkeSkgbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0ICB9KVxuXHRcdDogW107XG5cdCQkLnVwZGF0ZSgpO1xuXHRyZWFkeSA9IHRydWU7XG5cdHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG5cdC8vIGBmYWxzZWAgYXMgYSBzcGVjaWFsIGNhc2Ugb2Ygbm8gRE9NIGNvbXBvbmVudFxuXHQkJC5mcmFnbWVudCA9IGNyZWF0ZV9mcmFnbWVudCA/IGNyZWF0ZV9mcmFnbWVudCgkJC5jdHgpIDogZmFsc2U7XG5cdGlmIChvcHRpb25zLnRhcmdldCkge1xuXHRcdGlmIChvcHRpb25zLmh5ZHJhdGUpIHtcblx0XHRcdHN0YXJ0X2h5ZHJhdGluZygpO1xuXHRcdFx0Ly8gVE9ETzogd2hhdCBpcyB0aGUgY29ycmVjdCB0eXBlIGhlcmU/XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRjb25zdCBub2RlcyA9IGNoaWxkcmVuKG9wdGlvbnMudGFyZ2V0KTtcblx0XHRcdCQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50Lmwobm9kZXMpO1xuXHRcdFx0bm9kZXMuZm9yRWFjaChkZXRhY2gpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuXHRcdFx0JCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuYygpO1xuXHRcdH1cblx0XHRpZiAob3B0aW9ucy5pbnRybykgdHJhbnNpdGlvbl9pbihjb21wb25lbnQuJCQuZnJhZ21lbnQpO1xuXHRcdG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIG9wdGlvbnMudGFyZ2V0LCBvcHRpb25zLmFuY2hvcik7XG5cdFx0ZW5kX2h5ZHJhdGluZygpO1xuXHRcdGZsdXNoKCk7XG5cdH1cblx0c2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xufVxuXG5leHBvcnQgbGV0IFN2ZWx0ZUVsZW1lbnQ7XG5cbmlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcblx0U3ZlbHRlRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuXHRcdC8qKiBUaGUgU3ZlbHRlIGNvbXBvbmVudCBjb25zdHJ1Y3RvciAqL1xuXHRcdCQkY3Rvcjtcblx0XHQvKiogU2xvdHMgKi9cblx0XHQkJHM7XG5cdFx0LyoqIFRoZSBTdmVsdGUgY29tcG9uZW50IGluc3RhbmNlICovXG5cdFx0JCRjO1xuXHRcdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgY3VzdG9tIGVsZW1lbnQgaXMgY29ubmVjdGVkICovXG5cdFx0JCRjbiA9IGZhbHNlO1xuXHRcdC8qKiBDb21wb25lbnQgcHJvcHMgZGF0YSAqL1xuXHRcdCQkZCA9IHt9O1xuXHRcdC8qKiBgdHJ1ZWAgaWYgY3VycmVudGx5IGluIHRoZSBwcm9jZXNzIG9mIHJlZmxlY3RpbmcgY29tcG9uZW50IHByb3BzIGJhY2sgdG8gYXR0cmlidXRlcyAqL1xuXHRcdCQkciA9IGZhbHNlO1xuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uPn0gUHJvcHMgZGVmaW5pdGlvbiAobmFtZSwgcmVmbGVjdGVkLCB0eXBlIGV0YykgKi9cblx0XHQkJHBfZCA9IHt9O1xuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgRnVuY3Rpb25bXT59IEV2ZW50IGxpc3RlbmVycyAqL1xuXHRcdCQkbCA9IHt9O1xuXHRcdC8qKiBAdHlwZSB7TWFwPEZ1bmN0aW9uLCBGdW5jdGlvbj59IEV2ZW50IGxpc3RlbmVyIHVuc3Vic2NyaWJlIGZ1bmN0aW9ucyAqL1xuXHRcdCQkbF91ID0gbmV3IE1hcCgpO1xuXG5cdFx0Y29uc3RydWN0b3IoJCRjb21wb25lbnRDdG9yLCAkJHNsb3RzLCB1c2Vfc2hhZG93X2RvbSkge1xuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMuJCRjdG9yID0gJCRjb21wb25lbnRDdG9yO1xuXHRcdFx0dGhpcy4kJHMgPSAkJHNsb3RzO1xuXHRcdFx0aWYgKHVzZV9zaGFkb3dfZG9tKSB7XG5cdFx0XHRcdHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcblx0XHRcdC8vIFdlIGNhbid0IGRldGVybWluZSB1cGZyb250IGlmIHRoZSBldmVudCBpcyBhIGN1c3RvbSBldmVudCBvciBub3QsIHNvIHdlIGhhdmUgdG9cblx0XHRcdC8vIGxpc3RlbiB0byBib3RoLiBJZiBzb21lb25lIHVzZXMgYSBjdXN0b20gZXZlbnQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIGEgcmVndWxhclxuXHRcdFx0Ly8gYnJvd3NlciBldmVudCwgdGhpcyBmaXJlcyB0d2ljZSAtIHdlIGNhbid0IGF2b2lkIHRoYXQuXG5cdFx0XHR0aGlzLiQkbFt0eXBlXSA9IHRoaXMuJCRsW3R5cGVdIHx8IFtdO1xuXHRcdFx0dGhpcy4kJGxbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG5cdFx0XHRpZiAodGhpcy4kJGMpIHtcblx0XHRcdFx0Y29uc3QgdW5zdWIgPSB0aGlzLiQkYy4kb24odHlwZSwgbGlzdGVuZXIpO1xuXHRcdFx0XHR0aGlzLiQkbF91LnNldChsaXN0ZW5lciwgdW5zdWIpO1xuXHRcdFx0fVxuXHRcdFx0c3VwZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0cmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuXHRcdFx0c3VwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG5cdFx0XHRpZiAodGhpcy4kJGMpIHtcblx0XHRcdFx0Y29uc3QgdW5zdWIgPSB0aGlzLiQkbF91LmdldChsaXN0ZW5lcik7XG5cdFx0XHRcdGlmICh1bnN1Yikge1xuXHRcdFx0XHRcdHVuc3ViKCk7XG5cdFx0XHRcdFx0dGhpcy4kJGxfdS5kZWxldGUobGlzdGVuZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YXN5bmMgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG5cdFx0XHR0aGlzLiQkY24gPSB0cnVlO1xuXHRcdFx0aWYgKCF0aGlzLiQkYykge1xuXHRcdFx0XHQvLyBXZSB3YWl0IG9uZSB0aWNrIHRvIGxldCBwb3NzaWJsZSBjaGlsZCBzbG90IGVsZW1lbnRzIGJlIGNyZWF0ZWQvbW91bnRlZFxuXHRcdFx0XHRhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcblx0XHRcdFx0aWYgKCF0aGlzLiQkY24gfHwgdGhpcy4kJGMpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnVuY3Rpb24gY3JlYXRlX3Nsb3QobmFtZSkge1xuXHRcdFx0XHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgbm9kZTtcblx0XHRcdFx0XHRcdGNvbnN0IG9iaiA9IHtcblx0XHRcdFx0XHRcdFx0YzogZnVuY3Rpb24gY3JlYXRlKCkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtZW50KCdzbG90Jyk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG5hbWUgIT09ICdkZWZhdWx0Jykge1xuXHRcdFx0XHRcdFx0XHRcdFx0YXR0cihub2RlLCAnbmFtZScsIG5hbWUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxuXHRcdFx0XHRcdFx0XHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbYW5jaG9yXVxuXHRcdFx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRcdFx0bTogZnVuY3Rpb24gbW91bnQodGFyZ2V0LCBhbmNob3IpIHtcblx0XHRcdFx0XHRcdFx0XHRpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpO1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRkOiBmdW5jdGlvbiBkZXN0cm95KGRldGFjaGluZykge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChkZXRhY2hpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGRldGFjaChub2RlKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgJCRzbG90cyA9IHt9O1xuXHRcdFx0XHRjb25zdCBleGlzdGluZ19zbG90cyA9IGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHModGhpcyk7XG5cdFx0XHRcdGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLiQkcykge1xuXHRcdFx0XHRcdGlmIChuYW1lIGluIGV4aXN0aW5nX3Nsb3RzKSB7XG5cdFx0XHRcdFx0XHQkJHNsb3RzW25hbWVdID0gW2NyZWF0ZV9zbG90KG5hbWUpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgdGhpcy5hdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdFx0Ly8gdGhpcy4kJGRhdGEgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMuYXR0cmlidXRlc1xuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSB0aGlzLiQkZ19wKGF0dHJpYnV0ZS5uYW1lKTtcblx0XHRcdFx0XHRpZiAoIShuYW1lIGluIHRoaXMuJCRkKSkge1xuXHRcdFx0XHRcdFx0dGhpcy4kJGRbbmFtZV0gPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUobmFtZSwgYXR0cmlidXRlLnZhbHVlLCB0aGlzLiQkcF9kLCAndG9Qcm9wJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFBvcnQgb3ZlciBwcm9wcyB0aGF0IHdlcmUgc2V0IHByb2dyYW1tYXRpY2FsbHkgYmVmb3JlIGNlIHdhcyBpbml0aWFsaXplZFxuXHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiB0aGlzLiQkcF9kKSB7XG5cdFx0XHRcdFx0aWYgKCEoa2V5IGluIHRoaXMuJCRkKSAmJiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dGhpcy4kJGRba2V5XSA9IHRoaXNba2V5XTsgLy8gZG9uJ3QgdHJhbnNmb3JtLCB0aGVzZSB3ZXJlIHNldCB0aHJvdWdoIEphdmFTY3JpcHRcblx0XHRcdFx0XHRcdGRlbGV0ZSB0aGlzW2tleV07IC8vIHJlbW92ZSB0aGUgcHJvcGVydHkgdGhhdCBzaGFkb3dzIHRoZSBnZXR0ZXIvc2V0dGVyXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuJCRjID0gbmV3IHRoaXMuJCRjdG9yKHtcblx0XHRcdFx0XHR0YXJnZXQ6IHRoaXMuc2hhZG93Um9vdCB8fCB0aGlzLFxuXHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHQuLi50aGlzLiQkZCxcblx0XHRcdFx0XHRcdCQkc2xvdHMsXG5cdFx0XHRcdFx0XHQkJHNjb3BlOiB7XG5cdFx0XHRcdFx0XHRcdGN0eDogW11cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIFJlZmxlY3QgY29tcG9uZW50IHByb3BzIGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0Y29uc3QgcmVmbGVjdF9hdHRyaWJ1dGVzID0gKCkgPT4ge1xuXHRcdFx0XHRcdHRoaXMuJCRyID0gdHJ1ZTtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiB0aGlzLiQkcF9kKSB7XG5cdFx0XHRcdFx0XHR0aGlzLiQkZFtrZXldID0gdGhpcy4kJGMuJCQuY3R4W3RoaXMuJCRjLiQkLnByb3BzW2tleV1dO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuJCRwX2Rba2V5XS5yZWZsZWN0KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZV92YWx1ZSA9IGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShcblx0XHRcdFx0XHRcdFx0XHRrZXksXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy4kJGRba2V5XSxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLiQkcF9kLFxuXHRcdFx0XHRcdFx0XHRcdCd0b0F0dHJpYnV0ZSdcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0aWYgKGF0dHJpYnV0ZV92YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5yZW1vdmVBdHRyaWJ1dGUodGhpcy4kJHBfZFtrZXldLmF0dHJpYnV0ZSB8fCBrZXkpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKHRoaXMuJCRwX2Rba2V5XS5hdHRyaWJ1dGUgfHwga2V5LCBhdHRyaWJ1dGVfdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuJCRyID0gZmFsc2U7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRoaXMuJCRjLiQkLmFmdGVyX3VwZGF0ZS5wdXNoKHJlZmxlY3RfYXR0cmlidXRlcyk7XG5cdFx0XHRcdHJlZmxlY3RfYXR0cmlidXRlcygpOyAvLyBvbmNlIGluaXRpYWxseSBiZWNhdXNlIGFmdGVyX3VwZGF0ZSBpcyBhZGRlZCB0b28gbGF0ZSBmb3IgZmlyc3QgcmVuZGVyXG5cblx0XHRcdFx0Zm9yIChjb25zdCB0eXBlIGluIHRoaXMuJCRsKSB7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiQkbFt0eXBlXSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgdW5zdWIgPSB0aGlzLiQkYy4kb24odHlwZSwgbGlzdGVuZXIpO1xuXHRcdFx0XHRcdFx0dGhpcy4kJGxfdS5zZXQobGlzdGVuZXIsIHVuc3ViKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy4kJGwgPSB7fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBXZSBkb24ndCBuZWVkIHRoaXMgd2hlbiB3b3JraW5nIHdpdGhpbiBTdmVsdGUgY29kZSwgYnV0IGZvciBjb21wYXRpYmlsaXR5IG9mIHBlb3BsZSB1c2luZyB0aGlzIG91dHNpZGUgb2YgU3ZlbHRlXG5cdFx0Ly8gYW5kIHNldHRpbmcgYXR0cmlidXRlcyB0aHJvdWdoIHNldEF0dHJpYnV0ZSBldGMsIHRoaXMgaXMgaGVscGZ1bFxuXHRcdGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyLCBfb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG5cdFx0XHRpZiAodGhpcy4kJHIpIHJldHVybjtcblx0XHRcdGF0dHIgPSB0aGlzLiQkZ19wKGF0dHIpO1xuXHRcdFx0dGhpcy4kJGRbYXR0cl0gPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUoYXR0ciwgbmV3VmFsdWUsIHRoaXMuJCRwX2QsICd0b1Byb3AnKTtcblx0XHRcdHRoaXMuJCRjPy4kc2V0KHsgW2F0dHJdOiB0aGlzLiQkZFthdHRyXSB9KTtcblx0XHR9XG5cblx0XHRkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcblx0XHRcdHRoaXMuJCRjbiA9IGZhbHNlO1xuXHRcdFx0Ly8gSW4gYSBtaWNyb3Rhc2ssIGJlY2F1c2UgdGhpcyBjb3VsZCBiZSBhIG1vdmUgd2l0aGluIHRoZSBET01cblx0XHRcdFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRpZiAoIXRoaXMuJCRjbikge1xuXHRcdFx0XHRcdHRoaXMuJCRjLiRkZXN0cm95KCk7XG5cdFx0XHRcdFx0dGhpcy4kJGMgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdCQkZ19wKGF0dHJpYnV0ZV9uYW1lKSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRPYmplY3Qua2V5cyh0aGlzLiQkcF9kKS5maW5kKFxuXHRcdFx0XHRcdChrZXkpID0+XG5cdFx0XHRcdFx0XHR0aGlzLiQkcF9kW2tleV0uYXR0cmlidXRlID09PSBhdHRyaWJ1dGVfbmFtZSB8fFxuXHRcdFx0XHRcdFx0KCF0aGlzLiQkcF9kW2tleV0uYXR0cmlidXRlICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSBhdHRyaWJ1dGVfbmFtZSlcblx0XHRcdFx0KSB8fCBhdHRyaWJ1dGVfbmFtZVxuXHRcdFx0KTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb24+fSBwcm9wc19kZWZpbml0aW9uXG4gKiBAcGFyYW0geyd0b0F0dHJpYnV0ZScgfCAndG9Qcm9wJ30gW3RyYW5zZm9ybV1cbiAqL1xuZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKHByb3AsIHZhbHVlLCBwcm9wc19kZWZpbml0aW9uLCB0cmFuc2Zvcm0pIHtcblx0Y29uc3QgdHlwZSA9IHByb3BzX2RlZmluaXRpb25bcHJvcF0/LnR5cGU7XG5cdHZhbHVlID0gdHlwZSA9PT0gJ0Jvb2xlYW4nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nID8gdmFsdWUgIT0gbnVsbCA6IHZhbHVlO1xuXHRpZiAoIXRyYW5zZm9ybSB8fCAhcHJvcHNfZGVmaW5pdGlvbltwcm9wXSkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fSBlbHNlIGlmICh0cmFuc2Zvcm0gPT09ICd0b0F0dHJpYnV0ZScpIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ09iamVjdCc6XG5cdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gbnVsbCA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblx0XHRcdGNhc2UgJ0Jvb2xlYW4nOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPyAnJyA6IG51bGw7XG5cdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG51bGwgOiB2YWx1ZTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlICdPYmplY3QnOlxuXHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgJiYgSlNPTi5wYXJzZSh2YWx1ZSk7XG5cdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlOyAvLyBjb252ZXJzaW9uIGFscmVhZHkgaGFuZGxlZCBhYm92ZVxuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlICE9IG51bGwgPyArdmFsdWUgOiB2YWx1ZTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBUdXJuIGEgU3ZlbHRlIGNvbXBvbmVudCBpbnRvIGEgY3VzdG9tIGVsZW1lbnQuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5Db21wb25lbnRUeXBlfSBDb21wb25lbnQgIEEgU3ZlbHRlIGNvbXBvbmVudCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb24+fSBwcm9wc19kZWZpbml0aW9uICBUaGUgcHJvcHMgdG8gb2JzZXJ2ZVxuICogQHBhcmFtIHtzdHJpbmdbXX0gc2xvdHMgIFRoZSBzbG90cyB0byBjcmVhdGVcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFjY2Vzc29ycyAgT3RoZXIgYWNjZXNzb3JzIGJlc2lkZXMgdGhlIG9uZXMgZm9yIHByb3BzIHRoZSBjb21wb25lbnQgaGFzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVzZV9zaGFkb3dfZG9tICBXaGV0aGVyIHRvIHVzZSBzaGFkb3cgRE9NXG4gKiBAcGFyYW0geyhjZTogbmV3ICgpID0+IEhUTUxFbGVtZW50KSA9PiBuZXcgKCkgPT4gSFRNTEVsZW1lbnR9IFtleHRlbmRdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfY3VzdG9tX2VsZW1lbnQoXG5cdENvbXBvbmVudCxcblx0cHJvcHNfZGVmaW5pdGlvbixcblx0c2xvdHMsXG5cdGFjY2Vzc29ycyxcblx0dXNlX3NoYWRvd19kb20sXG5cdGV4dGVuZFxuKSB7XG5cdGxldCBDbGFzcyA9IGNsYXNzIGV4dGVuZHMgU3ZlbHRlRWxlbWVudCB7XG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cdFx0XHRzdXBlcihDb21wb25lbnQsIHNsb3RzLCB1c2Vfc2hhZG93X2RvbSk7XG5cdFx0XHR0aGlzLiQkcF9kID0gcHJvcHNfZGVmaW5pdGlvbjtcblx0XHR9XG5cdFx0c3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmtleXMocHJvcHNfZGVmaW5pdGlvbikubWFwKChrZXkpID0+XG5cdFx0XHRcdChwcm9wc19kZWZpbml0aW9uW2tleV0uYXR0cmlidXRlIHx8IGtleSkudG9Mb3dlckNhc2UoKVxuXHRcdFx0KTtcblx0XHR9XG5cdH07XG5cdE9iamVjdC5rZXlzKHByb3BzX2RlZmluaXRpb24pLmZvckVhY2goKHByb3ApID0+IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MucHJvdG90eXBlLCBwcm9wLCB7XG5cdFx0XHRnZXQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLiQkYyAmJiBwcm9wIGluIHRoaXMuJCRjID8gdGhpcy4kJGNbcHJvcF0gOiB0aGlzLiQkZFtwcm9wXTtcblx0XHRcdH0sXG5cdFx0XHRzZXQodmFsdWUpIHtcblx0XHRcdFx0dmFsdWUgPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUocHJvcCwgdmFsdWUsIHByb3BzX2RlZmluaXRpb24pO1xuXHRcdFx0XHR0aGlzLiQkZFtwcm9wXSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLiQkYz8uJHNldCh7IFtwcm9wXTogdmFsdWUgfSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRhY2Nlc3NvcnMuZm9yRWFjaCgoYWNjZXNzb3IpID0+IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MucHJvdG90eXBlLCBhY2Nlc3Nvciwge1xuXHRcdFx0Z2V0KCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy4kJGM/LlthY2Nlc3Nvcl07XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRpZiAoZXh0ZW5kKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciAtIGFzc2lnbmluZyBoZXJlIGlzIGZpbmVcblx0XHRDbGFzcyA9IGV4dGVuZChDbGFzcyk7XG5cdH1cblx0Q29tcG9uZW50LmVsZW1lbnQgPSAvKiogQHR5cGUge2FueX0gKi8gKENsYXNzKTtcblx0cmV0dXJuIENsYXNzO1xufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzLiBVc2VkIHdoZW4gZGV2PWZhbHNlLlxuICpcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW1Byb3BzPWFueV1cbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW0V2ZW50cz1hbnldXG4gKi9cbmV4cG9ydCBjbGFzcyBTdmVsdGVDb21wb25lbnQge1xuXHQvKipcblx0ICogIyMjIFBSSVZBVEUgQVBJXG5cdCAqXG5cdCAqIERvIG5vdCB1c2UsIG1heSBjaGFuZ2UgYXQgYW55IHRpbWVcblx0ICpcblx0ICogQHR5cGUge2FueX1cblx0ICovXG5cdCQkID0gdW5kZWZpbmVkO1xuXHQvKipcblx0ICogIyMjIFBSSVZBVEUgQVBJXG5cdCAqXG5cdCAqIERvIG5vdCB1c2UsIG1heSBjaGFuZ2UgYXQgYW55IHRpbWVcblx0ICpcblx0ICogQHR5cGUge2FueX1cblx0ICovXG5cdCQkc2V0ID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0JGRlc3Ryb3koKSB7XG5cdFx0ZGVzdHJveV9jb21wb25lbnQodGhpcywgMSk7XG5cdFx0dGhpcy4kZGVzdHJveSA9IG5vb3A7XG5cdH1cblxuXHQvKipcblx0ICogQHRlbXBsYXRlIHtFeHRyYWN0PGtleW9mIEV2ZW50cywgc3RyaW5nPn0gS1xuXHQgKiBAcGFyYW0ge0t9IHR5cGVcblx0ICogQHBhcmFtIHsoKGU6IEV2ZW50c1tLXSkgPT4gdm9pZCkgfCBudWxsIHwgdW5kZWZpbmVkfSBjYWxsYmFja1xuXHQgKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cblx0ICovXG5cdCRvbih0eXBlLCBjYWxsYmFjaykge1xuXHRcdGlmICghaXNfZnVuY3Rpb24oY2FsbGJhY2spKSB7XG5cdFx0XHRyZXR1cm4gbm9vcDtcblx0XHR9XG5cdFx0Y29uc3QgY2FsbGJhY2tzID0gdGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pO1xuXHRcdGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0Y29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG5cdFx0XHRpZiAoaW5kZXggIT09IC0xKSBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7UGFydGlhbDxQcm9wcz59IHByb3BzXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0JHNldChwcm9wcykge1xuXHRcdGlmICh0aGlzLiQkc2V0ICYmICFpc19lbXB0eShwcm9wcykpIHtcblx0XHRcdHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG5cdFx0XHR0aGlzLiQkc2V0KHByb3BzKTtcblx0XHRcdHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEN1c3RvbUVsZW1lbnRQcm9wRGVmaW5pdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IFthdHRyaWJ1dGVdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWZsZWN0XVxuICogQHByb3BlcnR5IHsnU3RyaW5nJ3wnQm9vbGVhbid8J051bWJlcid8J0FycmF5J3wnT2JqZWN0J30gW3R5cGVdXG4gKi9cbiIsICIvLyBnZW5lcmF0ZWQgZHVyaW5nIHJlbGVhc2UsIGRvIG5vdCBtb2RpZnlcblxuLyoqXG4gKiBUaGUgY3VycmVudCB2ZXJzaW9uLCBhcyBzZXQgaW4gcGFja2FnZS5qc29uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS1jb21waWxlciNzdmVsdGUtdmVyc2lvblxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IFZFUlNJT04gPSAnNC4yLjEyJztcbmV4cG9ydCBjb25zdCBQVUJMSUNfVkVSU0lPTiA9ICc0JztcbiIsICJpbXBvcnQgeyBQVUJMSUNfVkVSU0lPTiB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC92ZXJzaW9uLmpzJztcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKVxuXHQvLyBAdHMtaWdub3JlXG5cdCh3aW5kb3cuX19zdmVsdGUgfHwgKHdpbmRvdy5fX3N2ZWx0ZSA9IHsgdjogbmV3IFNldCgpIH0pKS52LmFkZChQVUJMSUNfVkVSU0lPTik7XG4iLCAiLy8gOjotIFBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGFuIG9yZGVyZWQgbWFwcGluZyBmcm9tXG4vLyBzdHJpbmdzIHRvIHZhbHVlcywgd2l0aCBzb21lIGNvbnZlbmllbnQgdXBkYXRlIG1ldGhvZHMuXG5mdW5jdGlvbiBPcmRlcmVkTWFwKGNvbnRlbnQpIHtcbiAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbn1cblxuT3JkZXJlZE1hcC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBPcmRlcmVkTWFwLFxuXG4gIGZpbmQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSArPSAyKVxuICAgICAgaWYgKHRoaXMuY29udGVudFtpXSA9PT0ga2V5KSByZXR1cm4gaVxuICAgIHJldHVybiAtMVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcpIFx1MjE5MiA/YW55XG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZSBzdG9yZWQgdW5kZXIgYGtleWAsIG9yIHJldHVybiB1bmRlZmluZWQgd2hlblxuICAvLyBubyBzdWNoIGtleSBleGlzdHMuXG4gIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5maW5kKGtleSk7XG4gICAgcmV0dXJuIGZvdW5kID09IC0xID8gdW5kZWZpbmVkIDogdGhpcy5jb250ZW50W2ZvdW5kICsgMV1cbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nLCBhbnksID9zdHJpbmcpIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG5ldyBtYXAgYnkgcmVwbGFjaW5nIHRoZSB2YWx1ZSBvZiBga2V5YCB3aXRoIGEgbmV3XG4gIC8vIHZhbHVlLCBvciBhZGRpbmcgYSBiaW5kaW5nIHRvIHRoZSBlbmQgb2YgdGhlIG1hcC4gSWYgYG5ld0tleWAgaXNcbiAgLy8gZ2l2ZW4sIHRoZSBrZXkgb2YgdGhlIGJpbmRpbmcgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoYXQga2V5LlxuICB1cGRhdGU6IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG5ld0tleSkge1xuICAgIHZhciBzZWxmID0gbmV3S2V5ICYmIG5ld0tleSAhPSBrZXkgPyB0aGlzLnJlbW92ZShuZXdLZXkpIDogdGhpcztcbiAgICB2YXIgZm91bmQgPSBzZWxmLmZpbmQoa2V5KSwgY29udGVudCA9IHNlbGYuY29udGVudC5zbGljZSgpO1xuICAgIGlmIChmb3VuZCA9PSAtMSkge1xuICAgICAgY29udGVudC5wdXNoKG5ld0tleSB8fCBrZXksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudFtmb3VuZCArIDFdID0gdmFsdWU7XG4gICAgICBpZiAobmV3S2V5KSBjb250ZW50W2ZvdW5kXSA9IG5ld0tleTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZykgXHUyMTkyIE9yZGVyZWRNYXBcbiAgLy8gUmV0dXJuIGEgbWFwIHdpdGggdGhlIGdpdmVuIGtleSByZW1vdmVkLCBpZiBpdCBleGlzdGVkLlxuICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMuZmluZChrZXkpO1xuICAgIGlmIChmb3VuZCA9PSAtMSkgcmV0dXJuIHRoaXNcbiAgICB2YXIgY29udGVudCA9IHRoaXMuY29udGVudC5zbGljZSgpO1xuICAgIGNvbnRlbnQuc3BsaWNlKGZvdW5kLCAyKTtcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nLCBhbnkpIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIEFkZCBhIG5ldyBrZXkgdG8gdGhlIHN0YXJ0IG9mIHRoZSBtYXAuXG4gIGFkZFRvU3RhcnQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoW2tleSwgdmFsdWVdLmNvbmNhdCh0aGlzLnJlbW92ZShrZXkpLmNvbnRlbnQpKVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcsIGFueSkgXHUyMTkyIE9yZGVyZWRNYXBcbiAgLy8gQWRkIGEgbmV3IGtleSB0byB0aGUgZW5kIG9mIHRoZSBtYXAuXG4gIGFkZFRvRW5kOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLnJlbW92ZShrZXkpLmNvbnRlbnQuc2xpY2UoKTtcbiAgICBjb250ZW50LnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgc3RyaW5nLCBhbnkpIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIEFkZCBhIGtleSBhZnRlciB0aGUgZ2l2ZW4ga2V5LiBJZiBgcGxhY2VgIGlzIG5vdCBmb3VuZCwgdGhlIG5ld1xuICAvLyBrZXkgaXMgYWRkZWQgdG8gdGhlIGVuZC5cbiAgYWRkQmVmb3JlOiBmdW5jdGlvbihwbGFjZSwga2V5LCB2YWx1ZSkge1xuICAgIHZhciB3aXRob3V0ID0gdGhpcy5yZW1vdmUoa2V5KSwgY29udGVudCA9IHdpdGhvdXQuY29udGVudC5zbGljZSgpO1xuICAgIHZhciBmb3VuZCA9IHdpdGhvdXQuZmluZChwbGFjZSk7XG4gICAgY29udGVudC5zcGxpY2UoZm91bmQgPT0gLTEgPyBjb250ZW50Lmxlbmd0aCA6IGZvdW5kLCAwLCBrZXksIHZhbHVlKTtcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbiAgfSxcblxuICAvLyA6OiAoKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSlcbiAgLy8gQ2FsbCB0aGUgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIG1hcCwgaW5cbiAgLy8gb3JkZXIuXG4gIGZvckVhY2g6IGZ1bmN0aW9uKGYpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkgKz0gMilcbiAgICAgIGYodGhpcy5jb250ZW50W2ldLCB0aGlzLmNvbnRlbnRbaSArIDFdKTtcbiAgfSxcblxuICAvLyA6OiAodW5pb248T2JqZWN0LCBPcmRlcmVkTWFwPikgXHUyMTkyIE9yZGVyZWRNYXBcbiAgLy8gQ3JlYXRlIGEgbmV3IG1hcCBieSBwcmVwZW5kaW5nIHRoZSBrZXlzIGluIHRoaXMgbWFwIHRoYXQgZG9uJ3RcbiAgLy8gYXBwZWFyIGluIGBtYXBgIGJlZm9yZSB0aGUga2V5cyBpbiBgbWFwYC5cbiAgcHJlcGVuZDogZnVuY3Rpb24obWFwKSB7XG4gICAgbWFwID0gT3JkZXJlZE1hcC5mcm9tKG1hcCk7XG4gICAgaWYgKCFtYXAuc2l6ZSkgcmV0dXJuIHRoaXNcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAobWFwLmNvbnRlbnQuY29uY2F0KHRoaXMuc3VidHJhY3QobWFwKS5jb250ZW50KSlcbiAgfSxcblxuICAvLyA6OiAodW5pb248T2JqZWN0LCBPcmRlcmVkTWFwPikgXHUyMTkyIE9yZGVyZWRNYXBcbiAgLy8gQ3JlYXRlIGEgbmV3IG1hcCBieSBhcHBlbmRpbmcgdGhlIGtleXMgaW4gdGhpcyBtYXAgdGhhdCBkb24ndFxuICAvLyBhcHBlYXIgaW4gYG1hcGAgYWZ0ZXIgdGhlIGtleXMgaW4gYG1hcGAuXG4gIGFwcGVuZDogZnVuY3Rpb24obWFwKSB7XG4gICAgbWFwID0gT3JkZXJlZE1hcC5mcm9tKG1hcCk7XG4gICAgaWYgKCFtYXAuc2l6ZSkgcmV0dXJuIHRoaXNcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAodGhpcy5zdWJ0cmFjdChtYXApLmNvbnRlbnQuY29uY2F0KG1hcC5jb250ZW50KSlcbiAgfSxcblxuICAvLyA6OiAodW5pb248T2JqZWN0LCBPcmRlcmVkTWFwPikgXHUyMTkyIE9yZGVyZWRNYXBcbiAgLy8gQ3JlYXRlIGEgbWFwIGNvbnRhaW5pbmcgYWxsIHRoZSBrZXlzIGluIHRoaXMgbWFwIHRoYXQgZG9uJ3RcbiAgLy8gYXBwZWFyIGluIGBtYXBgLlxuICBzdWJ0cmFjdDogZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXM7XG4gICAgbWFwID0gT3JkZXJlZE1hcC5mcm9tKG1hcCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXAuY29udGVudC5sZW5ndGg7IGkgKz0gMilcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZW1vdmUobWFwLmNvbnRlbnRbaV0pO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSxcblxuICAvLyA6OiAoKSBcdTIxOTIgT2JqZWN0XG4gIC8vIFR1cm4gb3JkZXJlZCBtYXAgaW50byBhIHBsYWluIG9iamVjdC5cbiAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkgeyByZXN1bHRba2V5XSA9IHZhbHVlOyB9KTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0sXG5cbiAgLy8gOjogbnVtYmVyXG4gIC8vIFRoZSBhbW91bnQgb2Yga2V5cyBpbiB0aGlzIG1hcC5cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPj4gMVxuICB9XG59O1xuXG4vLyA6OiAoP3VuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIFx1MjE5MiBPcmRlcmVkTWFwXG4vLyBSZXR1cm4gYSBtYXAgd2l0aCB0aGUgZ2l2ZW4gY29udGVudC4gSWYgbnVsbCwgY3JlYXRlIGFuIGVtcHR5XG4vLyBtYXAuIElmIGdpdmVuIGFuIG9yZGVyZWQgbWFwLCByZXR1cm4gdGhhdCBtYXAgaXRzZWxmLiBJZiBnaXZlbiBhblxuLy8gb2JqZWN0LCBjcmVhdGUgYSBtYXAgZnJvbSB0aGUgb2JqZWN0J3MgcHJvcGVydGllcy5cbk9yZGVyZWRNYXAuZnJvbSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9yZGVyZWRNYXApIHJldHVybiB2YWx1ZVxuICB2YXIgY29udGVudCA9IFtdO1xuICBpZiAodmFsdWUpIGZvciAodmFyIHByb3AgaW4gdmFsdWUpIGNvbnRlbnQucHVzaChwcm9wLCB2YWx1ZVtwcm9wXSk7XG4gIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxufTtcblxuZXhwb3J0IGRlZmF1bHQgT3JkZXJlZE1hcDtcbiIsICJpbXBvcnQgT3JkZXJlZE1hcCBmcm9tICdvcmRlcmVkbWFwJztcblxuZnVuY3Rpb24gZmluZERpZmZTdGFydChhLCBiLCBwb3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICBpZiAoaSA9PSBhLmNoaWxkQ291bnQgfHwgaSA9PSBiLmNoaWxkQ291bnQpXG4gICAgICAgICAgICByZXR1cm4gYS5jaGlsZENvdW50ID09IGIuY2hpbGRDb3VudCA/IG51bGwgOiBwb3M7XG4gICAgICAgIGxldCBjaGlsZEEgPSBhLmNoaWxkKGkpLCBjaGlsZEIgPSBiLmNoaWxkKGkpO1xuICAgICAgICBpZiAoY2hpbGRBID09IGNoaWxkQikge1xuICAgICAgICAgICAgcG9zICs9IGNoaWxkQS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hpbGRBLnNhbWVNYXJrdXAoY2hpbGRCKSlcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIGlmIChjaGlsZEEuaXNUZXh0ICYmIGNoaWxkQS50ZXh0ICE9IGNoaWxkQi50ZXh0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgY2hpbGRBLnRleHRbal0gPT0gY2hpbGRCLnRleHRbal07IGorKylcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkQS5jb250ZW50LnNpemUgfHwgY2hpbGRCLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gZmluZERpZmZTdGFydChjaGlsZEEuY29udGVudCwgY2hpbGRCLmNvbnRlbnQsIHBvcyArIDEpO1xuICAgICAgICAgICAgaWYgKGlubmVyICE9IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBjaGlsZEEubm9kZVNpemU7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZERpZmZFbmQoYSwgYiwgcG9zQSwgcG9zQikge1xuICAgIGZvciAobGV0IGlBID0gYS5jaGlsZENvdW50LCBpQiA9IGIuY2hpbGRDb3VudDs7KSB7XG4gICAgICAgIGlmIChpQSA9PSAwIHx8IGlCID09IDApXG4gICAgICAgICAgICByZXR1cm4gaUEgPT0gaUIgPyBudWxsIDogeyBhOiBwb3NBLCBiOiBwb3NCIH07XG4gICAgICAgIGxldCBjaGlsZEEgPSBhLmNoaWxkKC0taUEpLCBjaGlsZEIgPSBiLmNoaWxkKC0taUIpLCBzaXplID0gY2hpbGRBLm5vZGVTaXplO1xuICAgICAgICBpZiAoY2hpbGRBID09IGNoaWxkQikge1xuICAgICAgICAgICAgcG9zQSAtPSBzaXplO1xuICAgICAgICAgICAgcG9zQiAtPSBzaXplO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGlsZEEuc2FtZU1hcmt1cChjaGlsZEIpKVxuICAgICAgICAgICAgcmV0dXJuIHsgYTogcG9zQSwgYjogcG9zQiB9O1xuICAgICAgICBpZiAoY2hpbGRBLmlzVGV4dCAmJiBjaGlsZEEudGV4dCAhPSBjaGlsZEIudGV4dCkge1xuICAgICAgICAgICAgbGV0IHNhbWUgPSAwLCBtaW5TaXplID0gTWF0aC5taW4oY2hpbGRBLnRleHQubGVuZ3RoLCBjaGlsZEIudGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgd2hpbGUgKHNhbWUgPCBtaW5TaXplICYmIGNoaWxkQS50ZXh0W2NoaWxkQS50ZXh0Lmxlbmd0aCAtIHNhbWUgLSAxXSA9PSBjaGlsZEIudGV4dFtjaGlsZEIudGV4dC5sZW5ndGggLSBzYW1lIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBzYW1lKys7XG4gICAgICAgICAgICAgICAgcG9zQS0tO1xuICAgICAgICAgICAgICAgIHBvc0ItLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGE6IHBvc0EsIGI6IHBvc0IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRBLmNvbnRlbnQuc2l6ZSB8fCBjaGlsZEIuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBmaW5kRGlmZkVuZChjaGlsZEEuY29udGVudCwgY2hpbGRCLmNvbnRlbnQsIHBvc0EgLSAxLCBwb3NCIC0gMSk7XG4gICAgICAgICAgICBpZiAoaW5uZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICB9XG4gICAgICAgIHBvc0EgLT0gc2l6ZTtcbiAgICAgICAgcG9zQiAtPSBzaXplO1xuICAgIH1cbn1cblxuLyoqXG5BIGZyYWdtZW50IHJlcHJlc2VudHMgYSBub2RlJ3MgY29sbGVjdGlvbiBvZiBjaGlsZCBub2Rlcy5cblxuTGlrZSBub2RlcywgZnJhZ21lbnRzIGFyZSBwZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlcywgYW5kIHlvdVxuc2hvdWxkIG5vdCBtdXRhdGUgdGhlbSBvciB0aGVpciBjb250ZW50LiBSYXRoZXIsIHlvdSBjcmVhdGUgbmV3XG5pbnN0YW5jZXMgd2hlbmV2ZXIgbmVlZGVkLiBUaGUgQVBJIHRyaWVzIHRvIG1ha2UgdGhpcyBlYXN5LlxuKi9cbmNsYXNzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29udGVudCwgc2l6ZSkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplIHx8IDA7XG4gICAgICAgIGlmIChzaXplID09IG51bGwpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplICs9IGNvbnRlbnRbaV0ubm9kZVNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIEludm9rZSBhIGNhbGxiYWNrIGZvciBhbGwgZGVzY2VuZGFudCBub2RlcyBiZXR3ZWVuIHRoZSBnaXZlbiB0d29cbiAgICBwb3NpdGlvbnMgKHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHRoaXMgZnJhZ21lbnQpLiBEb2Vzbid0IGRlc2NlbmRcbiAgICBpbnRvIGEgbm9kZSB3aGVuIHRoZSBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAuXG4gICAgKi9cbiAgICBub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYsIG5vZGVTdGFydCA9IDAsIHBhcmVudCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jb250ZW50W2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChlbmQgPiBmcm9tICYmIGYoY2hpbGQsIG5vZGVTdGFydCArIHBvcywgcGFyZW50IHx8IG51bGwsIGkpICE9PSBmYWxzZSAmJiBjaGlsZC5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgIGNoaWxkLm5vZGVzQmV0d2VlbihNYXRoLm1heCgwLCBmcm9tIC0gc3RhcnQpLCBNYXRoLm1pbihjaGlsZC5jb250ZW50LnNpemUsIHRvIC0gc3RhcnQpLCBmLCBub2RlU3RhcnQgKyBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbCB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IGRlc2NlbmRhbnQgbm9kZS4gYHBvc2Agd2lsbCBiZVxuICAgIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQuIFRoZSBjYWxsYmFjayBtYXkgcmV0dXJuXG4gICAgYGZhbHNlYCB0byBwcmV2ZW50IHRyYXZlcnNhbCBvZiBhIGdpdmVuIG5vZGUncyBjaGlsZHJlbi5cbiAgICAqL1xuICAgIGRlc2NlbmRhbnRzKGYpIHtcbiAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oMCwgdGhpcy5zaXplLCBmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0cmFjdCB0aGUgdGV4dCBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC4gU2VlIHRoZSBzYW1lIG1ldGhvZCBvblxuICAgIFtgTm9kZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnRleHRCZXR3ZWVuKS5cbiAgICAqL1xuICAgIHRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpIHtcbiAgICAgICAgbGV0IHRleHQgPSBcIlwiLCBmaXJzdCA9IHRydWU7XG4gICAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICBsZXQgbm9kZVRleHQgPSBub2RlLmlzVGV4dCA/IG5vZGUudGV4dC5zbGljZShNYXRoLm1heChmcm9tLCBwb3MpIC0gcG9zLCB0byAtIHBvcylcbiAgICAgICAgICAgICAgICA6ICFub2RlLmlzTGVhZiA/IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgOiBsZWFmVGV4dCA/ICh0eXBlb2YgbGVhZlRleHQgPT09IFwiZnVuY3Rpb25cIiA/IGxlYWZUZXh0KG5vZGUpIDogbGVhZlRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5vZGUudHlwZS5zcGVjLmxlYWZUZXh0ID8gbm9kZS50eXBlLnNwZWMubGVhZlRleHQobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0Jsb2NrICYmIChub2RlLmlzTGVhZiAmJiBub2RlVGV4dCB8fCBub2RlLmlzVGV4dGJsb2NrKSAmJiBibG9ja1NlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdClcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gYmxvY2tTZXBhcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0ICs9IG5vZGVUZXh0O1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBjb250YWluaW5nIHRoZSBjb21iaW5lZCBjb250ZW50IG9mIHRoaXNcbiAgICBmcmFnbWVudCBhbmQgdGhlIG90aGVyLlxuICAgICovXG4gICAgYXBwZW5kKG90aGVyKSB7XG4gICAgICAgIGlmICghb3RoZXIuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmxhc3RDaGlsZCwgZmlyc3QgPSBvdGhlci5maXJzdENoaWxkLCBjb250ZW50ID0gdGhpcy5jb250ZW50LnNsaWNlKCksIGkgPSAwO1xuICAgICAgICBpZiAobGFzdC5pc1RleHQgJiYgbGFzdC5zYW1lTWFya3VwKGZpcnN0KSkge1xuICAgICAgICAgICAgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdID0gbGFzdC53aXRoVGV4dChsYXN0LnRleHQgKyBmaXJzdC50ZXh0KTtcbiAgICAgICAgICAgIGkgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpIDwgb3RoZXIuY29udGVudC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChvdGhlci5jb250ZW50W2ldKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50LCB0aGlzLnNpemUgKyBvdGhlci5zaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3V0IG91dCB0aGUgc3ViLWZyYWdtZW50IGJldHdlZW4gdGhlIHR3byBnaXZlbiBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBjdXQoZnJvbSwgdG8gPSB0aGlzLnNpemUpIHtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBzaXplID0gMDtcbiAgICAgICAgaWYgKHRvID4gZnJvbSlcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBwb3MgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jb250ZW50W2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zIDwgZnJvbSB8fCBlbmQgPiB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlzVGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zKSwgTWF0aC5taW4oY2hpbGQudGV4dC5sZW5ndGgsIHRvIC0gcG9zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jdXQoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyAtIDEpLCBNYXRoLm1pbihjaGlsZC5jb250ZW50LnNpemUsIHRvIC0gcG9zIC0gMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHJlc3VsdCwgc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3V0QnlJbmRleChmcm9tLCB0bykge1xuICAgICAgICBpZiAoZnJvbSA9PSB0bylcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQodGhpcy5jb250ZW50LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBpbiB3aGljaCB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXggaXNcbiAgICByZXBsYWNlZCBieSB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAqL1xuICAgIHJlcGxhY2VDaGlsZChpbmRleCwgbm9kZSkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuY29udGVudFtpbmRleF07XG4gICAgICAgIGlmIChjdXJyZW50ID09IG5vZGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IGNvcHkgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKTtcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplIC0gY3VycmVudC5ub2RlU2l6ZTtcbiAgICAgICAgY29weVtpbmRleF0gPSBub2RlO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvcHksIHNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgYnkgcHJlcGVuZGluZyB0aGUgZ2l2ZW4gbm9kZSB0byB0aGlzXG4gICAgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBhZGRUb1N0YXJ0KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZV0uY29uY2F0KHRoaXMuY29udGVudCksIHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgYnkgYXBwZW5kaW5nIHRoZSBnaXZlbiBub2RlIHRvIHRoaXNcbiAgICBmcmFnbWVudC5cbiAgICAqL1xuICAgIGFkZFRvRW5kKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmNvbnRlbnQuY29uY2F0KG5vZGUpLCB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIGZyYWdtZW50IHRvIGFub3RoZXIgb25lLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggIT0gb3RoZXIuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRbaV0uZXEob3RoZXIuY29udGVudFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBmcmFnbWVudCwgb3IgYG51bGxgIGlmIGl0IGlzIGVtcHR5LlxuICAgICovXG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50WzBdIDogbnVsbDsgfVxuICAgIC8qKlxuICAgIFRoZSBsYXN0IGNoaWxkIG9mIHRoZSBmcmFnbWVudCwgb3IgYG51bGxgIGlmIGl0IGlzIGVtcHR5LlxuICAgICovXG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdIDogbnVsbDsgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2YgY2hpbGQgbm9kZXMgaW4gdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIGdldCBjaGlsZENvdW50KCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguIFJhaXNlIGFuIGVycm9yIHdoZW4gdGhlXG4gICAgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgICovXG4gICAgY2hpbGQoaW5kZXgpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5jb250ZW50W2luZGV4XTtcbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggXCIgKyBpbmRleCArIFwiIG91dCBvZiByYW5nZSBmb3IgXCIgKyB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LCBpZiBpdCBleGlzdHMuXG4gICAgKi9cbiAgICBtYXliZUNoaWxkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRbaW5kZXhdIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGwgYGZgIGZvciBldmVyeSBjaGlsZCBub2RlLCBwYXNzaW5nIHRoZSBub2RlLCBpdHMgb2Zmc2V0XG4gICAgaW50byB0aGlzIHBhcmVudCBub2RlLCBhbmQgaXRzIGluZGV4LlxuICAgICovXG4gICAgZm9yRWFjaChmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jb250ZW50W2ldO1xuICAgICAgICAgICAgZihjaGlsZCwgcCwgaSk7XG4gICAgICAgICAgICBwICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGZpcnN0IHBvc2l0aW9uIGF0IHdoaWNoIHRoaXMgZnJhZ21lbnQgYW5kIGFub3RoZXJcbiAgICBmcmFnbWVudCBkaWZmZXIsIG9yIGBudWxsYCBpZiB0aGV5IGFyZSB0aGUgc2FtZS5cbiAgICAqL1xuICAgIGZpbmREaWZmU3RhcnQob3RoZXIsIHBvcyA9IDApIHtcbiAgICAgICAgcmV0dXJuIGZpbmREaWZmU3RhcnQodGhpcywgb3RoZXIsIHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGZpcnN0IHBvc2l0aW9uLCBzZWFyY2hpbmcgZnJvbSB0aGUgZW5kLCBhdCB3aGljaCB0aGlzXG4gICAgZnJhZ21lbnQgYW5kIHRoZSBnaXZlbiBmcmFnbWVudCBkaWZmZXIsIG9yIGBudWxsYCBpZiB0aGV5IGFyZVxuICAgIHRoZSBzYW1lLiBTaW5jZSB0aGlzIHBvc2l0aW9uIHdpbGwgbm90IGJlIHRoZSBzYW1lIGluIGJvdGhcbiAgICBub2RlcywgYW4gb2JqZWN0IHdpdGggdHdvIHNlcGFyYXRlIHBvc2l0aW9ucyBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIGZpbmREaWZmRW5kKG90aGVyLCBwb3MgPSB0aGlzLnNpemUsIG90aGVyUG9zID0gb3RoZXIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmluZERpZmZFbmQodGhpcywgb3RoZXIsIHBvcywgb3RoZXJQb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBpbmRleCBhbmQgaW5uZXIgb2Zmc2V0IGNvcnJlc3BvbmRpbmcgdG8gYSBnaXZlbiByZWxhdGl2ZVxuICAgIHBvc2l0aW9uIGluIHRoaXMgZnJhZ21lbnQuIFRoZSByZXN1bHQgb2JqZWN0IHdpbGwgYmUgcmV1c2VkXG4gICAgKG92ZXJ3cml0dGVuKSB0aGUgbmV4dCB0aW1lIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQuIChOb3QgcHVibGljLilcbiAgICAqL1xuICAgIGZpbmRJbmRleChwb3MsIHJvdW5kID0gLTEpIHtcbiAgICAgICAgaWYgKHBvcyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KDAsIHBvcyk7XG4gICAgICAgIGlmIChwb3MgPT0gdGhpcy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KHRoaXMuY29udGVudC5sZW5ndGgsIHBvcyk7XG4gICAgICAgIGlmIChwb3MgPiB0aGlzLnNpemUgfHwgcG9zIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQb3NpdGlvbiAke3Bvc30gb3V0c2lkZSBvZiBmcmFnbWVudCAoJHt0aGlzfSlgKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGN1clBvcyA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLmNoaWxkKGkpLCBlbmQgPSBjdXJQb3MgKyBjdXIubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoZW5kID49IHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPT0gcG9zIHx8IHJvdW5kID4gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KGkgKyAxLCBlbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXRJbmRleChpLCBjdXJQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyUG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIGRlYnVnZ2luZyBzdHJpbmcgdGhhdCBkZXNjcmliZXMgdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gXCI8XCIgKyB0aGlzLnRvU3RyaW5nSW5uZXIoKSArIFwiPlwiOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZ0lubmVyKCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmpvaW4oXCIsIFwiKTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZyYWdtZW50LlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudC5tYXAobiA9PiBuLnRvSlNPTigpKSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgZnJhZ21lbnQgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEZyYWdtZW50LmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHZhbHVlLm1hcChzY2hlbWEubm9kZUZyb21KU09OKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgZnJhZ21lbnQgZnJvbSBhbiBhcnJheSBvZiBub2Rlcy4gRW5zdXJlcyB0aGF0IGFkamFjZW50XG4gICAgdGV4dCBub2RlcyB3aXRoIHRoZSBzYW1lIG1hcmtzIGFyZSBqb2luZWQgdG9nZXRoZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUFycmF5KGFycmF5KSB7XG4gICAgICAgIGlmICghYXJyYXkubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBsZXQgam9pbmVkLCBzaXplID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChpICYmIG5vZGUuaXNUZXh0ICYmIGFycmF5W2kgLSAxXS5zYW1lTWFya3VwKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFqb2luZWQpXG4gICAgICAgICAgICAgICAgICAgIGpvaW5lZCA9IGFycmF5LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGpvaW5lZFtqb2luZWQubGVuZ3RoIC0gMV0gPSBub2RlXG4gICAgICAgICAgICAgICAgICAgIC53aXRoVGV4dChqb2luZWRbam9pbmVkLmxlbmd0aCAtIDFdLnRleHQgKyBub2RlLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoam9pbmVkKSB7XG4gICAgICAgICAgICAgICAgam9pbmVkLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChqb2luZWQgfHwgYXJyYXksIHNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmcmFnbWVudCBmcm9tIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBpbnRlcnByZXRlZCBhcyBhXG4gICAgc2V0IG9mIG5vZGVzLiBGb3IgYG51bGxgLCBpdCByZXR1cm5zIHRoZSBlbXB0eSBmcmFnbWVudC4gRm9yIGFcbiAgICBmcmFnbWVudCwgdGhlIGZyYWdtZW50IGl0c2VsZi4gRm9yIGEgbm9kZSBvciBhcnJheSBvZiBub2RlcywgYVxuICAgIGZyYWdtZW50IGNvbnRhaW5pbmcgdGhvc2Ugbm9kZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbShub2Rlcykge1xuICAgICAgICBpZiAoIW5vZGVzKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBpZiAobm9kZXMgaW5zdGFuY2VvZiBGcmFnbWVudClcbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUFycmF5KG5vZGVzKTtcbiAgICAgICAgaWYgKG5vZGVzLmF0dHJzKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZXNdLCBub2Rlcy5ub2RlU2l6ZSk7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IFwiICsgbm9kZXMgKyBcIiB0byBhIEZyYWdtZW50XCIgK1xuICAgICAgICAgICAgKG5vZGVzLm5vZGVzQmV0d2VlbiA/IFwiIChsb29rcyBsaWtlIG11bHRpcGxlIHZlcnNpb25zIG9mIHByb3NlbWlycm9yLW1vZGVsIHdlcmUgbG9hZGVkKVwiIDogXCJcIikpO1xuICAgIH1cbn1cbi8qKlxuQW4gZW1wdHkgZnJhZ21lbnQuIEludGVuZGVkIHRvIGJlIHJldXNlZCB3aGVuZXZlciBhIG5vZGUgZG9lc24ndFxuY29udGFpbiBhbnl0aGluZyAocmF0aGVyIHRoYW4gYWxsb2NhdGluZyBhIG5ldyBlbXB0eSBmcmFnbWVudCBmb3JcbmVhY2ggbGVhZiBub2RlKS5cbiovXG5GcmFnbWVudC5lbXB0eSA9IG5ldyBGcmFnbWVudChbXSwgMCk7XG5jb25zdCBmb3VuZCA9IHsgaW5kZXg6IDAsIG9mZnNldDogMCB9O1xuZnVuY3Rpb24gcmV0SW5kZXgoaW5kZXgsIG9mZnNldCkge1xuICAgIGZvdW5kLmluZGV4ID0gaW5kZXg7XG4gICAgZm91bmQub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiBmb3VuZDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZURlZXAoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIShhICYmIHR5cGVvZiBhID09IFwib2JqZWN0XCIpIHx8XG4gICAgICAgICEoYiAmJiB0eXBlb2YgYiA9PSBcIm9iamVjdFwiKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhcnJheSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYikgIT0gYXJyYXkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWNvbXBhcmVEZWVwKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IHAgaW4gYSlcbiAgICAgICAgICAgIGlmICghKHAgaW4gYikgfHwgIWNvbXBhcmVEZWVwKGFbcF0sIGJbcF0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgcCBpbiBiKVxuICAgICAgICAgICAgaWYgKCEocCBpbiBhKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbkEgbWFyayBpcyBhIHBpZWNlIG9mIGluZm9ybWF0aW9uIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgbm9kZSxcbnN1Y2ggYXMgaXQgYmVpbmcgZW1waGFzaXplZCwgaW4gY29kZSBmb250LCBvciBhIGxpbmsuIEl0IGhhcyBhXG50eXBlIGFuZCBvcHRpb25hbGx5IGEgc2V0IG9mIGF0dHJpYnV0ZXMgdGhhdCBwcm92aWRlIGZ1cnRoZXJcbmluZm9ybWF0aW9uIChzdWNoIGFzIHRoZSB0YXJnZXQgb2YgdGhlIGxpbmspLiBNYXJrcyBhcmUgY3JlYXRlZFxudGhyb3VnaCBhIGBTY2hlbWFgLCB3aGljaCBjb250cm9scyB3aGljaCB0eXBlcyBleGlzdCBhbmQgd2hpY2hcbmF0dHJpYnV0ZXMgdGhleSBoYXZlLlxuKi9cbmNsYXNzIE1hcmsge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgdGhpcyBtYXJrLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIGF0dHJpYnV0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWFyay5cbiAgICAqL1xuICAgIGF0dHJzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICB9XG4gICAgLyoqXG4gICAgR2l2ZW4gYSBzZXQgb2YgbWFya3MsIGNyZWF0ZSBhIG5ldyBzZXQgd2hpY2ggY29udGFpbnMgdGhpcyBvbmUgYXNcbiAgICB3ZWxsLCBpbiB0aGUgcmlnaHQgcG9zaXRpb24uIElmIHRoaXMgbWFyayBpcyBhbHJlYWR5IGluIHRoZSBzZXQsXG4gICAgdGhlIHNldCBpdHNlbGYgaXMgcmV0dXJuZWQuIElmIGFueSBtYXJrcyB0aGF0IGFyZSBzZXQgdG8gYmVcbiAgICBbZXhjbHVzaXZlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1NwZWMuZXhjbHVkZXMpIHdpdGggdGhpcyBtYXJrIGFyZSBwcmVzZW50LFxuICAgIHRob3NlIGFyZSByZXBsYWNlZCBieSB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFkZFRvU2V0KHNldCkge1xuICAgICAgICBsZXQgY29weSwgcGxhY2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgb3RoZXIgPSBzZXRbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5lcShvdGhlcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUuZXhjbHVkZXMob3RoZXIudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBzZXQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdGhlci50eXBlLmV4Y2x1ZGVzKHRoaXMudHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwbGFjZWQgJiYgb3RoZXIudHlwZS5yYW5rID4gdGhpcy50eXBlLnJhbmspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29weSA9IHNldC5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgY29weS5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwbGFjZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29weSlcbiAgICAgICAgICAgICAgICAgICAgY29weS5wdXNoKG90aGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICBjb3B5ID0gc2V0LnNsaWNlKCk7XG4gICAgICAgIGlmICghcGxhY2VkKVxuICAgICAgICAgICAgY29weS5wdXNoKHRoaXMpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIHRoaXMgbWFyayBmcm9tIHRoZSBnaXZlbiBzZXQsIHJldHVybmluZyBhIG5ldyBzZXQuIElmIHRoaXNcbiAgICBtYXJrIGlzIG5vdCBpbiB0aGUgc2V0LCB0aGUgc2V0IGl0c2VsZiBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIHJlbW92ZUZyb21TZXQoc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMuZXEoc2V0W2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0LnNsaWNlKDAsIGkpLmNvbmNhdChzZXQuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgbWFyayBpcyBpbiB0aGUgZ2l2ZW4gc2V0IG9mIG1hcmtzLlxuICAgICovXG4gICAgaXNJblNldChzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5lcShzZXRbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGlzIG1hcmsgaGFzIHRoZSBzYW1lIHR5cGUgYW5kIGF0dHJpYnV0ZXMgYXNcbiAgICBhbm90aGVyIG1hcmsuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgKHRoaXMudHlwZSA9PSBvdGhlci50eXBlICYmIGNvbXBhcmVEZWVwKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBtYXJrIHRvIGEgSlNPTi1zZXJpYWxpemVhYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgb2JqID0geyB0eXBlOiB0aGlzLnR5cGUubmFtZSB9O1xuICAgICAgICBmb3IgKGxldCBfIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgICAgIG9iai5hdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG1hcmsgZnJvbSBKU09OLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE1hcmsuZnJvbUpTT05cIik7XG4gICAgICAgIGxldCB0eXBlID0gc2NoZW1hLm1hcmtzW2pzb24udHlwZV07XG4gICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGVyZSBpcyBubyBtYXJrIHR5cGUgJHtqc29uLnR5cGV9IGluIHRoaXMgc2NoZW1hYCk7XG4gICAgICAgIHJldHVybiB0eXBlLmNyZWF0ZShqc29uLmF0dHJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHR3byBzZXRzIG9mIG1hcmtzIGFyZSBpZGVudGljYWwuXG4gICAgKi9cbiAgICBzdGF0aWMgc2FtZVNldChhLCBiKSB7XG4gICAgICAgIGlmIChhID09IGIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWFbaV0uZXEoYltpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcHJvcGVybHkgc29ydGVkIG1hcmsgc2V0IGZyb20gbnVsbCwgYSBzaW5nbGUgbWFyaywgb3IgYW5cbiAgICB1bnNvcnRlZCBhcnJheSBvZiBtYXJrcy5cbiAgICAqL1xuICAgIHN0YXRpYyBzZXRGcm9tKG1hcmtzKSB7XG4gICAgICAgIGlmICghbWFya3MgfHwgQXJyYXkuaXNBcnJheShtYXJrcykgJiYgbWFya3MubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gTWFyay5ub25lO1xuICAgICAgICBpZiAobWFya3MgaW5zdGFuY2VvZiBNYXJrKVxuICAgICAgICAgICAgcmV0dXJuIFttYXJrc107XG4gICAgICAgIGxldCBjb3B5ID0gbWFya3Muc2xpY2UoKTtcbiAgICAgICAgY29weS5zb3J0KChhLCBiKSA9PiBhLnR5cGUucmFuayAtIGIudHlwZS5yYW5rKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIG1hcmtzLlxuKi9cbk1hcmsubm9uZSA9IFtdO1xuXG4vKipcbkVycm9yIHR5cGUgcmFpc2VkIGJ5IFtgTm9kZS5yZXBsYWNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUucmVwbGFjZSkgd2hlblxuZ2l2ZW4gYW4gaW52YWxpZCByZXBsYWNlbWVudC5cbiovXG5jbGFzcyBSZXBsYWNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG4vKlxuUmVwbGFjZUVycm9yID0gZnVuY3Rpb24odGhpczogYW55LCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgbGV0IGVyciA9IEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSlcbiAgOyhlcnIgYXMgYW55KS5fX3Byb3RvX18gPSBSZXBsYWNlRXJyb3IucHJvdG90eXBlXG4gIHJldHVybiBlcnJcbn0gYXMgYW55XG5cblJlcGxhY2VFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSlcblJlcGxhY2VFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXBsYWNlRXJyb3JcblJlcGxhY2VFcnJvci5wcm90b3R5cGUubmFtZSA9IFwiUmVwbGFjZUVycm9yXCJcbiovXG4vKipcbkEgc2xpY2UgcmVwcmVzZW50cyBhIHBpZWNlIGN1dCBvdXQgb2YgYSBsYXJnZXIgZG9jdW1lbnQuIEl0XG5zdG9yZXMgbm90IG9ubHkgYSBmcmFnbWVudCwgYnV0IGFsc28gdGhlIGRlcHRoIHVwIHRvIHdoaWNoIG5vZGVzIG9uXG5ib3RoIHNpZGUgYXJlIFx1MjAxOG9wZW5cdTIwMTkgKGN1dCB0aHJvdWdoKS5cbiovXG5jbGFzcyBTbGljZSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2xpY2UuIFdoZW4gc3BlY2lmeWluZyBhIG5vbi16ZXJvIG9wZW4gZGVwdGgsIHlvdSBtdXN0XG4gICAgbWFrZSBzdXJlIHRoYXQgdGhlcmUgYXJlIG5vZGVzIG9mIGF0IGxlYXN0IHRoYXQgZGVwdGggYXQgdGhlXG4gICAgYXBwcm9wcmlhdGUgc2lkZSBvZiB0aGUgZnJhZ21lbnRcdTIwMTRpLmUuIGlmIHRoZSBmcmFnbWVudCBpcyBhblxuICAgIGVtcHR5IHBhcmFncmFwaCBub2RlLCBgb3BlblN0YXJ0YCBhbmQgYG9wZW5FbmRgIGNhbid0IGJlIGdyZWF0ZXJcbiAgICB0aGFuIDEuXG4gICAgXG4gICAgSXQgaXMgbm90IG5lY2Vzc2FyeSBmb3IgdGhlIGNvbnRlbnQgb2Ygb3BlbiBub2RlcyB0byBjb25mb3JtIHRvXG4gICAgdGhlIHNjaGVtYSdzIGNvbnRlbnQgY29uc3RyYWludHMsIHRob3VnaCBpdCBzaG91bGQgYmUgYSB2YWxpZFxuICAgIHN0YXJ0L2VuZC9taWRkbGUgZm9yIHN1Y2ggYSBub2RlLCBkZXBlbmRpbmcgb24gd2hpY2ggc2lkZXMgYXJlXG4gICAgb3Blbi5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzbGljZSdzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBjb250ZW50LCBcbiAgICAvKipcbiAgICBUaGUgb3BlbiBkZXB0aCBhdCB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50LlxuICAgICovXG4gICAgb3BlblN0YXJ0LCBcbiAgICAvKipcbiAgICBUaGUgb3BlbiBkZXB0aCBhdCB0aGUgZW5kLlxuICAgICovXG4gICAgb3BlbkVuZCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICAgICAgdGhpcy5vcGVuRW5kID0gb3BlbkVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNpemUgdGhpcyBzbGljZSB3b3VsZCBhZGQgd2hlbiBpbnNlcnRlZCBpbnRvIGEgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5zaXplIC0gdGhpcy5vcGVuU3RhcnQgLSB0aGlzLm9wZW5FbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW5zZXJ0QXQocG9zLCBmcmFnbWVudCkge1xuICAgICAgICBsZXQgY29udGVudCA9IGluc2VydEludG8odGhpcy5jb250ZW50LCBwb3MgKyB0aGlzLm9wZW5TdGFydCwgZnJhZ21lbnQpO1xuICAgICAgICByZXR1cm4gY29udGVudCAmJiBuZXcgU2xpY2UoY29udGVudCwgdGhpcy5vcGVuU3RhcnQsIHRoaXMub3BlbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVtb3ZlQmV0d2Vlbihmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKHJlbW92ZVJhbmdlKHRoaXMuY29udGVudCwgZnJvbSArIHRoaXMub3BlblN0YXJ0LCB0byArIHRoaXMub3BlblN0YXJ0KSwgdGhpcy5vcGVuU3RhcnQsIHRoaXMub3BlbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3RzIHdoZXRoZXIgdGhpcyBzbGljZSBpcyBlcXVhbCB0byBhbm90aGVyIHNsaWNlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5lcShvdGhlci5jb250ZW50KSAmJiB0aGlzLm9wZW5TdGFydCA9PSBvdGhlci5vcGVuU3RhcnQgJiYgdGhpcy5vcGVuRW5kID09IG90aGVyLm9wZW5FbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQgKyBcIihcIiArIHRoaXMub3BlblN0YXJ0ICsgXCIsXCIgKyB0aGlzLm9wZW5FbmQgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCBhIHNsaWNlIHRvIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGpzb24gPSB7IGNvbnRlbnQ6IHRoaXMuY29udGVudC50b0pTT04oKSB9O1xuICAgICAgICBpZiAodGhpcy5vcGVuU3RhcnQgPiAwKVxuICAgICAgICAgICAganNvbi5vcGVuU3RhcnQgPSB0aGlzLm9wZW5TdGFydDtcbiAgICAgICAgaWYgKHRoaXMub3BlbkVuZCA+IDApXG4gICAgICAgICAgICBqc29uLm9wZW5FbmQgPSB0aGlzLm9wZW5FbmQ7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIHNsaWNlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHJldHVybiBTbGljZS5lbXB0eTtcbiAgICAgICAgbGV0IG9wZW5TdGFydCA9IGpzb24ub3BlblN0YXJ0IHx8IDAsIG9wZW5FbmQgPSBqc29uLm9wZW5FbmQgfHwgMDtcbiAgICAgICAgaWYgKHR5cGVvZiBvcGVuU3RhcnQgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygb3BlbkVuZCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTbGljZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShGcmFnbWVudC5mcm9tSlNPTihzY2hlbWEsIGpzb24uY29udGVudCksIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNsaWNlIGZyb20gYSBmcmFnbWVudCBieSB0YWtpbmcgdGhlIG1heGltdW0gcG9zc2libGVcbiAgICBvcGVuIHZhbHVlIG9uIGJvdGggc2lkZSBvZiB0aGUgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgbWF4T3BlbihmcmFnbWVudCwgb3Blbklzb2xhdGluZyA9IHRydWUpIHtcbiAgICAgICAgbGV0IG9wZW5TdGFydCA9IDAsIG9wZW5FbmQgPSAwO1xuICAgICAgICBmb3IgKGxldCBuID0gZnJhZ21lbnQuZmlyc3RDaGlsZDsgbiAmJiAhbi5pc0xlYWYgJiYgKG9wZW5Jc29sYXRpbmcgfHwgIW4udHlwZS5zcGVjLmlzb2xhdGluZyk7IG4gPSBuLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgZm9yIChsZXQgbiA9IGZyYWdtZW50Lmxhc3RDaGlsZDsgbiAmJiAhbi5pc0xlYWYgJiYgKG9wZW5Jc29sYXRpbmcgfHwgIW4udHlwZS5zcGVjLmlzb2xhdGluZyk7IG4gPSBuLmxhc3RDaGlsZClcbiAgICAgICAgICAgIG9wZW5FbmQrKztcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShmcmFnbWVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICB9XG59XG4vKipcblRoZSBlbXB0eSBzbGljZS5cbiovXG5TbGljZS5lbXB0eSA9IG5ldyBTbGljZShGcmFnbWVudC5lbXB0eSwgMCwgMCk7XG5mdW5jdGlvbiByZW1vdmVSYW5nZShjb250ZW50LCBmcm9tLCB0bykge1xuICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IGNvbnRlbnQuZmluZEluZGV4KGZyb20pLCBjaGlsZCA9IGNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgbGV0IHsgaW5kZXg6IGluZGV4VG8sIG9mZnNldDogb2Zmc2V0VG8gfSA9IGNvbnRlbnQuZmluZEluZGV4KHRvKTtcbiAgICBpZiAob2Zmc2V0ID09IGZyb20gfHwgY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgIGlmIChvZmZzZXRUbyAhPSB0byAmJiAhY29udGVudC5jaGlsZChpbmRleFRvKS5pc1RleHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlbW92aW5nIG5vbi1mbGF0IHJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gY29udGVudC5jdXQoMCwgZnJvbSkuYXBwZW5kKGNvbnRlbnQuY3V0KHRvKSk7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPSBpbmRleFRvKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlbW92aW5nIG5vbi1mbGF0IHJhbmdlXCIpO1xuICAgIHJldHVybiBjb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgY2hpbGQuY29weShyZW1vdmVSYW5nZShjaGlsZC5jb250ZW50LCBmcm9tIC0gb2Zmc2V0IC0gMSwgdG8gLSBvZmZzZXQgLSAxKSkpO1xufVxuZnVuY3Rpb24gaW5zZXJ0SW50byhjb250ZW50LCBkaXN0LCBpbnNlcnQsIHBhcmVudCkge1xuICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IGNvbnRlbnQuZmluZEluZGV4KGRpc3QpLCBjaGlsZCA9IGNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgaWYgKG9mZnNldCA9PSBkaXN0IHx8IGNoaWxkLmlzVGV4dCkge1xuICAgICAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXgsIGluc2VydCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQuY3V0KDAsIGRpc3QpLmFwcGVuZChpbnNlcnQpLmFwcGVuZChjb250ZW50LmN1dChkaXN0KSk7XG4gICAgfVxuICAgIGxldCBpbm5lciA9IGluc2VydEludG8oY2hpbGQuY29udGVudCwgZGlzdCAtIG9mZnNldCAtIDEsIGluc2VydCk7XG4gICAgcmV0dXJuIGlubmVyICYmIGNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBjaGlsZC5jb3B5KGlubmVyKSk7XG59XG5mdW5jdGlvbiByZXBsYWNlKCRmcm9tLCAkdG8sIHNsaWNlKSB7XG4gICAgaWYgKHNsaWNlLm9wZW5TdGFydCA+ICRmcm9tLmRlcHRoKVxuICAgICAgICB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiSW5zZXJ0ZWQgY29udGVudCBkZWVwZXIgdGhhbiBpbnNlcnRpb24gcG9zaXRpb25cIik7XG4gICAgaWYgKCRmcm9tLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0ICE9ICR0by5kZXB0aCAtIHNsaWNlLm9wZW5FbmQpXG4gICAgICAgIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbmNvbnNpc3RlbnQgb3BlbiBkZXB0aHNcIik7XG4gICAgcmV0dXJuIHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgMCk7XG59XG5mdW5jdGlvbiByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIGRlcHRoKSB7XG4gICAgbGV0IGluZGV4ID0gJGZyb20uaW5kZXgoZGVwdGgpLCBub2RlID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgaWYgKGluZGV4ID09ICR0by5pbmRleChkZXB0aCkgJiYgZGVwdGggPCAkZnJvbS5kZXB0aCAtIHNsaWNlLm9wZW5TdGFydCkge1xuICAgICAgICBsZXQgaW5uZXIgPSByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIGRlcHRoICsgMSk7XG4gICAgICAgIHJldHVybiBub2RlLmNvcHkobm9kZS5jb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgaW5uZXIpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXNsaWNlLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICByZXR1cm4gY2xvc2Uobm9kZSwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICghc2xpY2Uub3BlblN0YXJ0ICYmICFzbGljZS5vcGVuRW5kICYmICRmcm9tLmRlcHRoID09IGRlcHRoICYmICR0by5kZXB0aCA9PSBkZXB0aCkgeyAvLyBTaW1wbGUsIGZsYXQgY2FzZVxuICAgICAgICBsZXQgcGFyZW50ID0gJGZyb20ucGFyZW50LCBjb250ZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgICAgIHJldHVybiBjbG9zZShwYXJlbnQsIGNvbnRlbnQuY3V0KDAsICRmcm9tLnBhcmVudE9mZnNldCkuYXBwZW5kKHNsaWNlLmNvbnRlbnQpLmFwcGVuZChjb250ZW50LmN1dCgkdG8ucGFyZW50T2Zmc2V0KSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcHJlcGFyZVNsaWNlRm9yUmVwbGFjZShzbGljZSwgJGZyb20pO1xuICAgICAgICByZXR1cm4gY2xvc2Uobm9kZSwgcmVwbGFjZVRocmVlV2F5KCRmcm9tLCBzdGFydCwgZW5kLCAkdG8sIGRlcHRoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tKb2luKG1haW4sIHN1Yikge1xuICAgIGlmICghc3ViLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQobWFpbi50eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkNhbm5vdCBqb2luIFwiICsgc3ViLnR5cGUubmFtZSArIFwiIG9udG8gXCIgKyBtYWluLnR5cGUubmFtZSk7XG59XG5mdW5jdGlvbiBqb2luYWJsZSgkYmVmb3JlLCAkYWZ0ZXIsIGRlcHRoKSB7XG4gICAgbGV0IG5vZGUgPSAkYmVmb3JlLm5vZGUoZGVwdGgpO1xuICAgIGNoZWNrSm9pbihub2RlLCAkYWZ0ZXIubm9kZShkZXB0aCkpO1xuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gYWRkTm9kZShjaGlsZCwgdGFyZ2V0KSB7XG4gICAgbGV0IGxhc3QgPSB0YXJnZXQubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA+PSAwICYmIGNoaWxkLmlzVGV4dCAmJiBjaGlsZC5zYW1lTWFya3VwKHRhcmdldFtsYXN0XSkpXG4gICAgICAgIHRhcmdldFtsYXN0XSA9IGNoaWxkLndpdGhUZXh0KHRhcmdldFtsYXN0XS50ZXh0ICsgY2hpbGQudGV4dCk7XG4gICAgZWxzZVxuICAgICAgICB0YXJnZXQucHVzaChjaGlsZCk7XG59XG5mdW5jdGlvbiBhZGRSYW5nZSgkc3RhcnQsICRlbmQsIGRlcHRoLCB0YXJnZXQpIHtcbiAgICBsZXQgbm9kZSA9ICgkZW5kIHx8ICRzdGFydCkubm9kZShkZXB0aCk7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSAwLCBlbmRJbmRleCA9ICRlbmQgPyAkZW5kLmluZGV4KGRlcHRoKSA6IG5vZGUuY2hpbGRDb3VudDtcbiAgICBpZiAoJHN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSAkc3RhcnQuaW5kZXgoZGVwdGgpO1xuICAgICAgICBpZiAoJHN0YXJ0LmRlcHRoID4gZGVwdGgpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgkc3RhcnQudGV4dE9mZnNldCkge1xuICAgICAgICAgICAgYWRkTm9kZSgkc3RhcnQubm9kZUFmdGVyLCB0YXJnZXQpO1xuICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKylcbiAgICAgICAgYWRkTm9kZShub2RlLmNoaWxkKGkpLCB0YXJnZXQpO1xuICAgIGlmICgkZW5kICYmICRlbmQuZGVwdGggPT0gZGVwdGggJiYgJGVuZC50ZXh0T2Zmc2V0KVxuICAgICAgICBhZGROb2RlKCRlbmQubm9kZUJlZm9yZSwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGNsb3NlKG5vZGUsIGNvbnRlbnQpIHtcbiAgICBub2RlLnR5cGUuY2hlY2tDb250ZW50KGNvbnRlbnQpO1xuICAgIHJldHVybiBub2RlLmNvcHkoY29udGVudCk7XG59XG5mdW5jdGlvbiByZXBsYWNlVGhyZWVXYXkoJGZyb20sICRzdGFydCwgJGVuZCwgJHRvLCBkZXB0aCkge1xuICAgIGxldCBvcGVuU3RhcnQgPSAkZnJvbS5kZXB0aCA+IGRlcHRoICYmIGpvaW5hYmxlKCRmcm9tLCAkc3RhcnQsIGRlcHRoICsgMSk7XG4gICAgbGV0IG9wZW5FbmQgPSAkdG8uZGVwdGggPiBkZXB0aCAmJiBqb2luYWJsZSgkZW5kLCAkdG8sIGRlcHRoICsgMSk7XG4gICAgbGV0IGNvbnRlbnQgPSBbXTtcbiAgICBhZGRSYW5nZShudWxsLCAkZnJvbSwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIGlmIChvcGVuU3RhcnQgJiYgb3BlbkVuZCAmJiAkc3RhcnQuaW5kZXgoZGVwdGgpID09ICRlbmQuaW5kZXgoZGVwdGgpKSB7XG4gICAgICAgIGNoZWNrSm9pbihvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICBhZGROb2RlKGNsb3NlKG9wZW5TdGFydCwgcmVwbGFjZVRocmVlV2F5KCRmcm9tLCAkc3RhcnQsICRlbmQsICR0bywgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9wZW5TdGFydClcbiAgICAgICAgICAgIGFkZE5vZGUoY2xvc2Uob3BlblN0YXJ0LCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkc3RhcnQsIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICAgICAgYWRkUmFuZ2UoJHN0YXJ0LCAkZW5kLCBkZXB0aCwgY29udGVudCk7XG4gICAgICAgIGlmIChvcGVuRW5kKVxuICAgICAgICAgICAgYWRkTm9kZShjbG9zZShvcGVuRW5kLCByZXBsYWNlVHdvV2F5KCRlbmQsICR0bywgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgIH1cbiAgICBhZGRSYW5nZSgkdG8sIG51bGwsIGRlcHRoLCBjb250ZW50KTtcbiAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCkge1xuICAgIGxldCBjb250ZW50ID0gW107XG4gICAgYWRkUmFuZ2UobnVsbCwgJGZyb20sIGRlcHRoLCBjb250ZW50KTtcbiAgICBpZiAoJGZyb20uZGVwdGggPiBkZXB0aCkge1xuICAgICAgICBsZXQgdHlwZSA9IGpvaW5hYmxlKCRmcm9tLCAkdG8sIGRlcHRoICsgMSk7XG4gICAgICAgIGFkZE5vZGUoY2xvc2UodHlwZSwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgfVxuICAgIGFkZFJhbmdlKCR0bywgbnVsbCwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudCk7XG59XG5mdW5jdGlvbiBwcmVwYXJlU2xpY2VGb3JSZXBsYWNlKHNsaWNlLCAkYWxvbmcpIHtcbiAgICBsZXQgZXh0cmEgPSAkYWxvbmcuZGVwdGggLSBzbGljZS5vcGVuU3RhcnQsIHBhcmVudCA9ICRhbG9uZy5ub2RlKGV4dHJhKTtcbiAgICBsZXQgbm9kZSA9IHBhcmVudC5jb3B5KHNsaWNlLmNvbnRlbnQpO1xuICAgIGZvciAobGV0IGkgPSBleHRyYSAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBub2RlID0gJGFsb25nLm5vZGUoaSkuY29weShGcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgICByZXR1cm4geyBzdGFydDogbm9kZS5yZXNvbHZlTm9DYWNoZShzbGljZS5vcGVuU3RhcnQgKyBleHRyYSksXG4gICAgICAgIGVuZDogbm9kZS5yZXNvbHZlTm9DYWNoZShub2RlLmNvbnRlbnQuc2l6ZSAtIHNsaWNlLm9wZW5FbmQgLSBleHRyYSkgfTtcbn1cblxuLyoqXG5Zb3UgY2FuIFtfcmVzb2x2ZV9dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnJlc29sdmUpIGEgcG9zaXRpb24gdG8gZ2V0IG1vcmVcbmluZm9ybWF0aW9uIGFib3V0IGl0LiBPYmplY3RzIG9mIHRoaXMgY2xhc3MgcmVwcmVzZW50IHN1Y2ggYVxucmVzb2x2ZWQgcG9zaXRpb24sIHByb3ZpZGluZyB2YXJpb3VzIHBpZWNlcyBvZiBjb250ZXh0XG5pbmZvcm1hdGlvbiwgYW5kIHNvbWUgaGVscGVyIG1ldGhvZHMuXG5cblRocm91Z2hvdXQgdGhpcyBpbnRlcmZhY2UsIG1ldGhvZHMgdGhhdCB0YWtlIGFuIG9wdGlvbmFsIGBkZXB0aGBcbnBhcmFtZXRlciB3aWxsIGludGVycHJldCB1bmRlZmluZWQgYXMgYHRoaXMuZGVwdGhgIGFuZCBuZWdhdGl2ZVxubnVtYmVycyBhcyBgdGhpcy5kZXB0aCArIHZhbHVlYC5cbiovXG5jbGFzcyBSZXNvbHZlZFBvcyB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gdGhhdCB3YXMgcmVzb2x2ZWQuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcGF0aCwgXG4gICAgLyoqXG4gICAgVGhlIG9mZnNldCB0aGlzIHBvc2l0aW9uIGhhcyBpbnRvIGl0cyBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIHBhcmVudE9mZnNldCkge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5wYXJlbnRPZmZzZXQgPSBwYXJlbnRPZmZzZXQ7XG4gICAgICAgIHRoaXMuZGVwdGggPSBwYXRoLmxlbmd0aCAvIDMgLSAxO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVEZXB0aCh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGg7XG4gICAgICAgIGlmICh2YWwgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGggKyB2YWw7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBwYXJlbnQgbm9kZSB0aGF0IHRoZSBwb3NpdGlvbiBwb2ludHMgaW50by4gTm90ZSB0aGF0IGV2ZW4gaWZcbiAgICBhIHBvc2l0aW9uIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCB0aGF0IG5vZGUgaXMgbm90IGNvbnNpZGVyZWRcbiAgICB0aGUgcGFyZW50XHUyMDE0dGV4dCBub2RlcyBhcmUgXHUyMDE4ZmxhdFx1MjAxOSBpbiB0aGlzIG1vZGVsLCBhbmQgaGF2ZSBubyBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHsgcmV0dXJuIHRoaXMubm9kZSh0aGlzLmRlcHRoKTsgfVxuICAgIC8qKlxuICAgIFRoZSByb290IG5vZGUgaW4gd2hpY2ggdGhlIHBvc2l0aW9uIHdhcyByZXNvbHZlZC5cbiAgICAqL1xuICAgIGdldCBkb2MoKSB7IHJldHVybiB0aGlzLm5vZGUoMCk7IH1cbiAgICAvKipcbiAgICBUaGUgYW5jZXN0b3Igbm9kZSBhdCB0aGUgZ2l2ZW4gbGV2ZWwuIGBwLm5vZGUocC5kZXB0aClgIGlzIHRoZVxuICAgIHNhbWUgYXMgYHAucGFyZW50YC5cbiAgICAqL1xuICAgIG5vZGUoZGVwdGgpIHsgcmV0dXJuIHRoaXMucGF0aFt0aGlzLnJlc29sdmVEZXB0aChkZXB0aCkgKiAzXTsgfVxuICAgIC8qKlxuICAgIFRoZSBpbmRleCBpbnRvIHRoZSBhbmNlc3RvciBhdCB0aGUgZ2l2ZW4gbGV2ZWwuIElmIHRoaXMgcG9pbnRzXG4gICAgYXQgdGhlIDNyZCBub2RlIGluIHRoZSAybmQgcGFyYWdyYXBoIG9uIHRoZSB0b3AgbGV2ZWwsIGZvclxuICAgIGV4YW1wbGUsIGBwLmluZGV4KDApYCBpcyAxIGFuZCBgcC5pbmRleCgxKWAgaXMgMi5cbiAgICAqL1xuICAgIGluZGV4KGRlcHRoKSB7IHJldHVybiB0aGlzLnBhdGhbdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpICogMyArIDFdOyB9XG4gICAgLyoqXG4gICAgVGhlIGluZGV4IHBvaW50aW5nIGFmdGVyIHRoaXMgcG9zaXRpb24gaW50byB0aGUgYW5jZXN0b3IgYXQgdGhlXG4gICAgZ2l2ZW4gbGV2ZWwuXG4gICAgKi9cbiAgICBpbmRleEFmdGVyKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleChkZXB0aCkgKyAoZGVwdGggPT0gdGhpcy5kZXB0aCAmJiAhdGhpcy50ZXh0T2Zmc2V0ID8gMCA6IDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuXG4gICAgbGV2ZWwuXG4gICAgKi9cbiAgICBzdGFydChkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIGRlcHRoID09IDAgPyAwIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW5cbiAgICBsZXZlbC5cbiAgICAqL1xuICAgIGVuZChkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoZGVwdGgpICsgdGhpcy5ub2RlKGRlcHRoKS5jb250ZW50LnNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGRpcmVjdGx5IGJlZm9yZSB0aGUgd3JhcHBpbmcgbm9kZSBhdCB0aGVcbiAgICBnaXZlbiBsZXZlbCwgb3IsIHdoZW4gYGRlcHRoYCBpcyBgdGhpcy5kZXB0aCArIDFgLCB0aGUgb3JpZ2luYWxcbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGJlZm9yZShkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlcmUgaXMgbm8gcG9zaXRpb24gYmVmb3JlIHRoZSB0b3AtbGV2ZWwgbm9kZVwiKTtcbiAgICAgICAgcmV0dXJuIGRlcHRoID09IHRoaXMuZGVwdGggKyAxID8gdGhpcy5wb3MgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV07XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGRpcmVjdGx5IGFmdGVyIHRoZSB3cmFwcGluZyBub2RlIGF0IHRoZVxuICAgIGdpdmVuIGxldmVsLCBvciB0aGUgb3JpZ2luYWwgcG9zaXRpb24gd2hlbiBgZGVwdGhgIGlzIGB0aGlzLmRlcHRoICsgMWAuXG4gICAgKi9cbiAgICBhZnRlcihkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlcmUgaXMgbm8gcG9zaXRpb24gYWZ0ZXIgdGhlIHRvcC1sZXZlbCBub2RlXCIpO1xuICAgICAgICByZXR1cm4gZGVwdGggPT0gdGhpcy5kZXB0aCArIDEgPyB0aGlzLnBvcyA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIHRoaXMucGF0aFtkZXB0aCAqIDNdLm5vZGVTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGVuIHRoaXMgcG9zaXRpb24gcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIHRoaXMgcmV0dXJucyB0aGVcbiAgICBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb3NpdGlvbiBhbmQgdGhlIHN0YXJ0IG9mIHRoZSB0ZXh0IG5vZGUuXG4gICAgV2lsbCBiZSB6ZXJvIGZvciBwb3NpdGlvbnMgdGhhdCBwb2ludCBiZXR3ZWVuIG5vZGVzLlxuICAgICovXG4gICAgZ2V0IHRleHRPZmZzZXQoKSB7IHJldHVybiB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG5vZGUgZGlyZWN0bHkgYWZ0ZXIgdGhlIHBvc2l0aW9uLCBpZiBhbnkuIElmIHRoZSBwb3NpdGlvblxuICAgIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCBvbmx5IHRoZSBwYXJ0IG9mIHRoYXQgbm9kZSBhZnRlciB0aGVcbiAgICBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIGdldCBub2RlQWZ0ZXIoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudCwgaW5kZXggPSB0aGlzLmluZGV4KHRoaXMuZGVwdGgpO1xuICAgICAgICBpZiAoaW5kZXggPT0gcGFyZW50LmNoaWxkQ291bnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGRPZmYgPSB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV0sIGNoaWxkID0gcGFyZW50LmNoaWxkKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGRPZmYgPyBwYXJlbnQuY2hpbGQoaW5kZXgpLmN1dChkT2ZmKSA6IGNoaWxkO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG5vZGUgZGlyZWN0bHkgYmVmb3JlIHRoZSBwb3NpdGlvbiwgaWYgYW55LiBJZiB0aGVcbiAgICBwb3NpdGlvbiBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgb25seSB0aGUgcGFydCBvZiB0aGF0IG5vZGVcbiAgICBiZWZvcmUgdGhlIHBvc2l0aW9uIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgZ2V0IG5vZGVCZWZvcmUoKSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuaW5kZXgodGhpcy5kZXB0aCk7XG4gICAgICAgIGxldCBkT2ZmID0gdGhpcy5wb3MgLSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZE9mZilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGlsZChpbmRleCkuY3V0KDAsIGRPZmYpO1xuICAgICAgICByZXR1cm4gaW5kZXggPT0gMCA/IG51bGwgOiB0aGlzLnBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBpbmRleCBpbiB0aGUgcGFyZW50IG5vZGUgYXQgdGhlXG4gICAgZ2l2ZW4gZGVwdGggKHdoaWNoIGRlZmF1bHRzIHRvIGB0aGlzLmRlcHRoYCkuXG4gICAgKi9cbiAgICBwb3NBdEluZGV4KGluZGV4LCBkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnBhdGhbZGVwdGggKiAzXSwgcG9zID0gZGVwdGggPT0gMCA/IDAgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspXG4gICAgICAgICAgICBwb3MgKz0gbm9kZS5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBtYXJrcyBhdCB0aGlzIHBvc2l0aW9uLCBmYWN0b3JpbmcgaW4gdGhlIHN1cnJvdW5kaW5nXG4gICAgbWFya3MnIFtgaW5jbHVzaXZlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtTcGVjLmluY2x1c2l2ZSkgcHJvcGVydHkuIElmIHRoZVxuICAgIHBvc2l0aW9uIGlzIGF0IHRoZSBzdGFydCBvZiBhIG5vbi1lbXB0eSBub2RlLCB0aGUgbWFya3Mgb2YgdGhlXG4gICAgbm9kZSBhZnRlciBpdCAoaWYgYW55KSBhcmUgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBtYXJrcygpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50LCBpbmRleCA9IHRoaXMuaW5kZXgoKTtcbiAgICAgICAgLy8gSW4gYW4gZW1wdHkgcGFyZW50LCByZXR1cm4gdGhlIGVtcHR5IGFycmF5XG4gICAgICAgIGlmIChwYXJlbnQuY29udGVudC5zaXplID09IDApXG4gICAgICAgICAgICByZXR1cm4gTWFyay5ub25lO1xuICAgICAgICAvLyBXaGVuIGluc2lkZSBhIHRleHQgbm9kZSwganVzdCByZXR1cm4gdGhlIHRleHQgbm9kZSdzIG1hcmtzXG4gICAgICAgIGlmICh0aGlzLnRleHRPZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkKGluZGV4KS5tYXJrcztcbiAgICAgICAgbGV0IG1haW4gPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCAtIDEpLCBvdGhlciA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgLy8gSWYgdGhlIGBhZnRlcmAgZmxhZyBpcyB0cnVlIG9mIHRoZXJlIGlzIG5vIG5vZGUgYmVmb3JlLCBtYWtlXG4gICAgICAgIC8vIHRoZSBub2RlIGFmdGVyIHRoaXMgcG9zaXRpb24gdGhlIG1haW4gcmVmZXJlbmNlLlxuICAgICAgICBpZiAoIW1haW4pIHtcbiAgICAgICAgICAgIGxldCB0bXAgPSBtYWluO1xuICAgICAgICAgICAgbWFpbiA9IG90aGVyO1xuICAgICAgICAgICAgb3RoZXIgPSB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGFsbCBtYXJrcyBpbiB0aGUgbWFpbiBub2RlLCBleGNlcHQgdGhvc2UgdGhhdCBoYXZlXG4gICAgICAgIC8vIGBpbmNsdXNpdmVgIHNldCB0byBmYWxzZSBhbmQgYXJlIG5vdCBwcmVzZW50IGluIHRoZSBvdGhlciBub2RlLlxuICAgICAgICBsZXQgbWFya3MgPSBtYWluLm1hcmtzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG1hcmtzW2ldLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlICYmICghb3RoZXIgfHwgIW1hcmtzW2ldLmlzSW5TZXQob3RoZXIubWFya3MpKSlcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzW2ktLV0ucmVtb3ZlRnJvbVNldChtYXJrcyk7XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBtYXJrcyBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbiwgaWYgYW55LCBleGNlcHQgdGhvc2VcbiAgICB0aGF0IGFyZSBub24taW5jbHVzaXZlIGFuZCBub3QgcHJlc2VudCBhdCBwb3NpdGlvbiBgJGVuZGAuIFRoaXNcbiAgICBpcyBtb3N0bHkgdXNlZnVsIGZvciBnZXR0aW5nIHRoZSBzZXQgb2YgbWFya3MgdG8gcHJlc2VydmUgYWZ0ZXIgYVxuICAgIGRlbGV0aW9uLiBXaWxsIHJldHVybiBgbnVsbGAgaWYgdGhpcyBwb3NpdGlvbiBpcyBhdCB0aGUgZW5kIG9mXG4gICAgaXRzIHBhcmVudCBub2RlIG9yIGl0cyBwYXJlbnQgbm9kZSBpc24ndCBhIHRleHRibG9jayAoaW4gd2hpY2hcbiAgICBjYXNlIG5vIG1hcmtzIHNob3VsZCBiZSBwcmVzZXJ2ZWQpLlxuICAgICovXG4gICAgbWFya3NBY3Jvc3MoJGVuZCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLnBhcmVudC5tYXliZUNoaWxkKHRoaXMuaW5kZXgoKSk7XG4gICAgICAgIGlmICghYWZ0ZXIgfHwgIWFmdGVyLmlzSW5saW5lKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBtYXJrcyA9IGFmdGVyLm1hcmtzLCBuZXh0ID0gJGVuZC5wYXJlbnQubWF5YmVDaGlsZCgkZW5kLmluZGV4KCkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG1hcmtzW2ldLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlICYmICghbmV4dCB8fCAhbWFya3NbaV0uaXNJblNldChuZXh0Lm1hcmtzKSkpXG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrc1tpLS1dLnJlbW92ZUZyb21TZXQobWFya3MpO1xuICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBkZXB0aCB1cCB0byB3aGljaCB0aGlzIHBvc2l0aW9uIGFuZCB0aGUgZ2l2ZW4gKG5vbi1yZXNvbHZlZClcbiAgICBwb3NpdGlvbiBzaGFyZSB0aGUgc2FtZSBwYXJlbnQgbm9kZXMuXG4gICAgKi9cbiAgICBzaGFyZWREZXB0aChwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSB0aGlzLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoLS0pXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydChkZXB0aCkgPD0gcG9zICYmIHRoaXMuZW5kKGRlcHRoKSA+PSBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHJhbmdlIGJhc2VkIG9uIHRoZSBwbGFjZSB3aGVyZSB0aGlzIHBvc2l0aW9uIGFuZCB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbiBkaXZlcmdlIGFyb3VuZCBibG9jayBjb250ZW50LiBJZiBib3RoIHBvaW50IGludG9cbiAgICB0aGUgc2FtZSB0ZXh0YmxvY2ssIGZvciBleGFtcGxlLCBhIHJhbmdlIGFyb3VuZCB0aGF0IHRleHRibG9ja1xuICAgIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZXkgcG9pbnQgaW50byBkaWZmZXJlbnQgYmxvY2tzLCB0aGUgcmFuZ2VcbiAgICBhcm91bmQgdGhvc2UgYmxvY2tzIGluIHRoZWlyIHNoYXJlZCBhbmNlc3RvciBpcyByZXR1cm5lZC4gWW91IGNhblxuICAgIHBhc3MgaW4gYW4gb3B0aW9uYWwgcHJlZGljYXRlIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHBhcmVudFxuICAgIG5vZGUgdG8gc2VlIGlmIGEgcmFuZ2UgaW50byB0aGF0IHBhcmVudCBpcyBhY2NlcHRhYmxlLlxuICAgICovXG4gICAgYmxvY2tSYW5nZShvdGhlciA9IHRoaXMsIHByZWQpIHtcbiAgICAgICAgaWYgKG90aGVyLnBvcyA8IHRoaXMucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG90aGVyLmJsb2NrUmFuZ2UodGhpcyk7XG4gICAgICAgIGZvciAobGV0IGQgPSB0aGlzLmRlcHRoIC0gKHRoaXMucGFyZW50LmlubGluZUNvbnRlbnQgfHwgdGhpcy5wb3MgPT0gb3RoZXIucG9zID8gMSA6IDApOyBkID49IDA7IGQtLSlcbiAgICAgICAgICAgIGlmIChvdGhlci5wb3MgPD0gdGhpcy5lbmQoZCkgJiYgKCFwcmVkIHx8IHByZWQodGhpcy5ub2RlKGQpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2RlUmFuZ2UodGhpcywgb3RoZXIsIGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcnkgd2hldGhlciB0aGUgZ2l2ZW4gcG9zaXRpb24gc2hhcmVzIHRoZSBzYW1lIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgc2FtZVBhcmVudChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgLSB0aGlzLnBhcmVudE9mZnNldCA9PSBvdGhlci5wb3MgLSBvdGhlci5wYXJlbnRPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgZ3JlYXRlciBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBtYXgob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLnBvcyA+IHRoaXMucG9zID8gb3RoZXIgOiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIHNtYWxsZXIgb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbWluKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlci5wb3MgPCB0aGlzLnBvcyA/IG90aGVyIDogdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXMuZGVwdGg7IGkrKylcbiAgICAgICAgICAgIHN0ciArPSAoc3RyID8gXCIvXCIgOiBcIlwiKSArIHRoaXMubm9kZShpKS50eXBlLm5hbWUgKyBcIl9cIiArIHRoaXMuaW5kZXgoaSAtIDEpO1xuICAgICAgICByZXR1cm4gc3RyICsgXCI6XCIgKyB0aGlzLnBhcmVudE9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZShkb2MsIHBvcykge1xuICAgICAgICBpZiAoIShwb3MgPj0gMCAmJiBwb3MgPD0gZG9jLmNvbnRlbnQuc2l6ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBvc2l0aW9uIFwiICsgcG9zICsgXCIgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICBsZXQgcGF0aCA9IFtdO1xuICAgICAgICBsZXQgc3RhcnQgPSAwLCBwYXJlbnRPZmZzZXQgPSBwb3M7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSBkb2M7Oykge1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChwYXJlbnRPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IHJlbSA9IHBhcmVudE9mZnNldCAtIG9mZnNldDtcbiAgICAgICAgICAgIHBhdGgucHVzaChub2RlLCBpbmRleCwgc3RhcnQgKyBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCFyZW0pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZChpbmRleCk7XG4gICAgICAgICAgICBpZiAobm9kZS5pc1RleHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSByZW0gLSAxO1xuICAgICAgICAgICAgc3RhcnQgKz0gb2Zmc2V0ICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkUG9zKHBvcywgcGF0aCwgcGFyZW50T2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZUNhY2hlZChkb2MsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc29sdmVDYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNhY2hlZCA9IHJlc29sdmVDYWNoZVtpXTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQucG9zID09IHBvcyAmJiBjYWNoZWQuZG9jID09IGRvYylcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSByZXNvbHZlQ2FjaGVbcmVzb2x2ZUNhY2hlUG9zXSA9IFJlc29sdmVkUG9zLnJlc29sdmUoZG9jLCBwb3MpO1xuICAgICAgICByZXNvbHZlQ2FjaGVQb3MgPSAocmVzb2x2ZUNhY2hlUG9zICsgMSkgJSByZXNvbHZlQ2FjaGVTaXplO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmxldCByZXNvbHZlQ2FjaGUgPSBbXSwgcmVzb2x2ZUNhY2hlUG9zID0gMCwgcmVzb2x2ZUNhY2hlU2l6ZSA9IDEyO1xuLyoqXG5SZXByZXNlbnRzIGEgZmxhdCByYW5nZSBvZiBjb250ZW50LCBpLmUuIG9uZSB0aGF0IHN0YXJ0cyBhbmRcbmVuZHMgaW4gdGhlIHNhbWUgbm9kZS5cbiovXG5jbGFzcyBOb2RlUmFuZ2Uge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIG5vZGUgcmFuZ2UuIGAkZnJvbWAgYW5kIGAkdG9gIHNob3VsZCBwb2ludCBpbnRvIHRoZVxuICAgIHNhbWUgbm9kZSB1bnRpbCBhdCBsZWFzdCB0aGUgZ2l2ZW4gYGRlcHRoYCwgc2luY2UgYSBub2RlIHJhbmdlXG4gICAgZGVub3RlcyBhbiBhZGphY2VudCBzZXQgb2Ygbm9kZXMgaW4gYSBzaW5nbGUgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBBIHJlc29sdmVkIHBvc2l0aW9uIGFsb25nIHRoZSBzdGFydCBvZiB0aGUgY29udGVudC4gTWF5IGhhdmUgYVxuICAgIGBkZXB0aGAgZ3JlYXRlciB0aGFuIHRoaXMgb2JqZWN0J3MgYGRlcHRoYCBwcm9wZXJ0eSwgc2luY2VcbiAgICB0aGVzZSBhcmUgdGhlIHBvc2l0aW9ucyB0aGF0IHdlcmUgdXNlZCB0byBjb21wdXRlIHRoZSByYW5nZSxcbiAgICBub3QgcmUtcmVzb2x2ZWQgcG9zaXRpb25zIGRpcmVjdGx5IGF0IGl0cyBib3VuZGFyaWVzLlxuICAgICovXG4gICAgJGZyb20sIFxuICAgIC8qKlxuICAgIEEgcG9zaXRpb24gYWxvbmcgdGhlIGVuZCBvZiB0aGUgY29udGVudC4gU2VlXG4gICAgY2F2ZWF0IGZvciBbYCRmcm9tYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVSYW5nZS4kZnJvbSkuXG4gICAgKi9cbiAgICAkdG8sIFxuICAgIC8qKlxuICAgIFRoZSBkZXB0aCBvZiB0aGUgbm9kZSB0aGF0IHRoaXMgcmFuZ2UgcG9pbnRzIGludG8uXG4gICAgKi9cbiAgICBkZXB0aCkge1xuICAgICAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgICAgIHRoaXMuJHRvID0gJHRvO1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy4kZnJvbS5iZWZvcmUodGhpcy5kZXB0aCArIDEpOyB9XG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuJHRvLmFmdGVyKHRoaXMuZGVwdGggKyAxKTsgfVxuICAgIC8qKlxuICAgIFRoZSBwYXJlbnQgbm9kZSB0aGF0IHRoZSByYW5nZSBwb2ludHMgaW50by5cbiAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7IHJldHVybiB0aGlzLiRmcm9tLm5vZGUodGhpcy5kZXB0aCk7IH1cbiAgICAvKipcbiAgICBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIHJhbmdlIGluIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBzdGFydEluZGV4KCkgeyByZXR1cm4gdGhpcy4kZnJvbS5pbmRleCh0aGlzLmRlcHRoKTsgfVxuICAgIC8qKlxuICAgIFRoZSBlbmQgaW5kZXggb2YgdGhlIHJhbmdlIGluIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBlbmRJbmRleCgpIHsgcmV0dXJuIHRoaXMuJHRvLmluZGV4QWZ0ZXIodGhpcy5kZXB0aCk7IH1cbn1cblxuY29uc3QgZW1wdHlBdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcblRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIG5vZGUgaW4gdGhlIHRyZWUgdGhhdCBtYWtlcyB1cCBhXG5Qcm9zZU1pcnJvciBkb2N1bWVudC4gU28gYSBkb2N1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBgTm9kZWAsIHdpdGhcbmNoaWxkcmVuIHRoYXQgYXJlIGFsc28gaW5zdGFuY2VzIG9mIGBOb2RlYC5cblxuTm9kZXMgYXJlIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVzLiBJbnN0ZWFkIG9mIGNoYW5naW5nIHRoZW0sIHlvdVxuY3JlYXRlIG5ldyBvbmVzIHdpdGggdGhlIGNvbnRlbnQgeW91IHdhbnQuIE9sZCBvbmVzIGtlZXAgcG9pbnRpbmdcbmF0IHRoZSBvbGQgZG9jdW1lbnQgc2hhcGUuIFRoaXMgaXMgbWFkZSBjaGVhcGVyIGJ5IHNoYXJpbmdcbnN0cnVjdHVyZSBiZXR3ZWVuIHRoZSBvbGQgYW5kIG5ldyBkYXRhIGFzIG11Y2ggYXMgcG9zc2libGUsIHdoaWNoIGFcbnRyZWUgc2hhcGUgbGlrZSB0aGlzICh3aXRob3V0IGJhY2sgcG9pbnRlcnMpIG1ha2VzIGVhc3kuXG5cbioqRG8gbm90KiogZGlyZWN0bHkgbXV0YXRlIHRoZSBwcm9wZXJ0aWVzIG9mIGEgYE5vZGVgIG9iamVjdC4gU2VlXG5bdGhlIGd1aWRlXSgvZG9jcy9ndWlkZS8jZG9jKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiovXG5jbGFzcyBOb2RlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIG5vZGUgdGhhdCB0aGlzIGlzLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgQW4gb2JqZWN0IG1hcHBpbmcgYXR0cmlidXRlIG5hbWVzIHRvIHZhbHVlcy4gVGhlIGtpbmQgb2ZcbiAgICBhdHRyaWJ1dGVzIGFsbG93ZWQgYW5kIHJlcXVpcmVkIGFyZVxuICAgIFtkZXRlcm1pbmVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuYXR0cnMpIGJ5IHRoZSBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBhdHRycywgXG4gICAgLy8gQSBmcmFnbWVudCBob2xkaW5nIHRoZSBub2RlJ3MgY2hpbGRyZW4uXG4gICAgY29udGVudCwgXG4gICAgLyoqXG4gICAgVGhlIG1hcmtzICh0aGluZ3MgbGlrZSB3aGV0aGVyIGl0IGlzIGVtcGhhc2l6ZWQgb3IgcGFydCBvZiBhXG4gICAgbGluaykgYXBwbGllZCB0byB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBtYXJrcyA9IE1hcmsubm9uZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudCB8fCBGcmFnbWVudC5lbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNpemUgb2YgdGhpcyBub2RlLCBhcyBkZWZpbmVkIGJ5IHRoZSBpbnRlZ2VyLWJhc2VkIFtpbmRleGluZ1xuICAgIHNjaGVtZV0oL2RvY3MvZ3VpZGUvI2RvYy5pbmRleGluZykuIEZvciB0ZXh0IG5vZGVzLCB0aGlzIGlzIHRoZVxuICAgIGFtb3VudCBvZiBjaGFyYWN0ZXJzLiBGb3Igb3RoZXIgbGVhZiBub2RlcywgaXQgaXMgb25lLiBGb3JcbiAgICBub24tbGVhZiBub2RlcywgaXQgaXMgdGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgcGx1cyB0d28gKHRoZVxuICAgIHN0YXJ0IGFuZCBlbmQgdG9rZW4pLlxuICAgICovXG4gICAgZ2V0IG5vZGVTaXplKCkgeyByZXR1cm4gdGhpcy5pc0xlYWYgPyAxIDogMiArIHRoaXMuY29udGVudC5zaXplOyB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IHRoZSBub2RlIGhhcy5cbiAgICAqL1xuICAgIGdldCBjaGlsZENvdW50KCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmNoaWxkQ291bnQ7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LiBSYWlzZXMgYW4gZXJyb3Igd2hlbiB0aGVcbiAgICBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgKi9cbiAgICBjaGlsZChpbmRleCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmNoaWxkKGluZGV4KTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGl0IGV4aXN0cy5cbiAgICAqL1xuICAgIG1heWJlQ2hpbGQoaW5kZXgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5tYXliZUNoaWxkKGluZGV4KTsgfVxuICAgIC8qKlxuICAgIENhbGwgYGZgIGZvciBldmVyeSBjaGlsZCBub2RlLCBwYXNzaW5nIHRoZSBub2RlLCBpdHMgb2Zmc2V0XG4gICAgaW50byB0aGlzIHBhcmVudCBub2RlLCBhbmQgaXRzIGluZGV4LlxuICAgICovXG4gICAgZm9yRWFjaChmKSB7IHRoaXMuY29udGVudC5mb3JFYWNoKGYpOyB9XG4gICAgLyoqXG4gICAgSW52b2tlIGEgY2FsbGJhY2sgZm9yIGFsbCBkZXNjZW5kYW50IG5vZGVzIHJlY3Vyc2l2ZWx5IGJldHdlZW5cbiAgICB0aGUgZ2l2ZW4gdHdvIHBvc2l0aW9ucyB0aGF0IGFyZSByZWxhdGl2ZSB0byBzdGFydCBvZiB0aGlzXG4gICAgbm9kZSdzIGNvbnRlbnQuIFRoZSBjYWxsYmFjayBpcyBpbnZva2VkIHdpdGggdGhlIG5vZGUsIGl0c1xuICAgIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW5hbCBub2RlIChtZXRob2QgcmVjZWl2ZXIpLFxuICAgIGl0cyBwYXJlbnQgbm9kZSwgYW5kIGl0cyBjaGlsZCBpbmRleC4gV2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJuc1xuICAgIGZhbHNlIGZvciBhIGdpdmVuIG5vZGUsIHRoYXQgbm9kZSdzIGNoaWxkcmVuIHdpbGwgbm90IGJlXG4gICAgcmVjdXJzZWQgb3Zlci4gVGhlIGxhc3QgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgYVxuICAgIHN0YXJ0aW5nIHBvc2l0aW9uIHRvIGNvdW50IGZyb20uXG4gICAgKi9cbiAgICBub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYsIHN0YXJ0UG9zID0gMCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmLCBzdGFydFBvcywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBldmVyeSBkZXNjZW5kYW50IG5vZGUuIERvZXNuJ3RcbiAgICBkZXNjZW5kIGludG8gYSBub2RlIHdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYC5cbiAgICAqL1xuICAgIGRlc2NlbmRhbnRzKGYpIHtcbiAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oMCwgdGhpcy5jb250ZW50LnNpemUsIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb25jYXRlbmF0ZXMgYWxsIHRoZSB0ZXh0IG5vZGVzIGZvdW5kIGluIHRoaXMgZnJhZ21lbnQgYW5kIGl0c1xuICAgIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IHRleHRDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaXNMZWFmICYmIHRoaXMudHlwZS5zcGVjLmxlYWZUZXh0KVxuICAgICAgICAgICAgPyB0aGlzLnR5cGUuc3BlYy5sZWFmVGV4dCh0aGlzKVxuICAgICAgICAgICAgOiB0aGlzLnRleHRCZXR3ZWVuKDAsIHRoaXMuY29udGVudC5zaXplLCBcIlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGFsbCB0ZXh0IGJldHdlZW4gcG9zaXRpb25zIGBmcm9tYCBhbmQgYHRvYC4gV2hlblxuICAgIGBibG9ja1NlcGFyYXRvcmAgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgaW5zZXJ0ZWQgdG8gc2VwYXJhdGUgdGV4dFxuICAgIGZyb20gZGlmZmVyZW50IGJsb2NrIG5vZGVzLiBJZiBgbGVhZlRleHRgIGlzIGdpdmVuLCBpdCdsbCBiZVxuICAgIGluc2VydGVkIGZvciBldmVyeSBub24tdGV4dCBsZWFmIG5vZGUgZW5jb3VudGVyZWQsIG90aGVyd2lzZVxuICAgIFtgbGVhZlRleHRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWNebGVhZlRleHQpIHdpbGwgYmUgdXNlZC5cbiAgICAqL1xuICAgIHRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC50ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGlzIG5vZGUncyBmaXJzdCBjaGlsZCwgb3IgYG51bGxgIGlmIHRoZXJlIGFyZSBub1xuICAgIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZDsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhpcyBub2RlJ3MgbGFzdCBjaGlsZCwgb3IgYG51bGxgIGlmIHRoZXJlIGFyZSBub1xuICAgIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sYXN0Q2hpbGQ7IH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdHdvIG5vZGVzIHJlcHJlc2VudCB0aGUgc2FtZSBwaWVjZSBvZiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8ICh0aGlzLnNhbWVNYXJrdXAob3RoZXIpICYmIHRoaXMuY29udGVudC5lcShvdGhlci5jb250ZW50KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhlIG1hcmt1cCAodHlwZSwgYXR0cmlidXRlcywgYW5kIG1hcmtzKSBvZiB0aGlzIG5vZGUgdG9cbiAgICB0aG9zZSBvZiBhbm90aGVyLiBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGhhdmUgdGhlIHNhbWUgbWFya3VwLlxuICAgICovXG4gICAgc2FtZU1hcmt1cChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNNYXJrdXAob3RoZXIudHlwZSwgb3RoZXIuYXR0cnMsIG90aGVyLm1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGlzIG5vZGUncyBtYXJrdXAgY29ycmVzcG9uZCB0byB0aGUgZ2l2ZW4gdHlwZSxcbiAgICBhdHRyaWJ1dGVzLCBhbmQgbWFya3MuXG4gICAgKi9cbiAgICBoYXNNYXJrdXAodHlwZSwgYXR0cnMsIG1hcmtzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gdHlwZSAmJlxuICAgICAgICAgICAgY29tcGFyZURlZXAodGhpcy5hdHRycywgYXR0cnMgfHwgdHlwZS5kZWZhdWx0QXR0cnMgfHwgZW1wdHlBdHRycykgJiZcbiAgICAgICAgICAgIE1hcmsuc2FtZVNldCh0aGlzLm1hcmtzLCBtYXJrcyB8fCBNYXJrLm5vbmUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgbm9kZSB3aXRoIHRoZSBzYW1lIG1hcmt1cCBhcyB0aGlzIG5vZGUsIGNvbnRhaW5pbmdcbiAgICB0aGUgZ2l2ZW4gY29udGVudCAob3IgZW1wdHksIGlmIG5vIGNvbnRlbnQgaXMgZ2l2ZW4pLlxuICAgICovXG4gICAgY29weShjb250ZW50ID0gbnVsbCkge1xuICAgICAgICBpZiAoY29udGVudCA9PSB0aGlzLmNvbnRlbnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgY29udGVudCwgdGhpcy5tYXJrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBub2RlLCB3aXRoIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MgaW5zdGVhZFxuICAgIG9mIHRoZSBub2RlJ3Mgb3duIG1hcmtzLlxuICAgICovXG4gICAgbWFyayhtYXJrcykge1xuICAgICAgICByZXR1cm4gbWFya3MgPT0gdGhpcy5tYXJrcyA/IHRoaXMgOiBuZXcgTm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRoaXMuY29udGVudCwgbWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgbm9kZSB3aXRoIG9ubHkgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbnMuIElmIGB0b2AgaXMgbm90IGdpdmVuLCBpdCBkZWZhdWx0cyB0byB0aGUgZW5kIG9mXG4gICAgdGhlIG5vZGUuXG4gICAgKi9cbiAgICBjdXQoZnJvbSwgdG8gPSB0aGlzLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkodGhpcy5jb250ZW50LmN1dChmcm9tLCB0bykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDdXQgb3V0IHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMsIGFuZFxuICAgIHJldHVybiBpdCBhcyBhIGBTbGljZWAgb2JqZWN0LlxuICAgICovXG4gICAgc2xpY2UoZnJvbSwgdG8gPSB0aGlzLmNvbnRlbnQuc2l6ZSwgaW5jbHVkZVBhcmVudHMgPSBmYWxzZSkge1xuICAgICAgICBpZiAoZnJvbSA9PSB0bylcbiAgICAgICAgICAgIHJldHVybiBTbGljZS5lbXB0eTtcbiAgICAgICAgbGV0ICRmcm9tID0gdGhpcy5yZXNvbHZlKGZyb20pLCAkdG8gPSB0aGlzLnJlc29sdmUodG8pO1xuICAgICAgICBsZXQgZGVwdGggPSBpbmNsdWRlUGFyZW50cyA/IDAgOiAkZnJvbS5zaGFyZWREZXB0aCh0byk7XG4gICAgICAgIGxldCBzdGFydCA9ICRmcm9tLnN0YXJ0KGRlcHRoKSwgbm9kZSA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgICBsZXQgY29udGVudCA9IG5vZGUuY29udGVudC5jdXQoJGZyb20ucG9zIC0gc3RhcnQsICR0by5wb3MgLSBzdGFydCk7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoY29udGVudCwgJGZyb20uZGVwdGggLSBkZXB0aCwgJHRvLmRlcHRoIC0gZGVwdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMgd2l0aFxuICAgIHRoZSBnaXZlbiBzbGljZS4gVGhlIHNsaWNlIG11c3QgJ2ZpdCcsIG1lYW5pbmcgaXRzIG9wZW4gc2lkZXNcbiAgICBtdXN0IGJlIGFibGUgdG8gY29ubmVjdCB0byB0aGUgc3Vycm91bmRpbmcgY29udGVudCwgYW5kIGl0c1xuICAgIGNvbnRlbnQgbm9kZXMgbXVzdCBiZSB2YWxpZCBjaGlsZHJlbiBmb3IgdGhlIG5vZGUgdGhleSBhcmUgcGxhY2VkXG4gICAgaW50by4gSWYgYW55IG9mIHRoaXMgaXMgdmlvbGF0ZWQsIGFuIGVycm9yIG9mIHR5cGVcbiAgICBbYFJlcGxhY2VFcnJvcmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5SZXBsYWNlRXJyb3IpIGlzIHRocm93bi5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlKHRoaXMucmVzb2x2ZShmcm9tKSwgdGhpcy5yZXNvbHZlKHRvKSwgc2xpY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBub2RlIGRpcmVjdGx5IGFmdGVyIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIG5vZGVBdChwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHRoaXM7Oykge1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChwb3MpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IHBvcyB8fCBub2RlLmlzVGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIHBvcyAtPSBvZmZzZXQgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIChkaXJlY3QpIGNoaWxkIG5vZGUgYWZ0ZXIgdGhlIGdpdmVuIG9mZnNldCwgaWYgYW55LFxuICAgIGFuZCByZXR1cm4gaXQgYWxvbmcgd2l0aCBpdHMgaW5kZXggYW5kIG9mZnNldCByZWxhdGl2ZSB0byB0aGlzXG4gICAgbm9kZS5cbiAgICAqL1xuICAgIGNoaWxkQWZ0ZXIocG9zKSB7XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IHRoaXMuY29udGVudC5maW5kSW5kZXgocG9zKTtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpLCBpbmRleCwgb2Zmc2V0IH07XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIChkaXJlY3QpIGNoaWxkIG5vZGUgYmVmb3JlIHRoZSBnaXZlbiBvZmZzZXQsIGlmIGFueSxcbiAgICBhbmQgcmV0dXJuIGl0IGFsb25nIHdpdGggaXRzIGluZGV4IGFuZCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhpc1xuICAgIG5vZGUuXG4gICAgKi9cbiAgICBjaGlsZEJlZm9yZShwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogbnVsbCwgaW5kZXg6IDAsIG9mZnNldDogMCB9O1xuICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSB0aGlzLmNvbnRlbnQuZmluZEluZGV4KHBvcyk7XG4gICAgICAgIGlmIChvZmZzZXQgPCBwb3MpXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXgpLCBpbmRleCwgb2Zmc2V0IH07XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5jb250ZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgIHJldHVybiB7IG5vZGUsIGluZGV4OiBpbmRleCAtIDEsIG9mZnNldDogb2Zmc2V0IC0gbm9kZS5ub2RlU2l6ZSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBSZXNvbHZlIHRoZSBnaXZlbiBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQsIHJldHVybmluZyBhblxuICAgIFtvYmplY3RdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5SZXNvbHZlZFBvcykgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCBpdHMgY29udGV4dC5cbiAgICAqL1xuICAgIHJlc29sdmUocG9zKSB7IHJldHVybiBSZXNvbHZlZFBvcy5yZXNvbHZlQ2FjaGVkKHRoaXMsIHBvcyk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVOb0NhY2hlKHBvcykgeyByZXR1cm4gUmVzb2x2ZWRQb3MucmVzb2x2ZSh0aGlzLCBwb3MpOyB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gbWFyayBvciBtYXJrIHR5cGUgb2NjdXJzIGluIHRoaXMgZG9jdW1lbnRcbiAgICBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gcG9zaXRpb25zLlxuICAgICovXG4gICAgcmFuZ2VIYXNNYXJrKGZyb20sIHRvLCB0eXBlKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBpZiAodG8gPiBmcm9tKVxuICAgICAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLmlzSW5TZXQobm9kZS5tYXJrcykpXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWZvdW5kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSBibG9jayAobm9uLWlubGluZSBub2RlKVxuICAgICovXG4gICAgZ2V0IGlzQmxvY2soKSB7IHJldHVybiB0aGlzLnR5cGUuaXNCbG9jazsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGEgdGV4dGJsb2NrIG5vZGUsIGEgYmxvY2sgbm9kZSB3aXRoIGlubGluZVxuICAgIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaXNUZXh0YmxvY2soKSB7IHJldHVybiB0aGlzLnR5cGUuaXNUZXh0YmxvY2s7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBub2RlIGFsbG93cyBpbmxpbmUgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpbmxpbmVDb250ZW50KCkgeyByZXR1cm4gdGhpcy50eXBlLmlubGluZUNvbnRlbnQ7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhbiBpbmxpbmUgbm9kZSAoYSB0ZXh0IG5vZGUgb3IgYSBub2RlIHRoYXQgY2FuXG4gICAgYXBwZWFyIGFtb25nIHRleHQpLlxuICAgICovXG4gICAgZ2V0IGlzSW5saW5lKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzSW5saW5lOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSB0ZXh0IG5vZGUuXG4gICAgKi9cbiAgICBnZXQgaXNUZXh0KCkgeyByZXR1cm4gdGhpcy50eXBlLmlzVGV4dDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGEgbGVhZiBub2RlLlxuICAgICovXG4gICAgZ2V0IGlzTGVhZigpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0xlYWY7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhbiBhdG9tLCBpLmUuIHdoZW4gaXQgZG9lcyBub3QgaGF2ZSBkaXJlY3RseVxuICAgIGVkaXRhYmxlIGNvbnRlbnQuIFRoaXMgaXMgdXN1YWxseSB0aGUgc2FtZSBhcyBgaXNMZWFmYCwgYnV0IGNhblxuICAgIGJlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgW2BhdG9tYCBwcm9wZXJ0eV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmF0b20pXG4gICAgb24gYSBub2RlJ3Mgc3BlYyAodHlwaWNhbGx5IHVzZWQgd2hlbiB0aGUgbm9kZSBpcyBkaXNwbGF5ZWQgYXNcbiAgICBhbiB1bmVkaXRhYmxlIFtub2RlIHZpZXddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3Lk5vZGVWaWV3KSkuXG4gICAgKi9cbiAgICBnZXQgaXNBdG9tKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzQXRvbTsgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUgZm9yIGRlYnVnZ2luZ1xuICAgIHB1cnBvc2VzLlxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcodGhpcyk7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy50eXBlLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIG5hbWUgKz0gXCIoXCIgKyB0aGlzLmNvbnRlbnQudG9TdHJpbmdJbm5lcigpICsgXCIpXCI7XG4gICAgICAgIHJldHVybiB3cmFwTWFya3ModGhpcy5tYXJrcywgbmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29udGVudCBtYXRjaCBpbiB0aGlzIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICovXG4gICAgY29udGVudE1hdGNoQXQoaW5kZXgpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgMCwgaW5kZXgpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGVkIGNvbnRlbnRNYXRjaEF0IG9uIGEgbm9kZSB3aXRoIGludmFsaWQgY29udGVudFwiKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgcmVwbGFjaW5nIHRoZSByYW5nZSBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYCAoYnlcbiAgICBjaGlsZCBpbmRleCkgd2l0aCB0aGUgZ2l2ZW4gcmVwbGFjZW1lbnQgZnJhZ21lbnQgKHdoaWNoIGRlZmF1bHRzXG4gICAgdG8gdGhlIGVtcHR5IGZyYWdtZW50KSB3b3VsZCBsZWF2ZSB0aGUgbm9kZSdzIGNvbnRlbnQgdmFsaWQuIFlvdVxuICAgIGNhbiBvcHRpb25hbGx5IHBhc3MgYHN0YXJ0YCBhbmQgYGVuZGAgaW5kaWNlcyBpbnRvIHRoZVxuICAgIHJlcGxhY2VtZW50IGZyYWdtZW50LlxuICAgICovXG4gICAgY2FuUmVwbGFjZShmcm9tLCB0bywgcmVwbGFjZW1lbnQgPSBGcmFnbWVudC5lbXB0eSwgc3RhcnQgPSAwLCBlbmQgPSByZXBsYWNlbWVudC5jaGlsZENvdW50KSB7XG4gICAgICAgIGxldCBvbmUgPSB0aGlzLmNvbnRlbnRNYXRjaEF0KGZyb20pLm1hdGNoRnJhZ21lbnQocmVwbGFjZW1lbnQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICBsZXQgdHdvID0gb25lICYmIG9uZS5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICAgICAgICBpZiAoIXR3byB8fCAhdHdvLnZhbGlkRW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy50eXBlLmFsbG93c01hcmtzKHJlcGxhY2VtZW50LmNoaWxkKGkpLm1hcmtzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgcmVwbGFjaW5nIHRoZSByYW5nZSBgZnJvbWAgdG8gYHRvYCAoYnkgaW5kZXgpIHdpdGhcbiAgICBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUgd291bGQgbGVhdmUgdGhlIG5vZGUncyBjb250ZW50IHZhbGlkLlxuICAgICovXG4gICAgY2FuUmVwbGFjZVdpdGgoZnJvbSwgdG8sIHR5cGUsIG1hcmtzKSB7XG4gICAgICAgIGlmIChtYXJrcyAmJiAhdGhpcy50eXBlLmFsbG93c01hcmtzKG1hcmtzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jb250ZW50TWF0Y2hBdChmcm9tKS5tYXRjaFR5cGUodHlwZSk7XG4gICAgICAgIGxldCBlbmQgPSBzdGFydCAmJiBzdGFydC5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICAgICAgICByZXR1cm4gZW5kID8gZW5kLnZhbGlkRW5kIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGUgZ2l2ZW4gbm9kZSdzIGNvbnRlbnQgY291bGQgYmUgYXBwZW5kZWQgdG8gdGhpc1xuICAgIG5vZGUuIElmIHRoYXQgbm9kZSBpcyBlbXB0eSwgdGhpcyB3aWxsIG9ubHkgcmV0dXJuIHRydWUgaWYgdGhlcmVcbiAgICBpcyBhdCBsZWFzdCBvbmUgbm9kZSB0eXBlIHRoYXQgY2FuIGFwcGVhciBpbiBib3RoIG5vZGVzICh0byBhdm9pZFxuICAgIG1lcmdpbmcgY29tcGxldGVseSBpbmNvbXBhdGlibGUgbm9kZXMpLlxuICAgICovXG4gICAgY2FuQXBwZW5kKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYW5SZXBsYWNlKHRoaXMuY2hpbGRDb3VudCwgdGhpcy5jaGlsZENvdW50LCBvdGhlci5jb250ZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5jb21wYXRpYmxlQ29udGVudChvdGhlci50eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGlzIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50cyBjb25mb3JtIHRvIHRoZVxuICAgIHNjaGVtYSwgYW5kIHJhaXNlIGVycm9yIHdoZW4gdGhleSBkbyBub3QuXG4gICAgKi9cbiAgICBjaGVjaygpIHtcbiAgICAgICAgdGhpcy50eXBlLmNoZWNrQ29udGVudCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICBsZXQgY29weSA9IE1hcmsubm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgY29weSA9IHRoaXMubWFya3NbaV0uYWRkVG9TZXQoY29weSk7XG4gICAgICAgIGlmICghTWFyay5zYW1lU2V0KGNvcHksIHRoaXMubWFya3MpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgY29sbGVjdGlvbiBvZiBtYXJrcyBmb3Igbm9kZSAke3RoaXMudHlwZS5uYW1lfTogJHt0aGlzLm1hcmtzLm1hcChtID0+IG0udHlwZS5uYW1lKX1gKTtcbiAgICAgICAgdGhpcy5jb250ZW50LmZvckVhY2gobm9kZSA9PiBub2RlLmNoZWNrKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBKU09OLXNlcmlhbGl6ZWFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBub2RlLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgb2JqID0geyB0eXBlOiB0aGlzLnR5cGUubmFtZSB9O1xuICAgICAgICBmb3IgKGxldCBfIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgICAgIG9iai5hdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICBvYmouY29udGVudCA9IHRoaXMuY29udGVudC50b0pTT04oKTtcbiAgICAgICAgaWYgKHRoaXMubWFya3MubGVuZ3RoKVxuICAgICAgICAgICAgb2JqLm1hcmtzID0gdGhpcy5tYXJrcy5tYXAobiA9PiBuLnRvSlNPTigpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBub2RlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgTm9kZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgbGV0IG1hcmtzID0gbnVsbDtcbiAgICAgICAgaWYgKGpzb24ubWFya3MpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uLm1hcmtzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbWFyayBkYXRhIGZvciBOb2RlLmZyb21KU09OXCIpO1xuICAgICAgICAgICAgbWFya3MgPSBqc29uLm1hcmtzLm1hcChzY2hlbWEubWFya0Zyb21KU09OKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi50eXBlID09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24udGV4dCAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB0ZXh0IG5vZGUgaW4gSlNPTlwiKTtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEudGV4dChqc29uLnRleHQsIG1hcmtzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmZyb21KU09OKHNjaGVtYSwganNvbi5jb250ZW50KTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5ub2RlVHlwZShqc29uLnR5cGUpLmNyZWF0ZShqc29uLmF0dHJzLCBjb250ZW50LCBtYXJrcyk7XG4gICAgfVxufVxuTm9kZS5wcm90b3R5cGUudGV4dCA9IHVuZGVmaW5lZDtcbmNsYXNzIFRleHROb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBhdHRycywgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgYXR0cnMsIG51bGwsIG1hcmtzKTtcbiAgICAgICAgaWYgKCFjb250ZW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFbXB0eSB0ZXh0IG5vZGVzIGFyZSBub3QgYWxsb3dlZFwiKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gY29udGVudDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcodGhpcyk7XG4gICAgICAgIHJldHVybiB3cmFwTWFya3ModGhpcy5tYXJrcywgSlNPTi5zdHJpbmdpZnkodGhpcy50ZXh0KSk7XG4gICAgfVxuICAgIGdldCB0ZXh0Q29udGVudCgpIHsgcmV0dXJuIHRoaXMudGV4dDsgfVxuICAgIHRleHRCZXR3ZWVuKGZyb20sIHRvKSB7IHJldHVybiB0aGlzLnRleHQuc2xpY2UoZnJvbSwgdG8pOyB9XG4gICAgZ2V0IG5vZGVTaXplKCkgeyByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIG1hcmsobWFya3MpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtzID09IHRoaXMubWFya3MgPyB0aGlzIDogbmV3IFRleHROb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGhpcy50ZXh0LCBtYXJrcyk7XG4gICAgfVxuICAgIHdpdGhUZXh0KHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQgPT0gdGhpcy50ZXh0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0ZXh0LCB0aGlzLm1hcmtzKTtcbiAgICB9XG4gICAgY3V0KGZyb20gPSAwLCB0byA9IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhUZXh0KHRoaXMudGV4dC5zbGljZShmcm9tLCB0bykpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zYW1lTWFya3VwKG90aGVyKSAmJiB0aGlzLnRleHQgPT0gb3RoZXIudGV4dDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgYmFzZSA9IHN1cGVyLnRvSlNPTigpO1xuICAgICAgICBiYXNlLnRleHQgPSB0aGlzLnRleHQ7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdyYXBNYXJrcyhtYXJrcywgc3RyKSB7XG4gICAgZm9yIChsZXQgaSA9IG1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBzdHIgPSBtYXJrc1tpXS50eXBlLm5hbWUgKyBcIihcIiArIHN0ciArIFwiKVwiO1xuICAgIHJldHVybiBzdHI7XG59XG5cbi8qKlxuSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgcmVwcmVzZW50IGEgbWF0Y2ggc3RhdGUgb2YgYSBub2RlIHR5cGUnc1xuW2NvbnRlbnQgZXhwcmVzc2lvbl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvbnRlbnQpLCBhbmQgY2FuIGJlIHVzZWQgdG9cbmZpbmQgb3V0IHdoZXRoZXIgZnVydGhlciBjb250ZW50IG1hdGNoZXMgaGVyZSwgYW5kIHdoZXRoZXIgYSBnaXZlblxucG9zaXRpb24gaXMgYSB2YWxpZCBlbmQgb2YgdGhlIG5vZGUuXG4qL1xuY2xhc3MgQ29udGVudE1hdGNoIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG1hdGNoIHN0YXRlIHJlcHJlc2VudHMgYSB2YWxpZCBlbmQgb2YgdGhlIG5vZGUuXG4gICAgKi9cbiAgICB2YWxpZEVuZCkge1xuICAgICAgICB0aGlzLnZhbGlkRW5kID0gdmFsaWRFbmQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cmFwQ2FjaGUgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgcGFyc2Uoc3RyaW5nLCBub2RlVHlwZXMpIHtcbiAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyBUb2tlblN0cmVhbShzdHJpbmcsIG5vZGVUeXBlcyk7XG4gICAgICAgIGlmIChzdHJlYW0ubmV4dCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIENvbnRlbnRNYXRjaC5lbXB0eTtcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyZWFtKTtcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0KVxuICAgICAgICAgICAgc3RyZWFtLmVycihcIlVuZXhwZWN0ZWQgdHJhaWxpbmcgdGV4dFwiKTtcbiAgICAgICAgbGV0IG1hdGNoID0gZGZhKG5mYShleHByKSk7XG4gICAgICAgIGNoZWNrRm9yRGVhZEVuZHMobWF0Y2gsIHN0cmVhbSk7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggYSBub2RlIHR5cGUsIHJldHVybmluZyBhIG1hdGNoIGFmdGVyIHRoYXQgbm9kZSBpZlxuICAgIHN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBtYXRjaFR5cGUodHlwZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRbaV0udHlwZSA9PSB0eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRbaV0ubmV4dDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBtYXRjaCBhIGZyYWdtZW50LiBSZXR1cm5zIHRoZSByZXN1bHRpbmcgbWF0Y2ggd2hlblxuICAgIHN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBtYXRjaEZyYWdtZW50KGZyYWcsIHN0YXJ0ID0gMCwgZW5kID0gZnJhZy5jaGlsZENvdW50KSB7XG4gICAgICAgIGxldCBjdXIgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGN1ciAmJiBpIDwgZW5kOyBpKyspXG4gICAgICAgICAgICBjdXIgPSBjdXIubWF0Y2hUeXBlKGZyYWcuY2hpbGQoaSkudHlwZSk7XG4gICAgICAgIHJldHVybiBjdXI7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGlubGluZUNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQubGVuZ3RoICE9IDAgJiYgdGhpcy5uZXh0WzBdLnR5cGUuaXNJbmxpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZmlyc3QgbWF0Y2hpbmcgbm9kZSB0eXBlIGF0IHRoaXMgbWF0Y2ggcG9zaXRpb24gdGhhdCBjYW5cbiAgICBiZSBnZW5lcmF0ZWQuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdFR5cGUoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyB0eXBlIH0gPSB0aGlzLm5leHRbaV07XG4gICAgICAgICAgICBpZiAoISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGF0aWJsZShvdGhlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3RoZXIubmV4dC5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0W2ldLnR5cGUgPT0gb3RoZXIubmV4dFtqXS50eXBlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnkgdG8gbWF0Y2ggdGhlIGdpdmVuIGZyYWdtZW50LCBhbmQgaWYgdGhhdCBmYWlscywgc2VlIGlmIGl0IGNhblxuICAgIGJlIG1hZGUgdG8gbWF0Y2ggYnkgaW5zZXJ0aW5nIG5vZGVzIGluIGZyb250IG9mIGl0LiBXaGVuXG4gICAgc3VjY2Vzc2Z1bCwgcmV0dXJuIGEgZnJhZ21lbnQgb2YgaW5zZXJ0ZWQgbm9kZXMgKHdoaWNoIG1heSBiZVxuICAgIGVtcHR5IGlmIG5vdGhpbmcgaGFkIHRvIGJlIGluc2VydGVkKS4gV2hlbiBgdG9FbmRgIGlzIHRydWUsIG9ubHlcbiAgICByZXR1cm4gYSBmcmFnbWVudCBpZiB0aGUgcmVzdWx0aW5nIG1hdGNoIGdvZXMgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICBjb250ZW50IGV4cHJlc3Npb24uXG4gICAgKi9cbiAgICBmaWxsQmVmb3JlKGFmdGVyLCB0b0VuZCA9IGZhbHNlLCBzdGFydEluZGV4ID0gMCkge1xuICAgICAgICBsZXQgc2VlbiA9IFt0aGlzXTtcbiAgICAgICAgZnVuY3Rpb24gc2VhcmNoKG1hdGNoLCB0eXBlcykge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gbWF0Y2gubWF0Y2hGcmFnbWVudChhZnRlciwgc3RhcnRJbmRleCk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQgJiYgKCF0b0VuZCB8fCBmaW5pc2hlZC52YWxpZEVuZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb20odHlwZXMubWFwKHRwID0+IHRwLmNyZWF0ZUFuZEZpbGwoKSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gbWF0Y2gubmV4dFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkgJiYgc2Vlbi5pbmRleE9mKG5leHQpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZW4ucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gc2VhcmNoKG5leHQsIHR5cGVzLmNvbmNhdCh0eXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VhcmNoKHRoaXMsIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBhIHNldCBvZiB3cmFwcGluZyBub2RlIHR5cGVzIHRoYXQgd291bGQgYWxsb3cgYSBub2RlIG9mIHRoZVxuICAgIGdpdmVuIHR5cGUgdG8gYXBwZWFyIGF0IHRoaXMgcG9zaXRpb24uIFRoZSByZXN1bHQgbWF5IGJlIGVtcHR5XG4gICAgKHdoZW4gaXQgZml0cyBkaXJlY3RseSkgYW5kIHdpbGwgYmUgbnVsbCB3aGVuIG5vIHN1Y2ggd3JhcHBpbmdcbiAgICBleGlzdHMuXG4gICAgKi9cbiAgICBmaW5kV3JhcHBpbmcodGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53cmFwQ2FjaGUubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgICAgICBpZiAodGhpcy53cmFwQ2FjaGVbaV0gPT0gdGFyZ2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBDYWNoZVtpICsgMV07XG4gICAgICAgIGxldCBjb21wdXRlZCA9IHRoaXMuY29tcHV0ZVdyYXBwaW5nKHRhcmdldCk7XG4gICAgICAgIHRoaXMud3JhcENhY2hlLnB1c2godGFyZ2V0LCBjb21wdXRlZCk7XG4gICAgICAgIHJldHVybiBjb21wdXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wdXRlV3JhcHBpbmcodGFyZ2V0KSB7XG4gICAgICAgIGxldCBzZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgYWN0aXZlID0gW3sgbWF0Y2g6IHRoaXMsIHR5cGU6IG51bGwsIHZpYTogbnVsbCB9XTtcbiAgICAgICAgd2hpbGUgKGFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gYWN0aXZlLnNoaWZ0KCksIG1hdGNoID0gY3VycmVudC5tYXRjaDtcbiAgICAgICAgICAgIGlmIChtYXRjaC5tYXRjaFR5cGUodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvYmogPSBjdXJyZW50OyBvYmoudHlwZTsgb2JqID0gb2JqLnZpYSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqLnR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gbWF0Y2gubmV4dFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUuaXNMZWFmICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSAmJiAhKHR5cGUubmFtZSBpbiBzZWVuKSAmJiAoIWN1cnJlbnQudHlwZSB8fCBuZXh0LnZhbGlkRW5kKSkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmUucHVzaCh7IG1hdGNoOiB0eXBlLmNvbnRlbnRNYXRjaCwgdHlwZSwgdmlhOiBjdXJyZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICBzZWVuW3R5cGUubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBvdXRnb2luZyBlZGdlcyB0aGlzIG5vZGUgaGFzIGluIHRoZSBmaW5pdGVcbiAgICBhdXRvbWF0b24gdGhhdCBkZXNjcmliZXMgdGhlIGNvbnRlbnQgZXhwcmVzc2lvbi5cbiAgICAqL1xuICAgIGdldCBlZGdlQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIF9uX1x1MjAwQnRoIG91dGdvaW5nIGVkZ2UgZnJvbSB0aGlzIG5vZGUgaW4gdGhlIGZpbml0ZVxuICAgIGF1dG9tYXRvbiB0aGF0IGRlc2NyaWJlcyB0aGUgY29udGVudCBleHByZXNzaW9uLlxuICAgICovXG4gICAgZWRnZShuKSB7XG4gICAgICAgIGlmIChuID49IHRoaXMubmV4dC5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlcmUncyBubyAke259dGggZWRnZSBpbiB0aGlzIGNvbnRlbnQgbWF0Y2hgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFtuXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHNlZW4gPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gc2NhbihtKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2gobSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG0ubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG0ubmV4dFtpXS5uZXh0KSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgc2NhbihtLm5leHRbaV0ubmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Nhbih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHNlZW4ubWFwKChtLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgb3V0ID0gaSArIChtLnZhbGlkRW5kID8gXCIqXCIgOiBcIiBcIikgKyBcIiBcIjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbS5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIG91dCArPSAoaSA/IFwiLCBcIiA6IFwiXCIpICsgbS5uZXh0W2ldLnR5cGUubmFtZSArIFwiLT5cIiArIHNlZW4uaW5kZXhPZihtLm5leHRbaV0ubmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgIH1cbn1cbi8qKlxuQGludGVybmFsXG4qL1xuQ29udGVudE1hdGNoLmVtcHR5ID0gbmV3IENvbnRlbnRNYXRjaCh0cnVlKTtcbmNsYXNzIFRva2VuU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmcsIG5vZGVUeXBlcykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICAgICAgdGhpcy5ub2RlVHlwZXMgPSBub2RlVHlwZXM7XG4gICAgICAgIHRoaXMuaW5saW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnRva2VucyA9IHN0cmluZy5zcGxpdCgvXFxzKig/PVxcYnxcXFd8JCkvKTtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdID09IFwiXCIpXG4gICAgICAgICAgICB0aGlzLnRva2Vucy5wb3AoKTtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zWzBdID09IFwiXCIpXG4gICAgICAgICAgICB0aGlzLnRva2Vucy5zaGlmdCgpO1xuICAgIH1cbiAgICBnZXQgbmV4dCgpIHsgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMucG9zXTsgfVxuICAgIGVhdCh0b2spIHsgcmV0dXJuIHRoaXMubmV4dCA9PSB0b2sgJiYgKHRoaXMucG9zKysgfHwgdHJ1ZSk7IH1cbiAgICBlcnIoc3RyKSB7IHRocm93IG5ldyBTeW50YXhFcnJvcihzdHIgKyBcIiAoaW4gY29udGVudCBleHByZXNzaW9uICdcIiArIHRoaXMuc3RyaW5nICsgXCInKVwiKTsgfVxufVxuZnVuY3Rpb24gcGFyc2VFeHByKHN0cmVhbSkge1xuICAgIGxldCBleHBycyA9IFtdO1xuICAgIGRvIHtcbiAgICAgICAgZXhwcnMucHVzaChwYXJzZUV4cHJTZXEoc3RyZWFtKSk7XG4gICAgfSB3aGlsZSAoc3RyZWFtLmVhdChcInxcIikpO1xuICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogeyB0eXBlOiBcImNob2ljZVwiLCBleHBycyB9O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByU2VxKHN0cmVhbSkge1xuICAgIGxldCBleHBycyA9IFtdO1xuICAgIGRvIHtcbiAgICAgICAgZXhwcnMucHVzaChwYXJzZUV4cHJTdWJzY3JpcHQoc3RyZWFtKSk7XG4gICAgfSB3aGlsZSAoc3RyZWFtLm5leHQgJiYgc3RyZWFtLm5leHQgIT0gXCIpXCIgJiYgc3RyZWFtLm5leHQgIT0gXCJ8XCIpO1xuICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogeyB0eXBlOiBcInNlcVwiLCBleHBycyB9O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByU3Vic2NyaXB0KHN0cmVhbSkge1xuICAgIGxldCBleHByID0gcGFyc2VFeHByQXRvbShzdHJlYW0pO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIrXCIpKVxuICAgICAgICAgICAgZXhwciA9IHsgdHlwZTogXCJwbHVzXCIsIGV4cHIgfTtcbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIipcIikpXG4gICAgICAgICAgICBleHByID0geyB0eXBlOiBcInN0YXJcIiwgZXhwciB9O1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0uZWF0KFwiP1wiKSlcbiAgICAgICAgICAgIGV4cHIgPSB7IHR5cGU6IFwib3B0XCIsIGV4cHIgfTtcbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIntcIikpXG4gICAgICAgICAgICBleHByID0gcGFyc2VFeHByUmFuZ2Uoc3RyZWFtLCBleHByKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBleHByO1xufVxuZnVuY3Rpb24gcGFyc2VOdW0oc3RyZWFtKSB7XG4gICAgaWYgKC9cXEQvLnRlc3Qoc3RyZWFtLm5leHQpKVxuICAgICAgICBzdHJlYW0uZXJyKFwiRXhwZWN0ZWQgbnVtYmVyLCBnb3QgJ1wiICsgc3RyZWFtLm5leHQgKyBcIidcIik7XG4gICAgbGV0IHJlc3VsdCA9IE51bWJlcihzdHJlYW0ubmV4dCk7XG4gICAgc3RyZWFtLnBvcysrO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJSYW5nZShzdHJlYW0sIGV4cHIpIHtcbiAgICBsZXQgbWluID0gcGFyc2VOdW0oc3RyZWFtKSwgbWF4ID0gbWluO1xuICAgIGlmIChzdHJlYW0uZWF0KFwiLFwiKSkge1xuICAgICAgICBpZiAoc3RyZWFtLm5leHQgIT0gXCJ9XCIpXG4gICAgICAgICAgICBtYXggPSBwYXJzZU51bShzdHJlYW0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXggPSAtMTtcbiAgICB9XG4gICAgaWYgKCFzdHJlYW0uZWF0KFwifVwiKSlcbiAgICAgICAgc3RyZWFtLmVycihcIlVuY2xvc2VkIGJyYWNlZCByYW5nZVwiKTtcbiAgICByZXR1cm4geyB0eXBlOiBcInJhbmdlXCIsIG1pbiwgbWF4LCBleHByIH07XG59XG5mdW5jdGlvbiByZXNvbHZlTmFtZShzdHJlYW0sIG5hbWUpIHtcbiAgICBsZXQgdHlwZXMgPSBzdHJlYW0ubm9kZVR5cGVzLCB0eXBlID0gdHlwZXNbbmFtZV07XG4gICAgaWYgKHR5cGUpXG4gICAgICAgIHJldHVybiBbdHlwZV07XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHR5cGVOYW1lIGluIHR5cGVzKSB7XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbdHlwZU5hbWVdO1xuICAgICAgICBpZiAodHlwZS5ncm91cHMuaW5kZXhPZihuYW1lKSA+IC0xKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godHlwZSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQubGVuZ3RoID09IDApXG4gICAgICAgIHN0cmVhbS5lcnIoXCJObyBub2RlIHR5cGUgb3IgZ3JvdXAgJ1wiICsgbmFtZSArIFwiJyBmb3VuZFwiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByQXRvbShzdHJlYW0pIHtcbiAgICBpZiAoc3RyZWFtLmVhdChcIihcIikpIHtcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyZWFtKTtcbiAgICAgICAgaWYgKCFzdHJlYW0uZWF0KFwiKVwiKSlcbiAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJNaXNzaW5nIGNsb3NpbmcgcGFyZW5cIik7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgICBlbHNlIGlmICghL1xcVy8udGVzdChzdHJlYW0ubmV4dCkpIHtcbiAgICAgICAgbGV0IGV4cHJzID0gcmVzb2x2ZU5hbWUoc3RyZWFtLCBzdHJlYW0ubmV4dCkubWFwKHR5cGUgPT4ge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5pbmxpbmUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBzdHJlYW0uaW5saW5lID0gdHlwZS5pc0lubGluZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmVhbS5pbmxpbmUgIT0gdHlwZS5pc0lubGluZSlcbiAgICAgICAgICAgICAgICBzdHJlYW0uZXJyKFwiTWl4aW5nIGlubGluZSBhbmQgYmxvY2sgY29udGVudFwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibmFtZVwiLCB2YWx1ZTogdHlwZSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLnBvcysrO1xuICAgICAgICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHsgdHlwZTogXCJjaG9pY2VcIiwgZXhwcnMgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lcnIoXCJVbmV4cGVjdGVkIHRva2VuICdcIiArIHN0cmVhbS5uZXh0ICsgXCInXCIpO1xuICAgIH1cbn1cbi8qKlxuQ29uc3RydWN0IGFuIE5GQSBmcm9tIGFuIGV4cHJlc3Npb24gYXMgcmV0dXJuZWQgYnkgdGhlIHBhcnNlci4gVGhlXG5ORkEgaXMgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2Ygc3RhdGVzLCB3aGljaCBhcmUgdGhlbXNlbHZlc1xuYXJyYXlzIG9mIGVkZ2VzLCB3aGljaCBhcmUgYHt0ZXJtLCB0b31gIG9iamVjdHMuIFRoZSBmaXJzdCBzdGF0ZSBpc1xudGhlIGVudHJ5IHN0YXRlIGFuZCB0aGUgbGFzdCBub2RlIGlzIHRoZSBzdWNjZXNzIHN0YXRlLlxuXG5Ob3RlIHRoYXQgdW5saWtlIHR5cGljYWwgTkZBcywgdGhlIGVkZ2Ugb3JkZXJpbmcgaW4gdGhpcyBvbmUgaXNcbnNpZ25pZmljYW50LCBpbiB0aGF0IGl0IGlzIHVzZWQgdG8gY29udHJ1Y3QgZmlsbGVyIGNvbnRlbnQgd2hlblxubmVjZXNzYXJ5LlxuKi9cbmZ1bmN0aW9uIG5mYShleHByKSB7XG4gICAgbGV0IG5mYSA9IFtbXV07XG4gICAgY29ubmVjdChjb21waWxlKGV4cHIsIDApLCBub2RlKCkpO1xuICAgIHJldHVybiBuZmE7XG4gICAgZnVuY3Rpb24gbm9kZSgpIHsgcmV0dXJuIG5mYS5wdXNoKFtdKSAtIDE7IH1cbiAgICBmdW5jdGlvbiBlZGdlKGZyb20sIHRvLCB0ZXJtKSB7XG4gICAgICAgIGxldCBlZGdlID0geyB0ZXJtLCB0byB9O1xuICAgICAgICBuZmFbZnJvbV0ucHVzaChlZGdlKTtcbiAgICAgICAgcmV0dXJuIGVkZ2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbm5lY3QoZWRnZXMsIHRvKSB7XG4gICAgICAgIGVkZ2VzLmZvckVhY2goZWRnZSA9PiBlZGdlLnRvID0gdG8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21waWxlKGV4cHIsIGZyb20pIHtcbiAgICAgICAgaWYgKGV4cHIudHlwZSA9PSBcImNob2ljZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwci5leHBycy5yZWR1Y2UoKG91dCwgZXhwcikgPT4gb3V0LmNvbmNhdChjb21waWxlKGV4cHIsIGZyb20pKSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInNlcVwiKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY29tcGlsZShleHByLmV4cHJzW2ldLCBmcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBleHByLmV4cHJzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgIGNvbm5lY3QobmV4dCwgZnJvbSA9IG5vZGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwic3RhclwiKSB7XG4gICAgICAgICAgICBsZXQgbG9vcCA9IG5vZGUoKTtcbiAgICAgICAgICAgIGVkZ2UoZnJvbSwgbG9vcCk7XG4gICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBsb29wKSwgbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UobG9vcCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInBsdXNcIikge1xuICAgICAgICAgICAgbGV0IGxvb3AgPSBub2RlKCk7XG4gICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBmcm9tKSwgbG9vcCk7XG4gICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBsb29wKSwgbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UobG9vcCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcIm9wdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UoZnJvbSldLmNvbmNhdChjb21waWxlKGV4cHIuZXhwciwgZnJvbSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInJhbmdlXCIpIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSBmcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHByLm1pbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlKCk7XG4gICAgICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHByLm1heCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZXhwci5taW47IGkgPCBleHByLm1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICBlZGdlKGN1ciwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbZWRnZShjdXIpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShmcm9tLCB1bmRlZmluZWQsIGV4cHIudmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZXhwciB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY21wKGEsIGIpIHsgcmV0dXJuIGIgLSBhOyB9XG4vLyBHZXQgdGhlIHNldCBvZiBub2RlcyByZWFjaGFibGUgYnkgbnVsbCBlZGdlcyBmcm9tIGBub2RlYC4gT21pdFxuLy8gbm9kZXMgd2l0aCBvbmx5IGEgc2luZ2xlIG51bGwtb3V0LWVkZ2UsIHNpbmNlIHRoZXkgbWF5IGxlYWQgdG9cbi8vIG5lZWRsZXNzIGR1cGxpY2F0ZWQgbm9kZXMuXG5mdW5jdGlvbiBudWxsRnJvbShuZmEsIG5vZGUpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgc2Nhbihub2RlKTtcbiAgICByZXR1cm4gcmVzdWx0LnNvcnQoY21wKTtcbiAgICBmdW5jdGlvbiBzY2FuKG5vZGUpIHtcbiAgICAgICAgbGV0IGVkZ2VzID0gbmZhW25vZGVdO1xuICAgICAgICBpZiAoZWRnZXMubGVuZ3RoID09IDEgJiYgIWVkZ2VzWzBdLnRlcm0pXG4gICAgICAgICAgICByZXR1cm4gc2NhbihlZGdlc1swXS50byk7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyB0ZXJtLCB0byB9ID0gZWRnZXNbaV07XG4gICAgICAgICAgICBpZiAoIXRlcm0gJiYgcmVzdWx0LmluZGV4T2YodG8pID09IC0xKVxuICAgICAgICAgICAgICAgIHNjYW4odG8pO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gQ29tcGlsZXMgYW4gTkZBIGFzIHByb2R1Y2VkIGJ5IGBuZmFgIGludG8gYSBERkEsIG1vZGVsZWQgYXMgYSBzZXRcbi8vIG9mIHN0YXRlIG9iamVjdHMgKGBDb250ZW50TWF0Y2hgIGluc3RhbmNlcykgd2l0aCB0cmFuc2l0aW9uc1xuLy8gYmV0d2VlbiB0aGVtLlxuZnVuY3Rpb24gZGZhKG5mYSkge1xuICAgIGxldCBsYWJlbGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gZXhwbG9yZShudWxsRnJvbShuZmEsIDApKTtcbiAgICBmdW5jdGlvbiBleHBsb3JlKHN0YXRlcykge1xuICAgICAgICBsZXQgb3V0ID0gW107XG4gICAgICAgIHN0YXRlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgbmZhW25vZGVdLmZvckVhY2goKHsgdGVybSwgdG8gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGVybSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxldCBzZXQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRbaV1bMF0gPT0gdGVybSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldCA9IG91dFtpXVsxXTtcbiAgICAgICAgICAgICAgICBudWxsRnJvbShuZmEsIHRvKS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldClcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKFt0ZXJtLCBzZXQgPSBbXV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0LmluZGV4T2Yobm9kZSkgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHN0YXRlID0gbGFiZWxlZFtzdGF0ZXMuam9pbihcIixcIildID0gbmV3IENvbnRlbnRNYXRjaChzdGF0ZXMuaW5kZXhPZihuZmEubGVuZ3RoIC0gMSkgPiAtMSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhdGVzID0gb3V0W2ldWzFdLnNvcnQoY21wKTtcbiAgICAgICAgICAgIHN0YXRlLm5leHQucHVzaCh7IHR5cGU6IG91dFtpXVswXSwgbmV4dDogbGFiZWxlZFtzdGF0ZXMuam9pbihcIixcIildIHx8IGV4cGxvcmUoc3RhdGVzKSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tGb3JEZWFkRW5kcyhtYXRjaCwgc3RyZWFtKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIHdvcmsgPSBbbWF0Y2hdOyBpIDwgd29yay5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc3RhdGUgPSB3b3JrW2ldLCBkZWFkID0gIXN0YXRlLnZhbGlkRW5kLCBub2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0YXRlLm5leHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCB7IHR5cGUsIG5leHQgfSA9IHN0YXRlLm5leHRbal07XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHR5cGUubmFtZSk7XG4gICAgICAgICAgICBpZiAoZGVhZCAmJiAhKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSlcbiAgICAgICAgICAgICAgICBkZWFkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAod29yay5pbmRleE9mKG5leHQpID09IC0xKVxuICAgICAgICAgICAgICAgIHdvcmsucHVzaChuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVhZClcbiAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJPbmx5IG5vbi1nZW5lcmF0YWJsZSBub2RlcyAoXCIgKyBub2Rlcy5qb2luKFwiLCBcIikgKyBcIikgaW4gYSByZXF1aXJlZCBwb3NpdGlvbiAoc2VlIGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvZ3VpZGUvI2dlbmVyYXRhYmxlKVwiKTtcbiAgICB9XG59XG5cbi8vIEZvciBub2RlIHR5cGVzIHdoZXJlIGFsbCBhdHRycyBoYXZlIGEgZGVmYXVsdCB2YWx1ZSAob3Igd2hpY2ggZG9uJ3Rcbi8vIGhhdmUgYW55IGF0dHJpYnV0ZXMpLCBidWlsZCB1cCBhIHNpbmdsZSByZXVzYWJsZSBkZWZhdWx0IGF0dHJpYnV0ZVxuLy8gb2JqZWN0LCBhbmQgdXNlIGl0IGZvciBhbGwgbm9kZXMgdGhhdCBkb24ndCBzcGVjaWZ5IHNwZWNpZmljXG4vLyBhdHRyaWJ1dGVzLlxuZnVuY3Rpb24gZGVmYXVsdEF0dHJzKGF0dHJzKSB7XG4gICAgbGV0IGRlZmF1bHRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBhdHRyTmFtZSBpbiBhdHRycykge1xuICAgICAgICBsZXQgYXR0ciA9IGF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgaWYgKCFhdHRyLmhhc0RlZmF1bHQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZGVmYXVsdHNbYXR0ck5hbWVdID0gYXR0ci5kZWZhdWx0O1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdHM7XG59XG5mdW5jdGlvbiBjb21wdXRlQXR0cnMoYXR0cnMsIHZhbHVlKSB7XG4gICAgbGV0IGJ1aWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKSB7XG4gICAgICAgIGxldCBnaXZlbiA9IHZhbHVlICYmIHZhbHVlW25hbWVdO1xuICAgICAgICBpZiAoZ2l2ZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGF0dHIgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChhdHRyLmhhc0RlZmF1bHQpXG4gICAgICAgICAgICAgICAgZ2l2ZW4gPSBhdHRyLmRlZmF1bHQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyB2YWx1ZSBzdXBwbGllZCBmb3IgYXR0cmlidXRlIFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbHRbbmFtZV0gPSBnaXZlbjtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWx0O1xufVxuZnVuY3Rpb24gaW5pdEF0dHJzKGF0dHJzKSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGF0dHJzKVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKVxuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gbmV3IEF0dHJpYnV0ZShhdHRyc1tuYW1lXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuTm9kZSB0eXBlcyBhcmUgb2JqZWN0cyBhbGxvY2F0ZWQgb25jZSBwZXIgYFNjaGVtYWAgYW5kIHVzZWQgdG9cblt0YWddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnR5cGUpIGBOb2RlYCBpbnN0YW5jZXMuIFRoZXkgY29udGFpbiBpbmZvcm1hdGlvblxuYWJvdXQgdGhlIG5vZGUgdHlwZSwgc3VjaCBhcyBpdHMgbmFtZSBhbmQgd2hhdCBraW5kIG9mIG5vZGUgaXRcbnJlcHJlc2VudHMuXG4qL1xuY2xhc3MgTm9kZVR5cGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5hbWUgdGhlIG5vZGUgdHlwZSBoYXMgaW4gdGhpcyBzY2hlbWEuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBBIGxpbmsgYmFjayB0byB0aGUgYFNjaGVtYWAgdGhlIG5vZGUgdHlwZSBiZWxvbmdzIHRvLlxuICAgICovXG4gICAgc2NoZW1hLCBcbiAgICAvKipcbiAgICBUaGUgc3BlYyB0aGF0IHRoaXMgdHlwZSBpcyBiYXNlZCBvblxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBzZXQgb2YgbWFya3MgYWxsb3dlZCBpbiB0aGlzIG5vZGUuIGBudWxsYCBtZWFucyBhbGwgbWFya3NcbiAgICAgICAgYXJlIGFsbG93ZWQuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFya1NldCA9IG51bGw7XG4gICAgICAgIHRoaXMuZ3JvdXBzID0gc3BlYy5ncm91cCA/IHNwZWMuZ3JvdXAuc3BsaXQoXCIgXCIpIDogW107XG4gICAgICAgIHRoaXMuYXR0cnMgPSBpbml0QXR0cnMoc3BlYy5hdHRycyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdEF0dHJzID0gZGVmYXVsdEF0dHJzKHRoaXMuYXR0cnMpO1xuICAgICAgICB0aGlzLmNvbnRlbnRNYXRjaCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5saW5lQ29udGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNCbG9jayA9ICEoc3BlYy5pbmxpbmUgfHwgbmFtZSA9PSBcInRleHRcIik7XG4gICAgICAgIHRoaXMuaXNUZXh0ID0gbmFtZSA9PSBcInRleHRcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB0aGlzIGlzIGFuIGlubGluZSB0eXBlLlxuICAgICovXG4gICAgZ2V0IGlzSW5saW5lKCkgeyByZXR1cm4gIXRoaXMuaXNCbG9jazsgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgdGhpcyBpcyBhIHRleHRibG9jayB0eXBlLCBhIGJsb2NrIHRoYXQgY29udGFpbnMgaW5saW5lXG4gICAgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc1RleHRibG9jaygpIHsgcmV0dXJuIHRoaXMuaXNCbG9jayAmJiB0aGlzLmlubGluZUNvbnRlbnQ7IH1cbiAgICAvKipcbiAgICBUcnVlIGZvciBub2RlIHR5cGVzIHRoYXQgYWxsb3cgbm8gY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc0xlYWYoKSB7IHJldHVybiB0aGlzLmNvbnRlbnRNYXRjaCA9PSBDb250ZW50TWF0Y2guZW1wdHk7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBub2RlIGlzIGFuIGF0b20sIGkuZS4gd2hlbiBpdCBkb2VzIG5vdCBoYXZlXG4gICAgZGlyZWN0bHkgZWRpdGFibGUgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc0F0b20oKSB7IHJldHVybiB0aGlzLmlzTGVhZiB8fCAhIXRoaXMuc3BlYy5hdG9tOyB9XG4gICAgLyoqXG4gICAgVGhlIG5vZGUgdHlwZSdzIFt3aGl0ZXNwYWNlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMud2hpdGVzcGFjZSkgb3B0aW9uLlxuICAgICovXG4gICAgZ2V0IHdoaXRlc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMud2hpdGVzcGFjZSB8fCAodGhpcy5zcGVjLmNvZGUgPyBcInByZVwiIDogXCJub3JtYWxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoaXMgbm9kZSB0eXBlIGhhcyBhbnkgcmVxdWlyZWQgYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIGhhc1JlcXVpcmVkQXR0cnMoKSB7XG4gICAgICAgIGZvciAobGV0IG4gaW4gdGhpcy5hdHRycylcbiAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzW25dLmlzUmVxdWlyZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBub2RlIGFsbG93cyBzb21lIG9mIHRoZSBzYW1lIGNvbnRlbnQgYXNcbiAgICB0aGUgZ2l2ZW4gbm9kZSB0eXBlLlxuICAgICovXG4gICAgY29tcGF0aWJsZUNvbnRlbnQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb250ZW50TWF0Y2guY29tcGF0aWJsZShvdGhlci5jb250ZW50TWF0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXB1dGVBdHRycyhhdHRycykge1xuICAgICAgICBpZiAoIWF0dHJzICYmIHRoaXMuZGVmYXVsdEF0dHJzKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEF0dHJzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gY29tcHV0ZUF0dHJzKHRoaXMuYXR0cnMsIGF0dHJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgYE5vZGVgIG9mIHRoaXMgdHlwZS4gVGhlIGdpdmVuIGF0dHJpYnV0ZXMgYXJlXG4gICAgY2hlY2tlZCBhbmQgZGVmYXVsdGVkICh5b3UgY2FuIHBhc3MgYG51bGxgIHRvIHVzZSB0aGUgdHlwZSdzXG4gICAgZGVmYXVsdHMgZW50aXJlbHksIGlmIG5vIHJlcXVpcmVkIGF0dHJpYnV0ZXMgZXhpc3QpLiBgY29udGVudGBcbiAgICBtYXkgYmUgYSBgRnJhZ21lbnRgLCBhIG5vZGUsIGFuIGFycmF5IG9mIG5vZGVzLCBvclxuICAgIGBudWxsYC4gU2ltaWxhcmx5IGBtYXJrc2AgbWF5IGJlIGBudWxsYCB0byBkZWZhdWx0IHRvIHRoZSBlbXB0eVxuICAgIHNldCBvZiBtYXJrcy5cbiAgICAqL1xuICAgIGNyZWF0ZShhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVGV4dClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGVUeXBlLmNyZWF0ZSBjYW4ndCBjb25zdHJ1Y3QgdGV4dCBub2Rlc1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKSwgRnJhZ21lbnQuZnJvbShjb250ZW50KSwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIExpa2UgW2BjcmVhdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVR5cGUuY3JlYXRlKSwgYnV0IGNoZWNrIHRoZSBnaXZlbiBjb250ZW50XG4gICAgYWdhaW5zdCB0aGUgbm9kZSB0eXBlJ3MgY29udGVudCByZXN0cmljdGlvbnMsIGFuZCB0aHJvdyBhbiBlcnJvclxuICAgIGlmIGl0IGRvZXNuJ3QgbWF0Y2guXG4gICAgKi9cbiAgICBjcmVhdGVDaGVja2VkKGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20oY29udGVudCk7XG4gICAgICAgIHRoaXMuY2hlY2tDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpLCBjb250ZW50LCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTGlrZSBbYGNyZWF0ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlVHlwZS5jcmVhdGUpLCBidXQgc2VlIGlmIGl0IGlzXG4gICAgbmVjZXNzYXJ5IHRvIGFkZCBub2RlcyB0byB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBnaXZlbiBmcmFnbWVudFxuICAgIHRvIG1ha2UgaXQgZml0IHRoZSBub2RlLiBJZiBubyBmaXR0aW5nIHdyYXBwaW5nIGNhbiBiZSBmb3VuZCxcbiAgICByZXR1cm4gbnVsbC4gTm90ZSB0aGF0LCBkdWUgdG8gdGhlIGZhY3QgdGhhdCByZXF1aXJlZCBub2RlcyBjYW5cbiAgICBhbHdheXMgYmUgY3JlYXRlZCwgdGhpcyB3aWxsIGFsd2F5cyBzdWNjZWVkIGlmIHlvdSBwYXNzIG51bGwgb3JcbiAgICBgRnJhZ21lbnQuZW1wdHlgIGFzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBjcmVhdGVBbmRGaWxsKGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgYXR0cnMgPSB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyk7XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKGNvbnRlbnQpO1xuICAgICAgICBpZiAoY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gdGhpcy5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShjb250ZW50KTtcbiAgICAgICAgICAgIGlmICghYmVmb3JlKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29udGVudCA9IGJlZm9yZS5hcHBlbmQoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hdGNoZWQgPSB0aGlzLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgICBsZXQgYWZ0ZXIgPSBtYXRjaGVkICYmIG1hdGNoZWQuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgICAgIGlmICghYWZ0ZXIpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIGF0dHJzLCBjb250ZW50LmFwcGVuZChhZnRlciksIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGZyYWdtZW50IGlzIHZhbGlkIGNvbnRlbnQgZm9yIHRoaXMgbm9kZVxuICAgIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIHZhbGlkQ29udGVudChjb250ZW50KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LnZhbGlkRW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbG93c01hcmtzKGNvbnRlbnQuY2hpbGQoaSkubWFya3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRocm93cyBhIFJhbmdlRXJyb3IgaWYgdGhlIGdpdmVuIGZyYWdtZW50IGlzIG5vdCB2YWxpZCBjb250ZW50IGZvciB0aGlzXG4gICAgbm9kZSB0eXBlLlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hlY2tDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkQ29udGVudChjb250ZW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGNvbnRlbnQgZm9yIG5vZGUgJHt0aGlzLm5hbWV9OiAke2NvbnRlbnQudG9TdHJpbmcoKS5zbGljZSgwLCA1MCl9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIG1hcmsgdHlwZSBpcyBhbGxvd2VkIGluIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIGFsbG93c01hcmtUeXBlKG1hcmtUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtTZXQgPT0gbnVsbCB8fCB0aGlzLm1hcmtTZXQuaW5kZXhPZihtYXJrVHlwZSkgPiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MgYXJlIGFsbG93ZWQgaW4gdGhpcyBub2RlLlxuICAgICovXG4gICAgYWxsb3dzTWFya3MobWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya1NldCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya1R5cGUobWFya3NbaV0udHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlcyB0aGUgbWFya3MgdGhhdCBhcmUgbm90IGFsbG93ZWQgaW4gdGhpcyBub2RlIGZyb20gdGhlIGdpdmVuIHNldC5cbiAgICAqL1xuICAgIGFsbG93ZWRNYXJrcyhtYXJrcykge1xuICAgICAgICBpZiAodGhpcy5tYXJrU2V0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgICAgIGxldCBjb3B5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya1R5cGUobWFya3NbaV0udHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBtYXJrcy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgICAgICBjb3B5LnB1c2gobWFya3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhY29weSA/IG1hcmtzIDogY29weS5sZW5ndGggPyBjb3B5IDogTWFyay5ub25lO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjb21waWxlKG5vZGVzLCBzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIG5vZGVzLmZvckVhY2goKG5hbWUsIHNwZWMpID0+IHJlc3VsdFtuYW1lXSA9IG5ldyBOb2RlVHlwZShuYW1lLCBzY2hlbWEsIHNwZWMpKTtcbiAgICAgICAgbGV0IHRvcFR5cGUgPSBzY2hlbWEuc3BlYy50b3BOb2RlIHx8IFwiZG9jXCI7XG4gICAgICAgIGlmICghcmVzdWx0W3RvcFR5cGVdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTY2hlbWEgaXMgbWlzc2luZyBpdHMgdG9wIG5vZGUgdHlwZSAoJ1wiICsgdG9wVHlwZSArIFwiJylcIik7XG4gICAgICAgIGlmICghcmVzdWx0LnRleHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkV2ZXJ5IHNjaGVtYSBuZWVkcyBhICd0ZXh0JyB0eXBlXCIpO1xuICAgICAgICBmb3IgKGxldCBfIGluIHJlc3VsdC50ZXh0LmF0dHJzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdGV4dCBub2RlIHR5cGUgc2hvdWxkIG5vdCBoYXZlIGF0dHJpYnV0ZXNcIik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8gQXR0cmlidXRlIGRlc2NyaXB0b3JzXG5jbGFzcyBBdHRyaWJ1dGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5oYXNEZWZhdWx0ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwiZGVmYXVsdFwiKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gb3B0aW9ucy5kZWZhdWx0O1xuICAgIH1cbiAgICBnZXQgaXNSZXF1aXJlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmhhc0RlZmF1bHQ7XG4gICAgfVxufVxuLy8gTWFya3Ncbi8qKlxuTGlrZSBub2RlcywgbWFya3MgKHdoaWNoIGFyZSBhc3NvY2lhdGVkIHdpdGggbm9kZXMgdG8gc2lnbmlmeVxudGhpbmdzIGxpa2UgZW1waGFzaXMgb3IgYmVpbmcgcGFydCBvZiBhIGxpbmspIGFyZVxuW3RhZ2dlZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmsudHlwZSkgd2l0aCB0eXBlIG9iamVjdHMsIHdoaWNoIGFyZVxuaW5zdGFudGlhdGVkIG9uY2UgcGVyIGBTY2hlbWFgLlxuKi9cbmNsYXNzIE1hcmtUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoZSBtYXJrIHR5cGUuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJhbmssIFxuICAgIC8qKlxuICAgIFRoZSBzY2hlbWEgdGhhdCB0aGlzIG1hcmsgdHlwZSBpbnN0YW5jZSBpcyBwYXJ0IG9mLlxuICAgICovXG4gICAgc2NoZW1hLCBcbiAgICAvKipcbiAgICBUaGUgc3BlYyBvbiB3aGljaCB0aGUgdHlwZSBpcyBiYXNlZC5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5yYW5rID0gcmFuaztcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBpbml0QXR0cnMoc3BlYy5hdHRycyk7XG4gICAgICAgIHRoaXMuZXhjbHVkZWQgPSBudWxsO1xuICAgICAgICBsZXQgZGVmYXVsdHMgPSBkZWZhdWx0QXR0cnModGhpcy5hdHRycyk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBkZWZhdWx0cyA/IG5ldyBNYXJrKHRoaXMsIGRlZmF1bHRzKSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgb2YgdGhpcyB0eXBlLiBgYXR0cnNgIG1heSBiZSBgbnVsbGAgb3IgYW4gb2JqZWN0XG4gICAgY29udGFpbmluZyBvbmx5IHNvbWUgb2YgdGhlIG1hcmsncyBhdHRyaWJ1dGVzLiBUaGUgb3RoZXJzLCBpZlxuICAgIHRoZXkgaGF2ZSBkZWZhdWx0cywgd2lsbCBiZSBhZGRlZC5cbiAgICAqL1xuICAgIGNyZWF0ZShhdHRycyA9IG51bGwpIHtcbiAgICAgICAgaWYgKCFhdHRycyAmJiB0aGlzLmluc3RhbmNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gICAgICAgIHJldHVybiBuZXcgTWFyayh0aGlzLCBjb21wdXRlQXR0cnModGhpcy5hdHRycywgYXR0cnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY29tcGlsZShtYXJrcywgc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpLCByYW5rID0gMDtcbiAgICAgICAgbWFya3MuZm9yRWFjaCgobmFtZSwgc3BlYykgPT4gcmVzdWx0W25hbWVdID0gbmV3IE1hcmtUeXBlKG5hbWUsIHJhbmsrKywgc2NoZW1hLCBzcGVjKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZW4gdGhlcmUgaXMgYSBtYXJrIG9mIHRoaXMgdHlwZSBpbiB0aGUgZ2l2ZW4gc2V0LCBhIG5ldyBzZXRcbiAgICB3aXRob3V0IGl0IGlzIHJldHVybmVkLiBPdGhlcndpc2UsIHRoZSBpbnB1dCBzZXQgaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICByZW1vdmVGcm9tU2V0KHNldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChzZXRbaV0udHlwZSA9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgc2V0ID0gc2V0LnNsaWNlKDAsIGkpLmNvbmNhdChzZXQuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3RzIHdoZXRoZXIgdGhlcmUgaXMgYSBtYXJrIG9mIHRoaXMgdHlwZSBpbiB0aGUgZ2l2ZW4gc2V0LlxuICAgICovXG4gICAgaXNJblNldChzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoc2V0W2ldLnR5cGUgPT0gdGhpcylcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0W2ldO1xuICAgIH1cbiAgICAvKipcbiAgICBRdWVyaWVzIHdoZXRoZXIgYSBnaXZlbiBtYXJrIHR5cGUgaXNcbiAgICBbZXhjbHVkZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrU3BlYy5leGNsdWRlcykgYnkgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBleGNsdWRlcyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5leGNsdWRlZC5pbmRleE9mKG90aGVyKSA+IC0xO1xuICAgIH1cbn1cbi8qKlxuQSBkb2N1bWVudCBzY2hlbWEuIEhvbGRzIFtub2RlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVR5cGUpIGFuZCBbbWFya1xudHlwZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtUeXBlKSBvYmplY3RzIGZvciB0aGUgbm9kZXMgYW5kIG1hcmtzIHRoYXQgbWF5XG5vY2N1ciBpbiBjb25mb3JtaW5nIGRvY3VtZW50cywgYW5kIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yXG5jcmVhdGluZyBhbmQgZGVzZXJpYWxpemluZyBzdWNoIGRvY3VtZW50cy5cblxuV2hlbiBnaXZlbiwgdGhlIHR5cGUgcGFyYW1ldGVycyBwcm92aWRlIHRoZSBuYW1lcyBvZiB0aGUgbm9kZXMgYW5kXG5tYXJrcyBpbiB0aGlzIHNjaGVtYS5cbiovXG5jbGFzcyBTY2hlbWEge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIHNjaGVtYSBmcm9tIGEgc2NoZW1hIFtzcGVjaWZpY2F0aW9uXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuU2NoZW1hU3BlYykuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIC8qKlxuICAgICAgICBBbiBvYmplY3QgZm9yIHN0b3Jpbmcgd2hhdGV2ZXIgdmFsdWVzIG1vZHVsZXMgbWF5IHdhbnQgdG9cbiAgICAgICAgY29tcHV0ZSBhbmQgY2FjaGUgcGVyIHNjaGVtYS4gKElmIHlvdSB3YW50IHRvIHN0b3JlIHNvbWV0aGluZ1xuICAgICAgICBpbiBpdCwgdHJ5IHRvIHVzZSBwcm9wZXJ0eSBuYW1lcyB1bmxpa2VseSB0byBjbGFzaC4pXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2FjaGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IGluc3RhbmNlU3BlYyA9IHRoaXMuc3BlYyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpXG4gICAgICAgICAgICBpbnN0YW5jZVNwZWNbcHJvcF0gPSBzcGVjW3Byb3BdO1xuICAgICAgICBpbnN0YW5jZVNwZWMubm9kZXMgPSBPcmRlcmVkTWFwLmZyb20oc3BlYy5ub2RlcyksXG4gICAgICAgICAgICBpbnN0YW5jZVNwZWMubWFya3MgPSBPcmRlcmVkTWFwLmZyb20oc3BlYy5tYXJrcyB8fCB7fSksXG4gICAgICAgICAgICB0aGlzLm5vZGVzID0gTm9kZVR5cGUuY29tcGlsZSh0aGlzLnNwZWMubm9kZXMsIHRoaXMpO1xuICAgICAgICB0aGlzLm1hcmtzID0gTWFya1R5cGUuY29tcGlsZSh0aGlzLnNwZWMubWFya3MsIHRoaXMpO1xuICAgICAgICBsZXQgY29udGVudEV4cHJDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gdGhpcy5tYXJrcylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihwcm9wICsgXCIgY2FuIG5vdCBiZSBib3RoIGEgbm9kZSBhbmQgYSBtYXJrXCIpO1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm5vZGVzW3Byb3BdLCBjb250ZW50RXhwciA9IHR5cGUuc3BlYy5jb250ZW50IHx8IFwiXCIsIG1hcmtFeHByID0gdHlwZS5zcGVjLm1hcmtzO1xuICAgICAgICAgICAgdHlwZS5jb250ZW50TWF0Y2ggPSBjb250ZW50RXhwckNhY2hlW2NvbnRlbnRFeHByXSB8fFxuICAgICAgICAgICAgICAgIChjb250ZW50RXhwckNhY2hlW2NvbnRlbnRFeHByXSA9IENvbnRlbnRNYXRjaC5wYXJzZShjb250ZW50RXhwciwgdGhpcy5ub2RlcykpO1xuICAgICAgICAgICAgdHlwZS5pbmxpbmVDb250ZW50ID0gdHlwZS5jb250ZW50TWF0Y2guaW5saW5lQ29udGVudDtcbiAgICAgICAgICAgIHR5cGUubWFya1NldCA9IG1hcmtFeHByID09IFwiX1wiID8gbnVsbCA6XG4gICAgICAgICAgICAgICAgbWFya0V4cHIgPyBnYXRoZXJNYXJrcyh0aGlzLCBtYXJrRXhwci5zcGxpdChcIiBcIikpIDpcbiAgICAgICAgICAgICAgICAgICAgbWFya0V4cHIgPT0gXCJcIiB8fCAhdHlwZS5pbmxpbmVDb250ZW50ID8gW10gOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gdGhpcy5tYXJrcykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm1hcmtzW3Byb3BdLCBleGNsID0gdHlwZS5zcGVjLmV4Y2x1ZGVzO1xuICAgICAgICAgICAgdHlwZS5leGNsdWRlZCA9IGV4Y2wgPT0gbnVsbCA/IFt0eXBlXSA6IGV4Y2wgPT0gXCJcIiA/IFtdIDogZ2F0aGVyTWFya3ModGhpcywgZXhjbC5zcGxpdChcIiBcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZUZyb21KU09OID0gdGhpcy5ub2RlRnJvbUpTT04uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tYXJrRnJvbUpTT04gPSB0aGlzLm1hcmtGcm9tSlNPTi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRvcE5vZGVUeXBlID0gdGhpcy5ub2Rlc1t0aGlzLnNwZWMudG9wTm9kZSB8fCBcImRvY1wiXTtcbiAgICAgICAgdGhpcy5jYWNoZWQud3JhcHBpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBpbiB0aGlzIHNjaGVtYS4gVGhlIGB0eXBlYCBtYXkgYmUgYSBzdHJpbmcgb3IgYVxuICAgIGBOb2RlVHlwZWAgaW5zdGFuY2UuIEF0dHJpYnV0ZXMgd2lsbCBiZSBleHRlbmRlZCB3aXRoIGRlZmF1bHRzLFxuICAgIGBjb250ZW50YCBtYXkgYmUgYSBgRnJhZ21lbnRgLCBgbnVsbGAsIGEgYE5vZGVgLCBvciBhbiBhcnJheSBvZlxuICAgIG5vZGVzLlxuICAgICovXG4gICAgbm9kZSh0eXBlLCBhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdHlwZSA9IHRoaXMubm9kZVR5cGUodHlwZSk7XG4gICAgICAgIGVsc2UgaWYgKCEodHlwZSBpbnN0YW5jZW9mIE5vZGVUeXBlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBub2RlIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUuc2NoZW1hICE9IHRoaXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vZGUgdHlwZSBmcm9tIGRpZmZlcmVudCBzY2hlbWEgdXNlZCAoXCIgKyB0eXBlLm5hbWUgKyBcIilcIik7XG4gICAgICAgIHJldHVybiB0eXBlLmNyZWF0ZUNoZWNrZWQoYXR0cnMsIGNvbnRlbnQsIG1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBub2RlIGluIHRoZSBzY2hlbWEuIEVtcHR5IHRleHQgbm9kZXMgYXJlIG5vdFxuICAgIGFsbG93ZWQuXG4gICAgKi9cbiAgICB0ZXh0KHRleHQsIG1hcmtzKSB7XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5ub2Rlcy50ZXh0O1xuICAgICAgICByZXR1cm4gbmV3IFRleHROb2RlKHR5cGUsIHR5cGUuZGVmYXVsdEF0dHJzLCB0ZXh0LCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgbWFyayh0eXBlLCBhdHRycykge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLm1hcmtzW3R5cGVdO1xuICAgICAgICByZXR1cm4gdHlwZS5jcmVhdGUoYXR0cnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG5vZGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gVGhpcyBtZXRob2QgaXNcbiAgICBib3VuZC5cbiAgICAqL1xuICAgIG5vZGVGcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBOb2RlLmZyb21KU09OKHRoaXMsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG1hcmsgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gVGhpcyBtZXRob2QgaXNcbiAgICBib3VuZC5cbiAgICAqL1xuICAgIG1hcmtGcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBNYXJrLmZyb21KU09OKHRoaXMsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG5vZGVUeXBlKG5hbWUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5ub2Rlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5rbm93biBub2RlIHR5cGU6IFwiICsgbmFtZSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG59XG5mdW5jdGlvbiBnYXRoZXJNYXJrcyhzY2hlbWEsIG1hcmtzKSB7XG4gICAgbGV0IGZvdW5kID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbmFtZSA9IG1hcmtzW2ldLCBtYXJrID0gc2NoZW1hLm1hcmtzW25hbWVdLCBvayA9IG1hcms7XG4gICAgICAgIGlmIChtYXJrKSB7XG4gICAgICAgICAgICBmb3VuZC5wdXNoKG1hcmspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBzY2hlbWEubWFya3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyayA9IHNjaGVtYS5tYXJrc1twcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcIl9cIiB8fCAobWFyay5zcGVjLmdyb3VwICYmIG1hcmsuc3BlYy5ncm91cC5zcGxpdChcIiBcIikuaW5kZXhPZihuYW1lKSA+IC0xKSlcbiAgICAgICAgICAgICAgICAgICAgZm91bmQucHVzaChvayA9IG1hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghb2spXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbmtub3duIG1hcmsgdHlwZTogJ1wiICsgbWFya3NbaV0gKyBcIidcIik7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cblxuLyoqXG5BIERPTSBwYXJzZXIgcmVwcmVzZW50cyBhIHN0cmF0ZWd5IGZvciBwYXJzaW5nIERPTSBjb250ZW50IGludG8gYVxuUHJvc2VNaXJyb3IgZG9jdW1lbnQgY29uZm9ybWluZyB0byBhIGdpdmVuIHNjaGVtYS4gSXRzIGJlaGF2aW9yIGlzXG5kZWZpbmVkIGJ5IGFuIGFycmF5IG9mIFtydWxlc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlBhcnNlUnVsZSkuXG4qL1xuY2xhc3MgRE9NUGFyc2VyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBwYXJzZXIgdGhhdCB0YXJnZXRzIHRoZSBnaXZlbiBzY2hlbWEsIHVzaW5nIHRoZSBnaXZlblxuICAgIHBhcnNpbmcgcnVsZXMuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc2NoZW1hIGludG8gd2hpY2ggdGhlIHBhcnNlciBwYXJzZXMuXG4gICAgKi9cbiAgICBzY2hlbWEsIFxuICAgIC8qKlxuICAgIFRoZSBzZXQgb2YgW3BhcnNlIHJ1bGVzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUGFyc2VSdWxlKSB0aGF0IHRoZSBwYXJzZXJcbiAgICB1c2VzLCBpbiBvcmRlciBvZiBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgcnVsZXMpIHtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bGUudGFnKVxuICAgICAgICAgICAgICAgIHRoaXMudGFncy5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAocnVsZS5zdHlsZSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gT25seSBub3JtYWxpemUgbGlzdCBlbGVtZW50cyB3aGVuIGxpc3RzIGluIHRoZSBzY2hlbWEgY2FuJ3QgZGlyZWN0bHkgY29udGFpbiB0aGVtc2VsdmVzXG4gICAgICAgIHRoaXMubm9ybWFsaXplTGlzdHMgPSAhdGhpcy50YWdzLnNvbWUociA9PiB7XG4gICAgICAgICAgICBpZiAoIS9eKHVsfG9sKVxcYi8udGVzdChyLnRhZykgfHwgIXIubm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHNjaGVtYS5ub2Rlc1tyLm5vZGVdO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY29udGVudE1hdGNoLm1hdGNoVHlwZShub2RlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFBhcnNlIGEgZG9jdW1lbnQgZnJvbSB0aGUgY29udGVudCBvZiBhIERPTSBub2RlLlxuICAgICovXG4gICAgcGFyc2UoZG9tLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgUGFyc2VDb250ZXh0KHRoaXMsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgY29udGV4dC5hZGRBbGwoZG9tLCBvcHRpb25zLmZyb20sIG9wdGlvbnMudG8pO1xuICAgICAgICByZXR1cm4gY29udGV4dC5maW5pc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUGFyc2VzIHRoZSBjb250ZW50IG9mIHRoZSBnaXZlbiBET00gbm9kZSwgbGlrZVxuICAgIFtgcGFyc2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuRE9NUGFyc2VyLnBhcnNlKSwgYW5kIHRha2VzIHRoZSBzYW1lIHNldCBvZlxuICAgIG9wdGlvbnMuIEJ1dCB1bmxpa2UgdGhhdCBtZXRob2QsIHdoaWNoIHByb2R1Y2VzIGEgd2hvbGUgbm9kZSxcbiAgICB0aGlzIG9uZSByZXR1cm5zIGEgc2xpY2UgdGhhdCBpcyBvcGVuIGF0IHRoZSBzaWRlcywgbWVhbmluZyB0aGF0XG4gICAgdGhlIHNjaGVtYSBjb25zdHJhaW50cyBhcmVuJ3QgYXBwbGllZCB0byB0aGUgc3RhcnQgb2Ygbm9kZXMgdG9cbiAgICB0aGUgbGVmdCBvZiB0aGUgaW5wdXQgYW5kIHRoZSBlbmQgb2Ygbm9kZXMgYXQgdGhlIGVuZC5cbiAgICAqL1xuICAgIHBhcnNlU2xpY2UoZG9tLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgUGFyc2VDb250ZXh0KHRoaXMsIG9wdGlvbnMsIHRydWUpO1xuICAgICAgICBjb250ZXh0LmFkZEFsbChkb20sIG9wdGlvbnMuZnJvbSwgb3B0aW9ucy50byk7XG4gICAgICAgIHJldHVybiBTbGljZS5tYXhPcGVuKGNvbnRleHQuZmluaXNoKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hdGNoVGFnKGRvbSwgY29udGV4dCwgYWZ0ZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFmdGVyID8gdGhpcy50YWdzLmluZGV4T2YoYWZ0ZXIpICsgMSA6IDA7IGkgPCB0aGlzLnRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBydWxlID0gdGhpcy50YWdzW2ldO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXMoZG9tLCBydWxlLnRhZykgJiZcbiAgICAgICAgICAgICAgICAocnVsZS5uYW1lc3BhY2UgPT09IHVuZGVmaW5lZCB8fCBkb20ubmFtZXNwYWNlVVJJID09IHJ1bGUubmFtZXNwYWNlKSAmJlxuICAgICAgICAgICAgICAgICghcnVsZS5jb250ZXh0IHx8IGNvbnRleHQubWF0Y2hlc0NvbnRleHQocnVsZS5jb250ZXh0KSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5nZXRBdHRycykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcnVsZS5nZXRBdHRycyhkb20pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBydWxlLmF0dHJzID0gcmVzdWx0IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXRjaFN0eWxlKHByb3AsIHZhbHVlLCBjb250ZXh0LCBhZnRlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gYWZ0ZXIgPyB0aGlzLnN0eWxlcy5pbmRleE9mKGFmdGVyKSArIDEgOiAwOyBpIDwgdGhpcy5zdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBydWxlID0gdGhpcy5zdHlsZXNbaV0sIHN0eWxlID0gcnVsZS5zdHlsZTtcbiAgICAgICAgICAgIGlmIChzdHlsZS5pbmRleE9mKHByb3ApICE9IDAgfHxcbiAgICAgICAgICAgICAgICBydWxlLmNvbnRleHQgJiYgIWNvbnRleHQubWF0Y2hlc0NvbnRleHQocnVsZS5jb250ZXh0KSB8fFxuICAgICAgICAgICAgICAgIC8vIFRlc3QgdGhhdCB0aGUgc3R5bGUgc3RyaW5nIGVpdGhlciBwcmVjaXNlbHkgbWF0Y2hlcyB0aGUgcHJvcCxcbiAgICAgICAgICAgICAgICAvLyBvciBoYXMgYW4gJz0nIHNpZ24gYWZ0ZXIgdGhlIHByb3AsIGZvbGxvd2VkIGJ5IHRoZSBnaXZlblxuICAgICAgICAgICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAgICAgICAgIHN0eWxlLmxlbmd0aCA+IHByb3AubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIChzdHlsZS5jaGFyQ29kZUF0KHByb3AubGVuZ3RoKSAhPSA2MSB8fCBzdHlsZS5zbGljZShwcm9wLmxlbmd0aCArIDEpICE9IHZhbHVlKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChydWxlLmdldEF0dHJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJ1bGUuZ2V0QXR0cnModmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBydWxlLmF0dHJzID0gcmVzdWx0IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydWxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHNjaGVtYVJ1bGVzKHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGluc2VydChydWxlKSB7XG4gICAgICAgICAgICBsZXQgcHJpb3JpdHkgPSBydWxlLnByaW9yaXR5ID09IG51bGwgPyA1MCA6IHJ1bGUucHJpb3JpdHksIGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHJlc3VsdFtpXSwgbmV4dFByaW9yaXR5ID0gbmV4dC5wcmlvcml0eSA9PSBudWxsID8gNTAgOiBuZXh0LnByaW9yaXR5O1xuICAgICAgICAgICAgICAgIGlmIChuZXh0UHJpb3JpdHkgPCBwcmlvcml0eSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuc3BsaWNlKGksIDAsIHJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gc2NoZW1hLm1hcmtzKSB7XG4gICAgICAgICAgICBsZXQgcnVsZXMgPSBzY2hlbWEubWFya3NbbmFtZV0uc3BlYy5wYXJzZURPTTtcbiAgICAgICAgICAgIGlmIChydWxlcylcbiAgICAgICAgICAgICAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQocnVsZSA9IGNvcHkocnVsZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShydWxlLm1hcmsgfHwgcnVsZS5pZ25vcmUgfHwgcnVsZS5jbGVhck1hcmspKVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5tYXJrID0gbmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHNjaGVtYS5ub2Rlcykge1xuICAgICAgICAgICAgbGV0IHJ1bGVzID0gc2NoZW1hLm5vZGVzW25hbWVdLnNwZWMucGFyc2VET007XG4gICAgICAgICAgICBpZiAocnVsZXMpXG4gICAgICAgICAgICAgICAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0KHJ1bGUgPSBjb3B5KHJ1bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocnVsZS5ub2RlIHx8IHJ1bGUuaWdub3JlIHx8IHJ1bGUubWFyaykpXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLm5vZGUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIERPTSBwYXJzZXIgdXNpbmcgdGhlIHBhcnNpbmcgcnVsZXMgbGlzdGVkIGluIGFcbiAgICBzY2hlbWEncyBbbm9kZSBzcGVjc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLnBhcnNlRE9NKSwgcmVvcmRlcmVkIGJ5XG4gICAgW3ByaW9yaXR5XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUGFyc2VSdWxlLnByaW9yaXR5KS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmNhY2hlZC5kb21QYXJzZXIgfHxcbiAgICAgICAgICAgIChzY2hlbWEuY2FjaGVkLmRvbVBhcnNlciA9IG5ldyBET01QYXJzZXIoc2NoZW1hLCBET01QYXJzZXIuc2NoZW1hUnVsZXMoc2NoZW1hKSkpO1xuICAgIH1cbn1cbmNvbnN0IGJsb2NrVGFncyA9IHtcbiAgICBhZGRyZXNzOiB0cnVlLCBhcnRpY2xlOiB0cnVlLCBhc2lkZTogdHJ1ZSwgYmxvY2txdW90ZTogdHJ1ZSwgY2FudmFzOiB0cnVlLFxuICAgIGRkOiB0cnVlLCBkaXY6IHRydWUsIGRsOiB0cnVlLCBmaWVsZHNldDogdHJ1ZSwgZmlnY2FwdGlvbjogdHJ1ZSwgZmlndXJlOiB0cnVlLFxuICAgIGZvb3RlcjogdHJ1ZSwgZm9ybTogdHJ1ZSwgaDE6IHRydWUsIGgyOiB0cnVlLCBoMzogdHJ1ZSwgaDQ6IHRydWUsIGg1OiB0cnVlLFxuICAgIGg2OiB0cnVlLCBoZWFkZXI6IHRydWUsIGhncm91cDogdHJ1ZSwgaHI6IHRydWUsIGxpOiB0cnVlLCBub3NjcmlwdDogdHJ1ZSwgb2w6IHRydWUsXG4gICAgb3V0cHV0OiB0cnVlLCBwOiB0cnVlLCBwcmU6IHRydWUsIHNlY3Rpb246IHRydWUsIHRhYmxlOiB0cnVlLCB0Zm9vdDogdHJ1ZSwgdWw6IHRydWVcbn07XG5jb25zdCBpZ25vcmVUYWdzID0ge1xuICAgIGhlYWQ6IHRydWUsIG5vc2NyaXB0OiB0cnVlLCBvYmplY3Q6IHRydWUsIHNjcmlwdDogdHJ1ZSwgc3R5bGU6IHRydWUsIHRpdGxlOiB0cnVlXG59O1xuY29uc3QgbGlzdFRhZ3MgPSB7IG9sOiB0cnVlLCB1bDogdHJ1ZSB9O1xuLy8gVXNpbmcgYSBiaXRmaWVsZCBmb3Igbm9kZSBjb250ZXh0IG9wdGlvbnNcbmNvbnN0IE9QVF9QUkVTRVJWRV9XUyA9IDEsIE9QVF9QUkVTRVJWRV9XU19GVUxMID0gMiwgT1BUX09QRU5fTEVGVCA9IDQ7XG5mdW5jdGlvbiB3c09wdGlvbnNGb3IodHlwZSwgcHJlc2VydmVXaGl0ZXNwYWNlLCBiYXNlKSB7XG4gICAgaWYgKHByZXNlcnZlV2hpdGVzcGFjZSAhPSBudWxsKVxuICAgICAgICByZXR1cm4gKHByZXNlcnZlV2hpdGVzcGFjZSA/IE9QVF9QUkVTRVJWRV9XUyA6IDApIHxcbiAgICAgICAgICAgIChwcmVzZXJ2ZVdoaXRlc3BhY2UgPT09IFwiZnVsbFwiID8gT1BUX1BSRVNFUlZFX1dTX0ZVTEwgOiAwKTtcbiAgICByZXR1cm4gdHlwZSAmJiB0eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIiA/IE9QVF9QUkVTRVJWRV9XUyB8IE9QVF9QUkVTRVJWRV9XU19GVUxMIDogYmFzZSAmIH5PUFRfT1BFTl9MRUZUO1xufVxuY2xhc3MgTm9kZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGF0dHJzLCBcbiAgICAvLyBNYXJrcyBhcHBsaWVkIHRvIHRoaXMgbm9kZSBpdHNlbGZcbiAgICBtYXJrcywgXG4gICAgLy8gTWFya3MgdGhhdCBjYW4ndCBhcHBseSBoZXJlLCBidXQgd2lsbCBiZSB1c2VkIGluIGNoaWxkcmVuIGlmIHBvc3NpYmxlXG4gICAgcGVuZGluZ01hcmtzLCBzb2xpZCwgbWF0Y2gsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgICAgIHRoaXMucGVuZGluZ01hcmtzID0gcGVuZGluZ01hcmtzO1xuICAgICAgICB0aGlzLnNvbGlkID0gc29saWQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29udGVudCA9IFtdO1xuICAgICAgICAvLyBNYXJrcyBhcHBsaWVkIHRvIHRoZSBub2RlJ3MgY2hpbGRyZW5cbiAgICAgICAgdGhpcy5hY3RpdmVNYXJrcyA9IE1hcmsubm9uZTtcbiAgICAgICAgLy8gTmVzdGVkIE1hcmtzIHdpdGggc2FtZSB0eXBlXG4gICAgICAgIHRoaXMuc3Rhc2hNYXJrcyA9IFtdO1xuICAgICAgICB0aGlzLm1hdGNoID0gbWF0Y2ggfHwgKG9wdGlvbnMgJiBPUFRfT1BFTl9MRUZUID8gbnVsbCA6IHR5cGUuY29udGVudE1hdGNoKTtcbiAgICB9XG4gICAgZmluZFdyYXBwaW5nKG5vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hdGNoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICBsZXQgZmlsbCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgICAgICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChmaWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gsIHdyYXA7XG4gICAgICAgICAgICAgICAgaWYgKHdyYXAgPSBzdGFydC5maW5kV3JhcHBpbmcobm9kZS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoLmZpbmRXcmFwcGluZyhub2RlLnR5cGUpO1xuICAgIH1cbiAgICBmaW5pc2gob3BlbkVuZCkge1xuICAgICAgICBpZiAoISh0aGlzLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1MpKSB7IC8vIFN0cmlwIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSwgbTtcbiAgICAgICAgICAgIGlmIChsYXN0ICYmIGxhc3QuaXNUZXh0ICYmIChtID0gL1sgXFx0XFxyXFxuXFx1MDAwY10rJC8uZXhlYyhsYXN0LnRleHQpKSkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gbGFzdDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdC50ZXh0Lmxlbmd0aCA9PSBtWzBdLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LnBvcCgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSA9IHRleHQud2l0aFRleHQodGV4dC50ZXh0LnNsaWNlKDAsIHRleHQudGV4dC5sZW5ndGggLSBtWzBdLmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh0aGlzLmNvbnRlbnQpO1xuICAgICAgICBpZiAoIW9wZW5FbmQgJiYgdGhpcy5tYXRjaClcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LmFwcGVuZCh0aGlzLm1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA/IHRoaXMudHlwZS5jcmVhdGUodGhpcy5hdHRycywgY29udGVudCwgdGhpcy5tYXJrcykgOiBjb250ZW50O1xuICAgIH1cbiAgICBwb3BGcm9tU3Rhc2hNYXJrKG1hcmspIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3Rhc2hNYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGlmIChtYXJrLmVxKHRoaXMuc3Rhc2hNYXJrc1tpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3Rhc2hNYXJrcy5zcGxpY2UoaSwgMSlbMF07XG4gICAgfVxuICAgIGFwcGx5UGVuZGluZyhuZXh0VHlwZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcGVuZGluZyA9IHRoaXMucGVuZGluZ01hcmtzOyBpIDwgcGVuZGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcmsgPSBwZW5kaW5nW2ldO1xuICAgICAgICAgICAgaWYgKCh0aGlzLnR5cGUgPyB0aGlzLnR5cGUuYWxsb3dzTWFya1R5cGUobWFyay50eXBlKSA6IG1hcmtNYXlBcHBseShtYXJrLnR5cGUsIG5leHRUeXBlKSkgJiZcbiAgICAgICAgICAgICAgICAhbWFyay5pc0luU2V0KHRoaXMuYWN0aXZlTWFya3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVNYXJrcyA9IG1hcmsuYWRkVG9TZXQodGhpcy5hY3RpdmVNYXJrcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWFya3MgPSBtYXJrLnJlbW92ZUZyb21TZXQodGhpcy5wZW5kaW5nTWFya3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlubGluZUNvbnRleHQobm9kZSkge1xuICAgICAgICBpZiAodGhpcy50eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5pbmxpbmVDb250ZW50O1xuICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRbMF0uaXNJbmxpbmU7XG4gICAgICAgIHJldHVybiBub2RlLnBhcmVudE5vZGUgJiYgIWJsb2NrVGFncy5oYXNPd25Qcm9wZXJ0eShub2RlLnBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxufVxuY2xhc3MgUGFyc2VDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgcGFyc2VyIHdlIGFyZSB1c2luZy5cbiAgICBwYXJzZXIsIFxuICAgIC8vIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGlzIHBhcnNlLlxuICAgIG9wdGlvbnMsIGlzT3Blbikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pc09wZW4gPSBpc09wZW47XG4gICAgICAgIHRoaXMub3BlbiA9IDA7XG4gICAgICAgIGxldCB0b3BOb2RlID0gb3B0aW9ucy50b3BOb2RlLCB0b3BDb250ZXh0O1xuICAgICAgICBsZXQgdG9wT3B0aW9ucyA9IHdzT3B0aW9uc0ZvcihudWxsLCBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSwgMCkgfCAoaXNPcGVuID8gT1BUX09QRU5fTEVGVCA6IDApO1xuICAgICAgICBpZiAodG9wTm9kZSlcbiAgICAgICAgICAgIHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQodG9wTm9kZS50eXBlLCB0b3BOb2RlLmF0dHJzLCBNYXJrLm5vbmUsIE1hcmsubm9uZSwgdHJ1ZSwgb3B0aW9ucy50b3BNYXRjaCB8fCB0b3BOb2RlLnR5cGUuY29udGVudE1hdGNoLCB0b3BPcHRpb25zKTtcbiAgICAgICAgZWxzZSBpZiAoaXNPcGVuKVxuICAgICAgICAgICAgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dChudWxsLCBudWxsLCBNYXJrLm5vbmUsIE1hcmsubm9uZSwgdHJ1ZSwgbnVsbCwgdG9wT3B0aW9ucyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQocGFyc2VyLnNjaGVtYS50b3BOb2RlVHlwZSwgbnVsbCwgTWFyay5ub25lLCBNYXJrLm5vbmUsIHRydWUsIG51bGwsIHRvcE9wdGlvbnMpO1xuICAgICAgICB0aGlzLm5vZGVzID0gW3RvcENvbnRleHRdO1xuICAgICAgICB0aGlzLmZpbmQgPSBvcHRpb25zLmZpbmRQb3NpdGlvbnM7XG4gICAgICAgIHRoaXMubmVlZHNCbG9jayA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgdG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1t0aGlzLm9wZW5dO1xuICAgIH1cbiAgICAvLyBBZGQgYSBET00gbm9kZSB0byB0aGUgY29udGVudC4gVGV4dCBpcyBpbnNlcnRlZCBhcyB0ZXh0IG5vZGUsXG4gICAgLy8gb3RoZXJ3aXNlLCB0aGUgbm9kZSBpcyBwYXNzZWQgdG8gYGFkZEVsZW1lbnRgIG9yLCBpZiBpdCBoYXMgYVxuICAgIC8vIGBzdHlsZWAgYXR0cmlidXRlLCBgYWRkRWxlbWVudFdpdGhTdHlsZXNgLlxuICAgIGFkZERPTShkb20pIHtcbiAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgdGhpcy5hZGRUZXh0Tm9kZShkb20pO1xuICAgICAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudChkb20pO1xuICAgIH1cbiAgICB3aXRoU3R5bGVSdWxlcyhkb20sIGYpIHtcbiAgICAgICAgbGV0IHN0eWxlID0gZG9tLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgICAgICBpZiAoIXN0eWxlKVxuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgbGV0IG1hcmtzID0gdGhpcy5yZWFkU3R5bGVzKHBhcnNlU3R5bGVzKHN0eWxlKSk7XG4gICAgICAgIGlmICghbWFya3MpXG4gICAgICAgICAgICByZXR1cm47IC8vIEEgc3R5bGUgd2l0aCBpZ25vcmU6IHRydWVcbiAgICAgICAgbGV0IFthZGRNYXJrcywgcmVtb3ZlTWFya3NdID0gbWFya3MsIHRvcCA9IHRoaXMudG9wO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZU1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVQZW5kaW5nTWFyayhyZW1vdmVNYXJrc1tpXSwgdG9wKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuYWRkUGVuZGluZ01hcmsoYWRkTWFya3NbaV0pO1xuICAgICAgICBmKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkTWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBlbmRpbmdNYXJrKGFkZE1hcmtzW2ldLCB0b3ApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZU1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5hZGRQZW5kaW5nTWFyayhyZW1vdmVNYXJrc1tpXSk7XG4gICAgfVxuICAgIGFkZFRleHROb2RlKGRvbSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBkb20ubm9kZVZhbHVlO1xuICAgICAgICBsZXQgdG9wID0gdGhpcy50b3A7XG4gICAgICAgIGlmICh0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XU19GVUxMIHx8XG4gICAgICAgICAgICB0b3AuaW5saW5lQ29udGV4dChkb20pIHx8XG4gICAgICAgICAgICAvW14gXFx0XFxyXFxuXFx1MDAwY10vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoISh0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XUykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1sgXFx0XFxyXFxuXFx1MDAwY10rL2csIFwiIFwiKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIHN0YXJ0cyB3aXRoIHdoaXRlc3BhY2UsIGFuZCB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSBpdCwgb3JcbiAgICAgICAgICAgICAgICAvLyBhIGhhcmQgYnJlYWssIG9yIGEgdGV4dCBub2RlIHRoYXQgZW5kcyB3aXRoIHdoaXRlc3BhY2UsIHN0cmlwIHRoZVxuICAgICAgICAgICAgICAgIC8vIGxlYWRpbmcgc3BhY2UuXG4gICAgICAgICAgICAgICAgaWYgKC9eWyBcXHRcXHJcXG5cXHUwMDBjXS8udGVzdCh2YWx1ZSkgJiYgdGhpcy5vcGVuID09IHRoaXMubm9kZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZUJlZm9yZSA9IHRvcC5jb250ZW50W3RvcC5jb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZG9tTm9kZUJlZm9yZSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZUJlZm9yZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGRvbU5vZGVCZWZvcmUgJiYgZG9tTm9kZUJlZm9yZS5ub2RlTmFtZSA9PSAnQlInKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGVCZWZvcmUuaXNUZXh0ICYmIC9bIFxcdFxcclxcblxcdTAwMGNdJC8udGVzdChub2RlQmVmb3JlLnRleHQpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoISh0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XU19GVUxMKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxyP1xcbnxcXHIvZywgXCIgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0Tm9kZSh0aGlzLnBhcnNlci5zY2hlbWEudGV4dCh2YWx1ZSkpO1xuICAgICAgICAgICAgdGhpcy5maW5kSW5UZXh0KGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gZmluZCBhIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiB0YWcgYW5kIHVzZSB0aGF0IHRvIHBhcnNlLiBJZlxuICAgIC8vIG5vbmUgaXMgZm91bmQsIHRoZSBlbGVtZW50J3MgY29udGVudCBub2RlcyBhcmUgYWRkZWQgZGlyZWN0bHkuXG4gICAgYWRkRWxlbWVudChkb20sIG1hdGNoQWZ0ZXIpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBkb20ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgcnVsZUlEO1xuICAgICAgICBpZiAobGlzdFRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgdGhpcy5wYXJzZXIubm9ybWFsaXplTGlzdHMpXG4gICAgICAgICAgICBub3JtYWxpemVMaXN0KGRvbSk7XG4gICAgICAgIGxldCBydWxlID0gKHRoaXMub3B0aW9ucy5ydWxlRnJvbU5vZGUgJiYgdGhpcy5vcHRpb25zLnJ1bGVGcm9tTm9kZShkb20pKSB8fFxuICAgICAgICAgICAgKHJ1bGVJRCA9IHRoaXMucGFyc2VyLm1hdGNoVGFnKGRvbSwgdGhpcywgbWF0Y2hBZnRlcikpO1xuICAgICAgICBpZiAocnVsZSA/IHJ1bGUuaWdub3JlIDogaWdub3JlVGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUZhbGxiYWNrKGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXJ1bGUgfHwgcnVsZS5za2lwIHx8IHJ1bGUuY2xvc2VQYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChydWxlICYmIHJ1bGUuY2xvc2VQYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuID0gTWF0aC5tYXgoMCwgdGhpcy5vcGVuIC0gMSk7XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlICYmIHJ1bGUuc2tpcC5ub2RlVHlwZSlcbiAgICAgICAgICAgICAgICBkb20gPSBydWxlLnNraXA7XG4gICAgICAgICAgICBsZXQgc3luYywgdG9wID0gdGhpcy50b3AsIG9sZE5lZWRzQmxvY2sgPSB0aGlzLm5lZWRzQmxvY2s7XG4gICAgICAgICAgICBpZiAoYmxvY2tUYWdzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvcC5jb250ZW50Lmxlbmd0aCAmJiB0b3AuY29udGVudFswXS5pc0lubGluZSAmJiB0aGlzLm9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuLS07XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IHRoaXMudG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRvcC50eXBlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5lZWRzQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWRvbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFmRmFsbGJhY2soZG9tKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocnVsZSAmJiBydWxlLnNraXApXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBbGwoZG9tKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLndpdGhTdHlsZVJ1bGVzKGRvbSwgKCkgPT4gdGhpcy5hZGRBbGwoZG9tKSk7XG4gICAgICAgICAgICBpZiAoc3luYylcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmModG9wKTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNCbG9jayA9IG9sZE5lZWRzQmxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndpdGhTdHlsZVJ1bGVzKGRvbSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudEJ5UnVsZShkb20sIHJ1bGUsIHJ1bGUuY29uc3VtaW5nID09PSBmYWxzZSA/IHJ1bGVJRCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYWxsZWQgZm9yIGxlYWYgRE9NIG5vZGVzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGJlIGlnbm9yZWRcbiAgICBsZWFmRmFsbGJhY2soZG9tKSB7XG4gICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmIHRoaXMudG9wLnR5cGUgJiYgdGhpcy50b3AudHlwZS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgdGhpcy5hZGRUZXh0Tm9kZShkb20ub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblwiKSk7XG4gICAgfVxuICAgIC8vIENhbGxlZCBmb3IgaWdub3JlZCBub2Rlc1xuICAgIGlnbm9yZUZhbGxiYWNrKGRvbSkge1xuICAgICAgICAvLyBJZ25vcmVkIEJSIG5vZGVzIHNob3VsZCBhdCBsZWFzdCBjcmVhdGUgYW4gaW5saW5lIGNvbnRleHRcbiAgICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgKCF0aGlzLnRvcC50eXBlIHx8ICF0aGlzLnRvcC50eXBlLmlubGluZUNvbnRlbnQpKVxuICAgICAgICAgICAgdGhpcy5maW5kUGxhY2UodGhpcy5wYXJzZXIuc2NoZW1hLnRleHQoXCItXCIpKTtcbiAgICB9XG4gICAgLy8gUnVuIGFueSBzdHlsZSBwYXJzZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBub2RlJ3Mgc3R5bGVzLiBFaXRoZXJcbiAgICAvLyByZXR1cm4gYW4gYXJyYXkgb2YgbWFya3MsIG9yIG51bGwgdG8gaW5kaWNhdGUgc29tZSBvZiB0aGUgc3R5bGVzXG4gICAgLy8gaGFkIGEgcnVsZSB3aXRoIGBpZ25vcmVgIHNldC5cbiAgICByZWFkU3R5bGVzKHN0eWxlcykge1xuICAgICAgICBsZXQgYWRkID0gTWFyay5ub25lLCByZW1vdmUgPSBNYXJrLm5vbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBhZnRlciA9IHVuZGVmaW5lZDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnBhcnNlci5tYXRjaFN0eWxlKHN0eWxlc1tpXSwgc3R5bGVzW2kgKyAxXSwgdGhpcywgYWZ0ZXIpO1xuICAgICAgICAgICAgICAgIGlmICghcnVsZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuaWdub3JlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5jbGVhck1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3AucGVuZGluZ01hcmtzLmNvbmNhdCh0aGlzLnRvcC5hY3RpdmVNYXJrcykuZm9yRWFjaChtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmNsZWFyTWFyayhtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUgPSBtLmFkZFRvU2V0KHJlbW92ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkID0gdGhpcy5wYXJzZXIuc2NoZW1hLm1hcmtzW3J1bGUubWFya10uY3JlYXRlKHJ1bGUuYXR0cnMpLmFkZFRvU2V0KGFkZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydWxlLmNvbnN1bWluZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyID0gcnVsZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbYWRkLCByZW1vdmVdO1xuICAgIH1cbiAgICAvLyBMb29rIHVwIGEgaGFuZGxlciBmb3IgdGhlIGdpdmVuIG5vZGUuIElmIG5vbmUgYXJlIGZvdW5kLCByZXR1cm5cbiAgICAvLyBmYWxzZS4gT3RoZXJ3aXNlLCBhcHBseSBpdCwgdXNlIGl0cyByZXR1cm4gdmFsdWUgdG8gZHJpdmUgdGhlIHdheVxuICAgIC8vIHRoZSBub2RlJ3MgY29udGVudCBpcyB3cmFwcGVkLCBhbmQgcmV0dXJuIHRydWUuXG4gICAgYWRkRWxlbWVudEJ5UnVsZShkb20sIHJ1bGUsIGNvbnRpbnVlQWZ0ZXIpIHtcbiAgICAgICAgbGV0IHN5bmMsIG5vZGVUeXBlLCBtYXJrO1xuICAgICAgICBpZiAocnVsZS5ub2RlKSB7XG4gICAgICAgICAgICBub2RlVHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlc1tydWxlLm5vZGVdO1xuICAgICAgICAgICAgaWYgKCFub2RlVHlwZS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICBzeW5jID0gdGhpcy5lbnRlcihub2RlVHlwZSwgcnVsZS5hdHRycyB8fCBudWxsLCBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5pbnNlcnROb2RlKG5vZGVUeXBlLmNyZWF0ZShydWxlLmF0dHJzKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlYWZGYWxsYmFjayhkb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1hcmtUeXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm1hcmtzW3J1bGUubWFya107XG4gICAgICAgICAgICBtYXJrID0gbWFya1R5cGUuY3JlYXRlKHJ1bGUuYXR0cnMpO1xuICAgICAgICAgICAgdGhpcy5hZGRQZW5kaW5nTWFyayhtYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRJbiA9IHRoaXMudG9wO1xuICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUuaXNMZWFmKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250aW51ZUFmdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQoZG9tLCBjb250aW51ZUFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydWxlLmdldENvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICAgICAgcnVsZS5nZXRDb250ZW50KGRvbSwgdGhpcy5wYXJzZXIuc2NoZW1hKS5mb3JFYWNoKG5vZGUgPT4gdGhpcy5pbnNlcnROb2RlKG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50RE9NID0gZG9tO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBydWxlLmNvbnRlbnRFbGVtZW50ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgY29udGVudERPTSA9IGRvbS5xdWVyeVNlbGVjdG9yKHJ1bGUuY29udGVudEVsZW1lbnQpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJ1bGUuY29udGVudEVsZW1lbnQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBydWxlLmNvbnRlbnRFbGVtZW50KGRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlLmNvbnRlbnRFbGVtZW50KVxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBydWxlLmNvbnRlbnRFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5maW5kQXJvdW5kKGRvbSwgY29udGVudERPTSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmFkZEFsbChjb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3luYyAmJiB0aGlzLnN5bmMoc3RhcnRJbikpXG4gICAgICAgICAgICB0aGlzLm9wZW4tLTtcbiAgICAgICAgaWYgKG1hcmspXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBlbmRpbmdNYXJrKG1hcmssIHN0YXJ0SW4pO1xuICAgIH1cbiAgICAvLyBBZGQgYWxsIGNoaWxkIG5vZGVzIGJldHdlZW4gYHN0YXJ0SW5kZXhgIGFuZCBgZW5kSW5kZXhgIChvciB0aGVcbiAgICAvLyB3aG9sZSBub2RlLCBpZiBub3QgZ2l2ZW4pLiBJZiBgc3luY2AgaXMgcGFzc2VkLCB1c2UgaXQgdG9cbiAgICAvLyBzeW5jaHJvbml6ZSBhZnRlciBldmVyeSBibG9jayBlbGVtZW50LlxuICAgIGFkZEFsbChwYXJlbnQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHN0YXJ0SW5kZXggfHwgMDtcbiAgICAgICAgZm9yIChsZXQgZG9tID0gc3RhcnRJbmRleCA/IHBhcmVudC5jaGlsZE5vZGVzW3N0YXJ0SW5kZXhdIDogcGFyZW50LmZpcnN0Q2hpbGQsIGVuZCA9IGVuZEluZGV4ID09IG51bGwgPyBudWxsIDogcGFyZW50LmNoaWxkTm9kZXNbZW5kSW5kZXhdOyBkb20gIT0gZW5kOyBkb20gPSBkb20ubmV4dFNpYmxpbmcsICsraW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEF0UG9pbnQocGFyZW50LCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLmFkZERPTShkb20pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluZEF0UG9pbnQocGFyZW50LCBpbmRleCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byBmaW5kIGEgd2F5IHRvIGZpdCB0aGUgZ2l2ZW4gbm9kZSB0eXBlIGludG8gdGhlIGN1cnJlbnRcbiAgICAvLyBjb250ZXh0LiBNYXkgYWRkIGludGVybWVkaWF0ZSB3cmFwcGVycyBhbmQvb3IgbGVhdmUgbm9uLXNvbGlkXG4gICAgLy8gbm9kZXMgdGhhdCB3ZSdyZSBpbi5cbiAgICBmaW5kUGxhY2Uobm9kZSkge1xuICAgICAgICBsZXQgcm91dGUsIHN5bmM7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gdGhpcy5vcGVuOyBkZXB0aCA+PSAwOyBkZXB0aC0tKSB7XG4gICAgICAgICAgICBsZXQgY3ggPSB0aGlzLm5vZGVzW2RlcHRoXTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGN4LmZpbmRXcmFwcGluZyhub2RlKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCAmJiAoIXJvdXRlIHx8IHJvdXRlLmxlbmd0aCA+IGZvdW5kLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICByb3V0ZSA9IGZvdW5kO1xuICAgICAgICAgICAgICAgIHN5bmMgPSBjeDtcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3guc29saWQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyb3V0ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5zeW5jKHN5bmMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5lbnRlcklubmVyKHJvdXRlW2ldLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gaW5zZXJ0IHRoZSBnaXZlbiBub2RlLCBhZGp1c3RpbmcgdGhlIGNvbnRleHQgd2hlbiBuZWVkZWQuXG4gICAgaW5zZXJ0Tm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmlzSW5saW5lICYmIHRoaXMubmVlZHNCbG9jayAmJiAhdGhpcy50b3AudHlwZSkge1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gdGhpcy50ZXh0YmxvY2tGcm9tQ29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKGJsb2NrKVxuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXJJbm5lcihibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmluZFBsYWNlKG5vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgICAgIHRvcC5hcHBseVBlbmRpbmcobm9kZS50eXBlKTtcbiAgICAgICAgICAgIGlmICh0b3AubWF0Y2gpXG4gICAgICAgICAgICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoLm1hdGNoVHlwZShub2RlLnR5cGUpO1xuICAgICAgICAgICAgbGV0IG1hcmtzID0gdG9wLmFjdGl2ZU1hcmtzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLm1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmICghdG9wLnR5cGUgfHwgdG9wLnR5cGUuYWxsb3dzTWFya1R5cGUobm9kZS5tYXJrc1tpXS50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgbWFya3MgPSBub2RlLm1hcmtzW2ldLmFkZFRvU2V0KG1hcmtzKTtcbiAgICAgICAgICAgIHRvcC5jb250ZW50LnB1c2gobm9kZS5tYXJrKG1hcmtzKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRyeSB0byBzdGFydCBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUsIGFkanVzdGluZyB0aGUgY29udGV4dCB3aGVuXG4gICAgLy8gbmVjZXNzYXJ5LlxuICAgIGVudGVyKHR5cGUsIGF0dHJzLCBwcmVzZXJ2ZVdTKSB7XG4gICAgICAgIGxldCBvayA9IHRoaXMuZmluZFBsYWNlKHR5cGUuY3JlYXRlKGF0dHJzKSk7XG4gICAgICAgIGlmIChvaylcbiAgICAgICAgICAgIHRoaXMuZW50ZXJJbm5lcih0eXBlLCBhdHRycywgdHJ1ZSwgcHJlc2VydmVXUyk7XG4gICAgICAgIHJldHVybiBvaztcbiAgICB9XG4gICAgLy8gT3BlbiBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGVcbiAgICBlbnRlcklubmVyKHR5cGUsIGF0dHJzID0gbnVsbCwgc29saWQgPSBmYWxzZSwgcHJlc2VydmVXUykge1xuICAgICAgICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgICB0b3AuYXBwbHlQZW5kaW5nKHR5cGUpO1xuICAgICAgICB0b3AubWF0Y2ggPSB0b3AubWF0Y2ggJiYgdG9wLm1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB3c09wdGlvbnNGb3IodHlwZSwgcHJlc2VydmVXUywgdG9wLm9wdGlvbnMpO1xuICAgICAgICBpZiAoKHRvcC5vcHRpb25zICYgT1BUX09QRU5fTEVGVCkgJiYgdG9wLmNvbnRlbnQubGVuZ3RoID09IDApXG4gICAgICAgICAgICBvcHRpb25zIHw9IE9QVF9PUEVOX0xFRlQ7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgTm9kZUNvbnRleHQodHlwZSwgYXR0cnMsIHRvcC5hY3RpdmVNYXJrcywgdG9wLnBlbmRpbmdNYXJrcywgc29saWQsIG51bGwsIG9wdGlvbnMpKTtcbiAgICAgICAgdGhpcy5vcGVuKys7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBhbGwgbm9kZXMgYWJvdmUgdGhpcy5vcGVuIGFyZSBmaW5pc2hlZCBhbmQgYWRkZWQgdG9cbiAgICAvLyB0aGVpciBwYXJlbnRzXG4gICAgY2xvc2VFeHRyYShvcGVuRW5kID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpID4gdGhpcy5vcGVuKSB7XG4gICAgICAgICAgICBmb3IgKDsgaSA+IHRoaXMub3BlbjsgaS0tKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXNbaSAtIDFdLmNvbnRlbnQucHVzaCh0aGlzLm5vZGVzW2ldLmZpbmlzaChvcGVuRW5kKSk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLmxlbmd0aCA9IHRoaXMub3BlbiArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICB0aGlzLm9wZW4gPSAwO1xuICAgICAgICB0aGlzLmNsb3NlRXh0cmEodGhpcy5pc09wZW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXS5maW5pc2godGhpcy5pc09wZW4gfHwgdGhpcy5vcHRpb25zLnRvcE9wZW4pO1xuICAgIH1cbiAgICBzeW5jKHRvKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLm9wZW47IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbaV0gPT0gdG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4gPSBpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBjdXJyZW50UG9zKCkge1xuICAgICAgICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLm9wZW47IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IHRoaXMubm9kZXNbaV0uY29udGVudDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBjb250ZW50Lmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuICAgICAgICAgICAgICAgIHBvcyArPSBjb250ZW50W2pdLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgZmluZEF0UG9pbnQocGFyZW50LCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5ub2RlID09IHBhcmVudCAmJiB0aGlzLmZpbmRbaV0ub2Zmc2V0ID09IG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZmluZEluc2lkZShwYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5wb3MgPT0gbnVsbCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMSAmJiBwYXJlbnQuY29udGFpbnModGhpcy5maW5kW2ldLm5vZGUpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kQXJvdW5kKHBhcmVudCwgY29udGVudCwgYmVmb3JlKSB7XG4gICAgICAgIGlmIChwYXJlbnQgIT0gY29udGVudCAmJiB0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ucG9zID09IG51bGwgJiYgcGFyZW50Lm5vZGVUeXBlID09IDEgJiYgcGFyZW50LmNvbnRhaW5zKHRoaXMuZmluZFtpXS5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9zID0gY29udGVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzLmZpbmRbaV0ubm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgJiAoYmVmb3JlID8gMiA6IDQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRJblRleHQodGV4dE5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5ub2RlID09IHRleHROb2RlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zIC0gKHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGggLSB0aGlzLmZpbmRbaV0ub2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBjb250ZXh0IHN0cmluZyBtYXRjaGVzIHRoaXMgY29udGV4dC5cbiAgICBtYXRjaGVzQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmluZGV4T2YoXCJ8XCIpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5zcGxpdCgvXFxzKlxcfFxccyovKS5zb21lKHRoaXMubWF0Y2hlc0NvbnRleHQsIHRoaXMpO1xuICAgICAgICBsZXQgcGFydHMgPSBjb250ZXh0LnNwbGl0KFwiL1wiKTtcbiAgICAgICAgbGV0IG9wdGlvbiA9IHRoaXMub3B0aW9ucy5jb250ZXh0O1xuICAgICAgICBsZXQgdXNlUm9vdCA9ICF0aGlzLmlzT3BlbiAmJiAoIW9wdGlvbiB8fCBvcHRpb24ucGFyZW50LnR5cGUgPT0gdGhpcy5ub2Rlc1swXS50eXBlKTtcbiAgICAgICAgbGV0IG1pbkRlcHRoID0gLShvcHRpb24gPyBvcHRpb24uZGVwdGggKyAxIDogMCkgKyAodXNlUm9vdCA/IDAgOiAxKTtcbiAgICAgICAgbGV0IG1hdGNoID0gKGksIGRlcHRoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0ID09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gcGFydHMubGVuZ3RoIC0gMSB8fCBpID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGRlcHRoID49IG1pbkRlcHRoOyBkZXB0aC0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKGkgLSAxLCBkZXB0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gZGVwdGggPiAwIHx8IChkZXB0aCA9PSAwICYmIHVzZVJvb3QpID8gdGhpcy5ub2Rlc1tkZXB0aF0udHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvcHRpb24gJiYgZGVwdGggPj0gbWluRGVwdGggPyBvcHRpb24ubm9kZShkZXB0aCAtIG1pbkRlcHRoKS50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgKG5leHQubmFtZSAhPSBwYXJ0ICYmIG5leHQuZ3JvdXBzLmluZGV4T2YocGFydCkgPT0gLTEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWF0Y2gocGFydHMubGVuZ3RoIC0gMSwgdGhpcy5vcGVuKTtcbiAgICB9XG4gICAgdGV4dGJsb2NrRnJvbUNvbnRleHQoKSB7XG4gICAgICAgIGxldCAkY29udGV4dCA9IHRoaXMub3B0aW9ucy5jb250ZXh0O1xuICAgICAgICBpZiAoJGNvbnRleHQpXG4gICAgICAgICAgICBmb3IgKGxldCBkID0gJGNvbnRleHQuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlZmx0ID0gJGNvbnRleHQubm9kZShkKS5jb250ZW50TWF0Y2hBdCgkY29udGV4dC5pbmRleEFmdGVyKGQpKS5kZWZhdWx0VHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoZGVmbHQgJiYgZGVmbHQuaXNUZXh0YmxvY2sgJiYgZGVmbHQuZGVmYXVsdEF0dHJzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmbHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmIHR5cGUuZGVmYXVsdEF0dHJzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFBlbmRpbmdNYXJrKG1hcmspIHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmluZFNhbWVNYXJrSW5TZXQobWFyaywgdGhpcy50b3AucGVuZGluZ01hcmtzKTtcbiAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgdGhpcy50b3Auc3Rhc2hNYXJrcy5wdXNoKGZvdW5kKTtcbiAgICAgICAgdGhpcy50b3AucGVuZGluZ01hcmtzID0gbWFyay5hZGRUb1NldCh0aGlzLnRvcC5wZW5kaW5nTWFya3MpO1xuICAgIH1cbiAgICByZW1vdmVQZW5kaW5nTWFyayhtYXJrLCB1cHRvKSB7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gdGhpcy5vcGVuOyBkZXB0aCA+PSAwOyBkZXB0aC0tKSB7XG4gICAgICAgICAgICBsZXQgbGV2ZWwgPSB0aGlzLm5vZGVzW2RlcHRoXTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGxldmVsLnBlbmRpbmdNYXJrcy5sYXN0SW5kZXhPZihtYXJrKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwucGVuZGluZ01hcmtzID0gbWFyay5yZW1vdmVGcm9tU2V0KGxldmVsLnBlbmRpbmdNYXJrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5hY3RpdmVNYXJrcyA9IG1hcmsucmVtb3ZlRnJvbVNldChsZXZlbC5hY3RpdmVNYXJrcyk7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXNoTWFyayA9IGxldmVsLnBvcEZyb21TdGFzaE1hcmsobWFyayk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXNoTWFyayAmJiBsZXZlbC50eXBlICYmIGxldmVsLnR5cGUuYWxsb3dzTWFya1R5cGUoc3Rhc2hNYXJrLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICBsZXZlbC5hY3RpdmVNYXJrcyA9IHN0YXNoTWFyay5hZGRUb1NldChsZXZlbC5hY3RpdmVNYXJrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGV2ZWwgPT0gdXB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBkaXJlY3RseSBuZXN0ZWQgbGlzdCBub2RlcyBwcm9kdWNlZCBieSBzb21lXG4vLyB0b29scyBhbmQgYWxsb3dlZCBieSBicm93c2VycyB0byBtZWFuIHRoYXQgdGhlIG5lc3RlZCBsaXN0IGlzXG4vLyBhY3R1YWxseSBwYXJ0IG9mIHRoZSBsaXN0IGl0ZW0gYWJvdmUgaXQuXG5mdW5jdGlvbiBub3JtYWxpemVMaXN0KGRvbSkge1xuICAgIGZvciAobGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQsIHByZXZJdGVtID0gbnVsbDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBjaGlsZC5ub2RlVHlwZSA9PSAxID8gY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XG4gICAgICAgIGlmIChuYW1lICYmIGxpc3RUYWdzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHByZXZJdGVtKSB7XG4gICAgICAgICAgICBwcmV2SXRlbS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICBjaGlsZCA9IHByZXZJdGVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJsaVwiKSB7XG4gICAgICAgICAgICBwcmV2SXRlbSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHByZXZJdGVtID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEFwcGx5IGEgQ1NTIHNlbGVjdG9yLlxuZnVuY3Rpb24gbWF0Y2hlcyhkb20sIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIChkb20ubWF0Y2hlcyB8fCBkb20ubXNNYXRjaGVzU2VsZWN0b3IgfHwgZG9tLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBkb20ubW96TWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGRvbSwgc2VsZWN0b3IpO1xufVxuLy8gVG9rZW5pemUgYSBzdHlsZSBhdHRyaWJ1dGUgaW50byBwcm9wZXJ0eS92YWx1ZSBwYWlycy5cbmZ1bmN0aW9uIHBhcnNlU3R5bGVzKHN0eWxlKSB7XG4gICAgbGV0IHJlID0gL1xccyooW1xcdy1dKylcXHMqOlxccyooW147XSspL2csIG0sIHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChtID0gcmUuZXhlYyhzdHlsZSkpXG4gICAgICAgIHJlc3VsdC5wdXNoKG1bMV0sIG1bMl0udHJpbSgpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29weShvYmopIHtcbiAgICBsZXQgY29weSA9IHt9O1xuICAgIGZvciAobGV0IHByb3AgaW4gb2JqKVxuICAgICAgICBjb3B5W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIHJldHVybiBjb3B5O1xufVxuLy8gVXNlZCB3aGVuIGZpbmRpbmcgYSBtYXJrIGF0IHRoZSB0b3AgbGV2ZWwgb2YgYSBmcmFnbWVudCBwYXJzZS5cbi8vIENoZWNrcyB3aGV0aGVyIGl0IHdvdWxkIGJlIHJlYXNvbmFibGUgdG8gYXBwbHkgYSBnaXZlbiBtYXJrIHR5cGUgdG9cbi8vIGEgZ2l2ZW4gbm9kZSwgYnkgbG9va2luZyBhdCB0aGUgd2F5IHRoZSBtYXJrIG9jY3VycyBpbiB0aGUgc2NoZW1hLlxuZnVuY3Rpb24gbWFya01heUFwcGx5KG1hcmtUeXBlLCBub2RlVHlwZSkge1xuICAgIGxldCBub2RlcyA9IG5vZGVUeXBlLnNjaGVtYS5ub2RlcztcbiAgICBmb3IgKGxldCBuYW1lIGluIG5vZGVzKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSBub2Rlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFwYXJlbnQuYWxsb3dzTWFya1R5cGUobWFya1R5cGUpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBzZWVuID0gW10sIHNjYW4gPSAobWF0Y2gpID0+IHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChtYXRjaCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gbWF0Y2guZWRnZShpKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBub2RlVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihuZXh0KSA8IDAgJiYgc2NhbihuZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzY2FuKHBhcmVudC5jb250ZW50TWF0Y2gpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZFNhbWVNYXJrSW5TZXQobWFyaywgc2V0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG1hcmsuZXEoc2V0W2ldKSlcbiAgICAgICAgICAgIHJldHVybiBzZXRbaV07XG4gICAgfVxufVxuXG4vKipcbkEgRE9NIHNlcmlhbGl6ZXIga25vd3MgaG93IHRvIGNvbnZlcnQgUHJvc2VNaXJyb3Igbm9kZXMgYW5kXG5tYXJrcyBvZiB2YXJpb3VzIHR5cGVzIHRvIERPTSBub2Rlcy5cbiovXG5jbGFzcyBET01TZXJpYWxpemVyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXJpYWxpemVyLiBgbm9kZXNgIHNob3VsZCBtYXAgbm9kZSBuYW1lcyB0byBmdW5jdGlvbnNcbiAgICB0aGF0IHRha2UgYSBub2RlIGFuZCByZXR1cm4gYSBkZXNjcmlwdGlvbiBvZiB0aGUgY29ycmVzcG9uZGluZ1xuICAgIERPTS4gYG1hcmtzYCBkb2VzIHRoZSBzYW1lIGZvciBtYXJrIG5hbWVzLCBidXQgYWxzbyBnZXRzIGFuXG4gICAgYXJndW1lbnQgdGhhdCB0ZWxscyBpdCB3aGV0aGVyIHRoZSBtYXJrJ3MgY29udGVudCBpcyBibG9jayBvclxuICAgIGlubGluZSBjb250ZW50IChmb3IgdHlwaWNhbCB1c2UsIGl0J2xsIGFsd2F5cyBiZSBpbmxpbmUpLiBBIG1hcmtcbiAgICBzZXJpYWxpemVyIG1heSBiZSBgbnVsbGAgdG8gaW5kaWNhdGUgdGhhdCBtYXJrcyBvZiB0aGF0IHR5cGVcbiAgICBzaG91bGQgbm90IGJlIHNlcmlhbGl6ZWQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbm9kZSBzZXJpYWxpemF0aW9uIGZ1bmN0aW9ucy5cbiAgICAqL1xuICAgIG5vZGVzLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayBzZXJpYWxpemF0aW9uIGZ1bmN0aW9ucy5cbiAgICAqL1xuICAgIG1hcmtzKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhlIGNvbnRlbnQgb2YgdGhpcyBmcmFnbWVudCB0byBhIERPTSBmcmFnbWVudC4gV2hlblxuICAgIG5vdCBpbiB0aGUgYnJvd3NlciwgdGhlIGBkb2N1bWVudGAgb3B0aW9uLCBjb250YWluaW5nIGEgRE9NXG4gICAgZG9jdW1lbnQsIHNob3VsZCBiZSBwYXNzZWQgc28gdGhhdCB0aGUgc2VyaWFsaXplciBjYW4gY3JlYXRlXG4gICAgbm9kZXMuXG4gICAgKi9cbiAgICBzZXJpYWxpemVGcmFnbWVudChmcmFnbWVudCwgb3B0aW9ucyA9IHt9LCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICB0YXJnZXQgPSBkb2Mob3B0aW9ucykuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBsZXQgdG9wID0gdGFyZ2V0LCBhY3RpdmUgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIGlmIChhY3RpdmUubGVuZ3RoIHx8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtlZXAgPSAwLCByZW5kZXJlZCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGtlZXAgPCBhY3RpdmUubGVuZ3RoICYmIHJlbmRlcmVkIDwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlLm1hcmtzW3JlbmRlcmVkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hcmtzW25leHQudHlwZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dC5lcShhY3RpdmVba2VlcF1bMF0pIHx8IG5leHQudHlwZS5zcGVjLnNwYW5uaW5nID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBrZWVwKys7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChrZWVwIDwgYWN0aXZlLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gYWN0aXZlLnBvcCgpWzFdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZW5kZXJlZCA8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZGQgPSBub2RlLm1hcmtzW3JlbmRlcmVkKytdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWFya0RPTSA9IHRoaXMuc2VyaWFsaXplTWFyayhhZGQsIG5vZGUuaXNJbmxpbmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFya0RPTSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlLnB1c2goW2FkZCwgdG9wXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuYXBwZW5kQ2hpbGQobWFya0RPTS5kb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gbWFya0RPTS5jb250ZW50RE9NIHx8IG1hcmtET00uZG9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9wLmFwcGVuZENoaWxkKHRoaXMuc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHsgZG9tLCBjb250ZW50RE9NIH0gPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jKG9wdGlvbnMpLCB0aGlzLm5vZGVzW25vZGUudHlwZS5uYW1lXShub2RlKSk7XG4gICAgICAgIGlmIChjb250ZW50RE9NKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDb250ZW50IGhvbGUgbm90IGFsbG93ZWQgaW4gYSBsZWFmIG5vZGUgc3BlY1wiKTtcbiAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplRnJhZ21lbnQobm9kZS5jb250ZW50LCBvcHRpb25zLCBjb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBub2RlIHRvIGEgRE9NIG5vZGUuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdVxuICAgIG5lZWQgdG8gc2VyaWFsaXplIGEgcGFydCBvZiBhIGRvY3VtZW50LCBhcyBvcHBvc2VkIHRvIHRoZSB3aG9sZVxuICAgIGRvY3VtZW50LiBUbyBzZXJpYWxpemUgYSB3aG9sZSBkb2N1bWVudCwgdXNlXG4gICAgW2BzZXJpYWxpemVGcmFnbWVudGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5ET01TZXJpYWxpemVyLnNlcmlhbGl6ZUZyYWdtZW50KSBvblxuICAgIGl0cyBbY29udGVudF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUuY29udGVudCkuXG4gICAgKi9cbiAgICBzZXJpYWxpemVOb2RlKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgZG9tID0gdGhpcy5zZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucyk7XG4gICAgICAgIGZvciAobGV0IGkgPSBub2RlLm1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgd3JhcCA9IHRoaXMuc2VyaWFsaXplTWFyayhub2RlLm1hcmtzW2ldLCBub2RlLmlzSW5saW5lLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICh3cmFwKSB7XG4gICAgICAgICAgICAgICAgKHdyYXAuY29udGVudERPTSB8fCB3cmFwLmRvbSkuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgICAgICBkb20gPSB3cmFwLmRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNlcmlhbGl6ZU1hcmsobWFyaywgaW5saW5lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHRvRE9NID0gdGhpcy5tYXJrc1ttYXJrLnR5cGUubmFtZV07XG4gICAgICAgIHJldHVybiB0b0RPTSAmJiBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jKG9wdGlvbnMpLCB0b0RPTShtYXJrLCBpbmxpbmUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVuZGVyIGFuIFtvdXRwdXQgc3BlY10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkRPTU91dHB1dFNwZWMpIHRvIGEgRE9NIG5vZGUuIElmXG4gICAgdGhlIHNwZWMgaGFzIGEgaG9sZSAoemVybykgaW4gaXQsIGBjb250ZW50RE9NYCB3aWxsIHBvaW50IGF0IHRoZVxuICAgIG5vZGUgd2l0aCB0aGUgaG9sZS5cbiAgICAqL1xuICAgIHN0YXRpYyByZW5kZXJTcGVjKGRvYywgc3RydWN0dXJlLCB4bWxOUyA9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJ1Y3R1cmUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiB7IGRvbTogZG9jLmNyZWF0ZVRleHROb2RlKHN0cnVjdHVyZSkgfTtcbiAgICAgICAgaWYgKHN0cnVjdHVyZS5ub2RlVHlwZSAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHsgZG9tOiBzdHJ1Y3R1cmUgfTtcbiAgICAgICAgaWYgKHN0cnVjdHVyZS5kb20gJiYgc3RydWN0dXJlLmRvbS5ub2RlVHlwZSAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdHVyZTtcbiAgICAgICAgbGV0IHRhZ05hbWUgPSBzdHJ1Y3R1cmVbMF0sIHNwYWNlID0gdGFnTmFtZS5pbmRleE9mKFwiIFwiKTtcbiAgICAgICAgaWYgKHNwYWNlID4gMCkge1xuICAgICAgICAgICAgeG1sTlMgPSB0YWdOYW1lLnNsaWNlKDAsIHNwYWNlKTtcbiAgICAgICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnNsaWNlKHNwYWNlICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnRET007XG4gICAgICAgIGxldCBkb20gPSAoeG1sTlMgPyBkb2MuY3JlYXRlRWxlbWVudE5TKHhtbE5TLCB0YWdOYW1lKSA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZ05hbWUpKTtcbiAgICAgICAgbGV0IGF0dHJzID0gc3RydWN0dXJlWzFdLCBzdGFydCA9IDE7XG4gICAgICAgIGlmIChhdHRycyAmJiB0eXBlb2YgYXR0cnMgPT0gXCJvYmplY3RcIiAmJiBhdHRycy5ub2RlVHlwZSA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuICAgICAgICAgICAgc3RhcnQgPSAyO1xuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycylcbiAgICAgICAgICAgICAgICBpZiAoYXR0cnNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2UgPSBuYW1lLmluZGV4T2YoXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BhY2UgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZU5TKG5hbWUuc2xpY2UoMCwgc3BhY2UpLCBuYW1lLnNsaWNlKHNwYWNlICsgMSksIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0cnVjdHVyZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gc3RydWN0dXJlW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBzdHJ1Y3R1cmUubGVuZ3RoIC0gMSB8fCBpID4gc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ29udGVudCBob2xlIG11c3QgYmUgdGhlIG9ubHkgY2hpbGQgb2YgaXRzIHBhcmVudCBub2RlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbSwgY29udGVudERPTTogZG9tIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBkb206IGlubmVyLCBjb250ZW50RE9NOiBpbm5lckNvbnRlbnQgfSA9IERPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2MsIGNoaWxkLCB4bWxOUyk7XG4gICAgICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKGlubmVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNdWx0aXBsZSBjb250ZW50IGhvbGVzXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gaW5uZXJDb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb20sIGNvbnRlbnRET00gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSBzZXJpYWxpemVyIHVzaW5nIHRoZSBbYHRvRE9NYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLnRvRE9NKVxuICAgIHByb3BlcnRpZXMgaW4gYSBzY2hlbWEncyBub2RlIGFuZCBtYXJrIHNwZWNzLlxuICAgICovXG4gICAgc3RhdGljIGZyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuY2FjaGVkLmRvbVNlcmlhbGl6ZXIgfHxcbiAgICAgICAgICAgIChzY2hlbWEuY2FjaGVkLmRvbVNlcmlhbGl6ZXIgPSBuZXcgRE9NU2VyaWFsaXplcih0aGlzLm5vZGVzRnJvbVNjaGVtYShzY2hlbWEpLCB0aGlzLm1hcmtzRnJvbVNjaGVtYShzY2hlbWEpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdhdGhlciB0aGUgc2VyaWFsaXplcnMgaW4gYSBzY2hlbWEncyBub2RlIHNwZWNzIGludG8gYW4gb2JqZWN0LlxuICAgIFRoaXMgY2FuIGJlIHVzZWZ1bCBhcyBhIGJhc2UgdG8gYnVpbGQgYSBjdXN0b20gc2VyaWFsaXplciBmcm9tLlxuICAgICovXG4gICAgc3RhdGljIG5vZGVzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGdhdGhlclRvRE9NKHNjaGVtYS5ub2Rlcyk7XG4gICAgICAgIGlmICghcmVzdWx0LnRleHQpXG4gICAgICAgICAgICByZXN1bHQudGV4dCA9IG5vZGUgPT4gbm9kZS50ZXh0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBHYXRoZXIgdGhlIHNlcmlhbGl6ZXJzIGluIGEgc2NoZW1hJ3MgbWFyayBzcGVjcyBpbnRvIGFuIG9iamVjdC5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXJrc0Zyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBnYXRoZXJUb0RPTShzY2hlbWEubWFya3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdhdGhlclRvRE9NKG9iaikge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBuYW1lIGluIG9iaikge1xuICAgICAgICBsZXQgdG9ET00gPSBvYmpbbmFtZV0uc3BlYy50b0RPTTtcbiAgICAgICAgaWYgKHRvRE9NKVxuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gdG9ET007XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBkb2Mob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudDtcbn1cblxuZXhwb3J0IHsgQ29udGVudE1hdGNoLCBET01QYXJzZXIsIERPTVNlcmlhbGl6ZXIsIEZyYWdtZW50LCBNYXJrLCBNYXJrVHlwZSwgTm9kZSwgTm9kZVJhbmdlLCBOb2RlVHlwZSwgUmVwbGFjZUVycm9yLCBSZXNvbHZlZFBvcywgU2NoZW1hLCBTbGljZSB9O1xuIiwgImltcG9ydCB7IFJlcGxhY2VFcnJvciwgU2xpY2UsIEZyYWdtZW50LCBNYXJrVHlwZSwgTWFyayB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcblxuLy8gUmVjb3ZlcnkgdmFsdWVzIGVuY29kZSBhIHJhbmdlIGluZGV4IGFuZCBhbiBvZmZzZXQuIFRoZXkgYXJlXG4vLyByZXByZXNlbnRlZCBhcyBudW1iZXJzLCBiZWNhdXNlIHRvbnMgb2YgdGhlbSB3aWxsIGJlIGNyZWF0ZWQgd2hlblxuLy8gbWFwcGluZywgZm9yIGV4YW1wbGUsIGEgbGFyZ2UgbnVtYmVyIG9mIGRlY29yYXRpb25zLiBUaGUgbnVtYmVyJ3Ncbi8vIGxvd2VyIDE2IGJpdHMgcHJvdmlkZSB0aGUgaW5kZXgsIHRoZSByZW1haW5pbmcgYml0cyB0aGUgb2Zmc2V0LlxuLy9cbi8vIE5vdGU6IFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGJpdCBzaGlmdCBvcGVyYXRvcnMgdG8gZW4tIGFuZFxuLy8gZGVjb2RlIHRoZXNlLCBzaW5jZSB0aG9zZSBjbGlwIHRvIDMyIGJpdHMsIHdoaWNoIHdlIG1pZ2h0IGluIHJhcmVcbi8vIGNhc2VzIHdhbnQgdG8gb3ZlcmZsb3cuIEEgNjQtYml0IGZsb2F0IGNhbiByZXByZXNlbnQgNDgtYml0XG4vLyBpbnRlZ2VycyBwcmVjaXNlbHkuXG5jb25zdCBsb3dlcjE2ID0gMHhmZmZmO1xuY29uc3QgZmFjdG9yMTYgPSBNYXRoLnBvdygyLCAxNik7XG5mdW5jdGlvbiBtYWtlUmVjb3ZlcihpbmRleCwgb2Zmc2V0KSB7IHJldHVybiBpbmRleCArIG9mZnNldCAqIGZhY3RvcjE2OyB9XG5mdW5jdGlvbiByZWNvdmVySW5kZXgodmFsdWUpIHsgcmV0dXJuIHZhbHVlICYgbG93ZXIxNjsgfVxuZnVuY3Rpb24gcmVjb3Zlck9mZnNldCh2YWx1ZSkgeyByZXR1cm4gKHZhbHVlIC0gKHZhbHVlICYgbG93ZXIxNikpIC8gZmFjdG9yMTY7IH1cbmNvbnN0IERFTF9CRUZPUkUgPSAxLCBERUxfQUZURVIgPSAyLCBERUxfQUNST1NTID0gNCwgREVMX1NJREUgPSA4O1xuLyoqXG5BbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgbWFwcGVkIHBvc2l0aW9uIHdpdGggZXh0cmFcbmluZm9ybWF0aW9uLlxuKi9cbmNsYXNzIE1hcFJlc3VsdCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbWFwcGVkIHZlcnNpb24gb2YgdGhlIHBvc2l0aW9uLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRlbEluZm8sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVjb3Zlcikge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5kZWxJbmZvID0gZGVsSW5mbztcbiAgICAgICAgdGhpcy5yZWNvdmVyID0gcmVjb3ZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIHBvc2l0aW9uIHdhcyBkZWxldGVkLCB0aGF0IGlzLCB3aGV0aGVyIHRoZVxuICAgIHN0ZXAgcmVtb3ZlZCB0aGUgdG9rZW4gb24gdGhlIHNpZGUgcXVlcmllZCAodmlhIHRoZSBgYXNzb2NgKVxuICAgIGFyZ3VtZW50IGZyb20gdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWQoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgREVMX1NJREUpID4gMDsgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoZSB0b2tlbiBiZWZvcmUgdGhlIG1hcHBlZCBwb3NpdGlvbiB3YXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIGdldCBkZWxldGVkQmVmb3JlKCkgeyByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIChERUxfQkVGT1JFIHwgREVMX0FDUk9TUykpID4gMDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGUgdG9rZW4gYWZ0ZXIgdGhlIG1hcHBlZCBwb3NpdGlvbiB3YXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIGdldCBkZWxldGVkQWZ0ZXIoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgKERFTF9BRlRFUiB8IERFTF9BQ1JPU1MpKSA+IDA7IH1cbiAgICAvKipcbiAgICBUZWxscyB3aGV0aGVyIGFueSBvZiB0aGUgc3RlcHMgbWFwcGVkIHRocm91Z2ggZGVsZXRlcyBhY3Jvc3MgdGhlXG4gICAgcG9zaXRpb24gKGluY2x1ZGluZyBib3RoIHRoZSB0b2tlbiBiZWZvcmUgYW5kIGFmdGVyIHRoZVxuICAgIHBvc2l0aW9uKS5cbiAgICAqL1xuICAgIGdldCBkZWxldGVkQWNyb3NzKCkgeyByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIERFTF9BQ1JPU1MpID4gMDsgfVxufVxuLyoqXG5BIG1hcCBkZXNjcmliaW5nIHRoZSBkZWxldGlvbnMgYW5kIGluc2VydGlvbnMgbWFkZSBieSBhIHN0ZXAsIHdoaWNoXG5jYW4gYmUgdXNlZCB0byBmaW5kIHRoZSBjb3JyZXNwb25kZW5jZSBiZXR3ZWVuIHBvc2l0aW9ucyBpbiB0aGVcbnByZS1zdGVwIHZlcnNpb24gb2YgYSBkb2N1bWVudCBhbmQgdGhlIHNhbWUgcG9zaXRpb24gaW4gdGhlXG5wb3N0LXN0ZXAgdmVyc2lvbi5cbiovXG5jbGFzcyBTdGVwTWFwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBwb3NpdGlvbiBtYXAuIFRoZSBtb2RpZmljYXRpb25zIHRvIHRoZSBkb2N1bWVudCBhcmVcbiAgICByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBudW1iZXJzLCBpbiB3aGljaCBlYWNoIGdyb3VwIG9mIHRocmVlXG4gICAgcmVwcmVzZW50cyBhIG1vZGlmaWVkIGNodW5rIGFzIGBbc3RhcnQsIG9sZFNpemUsIG5ld1NpemVdYC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmFuZ2VzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGludmVydGVkID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuaW52ZXJ0ZWQgPSBpbnZlcnRlZDtcbiAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoICYmIFN0ZXBNYXAuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gU3RlcE1hcC5lbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyKHZhbHVlKSB7XG4gICAgICAgIGxldCBkaWZmID0gMCwgaW5kZXggPSByZWNvdmVySW5kZXgodmFsdWUpO1xuICAgICAgICBpZiAoIXRoaXMuaW52ZXJ0ZWQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspXG4gICAgICAgICAgICAgICAgZGlmZiArPSB0aGlzLnJhbmdlc1tpICogMyArIDJdIC0gdGhpcy5yYW5nZXNbaSAqIDMgKyAxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzW2luZGV4ICogM10gKyBkaWZmICsgcmVjb3Zlck9mZnNldCh2YWx1ZSk7XG4gICAgfVxuICAgIG1hcFJlc3VsdChwb3MsIGFzc29jID0gMSkgeyByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIGZhbHNlKTsgfVxuICAgIG1hcChwb3MsIGFzc29jID0gMSkgeyByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBfbWFwKHBvcywgYXNzb2MsIHNpbXBsZSkge1xuICAgICAgICBsZXQgZGlmZiA9IDAsIG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0gLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgbmV3U2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF0sIGVuZCA9IHN0YXJ0ICsgb2xkU2l6ZTtcbiAgICAgICAgICAgIGlmIChwb3MgPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNpZGUgPSAhb2xkU2l6ZSA/IGFzc29jIDogcG9zID09IHN0YXJ0ID8gLTEgOiBwb3MgPT0gZW5kID8gMSA6IGFzc29jO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBzdGFydCArIGRpZmYgKyAoc2lkZSA8IDAgPyAwIDogbmV3U2l6ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpbXBsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICBsZXQgcmVjb3ZlciA9IHBvcyA9PSAoYXNzb2MgPCAwID8gc3RhcnQgOiBlbmQpID8gbnVsbCA6IG1ha2VSZWNvdmVyKGkgLyAzLCBwb3MgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgbGV0IGRlbCA9IHBvcyA9PSBzdGFydCA/IERFTF9BRlRFUiA6IHBvcyA9PSBlbmQgPyBERUxfQkVGT1JFIDogREVMX0FDUk9TUztcbiAgICAgICAgICAgICAgICBpZiAoYXNzb2MgPCAwID8gcG9zICE9IHN0YXJ0IDogcG9zICE9IGVuZClcbiAgICAgICAgICAgICAgICAgICAgZGVsIHw9IERFTF9TSURFO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWFwUmVzdWx0KHJlc3VsdCwgZGVsLCByZWNvdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpZmYgKz0gbmV3U2l6ZSAtIG9sZFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbXBsZSA/IHBvcyArIGRpZmYgOiBuZXcgTWFwUmVzdWx0KHBvcyArIGRpZmYsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvdWNoZXMocG9zLCByZWNvdmVyKSB7XG4gICAgICAgIGxldCBkaWZmID0gMCwgaW5kZXggPSByZWNvdmVySW5kZXgocmVjb3Zlcik7XG4gICAgICAgIGxldCBvbGRJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAyIDogMSwgbmV3SW5kZXggPSB0aGlzLmludmVydGVkID8gMSA6IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzW2ldIC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgb2xkU2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBvbGRJbmRleF0sIGVuZCA9IHN0YXJ0ICsgb2xkU2l6ZTtcbiAgICAgICAgICAgIGlmIChwb3MgPD0gZW5kICYmIGkgPT0gaW5kZXggKiAzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZGlmZiArPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGxzIHRoZSBnaXZlbiBmdW5jdGlvbiBvbiBlYWNoIG9mIHRoZSBjaGFuZ2VkIHJhbmdlcyBpbmNsdWRlZCBpblxuICAgIHRoaXMgbWFwLlxuICAgICovXG4gICAgZm9yRWFjaChmKSB7XG4gICAgICAgIGxldCBvbGRJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAyIDogMSwgbmV3SW5kZXggPSB0aGlzLmludmVydGVkID8gMSA6IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBkaWZmID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1tpXSwgb2xkU3RhcnQgPSBzdGFydCAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApLCBuZXdTdGFydCA9IHN0YXJ0ICsgKHRoaXMuaW52ZXJ0ZWQgPyAwIDogZGlmZik7XG4gICAgICAgICAgICBsZXQgb2xkU2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBvbGRJbmRleF0sIG5ld1NpemUgPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdO1xuICAgICAgICAgICAgZihvbGRTdGFydCwgb2xkU3RhcnQgKyBvbGRTaXplLCBuZXdTdGFydCwgbmV3U3RhcnQgKyBuZXdTaXplKTtcbiAgICAgICAgICAgIGRpZmYgKz0gbmV3U2l6ZSAtIG9sZFNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGludmVydGVkIHZlcnNpb24gb2YgdGhpcyBtYXAuIFRoZSByZXN1bHQgY2FuIGJlIHVzZWQgdG9cbiAgICBtYXAgcG9zaXRpb25zIGluIHRoZSBwb3N0LXN0ZXAgZG9jdW1lbnQgdG8gdGhlIHByZS1zdGVwIGRvY3VtZW50LlxuICAgICovXG4gICAgaW52ZXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0ZXBNYXAodGhpcy5yYW5nZXMsICF0aGlzLmludmVydGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmludmVydGVkID8gXCItXCIgOiBcIlwiKSArIEpTT04uc3RyaW5naWZ5KHRoaXMucmFuZ2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFwIHRoYXQgbW92ZXMgYWxsIHBvc2l0aW9ucyBieSBvZmZzZXQgYG5gICh3aGljaCBtYXkgYmVcbiAgICBuZWdhdGl2ZSkuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIGFwcGx5aW5nIHN0ZXBzIG1lYW50IGZvciBhXG4gICAgc3ViLWRvY3VtZW50IHRvIGEgbGFyZ2VyIGRvY3VtZW50LCBvciB2aWNlLXZlcnNhLlxuICAgICovXG4gICAgc3RhdGljIG9mZnNldChuKSB7XG4gICAgICAgIHJldHVybiBuID09IDAgPyBTdGVwTWFwLmVtcHR5IDogbmV3IFN0ZXBNYXAobiA8IDAgPyBbMCwgLW4sIDBdIDogWzAsIDAsIG5dKTtcbiAgICB9XG59XG4vKipcbkEgU3RlcE1hcCB0aGF0IGNvbnRhaW5zIG5vIGNoYW5nZWQgcmFuZ2VzLlxuKi9cblN0ZXBNYXAuZW1wdHkgPSBuZXcgU3RlcE1hcChbXSk7XG4vKipcbkEgbWFwcGluZyByZXByZXNlbnRzIGEgcGlwZWxpbmUgb2YgemVybyBvciBtb3JlIFtzdGVwXG5tYXBzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXBNYXApLiBJdCBoYXMgc3BlY2lhbCBwcm92aXNpb25zIGZvciBsb3NzbGVzc2x5XG5oYW5kbGluZyBtYXBwaW5nIHBvc2l0aW9ucyB0aHJvdWdoIGEgc2VyaWVzIG9mIHN0ZXBzIGluIHdoaWNoIHNvbWVcbnN0ZXBzIGFyZSBpbnZlcnRlZCB2ZXJzaW9ucyBvZiBlYXJsaWVyIHN0ZXBzLiAoVGhpcyBjb21lcyB1cCB3aGVuXG5cdTIwMThbcmViYXNpbmddKC9kb2NzL2d1aWRlLyN0cmFuc2Zvcm0ucmViYXNpbmcpXHUyMDE5IHN0ZXBzIGZvclxuY29sbGFib3JhdGlvbiBvciBoaXN0b3J5IG1hbmFnZW1lbnQuKVxuKi9cbmNsYXNzIE1hcHBpbmcge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBtYXBwaW5nIHdpdGggdGhlIGdpdmVuIHBvc2l0aW9uIG1hcHMuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RlcCBtYXBzIGluIHRoaXMgbWFwcGluZy5cbiAgICAqL1xuICAgIG1hcHMgPSBbXSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtaXJyb3IsIFxuICAgIC8qKlxuICAgIFRoZSBzdGFydGluZyBwb3NpdGlvbiBpbiB0aGUgYG1hcHNgIGFycmF5LCB1c2VkIHdoZW4gYG1hcGAgb3JcbiAgICBgbWFwUmVzdWx0YCBpcyBjYWxsZWQuXG4gICAgKi9cbiAgICBmcm9tID0gMCwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBwb3NpdGlvbiBpbiB0aGUgYG1hcHNgIGFycmF5LlxuICAgICovXG4gICAgdG8gPSBtYXBzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLm1hcHMgPSBtYXBzO1xuICAgICAgICB0aGlzLm1pcnJvciA9IG1pcnJvcjtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXBwaW5nIHRoYXQgbWFwcyBvbmx5IHRocm91Z2ggYSBwYXJ0IG9mIHRoaXMgb25lLlxuICAgICovXG4gICAgc2xpY2UoZnJvbSA9IDAsIHRvID0gdGhpcy5tYXBzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IE1hcHBpbmcodGhpcy5tYXBzLCB0aGlzLm1pcnJvciwgZnJvbSwgdG8pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwcGluZyh0aGlzLm1hcHMuc2xpY2UoKSwgdGhpcy5taXJyb3IgJiYgdGhpcy5taXJyb3Iuc2xpY2UoKSwgdGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgc3RlcCBtYXAgdG8gdGhlIGVuZCBvZiB0aGlzIG1hcHBpbmcuIElmIGBtaXJyb3JzYCBpc1xuICAgIGdpdmVuLCBpdCBzaG91bGQgYmUgdGhlIGluZGV4IG9mIHRoZSBzdGVwIG1hcCB0aGF0IGlzIHRoZSBtaXJyb3JcbiAgICBpbWFnZSBvZiB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZE1hcChtYXAsIG1pcnJvcnMpIHtcbiAgICAgICAgdGhpcy50byA9IHRoaXMubWFwcy5wdXNoKG1hcCk7XG4gICAgICAgIGlmIChtaXJyb3JzICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLnNldE1pcnJvcih0aGlzLm1hcHMubGVuZ3RoIC0gMSwgbWlycm9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhbGwgdGhlIHN0ZXAgbWFwcyBpbiBhIGdpdmVuIG1hcHBpbmcgdG8gdGhpcyBvbmUgKHByZXNlcnZpbmdcbiAgICBtaXJyb3JpbmcgaW5mb3JtYXRpb24pLlxuICAgICovXG4gICAgYXBwZW5kTWFwcGluZyhtYXBwaW5nKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBzdGFydFNpemUgPSB0aGlzLm1hcHMubGVuZ3RoOyBpIDwgbWFwcGluZy5tYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWlyciA9IG1hcHBpbmcuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRNYXAobWFwcGluZy5tYXBzW2ldLCBtaXJyICE9IG51bGwgJiYgbWlyciA8IGkgPyBzdGFydFNpemUgKyBtaXJyIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kcyB0aGUgb2Zmc2V0IG9mIHRoZSBzdGVwIG1hcCB0aGF0IG1pcnJvcnMgdGhlIG1hcCBhdCB0aGVcbiAgICBnaXZlbiBvZmZzZXQsIGluIHRoaXMgbWFwcGluZyAoYXMgcGVyIHRoZSBzZWNvbmQgYXJndW1lbnQgdG9cbiAgICBgYXBwZW5kTWFwYCkuXG4gICAgKi9cbiAgICBnZXRNaXJyb3Iobikge1xuICAgICAgICBpZiAodGhpcy5taXJyb3IpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWlycm9yLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pcnJvcltpXSA9PSBuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5taXJyb3JbaSArIChpICUgMiA/IC0xIDogMSldO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNldE1pcnJvcihuLCBtKSB7XG4gICAgICAgIGlmICghdGhpcy5taXJyb3IpXG4gICAgICAgICAgICB0aGlzLm1pcnJvciA9IFtdO1xuICAgICAgICB0aGlzLm1pcnJvci5wdXNoKG4sIG0pO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBlbmQgdGhlIGludmVyc2Ugb2YgdGhlIGdpdmVuIG1hcHBpbmcgdG8gdGhpcyBvbmUuXG4gICAgKi9cbiAgICBhcHBlbmRNYXBwaW5nSW52ZXJ0ZWQobWFwcGluZykge1xuICAgICAgICBmb3IgKGxldCBpID0gbWFwcGluZy5tYXBzLmxlbmd0aCAtIDEsIHRvdGFsU2l6ZSA9IHRoaXMubWFwcy5sZW5ndGggKyBtYXBwaW5nLm1hcHMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IG1pcnIgPSBtYXBwaW5nLmdldE1pcnJvcihpKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kTWFwKG1hcHBpbmcubWFwc1tpXS5pbnZlcnQoKSwgbWlyciAhPSBudWxsICYmIG1pcnIgPiBpID8gdG90YWxTaXplIC0gbWlyciAtIDEgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnZlcnRlZCB2ZXJzaW9uIG9mIHRoaXMgbWFwcGluZy5cbiAgICAqL1xuICAgIGludmVydCgpIHtcbiAgICAgICAgbGV0IGludmVyc2UgPSBuZXcgTWFwcGluZztcbiAgICAgICAgaW52ZXJzZS5hcHBlbmRNYXBwaW5nSW52ZXJ0ZWQodGhpcyk7XG4gICAgICAgIHJldHVybiBpbnZlcnNlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBwb3NpdGlvbiB0aHJvdWdoIHRoaXMgbWFwcGluZy5cbiAgICAqL1xuICAgIG1hcChwb3MsIGFzc29jID0gMSkge1xuICAgICAgICBpZiAodGhpcy5taXJyb3IpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIHRydWUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcm9tOyBpIDwgdGhpcy50bzsgaSsrKVxuICAgICAgICAgICAgcG9zID0gdGhpcy5tYXBzW2ldLm1hcChwb3MsIGFzc29jKTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIGEgcG9zaXRpb24gdGhyb3VnaCB0aGlzIG1hcHBpbmcsIHJldHVybmluZyBhIG1hcHBpbmdcbiAgICByZXN1bHQuXG4gICAgKi9cbiAgICBtYXBSZXN1bHQocG9zLCBhc3NvYyA9IDEpIHsgcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCBmYWxzZSk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIF9tYXAocG9zLCBhc3NvYywgc2ltcGxlKSB7XG4gICAgICAgIGxldCBkZWxJbmZvID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZnJvbTsgaSA8IHRoaXMudG87IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcCA9IHRoaXMubWFwc1tpXSwgcmVzdWx0ID0gbWFwLm1hcFJlc3VsdChwb3MsIGFzc29jKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvcnIgPSB0aGlzLmdldE1pcnJvcihpKTtcbiAgICAgICAgICAgICAgICBpZiAoY29yciAhPSBudWxsICYmIGNvcnIgPiBpICYmIGNvcnIgPCB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBjb3JyO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB0aGlzLm1hcHNbY29ycl0ucmVjb3ZlcihyZXN1bHQucmVjb3Zlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbEluZm8gfD0gcmVzdWx0LmRlbEluZm87XG4gICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW1wbGUgPyBwb3MgOiBuZXcgTWFwUmVzdWx0KHBvcywgZGVsSW5mbywgbnVsbCk7XG4gICAgfVxufVxuXG5jb25zdCBzdGVwc0J5SUQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5BIHN0ZXAgb2JqZWN0IHJlcHJlc2VudHMgYW4gYXRvbWljIGNoYW5nZS4gSXQgZ2VuZXJhbGx5IGFwcGxpZXNcbm9ubHkgdG8gdGhlIGRvY3VtZW50IGl0IHdhcyBjcmVhdGVkIGZvciwgc2luY2UgdGhlIHBvc2l0aW9uc1xuc3RvcmVkIGluIGl0IHdpbGwgb25seSBtYWtlIHNlbnNlIGZvciB0aGF0IGRvY3VtZW50LlxuXG5OZXcgc3RlcHMgYXJlIGRlZmluZWQgYnkgY3JlYXRpbmcgY2xhc3NlcyB0aGF0IGV4dGVuZCBgU3RlcGAsXG5vdmVycmlkaW5nIHRoZSBgYXBwbHlgLCBgaW52ZXJ0YCwgYG1hcGAsIGBnZXRNYXBgIGFuZCBgZnJvbUpTT05gXG5tZXRob2RzLCBhbmQgcmVnaXN0ZXJpbmcgeW91ciBjbGFzcyB3aXRoIGEgdW5pcXVlXG5KU09OLXNlcmlhbGl6YXRpb24gaWRlbnRpZmllciB1c2luZ1xuW2BTdGVwLmpzb25JRGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcF5qc29uSUQpLlxuKi9cbmNsYXNzIFN0ZXAge1xuICAgIC8qKlxuICAgIEdldCB0aGUgc3RlcCBtYXAgdGhhdCByZXByZXNlbnRzIHRoZSBjaGFuZ2VzIG1hZGUgYnkgdGhpcyBzdGVwLFxuICAgIGFuZCB3aGljaCBjYW4gYmUgdXNlZCB0byB0cmFuc2Zvcm0gYmV0d2VlbiBwb3NpdGlvbnMgaW4gdGhlIG9sZFxuICAgIGFuZCB0aGUgbmV3IGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0TWFwKCkgeyByZXR1cm4gU3RlcE1hcC5lbXB0eTsgfVxuICAgIC8qKlxuICAgIFRyeSB0byBtZXJnZSB0aGlzIHN0ZXAgd2l0aCBhbm90aGVyIG9uZSwgdG8gYmUgYXBwbGllZCBkaXJlY3RseVxuICAgIGFmdGVyIGl0LiBSZXR1cm5zIHRoZSBtZXJnZWQgc3RlcCB3aGVuIHBvc3NpYmxlLCBudWxsIGlmIHRoZVxuICAgIHN0ZXBzIGNhbid0IGJlIG1lcmdlZC5cbiAgICAqL1xuICAgIG1lcmdlKG90aGVyKSB7IHJldHVybiBudWxsOyB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBzdGVwIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFdpbGwgY2FsbFxuICAgIHRocm91Z2ggdG8gdGhlIHN0ZXAgY2xhc3MnIG93biBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8ICFqc29uLnN0ZXBUeXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgdHlwZSA9IHN0ZXBzQnlJRFtqc29uLnN0ZXBUeXBlXTtcbiAgICAgICAgaWYgKCF0eXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE5vIHN0ZXAgdHlwZSAke2pzb24uc3RlcFR5cGV9IGRlZmluZWRgKTtcbiAgICAgICAgcmV0dXJuIHR5cGUuZnJvbUpTT04oc2NoZW1hLCBqc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVG8gYmUgYWJsZSB0byBzZXJpYWxpemUgc3RlcHMgdG8gSlNPTiwgZWFjaCBzdGVwIG5lZWRzIGEgc3RyaW5nXG4gICAgSUQgdG8gYXR0YWNoIHRvIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBVc2UgdGhpcyBtZXRob2QgdG9cbiAgICByZWdpc3RlciBhbiBJRCBmb3IgeW91ciBzdGVwIGNsYXNzZXMuIFRyeSB0byBwaWNrIHNvbWV0aGluZ1xuICAgIHRoYXQncyB1bmxpa2VseSB0byBjbGFzaCB3aXRoIHN0ZXBzIGZyb20gb3RoZXIgbW9kdWxlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBqc29uSUQoaWQsIHN0ZXBDbGFzcykge1xuICAgICAgICBpZiAoaWQgaW4gc3RlcHNCeUlEKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEdXBsaWNhdGUgdXNlIG9mIHN0ZXAgSlNPTiBJRCBcIiArIGlkKTtcbiAgICAgICAgc3RlcHNCeUlEW2lkXSA9IHN0ZXBDbGFzcztcbiAgICAgICAgc3RlcENsYXNzLnByb3RvdHlwZS5qc29uSUQgPSBpZDtcbiAgICAgICAgcmV0dXJuIHN0ZXBDbGFzcztcbiAgICB9XG59XG4vKipcblRoZSByZXN1bHQgb2YgW2FwcGx5aW5nXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXAuYXBwbHkpIGEgc3RlcC4gQ29udGFpbnMgZWl0aGVyIGFcbm5ldyBkb2N1bWVudCBvciBhIGZhaWx1cmUgdmFsdWUuXG4qL1xuY2xhc3MgU3RlcFJlc3VsdCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHJhbnNmb3JtZWQgZG9jdW1lbnQsIGlmIHN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBkb2MsIFxuICAgIC8qKlxuICAgIFRoZSBmYWlsdXJlIG1lc3NhZ2UsIGlmIHVuc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIGZhaWxlZCkge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5mYWlsZWQgPSBmYWlsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHN1Y2Nlc3NmdWwgc3RlcCByZXN1bHQuXG4gICAgKi9cbiAgICBzdGF0aWMgb2soZG9jKSB7IHJldHVybiBuZXcgU3RlcFJlc3VsdChkb2MsIG51bGwpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZmFpbGVkIHN0ZXAgcmVzdWx0LlxuICAgICovXG4gICAgc3RhdGljIGZhaWwobWVzc2FnZSkgeyByZXR1cm4gbmV3IFN0ZXBSZXN1bHQobnVsbCwgbWVzc2FnZSk7IH1cbiAgICAvKipcbiAgICBDYWxsIFtgTm9kZS5yZXBsYWNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUucmVwbGFjZSkgd2l0aCB0aGUgZ2l2ZW5cbiAgICBhcmd1bWVudHMuIENyZWF0ZSBhIHN1Y2Nlc3NmdWwgcmVzdWx0IGlmIGl0IHN1Y2NlZWRzLCBhbmQgYVxuICAgIGZhaWxlZCBvbmUgaWYgaXQgdGhyb3dzIGEgYFJlcGxhY2VFcnJvcmAuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbVJlcGxhY2UoZG9jLCBmcm9tLCB0bywgc2xpY2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0Lm9rKGRvYy5yZXBsYWNlKGZyb20sIHRvLCBzbGljZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJlcGxhY2VFcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKGUubWVzc2FnZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtYXBGcmFnbWVudChmcmFnbWVudCwgZiwgcGFyZW50KSB7XG4gICAgbGV0IG1hcHBlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhZ21lbnQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGZyYWdtZW50LmNoaWxkKGkpO1xuICAgICAgICBpZiAoY2hpbGQuY29udGVudC5zaXplKVxuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jb3B5KG1hcEZyYWdtZW50KGNoaWxkLmNvbnRlbnQsIGYsIGNoaWxkKSk7XG4gICAgICAgIGlmIChjaGlsZC5pc0lubGluZSlcbiAgICAgICAgICAgIGNoaWxkID0gZihjaGlsZCwgcGFyZW50LCBpKTtcbiAgICAgICAgbWFwcGVkLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gRnJhZ21lbnQuZnJvbUFycmF5KG1hcHBlZCk7XG59XG4vKipcbkFkZCBhIG1hcmsgdG8gYWxsIGlubGluZSBjb250ZW50IGJldHdlZW4gdHdvIHBvc2l0aW9ucy5cbiovXG5jbGFzcyBBZGRNYXJrU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgbWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgbWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHRvIGFkZC5cbiAgICAqL1xuICAgIG1hcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG9sZFNsaWNlID0gZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50byksICRmcm9tID0gZG9jLnJlc29sdmUodGhpcy5mcm9tKTtcbiAgICAgICAgbGV0IHBhcmVudCA9ICRmcm9tLm5vZGUoJGZyb20uc2hhcmVkRGVwdGgodGhpcy50bykpO1xuICAgICAgICBsZXQgc2xpY2UgPSBuZXcgU2xpY2UobWFwRnJhZ21lbnQob2xkU2xpY2UuY29udGVudCwgKG5vZGUsIHBhcmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFub2RlLmlzQXRvbSB8fCAhcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUodGhpcy5tYXJrLnR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubWFyayh0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICB9LCBwYXJlbnQpLCBvbGRTbGljZS5vcGVuU3RhcnQsIG9sZFNsaWNlLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgc2xpY2UpO1xuICAgIH1cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkICYmIHRvLmRlbGV0ZWQgfHwgZnJvbS5wb3MgPj0gdG8ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoZnJvbS5wb3MsIHRvLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQWRkTWFya1N0ZXAgJiZcbiAgICAgICAgICAgIG90aGVyLm1hcmsuZXEodGhpcy5tYXJrKSAmJlxuICAgICAgICAgICAgdGhpcy5mcm9tIDw9IG90aGVyLnRvICYmIHRoaXMudG8gPj0gb3RoZXIuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoTWF0aC5taW4odGhpcy5mcm9tLCBvdGhlci5mcm9tKSwgTWF0aC5tYXgodGhpcy50bywgb3RoZXIudG8pLCB0aGlzLm1hcmspO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJhZGRNYXJrXCIsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQWRkTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYWRkTWFya1wiLCBBZGRNYXJrU3RlcCk7XG4vKipcblJlbW92ZSBhIG1hcmsgZnJvbSBhbGwgaW5saW5lIGNvbnRlbnQgYmV0d2VlbiB0d28gcG9zaXRpb25zLlxuKi9cbmNsYXNzIFJlbW92ZU1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyay1yZW1vdmluZyBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSB1bm1hcmtlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIHVubWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHRvIHJlbW92ZS5cbiAgICAqL1xuICAgIG1hcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG9sZFNsaWNlID0gZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShtYXBGcmFnbWVudChvbGRTbGljZS5jb250ZW50LCBub2RlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLm1hcmsodGhpcy5tYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICB9LCBkb2MpLCBvbGRTbGljZS5vcGVuU3RhcnQsIG9sZFNsaWNlLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgc2xpY2UpO1xuICAgIH1cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkICYmIHRvLmRlbGV0ZWQgfHwgZnJvbS5wb3MgPj0gdG8ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoZnJvbS5wb3MsIHRvLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgUmVtb3ZlTWFya1N0ZXAgJiZcbiAgICAgICAgICAgIG90aGVyLm1hcmsuZXEodGhpcy5tYXJrKSAmJlxuICAgICAgICAgICAgdGhpcy5mcm9tIDw9IG90aGVyLnRvICYmIHRoaXMudG8gPj0gb3RoZXIuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoTWF0aC5taW4odGhpcy5mcm9tLCBvdGhlci5mcm9tKSwgTWF0aC5tYXgodGhpcy50bywgb3RoZXIudG8pLCB0aGlzLm1hcmspO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJyZW1vdmVNYXJrXCIsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVtb3ZlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVtb3ZlTWFya1wiLCBSZW1vdmVNYXJrU3RlcCk7XG4vKipcbkFkZCBhIG1hcmsgdG8gYSBzcGVjaWZpYyBub2RlLlxuKi9cbmNsYXNzIEFkZE5vZGVNYXJrU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5vZGUgbWFyayBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gYWRkLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJObyBub2RlIGF0IG1hcmsgc3RlcCdzIHBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG5vZGUudHlwZS5jcmVhdGUobm9kZS5hdHRycywgbnVsbCwgdGhpcy5tYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLnBvcywgdGhpcy5wb3MgKyAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKSwgMCwgbm9kZS5pc0xlYWYgPyAwIDogMSkpO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBsZXQgbmV3U2V0ID0gdGhpcy5tYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpO1xuICAgICAgICAgICAgaWYgKG5ld1NldC5sZW5ndGggPT0gbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5tYXJrc1tpXS5pc0luU2V0KG5ld1NldCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgbm9kZS5tYXJrc1tpXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGROb2RlTWFya1N0ZXAodGhpcy5wb3MsIHRoaXMubWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAodGhpcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnBvcywgMSk7XG4gICAgICAgIHJldHVybiBwb3MuZGVsZXRlZEFmdGVyID8gbnVsbCA6IG5ldyBBZGROb2RlTWFya1N0ZXAocG9zLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJhZGROb2RlTWFya1wiLCBwb3M6IHRoaXMucG9zLCBtYXJrOiB0aGlzLm1hcmsudG9KU09OKCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQWRkTm9kZU1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcChqc29uLnBvcywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcImFkZE5vZGVNYXJrXCIsIEFkZE5vZGVNYXJrU3RlcCk7XG4vKipcblJlbW92ZSBhIG1hcmsgZnJvbSBhIHNwZWNpZmljIG5vZGUuXG4qL1xuY2xhc3MgUmVtb3ZlTm9kZU1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyay1yZW1vdmluZyBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gcmVtb3ZlLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJObyBub2RlIGF0IG1hcmsgc3RlcCdzIHBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG5vZGUudHlwZS5jcmVhdGUobm9kZS5hdHRycywgbnVsbCwgdGhpcy5tYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMucG9zLCB0aGlzLnBvcyArIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLCAwLCBub2RlLmlzTGVhZiA/IDAgOiAxKSk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlIHx8ICF0aGlzLm1hcmsuaXNJblNldChub2RlLm1hcmtzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMucG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIHBvcy5kZWxldGVkQWZ0ZXIgPyBudWxsIDogbmV3IFJlbW92ZU5vZGVNYXJrU3RlcChwb3MucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcInJlbW92ZU5vZGVNYXJrXCIsIHBvczogdGhpcy5wb3MsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZW1vdmVOb2RlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKGpzb24ucG9zLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVtb3ZlTm9kZU1hcmtcIiwgUmVtb3ZlTm9kZU1hcmtTdGVwKTtcblxuLyoqXG5SZXBsYWNlIGEgcGFydCBvZiB0aGUgZG9jdW1lbnQgd2l0aCBhIHNsaWNlIG9mIG5ldyBjb250ZW50LlxuKi9cbmNsYXNzIFJlcGxhY2VTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgVGhlIGdpdmVuIGBzbGljZWAgc2hvdWxkIGZpdCB0aGUgJ2dhcCcgYmV0d2VlbiBgZnJvbWAgYW5kXG4gICAgYHRvYFx1MjAxNHRoZSBkZXB0aHMgbXVzdCBsaW5lIHVwLCBhbmQgdGhlIHN1cnJvdW5kaW5nIG5vZGVzIG11c3QgYmVcbiAgICBhYmxlIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSBvcGVuIHNpZGVzIG9mIHRoZSBzbGljZS4gV2hlblxuICAgIGBzdHJ1Y3R1cmVgIGlzIHRydWUsIHRoZSBzdGVwIHdpbGwgZmFpbCBpZiB0aGUgY29udGVudCBiZXR3ZWVuXG4gICAgZnJvbSBhbmQgdG8gaXMgbm90IGp1c3QgYSBzZXF1ZW5jZSBvZiBjbG9zaW5nIGFuZCB0aGVuIG9wZW5pbmdcbiAgICB0b2tlbnMgKHRoaXMgaXMgdG8gZ3VhcmQgYWdhaW5zdCByZWJhc2VkIHJlcGxhY2Ugc3RlcHNcbiAgICBvdmVyd3JpdGluZyBzb21ldGhpbmcgdGhleSB3ZXJlbid0IHN1cHBvc2VkIHRvKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgc2xpY2UgdG8gaW5zZXJ0LlxuICAgICovXG4gICAgc2xpY2UsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RydWN0dXJlID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMuc3RydWN0dXJlID0gc3RydWN0dXJlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RydWN0dXJlICYmIGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvKSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJTdHJ1Y3R1cmUgcmVwbGFjZSB3b3VsZCBvdmVyd3JpdGUgY29udGVudFwiKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMuc2xpY2UpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RlcE1hcChbdGhpcy5mcm9tLCB0aGlzLnRvIC0gdGhpcy5mcm9tLCB0aGlzLnNsaWNlLnNpemVdKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKHRoaXMuZnJvbSwgdGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplLCBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWRBY3Jvc3MgJiYgdG8uZGVsZXRlZEFjcm9zcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGZyb20ucG9zLCBNYXRoLm1heChmcm9tLnBvcywgdG8ucG9zKSwgdGhpcy5zbGljZSk7XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXApIHx8IG90aGVyLnN0cnVjdHVyZSB8fCB0aGlzLnN0cnVjdHVyZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplID09IG90aGVyLmZyb20gJiYgIXRoaXMuc2xpY2Uub3BlbkVuZCAmJiAhb3RoZXIuc2xpY2Uub3BlblN0YXJ0KSB7XG4gICAgICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLnNsaWNlLnNpemUgKyBvdGhlci5zbGljZS5zaXplID09IDAgPyBTbGljZS5lbXB0eVxuICAgICAgICAgICAgICAgIDogbmV3IFNsaWNlKHRoaXMuc2xpY2UuY29udGVudC5hcHBlbmQob3RoZXIuc2xpY2UuY29udGVudCksIHRoaXMuc2xpY2Uub3BlblN0YXJ0LCBvdGhlci5zbGljZS5vcGVuRW5kKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAodGhpcy5mcm9tLCB0aGlzLnRvICsgKG90aGVyLnRvIC0gb3RoZXIuZnJvbSksIHNsaWNlLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIudG8gPT0gdGhpcy5mcm9tICYmICF0aGlzLnNsaWNlLm9wZW5TdGFydCAmJiAhb3RoZXIuc2xpY2Uub3BlbkVuZCkge1xuICAgICAgICAgICAgbGV0IHNsaWNlID0gdGhpcy5zbGljZS5zaXplICsgb3RoZXIuc2xpY2Uuc2l6ZSA9PSAwID8gU2xpY2UuZW1wdHlcbiAgICAgICAgICAgICAgICA6IG5ldyBTbGljZShvdGhlci5zbGljZS5jb250ZW50LmFwcGVuZCh0aGlzLnNsaWNlLmNvbnRlbnQpLCBvdGhlci5zbGljZS5vcGVuU3RhcnQsIHRoaXMuc2xpY2Uub3BlbkVuZCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKG90aGVyLmZyb20sIHRoaXMudG8sIHNsaWNlLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBqc29uID0geyBzdGVwVHlwZTogXCJyZXBsYWNlXCIsIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8gfTtcbiAgICAgICAgaWYgKHRoaXMuc2xpY2Uuc2l6ZSlcbiAgICAgICAgICAgIGpzb24uc2xpY2UgPSB0aGlzLnNsaWNlLnRvSlNPTigpO1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUpXG4gICAgICAgICAgICBqc29uLnN0cnVjdHVyZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZXBsYWNlU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChqc29uLmZyb20sIGpzb24udG8sIFNsaWNlLmZyb21KU09OKHNjaGVtYSwganNvbi5zbGljZSksICEhanNvbi5zdHJ1Y3R1cmUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVwbGFjZVwiLCBSZXBsYWNlU3RlcCk7XG4vKipcblJlcGxhY2UgYSBwYXJ0IG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgc2xpY2Ugb2YgY29udGVudCwgYnV0XG5wcmVzZXJ2ZSBhIHJhbmdlIG9mIHRoZSByZXBsYWNlZCBjb250ZW50IGJ5IG1vdmluZyBpdCBpbnRvIHRoZVxuc2xpY2UuXG4qL1xuY2xhc3MgUmVwbGFjZUFyb3VuZFN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSByZXBsYWNlLWFyb3VuZCBzdGVwIHdpdGggdGhlIGdpdmVuIHJhbmdlIGFuZCBnYXAuXG4gICAgYGluc2VydGAgc2hvdWxkIGJlIHRoZSBwb2ludCBpbiB0aGUgc2xpY2UgaW50byB3aGljaCB0aGUgY29udGVudFxuICAgIG9mIHRoZSBnYXAgc2hvdWxkIGJlIG1vdmVkLiBgc3RydWN0dXJlYCBoYXMgdGhlIHNhbWUgbWVhbmluZyBhc1xuICAgIGl0IGhhcyBpbiB0aGUgW2BSZXBsYWNlU3RlcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uUmVwbGFjZVN0ZXApIGNsYXNzLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiBwcmVzZXJ2ZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBnYXBGcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHByZXNlcnZlZCByYW5nZS5cbiAgICAqL1xuICAgIGdhcFRvLCBcbiAgICAvKipcbiAgICBUaGUgc2xpY2UgdG8gaW5zZXJ0LlxuICAgICovXG4gICAgc2xpY2UsIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBpbiB0aGUgc2xpY2Ugd2hlcmUgdGhlIHByZXNlcnZlZCByYW5nZSBzaG91bGQgYmVcbiAgICBpbnNlcnRlZC5cbiAgICAqL1xuICAgIGluc2VydCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdHJ1Y3R1cmUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZ2FwRnJvbSA9IGdhcEZyb207XG4gICAgICAgIHRoaXMuZ2FwVG8gPSBnYXBUbztcbiAgICAgICAgdGhpcy5zbGljZSA9IHNsaWNlO1xuICAgICAgICB0aGlzLmluc2VydCA9IGluc2VydDtcbiAgICAgICAgdGhpcy5zdHJ1Y3R1cmUgPSBzdHJ1Y3R1cmU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUgJiYgKGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5mcm9tLCB0aGlzLmdhcEZyb20pIHx8XG4gICAgICAgICAgICBjb250ZW50QmV0d2Vlbihkb2MsIHRoaXMuZ2FwVG8sIHRoaXMudG8pKSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJTdHJ1Y3R1cmUgZ2FwLXJlcGxhY2Ugd291bGQgb3ZlcndyaXRlIGNvbnRlbnRcIik7XG4gICAgICAgIGxldCBnYXAgPSBkb2Muc2xpY2UodGhpcy5nYXBGcm9tLCB0aGlzLmdhcFRvKTtcbiAgICAgICAgaWYgKGdhcC5vcGVuU3RhcnQgfHwgZ2FwLm9wZW5FbmQpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiR2FwIGlzIG5vdCBhIGZsYXQgcmFuZ2VcIik7XG4gICAgICAgIGxldCBpbnNlcnRlZCA9IHRoaXMuc2xpY2UuaW5zZXJ0QXQodGhpcy5pbnNlcnQsIGdhcC5jb250ZW50KTtcbiAgICAgICAgaWYgKCFpbnNlcnRlZClcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJDb250ZW50IGRvZXMgbm90IGZpdCBpbiBnYXBcIik7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBpbnNlcnRlZCk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKFt0aGlzLmZyb20sIHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5pbnNlcnQsXG4gICAgICAgICAgICB0aGlzLmdhcFRvLCB0aGlzLnRvIC0gdGhpcy5nYXBUbywgdGhpcy5zbGljZS5zaXplIC0gdGhpcy5pbnNlcnRdKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgZ2FwID0gdGhpcy5nYXBUbyAtIHRoaXMuZ2FwRnJvbTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcCh0aGlzLmZyb20sIHRoaXMuZnJvbSArIHRoaXMuc2xpY2Uuc2l6ZSArIGdhcCwgdGhpcy5mcm9tICsgdGhpcy5pbnNlcnQsIHRoaXMuZnJvbSArIHRoaXMuaW5zZXJ0ICsgZ2FwLCBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKS5yZW1vdmVCZXR3ZWVuKHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5nYXBUbyAtIHRoaXMuZnJvbSksIHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBsZXQgZ2FwRnJvbSA9IG1hcHBpbmcubWFwKHRoaXMuZ2FwRnJvbSwgLTEpLCBnYXBUbyA9IG1hcHBpbmcubWFwKHRoaXMuZ2FwVG8sIDEpO1xuICAgICAgICBpZiAoKGZyb20uZGVsZXRlZEFjcm9zcyAmJiB0by5kZWxldGVkQWNyb3NzKSB8fCBnYXBGcm9tIDwgZnJvbS5wb3MgfHwgZ2FwVG8gPiB0by5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcChmcm9tLnBvcywgdG8ucG9zLCBnYXBGcm9tLCBnYXBUbywgdGhpcy5zbGljZSwgdGhpcy5pbnNlcnQsIHRoaXMuc3RydWN0dXJlKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQganNvbiA9IHsgc3RlcFR5cGU6IFwicmVwbGFjZUFyb3VuZFwiLCBmcm9tOiB0aGlzLmZyb20sIHRvOiB0aGlzLnRvLFxuICAgICAgICAgICAgZ2FwRnJvbTogdGhpcy5nYXBGcm9tLCBnYXBUbzogdGhpcy5nYXBUbywgaW5zZXJ0OiB0aGlzLmluc2VydCB9O1xuICAgICAgICBpZiAodGhpcy5zbGljZS5zaXplKVxuICAgICAgICAgICAganNvbi5zbGljZSA9IHRoaXMuc2xpY2UudG9KU09OKCk7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSlcbiAgICAgICAgICAgIGpzb24uc3RydWN0dXJlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBqc29uLmdhcEZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5nYXBUbyAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmluc2VydCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZXBsYWNlQXJvdW5kU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcChqc29uLmZyb20sIGpzb24udG8sIGpzb24uZ2FwRnJvbSwganNvbi5nYXBUbywgU2xpY2UuZnJvbUpTT04oc2NoZW1hLCBqc29uLnNsaWNlKSwganNvbi5pbnNlcnQsICEhanNvbi5zdHJ1Y3R1cmUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVwbGFjZUFyb3VuZFwiLCBSZXBsYWNlQXJvdW5kU3RlcCk7XG5mdW5jdGlvbiBjb250ZW50QmV0d2Vlbihkb2MsIGZyb20sIHRvKSB7XG4gICAgbGV0ICRmcm9tID0gZG9jLnJlc29sdmUoZnJvbSksIGRpc3QgPSB0byAtIGZyb20sIGRlcHRoID0gJGZyb20uZGVwdGg7XG4gICAgd2hpbGUgKGRpc3QgPiAwICYmIGRlcHRoID4gMCAmJiAkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSA9PSAkZnJvbS5ub2RlKGRlcHRoKS5jaGlsZENvdW50KSB7XG4gICAgICAgIGRlcHRoLS07XG4gICAgICAgIGRpc3QtLTtcbiAgICB9XG4gICAgaWYgKGRpc3QgPiAwKSB7XG4gICAgICAgIGxldCBuZXh0ID0gJGZyb20ubm9kZShkZXB0aCkubWF5YmVDaGlsZCgkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSk7XG4gICAgICAgIHdoaWxlIChkaXN0ID4gMCkge1xuICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQuaXNMZWFmKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGRpc3QtLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZE1hcmsodHIsIGZyb20sIHRvLCBtYXJrKSB7XG4gICAgbGV0IHJlbW92ZWQgPSBbXSwgYWRkZWQgPSBbXTtcbiAgICBsZXQgcmVtb3ZpbmcsIGFkZGluZztcbiAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zLCBwYXJlbnQpID0+IHtcbiAgICAgICAgaWYgKCFub2RlLmlzSW5saW5lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbWFya3MgPSBub2RlLm1hcmtzO1xuICAgICAgICBpZiAoIW1hcmsuaXNJblNldChtYXJrcykgJiYgcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUobWFyay50eXBlKSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgocG9zLCBmcm9tKSwgZW5kID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgICAgbGV0IG5ld1NldCA9IG1hcmsuYWRkVG9TZXQobWFya3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghbWFya3NbaV0uaXNJblNldChuZXdTZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmluZyAmJiByZW1vdmluZy50byA9PSBzdGFydCAmJiByZW1vdmluZy5tYXJrLmVxKG1hcmtzW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92aW5nLnRvID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkLnB1c2gocmVtb3ZpbmcgPSBuZXcgUmVtb3ZlTWFya1N0ZXAoc3RhcnQsIGVuZCwgbWFya3NbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWRkaW5nICYmIGFkZGluZy50byA9PSBzdGFydClcbiAgICAgICAgICAgICAgICBhZGRpbmcudG8gPSBlbmQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYWRkZWQucHVzaChhZGRpbmcgPSBuZXcgQWRkTWFya1N0ZXAoc3RhcnQsIGVuZCwgbWFyaykpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmVtb3ZlZC5mb3JFYWNoKHMgPT4gdHIuc3RlcChzKSk7XG4gICAgYWRkZWQuZm9yRWFjaChzID0+IHRyLnN0ZXAocykpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTWFyayh0ciwgZnJvbSwgdG8sIG1hcmspIHtcbiAgICBsZXQgbWF0Y2hlZCA9IFtdLCBzdGVwID0gMDtcbiAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgIGlmICghbm9kZS5pc0lubGluZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc3RlcCsrO1xuICAgICAgICBsZXQgdG9SZW1vdmUgPSBudWxsO1xuICAgICAgICBpZiAobWFyayBpbnN0YW5jZW9mIE1hcmtUeXBlKSB7XG4gICAgICAgICAgICBsZXQgc2V0ID0gbm9kZS5tYXJrcywgZm91bmQ7XG4gICAgICAgICAgICB3aGlsZSAoZm91bmQgPSBtYXJrLmlzSW5TZXQoc2V0KSkge1xuICAgICAgICAgICAgICAgICh0b1JlbW92ZSB8fCAodG9SZW1vdmUgPSBbXSkpLnB1c2goZm91bmQpO1xuICAgICAgICAgICAgICAgIHNldCA9IGZvdW5kLnJlbW92ZUZyb21TZXQoc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXJrKSB7XG4gICAgICAgICAgICBpZiAobWFyay5pc0luU2V0KG5vZGUubWFya3MpKVxuICAgICAgICAgICAgICAgIHRvUmVtb3ZlID0gW21hcmtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9SZW1vdmUgPSBub2RlLm1hcmtzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b1JlbW92ZSAmJiB0b1JlbW92ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvUmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlID0gdG9SZW1vdmVbaV0sIGZvdW5kO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF0Y2hlZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IG1hdGNoZWRbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtLnN0ZXAgPT0gc3RlcCAtIDEgJiYgc3R5bGUuZXEobWF0Y2hlZFtqXS5zdHlsZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IG07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZC50byA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQuc3RlcCA9IHN0ZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLnB1c2goeyBzdHlsZSwgZnJvbTogTWF0aC5tYXgocG9zLCBmcm9tKSwgdG86IGVuZCwgc3RlcCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBtYXRjaGVkLmZvckVhY2gobSA9PiB0ci5zdGVwKG5ldyBSZW1vdmVNYXJrU3RlcChtLmZyb20sIG0udG8sIG0uc3R5bGUpKSk7XG59XG5mdW5jdGlvbiBjbGVhckluY29tcGF0aWJsZSh0ciwgcG9zLCBwYXJlbnRUeXBlLCBtYXRjaCA9IHBhcmVudFR5cGUuY29udGVudE1hdGNoKSB7XG4gICAgbGV0IG5vZGUgPSB0ci5kb2Mubm9kZUF0KHBvcyk7XG4gICAgbGV0IHJlcGxTdGVwcyA9IFtdLCBjdXIgPSBwb3MgKyAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gbm9kZS5jaGlsZChpKSwgZW5kID0gY3VyICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgIGxldCBhbGxvd2VkID0gbWF0Y2gubWF0Y2hUeXBlKGNoaWxkLnR5cGUpO1xuICAgICAgICBpZiAoIWFsbG93ZWQpIHtcbiAgICAgICAgICAgIHJlcGxTdGVwcy5wdXNoKG5ldyBSZXBsYWNlU3RlcChjdXIsIGVuZCwgU2xpY2UuZW1wdHkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoID0gYWxsb3dlZDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGQubWFya3MubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRUeXBlLmFsbG93c01hcmtUeXBlKGNoaWxkLm1hcmtzW2pdLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICB0ci5zdGVwKG5ldyBSZW1vdmVNYXJrU3RlcChjdXIsIGVuZCwgY2hpbGQubWFya3Nbal0pKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5pc1RleHQgJiYgIXBhcmVudFR5cGUuc3BlYy5jb2RlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG0sIG5ld2xpbmUgPSAvXFxyP1xcbnxcXHIvZywgc2xpY2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG0gPSBuZXdsaW5lLmV4ZWMoY2hpbGQudGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzbGljZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20ocGFyZW50VHlwZS5zY2hlbWEudGV4dChcIiBcIiwgcGFyZW50VHlwZS5hbGxvd2VkTWFya3MoY2hpbGQubWFya3MpKSksIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICByZXBsU3RlcHMucHVzaChuZXcgUmVwbGFjZVN0ZXAoY3VyICsgbS5pbmRleCwgY3VyICsgbS5pbmRleCArIG1bMF0ubGVuZ3RoLCBzbGljZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBlbmQ7XG4gICAgfVxuICAgIGlmICghbWF0Y2gudmFsaWRFbmQpIHtcbiAgICAgICAgbGV0IGZpbGwgPSBtYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgICAgdHIucmVwbGFjZShjdXIsIGN1ciwgbmV3IFNsaWNlKGZpbGwsIDAsIDApKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHJlcGxTdGVwcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgdHIuc3RlcChyZXBsU3RlcHNbaV0pO1xufVxuXG5mdW5jdGlvbiBjYW5DdXQobm9kZSwgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoc3RhcnQgPT0gMCB8fCBub2RlLmNhblJlcGxhY2Uoc3RhcnQsIG5vZGUuY2hpbGRDb3VudCkpICYmXG4gICAgICAgIChlbmQgPT0gbm9kZS5jaGlsZENvdW50IHx8IG5vZGUuY2FuUmVwbGFjZSgwLCBlbmQpKTtcbn1cbi8qKlxuVHJ5IHRvIGZpbmQgYSB0YXJnZXQgZGVwdGggdG8gd2hpY2ggdGhlIGNvbnRlbnQgaW4gdGhlIGdpdmVuIHJhbmdlXG5jYW4gYmUgbGlmdGVkLiBXaWxsIG5vdCBnbyBhY3Jvc3Ncbltpc29sYXRpbmddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5pc29sYXRpbmcpIHBhcmVudCBub2Rlcy5cbiovXG5mdW5jdGlvbiBsaWZ0VGFyZ2V0KHJhbmdlKSB7XG4gICAgbGV0IHBhcmVudCA9IHJhbmdlLnBhcmVudDtcbiAgICBsZXQgY29udGVudCA9IHBhcmVudC5jb250ZW50LmN1dEJ5SW5kZXgocmFuZ2Uuc3RhcnRJbmRleCwgcmFuZ2UuZW5kSW5kZXgpO1xuICAgIGZvciAobGV0IGRlcHRoID0gcmFuZ2UuZGVwdGg7OyAtLWRlcHRoKSB7XG4gICAgICAgIGxldCBub2RlID0gcmFuZ2UuJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgIGxldCBpbmRleCA9IHJhbmdlLiRmcm9tLmluZGV4KGRlcHRoKSwgZW5kSW5kZXggPSByYW5nZS4kdG8uaW5kZXhBZnRlcihkZXB0aCk7XG4gICAgICAgIGlmIChkZXB0aCA8IHJhbmdlLmRlcHRoICYmIG5vZGUuY2FuUmVwbGFjZShpbmRleCwgZW5kSW5kZXgsIGNvbnRlbnQpKVxuICAgICAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCB8fCBub2RlLnR5cGUuc3BlYy5pc29sYXRpbmcgfHwgIWNhbkN1dChub2RlLCBpbmRleCwgZW5kSW5kZXgpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbGlmdCh0ciwgcmFuZ2UsIHRhcmdldCkge1xuICAgIGxldCB7ICRmcm9tLCAkdG8sIGRlcHRoIH0gPSByYW5nZTtcbiAgICBsZXQgZ2FwU3RhcnQgPSAkZnJvbS5iZWZvcmUoZGVwdGggKyAxKSwgZ2FwRW5kID0gJHRvLmFmdGVyKGRlcHRoICsgMSk7XG4gICAgbGV0IHN0YXJ0ID0gZ2FwU3RhcnQsIGVuZCA9IGdhcEVuZDtcbiAgICBsZXQgYmVmb3JlID0gRnJhZ21lbnQuZW1wdHksIG9wZW5TdGFydCA9IDA7XG4gICAgZm9yIChsZXQgZCA9IGRlcHRoLCBzcGxpdHRpbmcgPSBmYWxzZTsgZCA+IHRhcmdldDsgZC0tKVxuICAgICAgICBpZiAoc3BsaXR0aW5nIHx8ICRmcm9tLmluZGV4KGQpID4gMCkge1xuICAgICAgICAgICAgc3BsaXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGJlZm9yZSA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KGJlZm9yZSkpO1xuICAgICAgICAgICAgb3BlblN0YXJ0Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydC0tO1xuICAgICAgICB9XG4gICAgbGV0IGFmdGVyID0gRnJhZ21lbnQuZW1wdHksIG9wZW5FbmQgPSAwO1xuICAgIGZvciAobGV0IGQgPSBkZXB0aCwgc3BsaXR0aW5nID0gZmFsc2U7IGQgPiB0YXJnZXQ7IGQtLSlcbiAgICAgICAgaWYgKHNwbGl0dGluZyB8fCAkdG8uYWZ0ZXIoZCArIDEpIDwgJHRvLmVuZChkKSkge1xuICAgICAgICAgICAgc3BsaXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGFmdGVyID0gRnJhZ21lbnQuZnJvbSgkdG8ubm9kZShkKS5jb3B5KGFmdGVyKSk7XG4gICAgICAgICAgICBvcGVuRW5kKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfVxuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0LCBlbmQsIGdhcFN0YXJ0LCBnYXBFbmQsIG5ldyBTbGljZShiZWZvcmUuYXBwZW5kKGFmdGVyKSwgb3BlblN0YXJ0LCBvcGVuRW5kKSwgYmVmb3JlLnNpemUgLSBvcGVuU3RhcnQsIHRydWUpKTtcbn1cbi8qKlxuVHJ5IHRvIGZpbmQgYSB2YWxpZCB3YXkgdG8gd3JhcCB0aGUgY29udGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2UgaW4gYVxubm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZS4gTWF5IGludHJvZHVjZSBleHRyYSBub2RlcyBhcm91bmQgYW5kIGluc2lkZVxudGhlIHdyYXBwZXIgbm9kZSwgaWYgbmVjZXNzYXJ5LiBSZXR1cm5zIG51bGwgaWYgbm8gdmFsaWQgd3JhcHBpbmdcbmNvdWxkIGJlIGZvdW5kLiBXaGVuIGBpbm5lclJhbmdlYCBpcyBnaXZlbiwgdGhhdCByYW5nZSdzIGNvbnRlbnQgaXNcbnVzZWQgYXMgdGhlIGNvbnRlbnQgdG8gZml0IGludG8gdGhlIHdyYXBwaW5nLCBpbnN0ZWFkIG9mIHRoZVxuY29udGVudCBvZiBgcmFuZ2VgLlxuKi9cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUsIGF0dHJzID0gbnVsbCwgaW5uZXJSYW5nZSA9IHJhbmdlKSB7XG4gICAgbGV0IGFyb3VuZCA9IGZpbmRXcmFwcGluZ091dHNpZGUocmFuZ2UsIG5vZGVUeXBlKTtcbiAgICBsZXQgaW5uZXIgPSBhcm91bmQgJiYgZmluZFdyYXBwaW5nSW5zaWRlKGlubmVyUmFuZ2UsIG5vZGVUeXBlKTtcbiAgICBpZiAoIWlubmVyKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gYXJvdW5kLm1hcCh3aXRoQXR0cnMpXG4gICAgICAgIC5jb25jYXQoeyB0eXBlOiBub2RlVHlwZSwgYXR0cnMgfSkuY29uY2F0KGlubmVyLm1hcCh3aXRoQXR0cnMpKTtcbn1cbmZ1bmN0aW9uIHdpdGhBdHRycyh0eXBlKSB7IHJldHVybiB7IHR5cGUsIGF0dHJzOiBudWxsIH07IH1cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ091dHNpZGUocmFuZ2UsIHR5cGUpIHtcbiAgICBsZXQgeyBwYXJlbnQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4IH0gPSByYW5nZTtcbiAgICBsZXQgYXJvdW5kID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KHN0YXJ0SW5kZXgpLmZpbmRXcmFwcGluZyh0eXBlKTtcbiAgICBpZiAoIWFyb3VuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG91dGVyID0gYXJvdW5kLmxlbmd0aCA/IGFyb3VuZFswXSA6IHR5cGU7XG4gICAgcmV0dXJuIHBhcmVudC5jYW5SZXBsYWNlV2l0aChzdGFydEluZGV4LCBlbmRJbmRleCwgb3V0ZXIpID8gYXJvdW5kIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ0luc2lkZShyYW5nZSwgdHlwZSkge1xuICAgIGxldCB7IHBhcmVudCwgc3RhcnRJbmRleCwgZW5kSW5kZXggfSA9IHJhbmdlO1xuICAgIGxldCBpbm5lciA9IHBhcmVudC5jaGlsZChzdGFydEluZGV4KTtcbiAgICBsZXQgaW5zaWRlID0gdHlwZS5jb250ZW50TWF0Y2guZmluZFdyYXBwaW5nKGlubmVyLnR5cGUpO1xuICAgIGlmICghaW5zaWRlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbGFzdFR5cGUgPSBpbnNpZGUubGVuZ3RoID8gaW5zaWRlW2luc2lkZS5sZW5ndGggLSAxXSA6IHR5cGU7XG4gICAgbGV0IGlubmVyTWF0Y2ggPSBsYXN0VHlwZS5jb250ZW50TWF0Y2g7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGlubmVyTWF0Y2ggJiYgaSA8IGVuZEluZGV4OyBpKyspXG4gICAgICAgIGlubmVyTWF0Y2ggPSBpbm5lck1hdGNoLm1hdGNoVHlwZShwYXJlbnQuY2hpbGQoaSkudHlwZSk7XG4gICAgaWYgKCFpbm5lck1hdGNoIHx8ICFpbm5lck1hdGNoLnZhbGlkRW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gaW5zaWRlO1xufVxuZnVuY3Rpb24gd3JhcCh0ciwgcmFuZ2UsIHdyYXBwZXJzKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBpID0gd3JhcHBlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gd3JhcHBlcnNbaV0udHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgICAgICAgIGlmICghbWF0Y2ggfHwgIW1hdGNoLnZhbGlkRW5kKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiV3JhcHBlciB0eXBlIGdpdmVuIHRvIFRyYW5zZm9ybS53cmFwIGRvZXMgbm90IGZvcm0gdmFsaWQgY29udGVudCBvZiBpdHMgcGFyZW50IHdyYXBwZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20od3JhcHBlcnNbaV0udHlwZS5jcmVhdGUod3JhcHBlcnNbaV0uYXR0cnMsIGNvbnRlbnQpKTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0ID0gcmFuZ2Uuc3RhcnQsIGVuZCA9IHJhbmdlLmVuZDtcbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCwgZW5kLCBzdGFydCwgZW5kLCBuZXcgU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xufVxuZnVuY3Rpb24gc2V0QmxvY2tUeXBlKHRyLCBmcm9tLCB0bywgdHlwZSwgYXR0cnMpIHtcbiAgICBpZiAoIXR5cGUuaXNUZXh0YmxvY2spXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHlwZSBnaXZlbiB0byBzZXRCbG9ja1R5cGUgc2hvdWxkIGJlIGEgdGV4dGJsb2NrXCIpO1xuICAgIGxldCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoO1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0YmxvY2sgJiYgIW5vZGUuaGFzTWFya3VwKHR5cGUsIGF0dHJzKSAmJiBjYW5DaGFuZ2VUeXBlKHRyLmRvYywgdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zKSwgdHlwZSkpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBhbGwgbWFya3VwIHRoYXQgaXNuJ3QgYWxsb3dlZCBpbiB0aGUgbmV3IG5vZGUgdHlwZSBpcyBjbGVhcmVkXG4gICAgICAgICAgICB0ci5jbGVhckluY29tcGF0aWJsZSh0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MsIDEpLCB0eXBlKTtcbiAgICAgICAgICAgIGxldCBtYXBwaW5nID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKTtcbiAgICAgICAgICAgIGxldCBzdGFydE0gPSBtYXBwaW5nLm1hcChwb3MsIDEpLCBlbmRNID0gbWFwcGluZy5tYXAocG9zICsgbm9kZS5ub2RlU2l6ZSwgMSk7XG4gICAgICAgICAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydE0sIGVuZE0sIHN0YXJ0TSArIDEsIGVuZE0gLSAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZShhdHRycywgbnVsbCwgbm9kZS5tYXJrcykpLCAwLCAwKSwgMSwgdHJ1ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjYW5DaGFuZ2VUeXBlKGRvYywgcG9zLCB0eXBlKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICByZXR1cm4gJHBvcy5wYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4ICsgMSwgdHlwZSk7XG59XG4vKipcbkNoYW5nZSB0aGUgdHlwZSwgYXR0cmlidXRlcywgYW5kL29yIG1hcmtzIG9mIHRoZSBub2RlIGF0IGBwb3NgLlxuV2hlbiBgdHlwZWAgaXNuJ3QgZ2l2ZW4sIHRoZSBleGlzdGluZyBub2RlIHR5cGUgaXMgcHJlc2VydmVkLFxuKi9cbmZ1bmN0aW9uIHNldE5vZGVNYXJrdXAodHIsIHBvcywgdHlwZSwgYXR0cnMsIG1hcmtzKSB7XG4gICAgbGV0IG5vZGUgPSB0ci5kb2Mubm9kZUF0KHBvcyk7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYXQgZ2l2ZW4gcG9zaXRpb25cIik7XG4gICAgaWYgKCF0eXBlKVxuICAgICAgICB0eXBlID0gbm9kZS50eXBlO1xuICAgIGxldCBuZXdOb2RlID0gdHlwZS5jcmVhdGUoYXR0cnMsIG51bGwsIG1hcmtzIHx8IG5vZGUubWFya3MpO1xuICAgIGlmIChub2RlLmlzTGVhZilcbiAgICAgICAgcmV0dXJuIHRyLnJlcGxhY2VXaXRoKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwgbmV3Tm9kZSk7XG4gICAgaWYgKCF0eXBlLnZhbGlkQ29udGVudChub2RlLmNvbnRlbnQpKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY29udGVudCBmb3Igbm9kZSB0eXBlIFwiICsgdHlwZS5uYW1lKTtcbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIHBvcyArIDEsIHBvcyArIG5vZGUubm9kZVNpemUgLSAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShuZXdOb2RlKSwgMCwgMCksIDEsIHRydWUpKTtcbn1cbi8qKlxuQ2hlY2sgd2hldGhlciBzcGxpdHRpbmcgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIGFsbG93ZWQuXG4qL1xuZnVuY3Rpb24gY2FuU3BsaXQoZG9jLCBwb3MsIGRlcHRoID0gMSwgdHlwZXNBZnRlcikge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKSwgYmFzZSA9ICRwb3MuZGVwdGggLSBkZXB0aDtcbiAgICBsZXQgaW5uZXJUeXBlID0gKHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlclt0eXBlc0FmdGVyLmxlbmd0aCAtIDFdKSB8fCAkcG9zLnBhcmVudDtcbiAgICBpZiAoYmFzZSA8IDAgfHwgJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZyB8fFxuICAgICAgICAhJHBvcy5wYXJlbnQuY2FuUmVwbGFjZSgkcG9zLmluZGV4KCksICRwb3MucGFyZW50LmNoaWxkQ291bnQpIHx8XG4gICAgICAgICFpbm5lclR5cGUudHlwZS52YWxpZENvbnRlbnQoJHBvcy5wYXJlbnQuY29udGVudC5jdXRCeUluZGV4KCRwb3MuaW5kZXgoKSwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudCkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGggLSAxLCBpID0gZGVwdGggLSAyOyBkID4gYmFzZTsgZC0tLCBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSAkcG9zLm5vZGUoZCksIGluZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICAgICAgaWYgKG5vZGUudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHJlc3QgPSBub2RlLmNvbnRlbnQuY3V0QnlJbmRleChpbmRleCwgbm9kZS5jaGlsZENvdW50KTtcbiAgICAgICAgbGV0IG92ZXJyaWRlQ2hpbGQgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaSArIDFdO1xuICAgICAgICBpZiAob3ZlcnJpZGVDaGlsZClcbiAgICAgICAgICAgIHJlc3QgPSByZXN0LnJlcGxhY2VDaGlsZCgwLCBvdmVycmlkZUNoaWxkLnR5cGUuY3JlYXRlKG92ZXJyaWRlQ2hpbGQuYXR0cnMpKTtcbiAgICAgICAgbGV0IGFmdGVyID0gKHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlcltpXSkgfHwgbm9kZTtcbiAgICAgICAgaWYgKCFub2RlLmNhblJlcGxhY2UoaW5kZXggKyAxLCBub2RlLmNoaWxkQ291bnQpIHx8ICFhZnRlci50eXBlLnZhbGlkQ29udGVudChyZXN0KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGJhc2UpO1xuICAgIGxldCBiYXNlVHlwZSA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlclswXTtcbiAgICByZXR1cm4gJHBvcy5ub2RlKGJhc2UpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgYmFzZVR5cGUgPyBiYXNlVHlwZS50eXBlIDogJHBvcy5ub2RlKGJhc2UgKyAxKS50eXBlKTtcbn1cbmZ1bmN0aW9uIHNwbGl0KHRyLCBwb3MsIGRlcHRoID0gMSwgdHlwZXNBZnRlcikge1xuICAgIGxldCAkcG9zID0gdHIuZG9jLnJlc29sdmUocG9zKSwgYmVmb3JlID0gRnJhZ21lbnQuZW1wdHksIGFmdGVyID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGgsIGUgPSAkcG9zLmRlcHRoIC0gZGVwdGgsIGkgPSBkZXB0aCAtIDE7IGQgPiBlOyBkLS0sIGktLSkge1xuICAgICAgICBiZWZvcmUgPSBGcmFnbWVudC5mcm9tKCRwb3Mubm9kZShkKS5jb3B5KGJlZm9yZSkpO1xuICAgICAgICBsZXQgdHlwZUFmdGVyID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2ldO1xuICAgICAgICBhZnRlciA9IEZyYWdtZW50LmZyb20odHlwZUFmdGVyID8gdHlwZUFmdGVyLnR5cGUuY3JlYXRlKHR5cGVBZnRlci5hdHRycywgYWZ0ZXIpIDogJHBvcy5ub2RlKGQpLmNvcHkoYWZ0ZXIpKTtcbiAgICB9XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZVN0ZXAocG9zLCBwb3MsIG5ldyBTbGljZShiZWZvcmUuYXBwZW5kKGFmdGVyKSwgZGVwdGgsIGRlcHRoKSwgdHJ1ZSkpO1xufVxuLyoqXG5UZXN0IHdoZXRoZXIgdGhlIGJsb2NrcyBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gcG9zaXRpb24gY2FuIGJlXG5qb2luZWQuXG4qL1xuZnVuY3Rpb24gY2FuSm9pbihkb2MsIHBvcykge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKSwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgcmV0dXJuIGpvaW5hYmxlKCRwb3Mubm9kZUJlZm9yZSwgJHBvcy5ub2RlQWZ0ZXIpICYmXG4gICAgICAgICRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSk7XG59XG5mdW5jdGlvbiBqb2luYWJsZShhLCBiKSB7XG4gICAgcmV0dXJuICEhKGEgJiYgYiAmJiAhYS5pc0xlYWYgJiYgYS5jYW5BcHBlbmQoYikpO1xufVxuLyoqXG5GaW5kIGFuIGFuY2VzdG9yIG9mIHRoZSBnaXZlbiBwb3NpdGlvbiB0aGF0IGNhbiBiZSBqb2luZWQgdG8gdGhlXG5ibG9jayBiZWZvcmUgKG9yIGFmdGVyIGlmIGBkaXJgIGlzIHBvc2l0aXZlKS4gUmV0dXJucyB0aGUgam9pbmFibGVcbnBvaW50LCBpZiBhbnkuXG4qL1xuZnVuY3Rpb24gam9pblBvaW50KGRvYywgcG9zLCBkaXIgPSAtMSkge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDs7IGQtLSkge1xuICAgICAgICBsZXQgYmVmb3JlLCBhZnRlciwgaW5kZXggPSAkcG9zLmluZGV4KGQpO1xuICAgICAgICBpZiAoZCA9PSAkcG9zLmRlcHRoKSB7XG4gICAgICAgICAgICBiZWZvcmUgPSAkcG9zLm5vZGVCZWZvcmU7XG4gICAgICAgICAgICBhZnRlciA9ICRwb3Mubm9kZUFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZShkICsgMSk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgYWZ0ZXIgPSAkcG9zLm5vZGUoZCkubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiZWZvcmUgPSAkcG9zLm5vZGUoZCkubWF5YmVDaGlsZChpbmRleCAtIDEpO1xuICAgICAgICAgICAgYWZ0ZXIgPSAkcG9zLm5vZGUoZCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiZWZvcmUgJiYgIWJlZm9yZS5pc1RleHRibG9jayAmJiBqb2luYWJsZShiZWZvcmUsIGFmdGVyKSAmJlxuICAgICAgICAgICAgJHBvcy5ub2RlKGQpLmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSkpXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICBpZiAoZCA9PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHBvcyA9IGRpciA8IDAgPyAkcG9zLmJlZm9yZShkKSA6ICRwb3MuYWZ0ZXIoZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gam9pbih0ciwgcG9zLCBkZXB0aCkge1xuICAgIGxldCBzdGVwID0gbmV3IFJlcGxhY2VTdGVwKHBvcyAtIGRlcHRoLCBwb3MgKyBkZXB0aCwgU2xpY2UuZW1wdHksIHRydWUpO1xuICAgIHRyLnN0ZXAoc3RlcCk7XG59XG4vKipcblRyeSB0byBmaW5kIGEgcG9pbnQgd2hlcmUgYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlIGNhbiBiZSBpbnNlcnRlZFxubmVhciBgcG9zYCwgYnkgc2VhcmNoaW5nIHVwIHRoZSBub2RlIGhpZXJhcmNoeSB3aGVuIGBwb3NgIGl0c2VsZlxuaXNuJ3QgYSB2YWxpZCBwbGFjZSBidXQgaXMgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhIG5vZGUuIFJldHVyblxubnVsbCBpZiBubyBwb3NpdGlvbiB3YXMgZm91bmQuXG4qL1xuZnVuY3Rpb24gaW5zZXJ0UG9pbnQoZG9jLCBwb3MsIG5vZGVUeXBlKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmICgkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aCgkcG9zLmluZGV4KCksICRwb3MuaW5kZXgoKSwgbm9kZVR5cGUpKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PSAwKVxuICAgICAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4KGQpO1xuICAgICAgICAgICAgaWYgKCRwb3Mubm9kZShkKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIG5vZGVUeXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5iZWZvcmUoZCArIDEpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PSAkcG9zLnBhcmVudC5jb250ZW50LnNpemUpXG4gICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXhBZnRlcihkKTtcbiAgICAgICAgICAgIGlmICgkcG9zLm5vZGUoZCkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBub2RlVHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3MuYWZ0ZXIoZCArIDEpO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgJHBvcy5ub2RlKGQpLmNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuRmluZHMgYSBwb3NpdGlvbiBhdCBvciBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uIHdoZXJlIHRoZSBnaXZlblxuc2xpY2UgY2FuIGJlIGluc2VydGVkLiBXaWxsIGxvb2sgYXQgcGFyZW50IG5vZGVzJyBuZWFyZXN0IGJvdW5kYXJ5XG5hbmQgdHJ5IHRoZXJlLCBldmVuIGlmIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiB3YXNuJ3QgZGlyZWN0bHkgYXQgdGhlXG5zdGFydCBvciBlbmQgb2YgdGhhdCBub2RlLiBSZXR1cm5zIG51bGwgd2hlbiBubyBwb3NpdGlvbiB3YXMgZm91bmQuXG4qL1xuZnVuY3Rpb24gZHJvcFBvaW50KGRvYywgcG9zLCBzbGljZSkge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoIXNsaWNlLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBsZXQgY29udGVudCA9IHNsaWNlLmNvbnRlbnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGljZS5vcGVuU3RhcnQ7IGkrKylcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgIGZvciAobGV0IHBhc3MgPSAxOyBwYXNzIDw9IChzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5zaXplID8gMiA6IDEpOyBwYXNzKyspIHtcbiAgICAgICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBsZXQgYmlhcyA9IGQgPT0gJHBvcy5kZXB0aCA/IDAgOiAkcG9zLnBvcyA8PSAoJHBvcy5zdGFydChkICsgMSkgKyAkcG9zLmVuZChkICsgMSkpIC8gMiA/IC0xIDogMTtcbiAgICAgICAgICAgIGxldCBpbnNlcnRQb3MgPSAkcG9zLmluZGV4KGQpICsgKGJpYXMgPiAwID8gMSA6IDApO1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9ICRwb3Mubm9kZShkKSwgZml0cyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHBhc3MgPT0gMSkge1xuICAgICAgICAgICAgICAgIGZpdHMgPSBwYXJlbnQuY2FuUmVwbGFjZShpbnNlcnRQb3MsIGluc2VydFBvcywgY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcHBpbmcgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoaW5zZXJ0UG9zKS5maW5kV3JhcHBpbmcoY29udGVudC5maXJzdENoaWxkLnR5cGUpO1xuICAgICAgICAgICAgICAgIGZpdHMgPSB3cmFwcGluZyAmJiBwYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5zZXJ0UG9zLCBpbnNlcnRQb3MsIHdyYXBwaW5nWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXRzKVxuICAgICAgICAgICAgICAgIHJldHVybiBiaWFzID09IDAgPyAkcG9zLnBvcyA6IGJpYXMgPCAwID8gJHBvcy5iZWZvcmUoZCArIDEpIDogJHBvcy5hZnRlcihkICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuXHUyMDE4Rml0XHUyMDE5IGEgc2xpY2UgaW50byBhIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCwgcHJvZHVjaW5nIGFcbltzdGVwXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXApIHRoYXQgaW5zZXJ0cyBpdC4gV2lsbCByZXR1cm4gbnVsbCBpZlxudGhlcmUncyBubyBtZWFuaW5nZnVsIHdheSB0byBpbnNlcnQgdGhlIHNsaWNlIGhlcmUsIG9yIGluc2VydGluZyBpdFxud291bGQgYmUgYSBuby1vcCAoYW4gZW1wdHkgc2xpY2Ugb3ZlciBhbiBlbXB0eSByYW5nZSkuXG4qL1xuZnVuY3Rpb24gcmVwbGFjZVN0ZXAoZG9jLCBmcm9tLCB0byA9IGZyb20sIHNsaWNlID0gU2xpY2UuZW1wdHkpIHtcbiAgICBpZiAoZnJvbSA9PSB0byAmJiAhc2xpY2Uuc2l6ZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0ICRmcm9tID0gZG9jLnJlc29sdmUoZnJvbSksICR0byA9IGRvYy5yZXNvbHZlKHRvKTtcbiAgICAvLyBPcHRpbWl6YXRpb24gLS0gYXZvaWQgd29yayBpZiBpdCdzIG9idmlvdXMgdGhhdCBpdCdzIG5vdCBuZWVkZWQuXG4gICAgaWYgKGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpKVxuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGZyb20sIHRvLCBzbGljZSk7XG4gICAgcmV0dXJuIG5ldyBGaXR0ZXIoJGZyb20sICR0bywgc2xpY2UpLmZpdCgpO1xufVxuZnVuY3Rpb24gZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkge1xuICAgIHJldHVybiAhc2xpY2Uub3BlblN0YXJ0ICYmICFzbGljZS5vcGVuRW5kICYmICRmcm9tLnN0YXJ0KCkgPT0gJHRvLnN0YXJ0KCkgJiZcbiAgICAgICAgJGZyb20ucGFyZW50LmNhblJlcGxhY2UoJGZyb20uaW5kZXgoKSwgJHRvLmluZGV4KCksIHNsaWNlLmNvbnRlbnQpO1xufVxuLy8gQWxnb3JpdGhtIGZvciAncGxhY2luZycgdGhlIGVsZW1lbnRzIG9mIGEgc2xpY2UgaW50byBhIGdhcDpcbi8vXG4vLyBXZSBjb25zaWRlciB0aGUgY29udGVudCBvZiBlYWNoIG5vZGUgdGhhdCBpcyBvcGVuIHRvIHRoZSBsZWZ0IHRvIGJlXG4vLyBpbmRlcGVuZGVudGx5IHBsYWNlYWJsZS4gSS5lLiBpbiA8cChcImZvb1wiKSwgcChcImJhclwiKT4sIHdoZW4gdGhlXG4vLyBwYXJhZ3JhcGggb24gdGhlIGxlZnQgaXMgb3BlbiwgXCJmb29cIiBjYW4gYmUgcGxhY2VkIChzb21ld2hlcmUgb25cbi8vIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHJlcGxhY2VtZW50IGdhcCkgaW5kZXBlbmRlbnRseSBmcm9tIHAoXCJiYXJcIikuXG4vL1xuLy8gVGhpcyBjbGFzcyB0cmFja3MgdGhlIHN0YXRlIG9mIHRoZSBwbGFjZW1lbnQgcHJvZ3Jlc3MgaW4gdGhlXG4vLyBmb2xsb3dpbmcgcHJvcGVydGllczpcbi8vXG4vLyAgLSBgZnJvbnRpZXJgIGhvbGRzIGEgc3RhY2sgb2YgYHt0eXBlLCBtYXRjaH1gIG9iamVjdHMgdGhhdFxuLy8gICAgcmVwcmVzZW50IHRoZSBvcGVuIHNpZGUgb2YgdGhlIHJlcGxhY2VtZW50LiBJdCBzdGFydHMgYXRcbi8vICAgIGAkZnJvbWAsIHRoZW4gbW92ZXMgZm9yd2FyZCBhcyBjb250ZW50IGlzIHBsYWNlZCwgYW5kIGlzIGZpbmFsbHlcbi8vICAgIHJlY29uY2lsZWQgd2l0aCBgJHRvYC5cbi8vXG4vLyAgLSBgdW5wbGFjZWRgIGlzIGEgc2xpY2UgdGhhdCByZXByZXNlbnRzIHRoZSBjb250ZW50IHRoYXQgaGFzbid0XG4vLyAgICBiZWVuIHBsYWNlZCB5ZXQuXG4vL1xuLy8gIC0gYHBsYWNlZGAgaXMgYSBmcmFnbWVudCBvZiBwbGFjZWQgY29udGVudC4gSXRzIG9wZW4tc3RhcnQgdmFsdWVcbi8vICAgIGlzIGltcGxpY2l0IGluIGAkZnJvbWAsIGFuZCBpdHMgb3Blbi1lbmQgdmFsdWUgaW4gYGZyb250aWVyYC5cbmNsYXNzIEZpdHRlciB7XG4gICAgY29uc3RydWN0b3IoJGZyb20sICR0bywgdW5wbGFjZWQpIHtcbiAgICAgICAgdGhpcy4kZnJvbSA9ICRmcm9tO1xuICAgICAgICB0aGlzLiR0byA9ICR0bztcbiAgICAgICAgdGhpcy51bnBsYWNlZCA9IHVucGxhY2VkO1xuICAgICAgICB0aGlzLmZyb250aWVyID0gW107XG4gICAgICAgIHRoaXMucGxhY2VkID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9ICRmcm9tLmRlcHRoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gJGZyb20ubm9kZShpKTtcbiAgICAgICAgICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIG1hdGNoOiBub2RlLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoaSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gJGZyb20uZGVwdGg7IGkgPiAwOyBpLS0pXG4gICAgICAgICAgICB0aGlzLnBsYWNlZCA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShpKS5jb3B5KHRoaXMucGxhY2VkKSk7XG4gICAgfVxuICAgIGdldCBkZXB0aCgpIHsgcmV0dXJuIHRoaXMuZnJvbnRpZXIubGVuZ3RoIC0gMTsgfVxuICAgIGZpdCgpIHtcbiAgICAgICAgLy8gQXMgbG9uZyBhcyB0aGVyZSdzIHVucGxhY2VkIGNvbnRlbnQsIHRyeSB0byBwbGFjZSBzb21lIG9mIGl0LlxuICAgICAgICAvLyBJZiB0aGF0IGZhaWxzLCBlaXRoZXIgaW5jcmVhc2UgdGhlIG9wZW4gc2NvcmUgb2YgdGhlIHVucGxhY2VkXG4gICAgICAgIC8vIHNsaWNlLCBvciBkcm9wIG5vZGVzIGZyb20gaXQsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICAgICAgd2hpbGUgKHRoaXMudW5wbGFjZWQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGZpdCA9IHRoaXMuZmluZEZpdHRhYmxlKCk7XG4gICAgICAgICAgICBpZiAoZml0KVxuICAgICAgICAgICAgICAgIHRoaXMucGxhY2VOb2RlcyhmaXQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMub3Blbk1vcmUoKSB8fCB0aGlzLmRyb3BOb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB0aGVyZSdzIGlubGluZSBjb250ZW50IGRpcmVjdGx5IGFmdGVyIHRoZSBmcm9udGllciBfYW5kX1xuICAgICAgICAvLyBkaXJlY3RseSBhZnRlciBgdGhpcy4kdG9gLCB3ZSBtdXN0IGdlbmVyYXRlIGEgYFJlcGxhY2VBcm91bmRgXG4gICAgICAgIC8vIHN0ZXAgdGhhdCBwdWxscyB0aGF0IGNvbnRlbnQgaW50byB0aGUgbm9kZSBhZnRlciB0aGUgZnJvbnRpZXIuXG4gICAgICAgIC8vIFRoYXQgbWVhbnMgdGhlIGZpdHRpbmcgbXVzdCBiZSBkb25lIHRvIHRoZSBlbmQgb2YgdGhlIHRleHRibG9ja1xuICAgICAgICAvLyBub2RlIGFmdGVyIGB0aGlzLiR0b2AsIG5vdCBgdGhpcy4kdG9gIGl0c2VsZi5cbiAgICAgICAgbGV0IG1vdmVJbmxpbmUgPSB0aGlzLm11c3RNb3ZlSW5saW5lKCksIHBsYWNlZFNpemUgPSB0aGlzLnBsYWNlZC5zaXplIC0gdGhpcy5kZXB0aCAtIHRoaXMuJGZyb20uZGVwdGg7XG4gICAgICAgIGxldCAkZnJvbSA9IHRoaXMuJGZyb20sICR0byA9IHRoaXMuY2xvc2UobW92ZUlubGluZSA8IDAgPyB0aGlzLiR0byA6ICRmcm9tLmRvYy5yZXNvbHZlKG1vdmVJbmxpbmUpKTtcbiAgICAgICAgaWYgKCEkdG8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gSWYgY2xvc2luZyB0byBgJHRvYCBzdWNjZWVkZWQsIGNyZWF0ZSBhIHN0ZXBcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLnBsYWNlZCwgb3BlblN0YXJ0ID0gJGZyb20uZGVwdGgsIG9wZW5FbmQgPSAkdG8uZGVwdGg7XG4gICAgICAgIHdoaWxlIChvcGVuU3RhcnQgJiYgb3BlbkVuZCAmJiBjb250ZW50LmNoaWxkQ291bnQgPT0gMSkgeyAvLyBOb3JtYWxpemUgYnkgZHJvcHBpbmcgb3BlbiBwYXJlbnQgbm9kZXNcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgICAgICAgICAgIG9wZW5TdGFydC0tO1xuICAgICAgICAgICAgb3BlbkVuZC0tO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICBpZiAobW92ZUlubGluZSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkZnJvbS5wb3MsIG1vdmVJbmxpbmUsIHRoaXMuJHRvLnBvcywgdGhpcy4kdG8uZW5kKCksIHNsaWNlLCBwbGFjZWRTaXplKTtcbiAgICAgICAgaWYgKHNsaWNlLnNpemUgfHwgJGZyb20ucG9zICE9IHRoaXMuJHRvLnBvcykgLy8gRG9uJ3QgZ2VuZXJhdGUgbm8tb3Agc3RlcHNcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoJGZyb20ucG9zLCAkdG8ucG9zLCBzbGljZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBGaW5kIGEgcG9zaXRpb24gb24gdGhlIHN0YXJ0IHNwaW5lIG9mIGB0aGlzLnVucGxhY2VkYCB0aGF0IGhhc1xuICAgIC8vIGNvbnRlbnQgdGhhdCBjYW4gYmUgbW92ZWQgc29tZXdoZXJlIG9uIHRoZSBmcm9udGllci4gUmV0dXJucyB0d29cbiAgICAvLyBkZXB0aHMsIG9uZSBmb3IgdGhlIHNsaWNlIGFuZCBvbmUgZm9yIHRoZSBmcm9udGllci5cbiAgICBmaW5kRml0dGFibGUoKSB7XG4gICAgICAgIGxldCBzdGFydERlcHRoID0gdGhpcy51bnBsYWNlZC5vcGVuU3RhcnQ7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IHRoaXMudW5wbGFjZWQuY29udGVudCwgZCA9IDAsIG9wZW5FbmQgPSB0aGlzLnVucGxhY2VkLm9wZW5FbmQ7IGQgPCBzdGFydERlcHRoOyBkKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gY3VyLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoY3VyLmNoaWxkQ291bnQgPiAxKVxuICAgICAgICAgICAgICAgIG9wZW5FbmQgPSAwO1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZS5zcGVjLmlzb2xhdGluZyAmJiBvcGVuRW5kIDw9IGQpIHtcbiAgICAgICAgICAgICAgICBzdGFydERlcHRoID0gZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IG5vZGUuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IHRyeSB3cmFwcGluZyBub2RlcyAocGFzcyAyKSBhZnRlciBmaW5kaW5nIGEgcGxhY2Ugd2l0aG91dFxuICAgICAgICAvLyB3cmFwcGluZyBmYWlsZWQuXG4gICAgICAgIGZvciAobGV0IHBhc3MgPSAxOyBwYXNzIDw9IDI7IHBhc3MrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgc2xpY2VEZXB0aCA9IHBhc3MgPT0gMSA/IHN0YXJ0RGVwdGggOiB0aGlzLnVucGxhY2VkLm9wZW5TdGFydDsgc2xpY2VEZXB0aCA+PSAwOyBzbGljZURlcHRoLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJhZ21lbnQsIHBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWNlRGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gY29udGVudEF0KHRoaXMudW5wbGFjZWQuY29udGVudCwgc2xpY2VEZXB0aCAtIDEpLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMudW5wbGFjZWQuY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBmcm9udGllckRlcHRoID0gdGhpcy5kZXB0aDsgZnJvbnRpZXJEZXB0aCA+PSAwOyBmcm9udGllckRlcHRoLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbWF0Y2ggfSA9IHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF0sIHdyYXAsIGluamVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHBhc3MgMSwgaWYgdGhlIG5leHQgbm9kZSBtYXRjaGVzLCBvciB0aGVyZSBpcyBubyBuZXh0XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vZGUgYnV0IHRoZSBwYXJlbnRzIGxvb2sgY29tcGF0aWJsZSwgd2UndmUgZm91bmQgYVxuICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhc3MgPT0gMSAmJiAoZmlyc3QgPyBtYXRjaC5tYXRjaFR5cGUoZmlyc3QudHlwZSkgfHwgKGluamVjdCA9IG1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZnJvbShmaXJzdCksIGZhbHNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGFyZW50ICYmIHR5cGUuY29tcGF0aWJsZUNvbnRlbnQocGFyZW50LnR5cGUpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGgsIHBhcmVudCwgaW5qZWN0IH07XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHBhc3MgMiwgbG9vayBmb3IgYSBzZXQgb2Ygd3JhcHBpbmcgbm9kZXMgdGhhdCBtYWtlXG4gICAgICAgICAgICAgICAgICAgIC8vIGBmaXJzdGAgZml0IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhc3MgPT0gMiAmJiBmaXJzdCAmJiAod3JhcCA9IG1hdGNoLmZpbmRXcmFwcGluZyhmaXJzdC50eXBlKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzbGljZURlcHRoLCBmcm9udGllckRlcHRoLCBwYXJlbnQsIHdyYXAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY29udGludWUgbG9va2luZyBmdXJ0aGVyIHVwIGlmIHRoZSBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyB3b3VsZCBmaXQgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBtYXRjaC5tYXRjaFR5cGUocGFyZW50LnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG9wZW5Nb3JlKCkge1xuICAgICAgICBsZXQgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHRoaXMudW5wbGFjZWQ7XG4gICAgICAgIGxldCBpbm5lciA9IGNvbnRlbnRBdChjb250ZW50LCBvcGVuU3RhcnQpO1xuICAgICAgICBpZiAoIWlubmVyLmNoaWxkQ291bnQgfHwgaW5uZXIuZmlyc3RDaGlsZC5pc0xlYWYpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgU2xpY2UoY29udGVudCwgb3BlblN0YXJ0ICsgMSwgTWF0aC5tYXgob3BlbkVuZCwgaW5uZXIuc2l6ZSArIG9wZW5TdGFydCA+PSBjb250ZW50LnNpemUgLSBvcGVuRW5kID8gb3BlblN0YXJ0ICsgMSA6IDApKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRyb3BOb2RlKCkge1xuICAgICAgICBsZXQgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHRoaXMudW5wbGFjZWQ7XG4gICAgICAgIGxldCBpbm5lciA9IGNvbnRlbnRBdChjb250ZW50LCBvcGVuU3RhcnQpO1xuICAgICAgICBpZiAoaW5uZXIuY2hpbGRDb3VudCA8PSAxICYmIG9wZW5TdGFydCA+IDApIHtcbiAgICAgICAgICAgIGxldCBvcGVuQXRFbmQgPSBjb250ZW50LnNpemUgLSBvcGVuU3RhcnQgPD0gb3BlblN0YXJ0ICsgaW5uZXIuc2l6ZTtcbiAgICAgICAgICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChjb250ZW50LCBvcGVuU3RhcnQgLSAxLCAxKSwgb3BlblN0YXJ0IC0gMSwgb3BlbkF0RW5kID8gb3BlblN0YXJ0IC0gMSA6IG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KGNvbnRlbnQsIG9wZW5TdGFydCwgMSksIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTW92ZSBjb250ZW50IGZyb20gdGhlIHVucGxhY2VkIHNsaWNlIGF0IGBzbGljZURlcHRoYCB0byB0aGVcbiAgICAvLyBmcm9udGllciBub2RlIGF0IGBmcm9udGllckRlcHRoYC4gQ2xvc2UgdGhhdCBmcm9udGllciBub2RlIHdoZW5cbiAgICAvLyBhcHBsaWNhYmxlLlxuICAgIHBsYWNlTm9kZXMoeyBzbGljZURlcHRoLCBmcm9udGllckRlcHRoLCBwYXJlbnQsIGluamVjdCwgd3JhcCB9KSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmRlcHRoID4gZnJvbnRpZXJEZXB0aClcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGcm9udGllck5vZGUoKTtcbiAgICAgICAgaWYgKHdyYXApXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXAubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuRnJvbnRpZXJOb2RlKHdyYXBbaV0pO1xuICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLnVucGxhY2VkLCBmcmFnbWVudCA9IHBhcmVudCA/IHBhcmVudC5jb250ZW50IDogc2xpY2UuY29udGVudDtcbiAgICAgICAgbGV0IG9wZW5TdGFydCA9IHNsaWNlLm9wZW5TdGFydCAtIHNsaWNlRGVwdGg7XG4gICAgICAgIGxldCB0YWtlbiA9IDAsIGFkZCA9IFtdO1xuICAgICAgICBsZXQgeyBtYXRjaCwgdHlwZSB9ID0gdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXTtcbiAgICAgICAgaWYgKGluamVjdCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmplY3QuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICAgICAgICAgIGFkZC5wdXNoKGluamVjdC5jaGlsZChpKSk7XG4gICAgICAgICAgICBtYXRjaCA9IG1hdGNoLm1hdGNoRnJhZ21lbnQoaW5qZWN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlcyB0aGUgYW1vdW50IG9mIChlbmQpIG9wZW4gbm9kZXMgYXQgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgLy8gZnJhZ21lbnQuIFdoZW4gMCwgdGhlIHBhcmVudCBpcyBvcGVuLCBidXQgbm8gbW9yZS4gV2hlblxuICAgICAgICAvLyBuZWdhdGl2ZSwgbm90aGluZyBpcyBvcGVuLlxuICAgICAgICBsZXQgb3BlbkVuZENvdW50ID0gKGZyYWdtZW50LnNpemUgKyBzbGljZURlcHRoKSAtIChzbGljZS5jb250ZW50LnNpemUgLSBzbGljZS5vcGVuRW5kKTtcbiAgICAgICAgLy8gU2NhbiBvdmVyIHRoZSBmcmFnbWVudCwgZml0dGluZyBhcyBtYW55IGNoaWxkIG5vZGVzIGFzXG4gICAgICAgIC8vIHBvc3NpYmxlLlxuICAgICAgICB3aGlsZSAodGFrZW4gPCBmcmFnbWVudC5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGZyYWdtZW50LmNoaWxkKHRha2VuKSwgbWF0Y2hlcyA9IG1hdGNoLm1hdGNoVHlwZShuZXh0LnR5cGUpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdGFrZW4rKztcbiAgICAgICAgICAgIGlmICh0YWtlbiA+IDEgfHwgb3BlblN0YXJ0ID09IDAgfHwgbmV4dC5jb250ZW50LnNpemUpIHsgLy8gRHJvcCBlbXB0eSBvcGVuIG5vZGVzXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaGVzO1xuICAgICAgICAgICAgICAgIGFkZC5wdXNoKGNsb3NlTm9kZVN0YXJ0KG5leHQubWFyayh0eXBlLmFsbG93ZWRNYXJrcyhuZXh0Lm1hcmtzKSksIHRha2VuID09IDEgPyBvcGVuU3RhcnQgOiAwLCB0YWtlbiA9PSBmcmFnbWVudC5jaGlsZENvdW50ID8gb3BlbkVuZENvdW50IDogLTEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9FbmQgPSB0YWtlbiA9PSBmcmFnbWVudC5jaGlsZENvdW50O1xuICAgICAgICBpZiAoIXRvRW5kKVxuICAgICAgICAgICAgb3BlbkVuZENvdW50ID0gLTE7XG4gICAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgZnJvbnRpZXJEZXB0aCwgRnJhZ21lbnQuZnJvbShhZGQpKTtcbiAgICAgICAgdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXS5tYXRjaCA9IG1hdGNoO1xuICAgICAgICAvLyBJZiB0aGUgcGFyZW50IHR5cGVzIG1hdGNoLCBhbmQgdGhlIGVudGlyZSBub2RlIHdhcyBtb3ZlZCwgYW5kXG4gICAgICAgIC8vIGl0J3Mgbm90IG9wZW4sIGNsb3NlIHRoaXMgZnJvbnRpZXIgbm9kZSByaWdodCBhd2F5LlxuICAgICAgICBpZiAodG9FbmQgJiYgb3BlbkVuZENvdW50IDwgMCAmJiBwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXS50eXBlICYmIHRoaXMuZnJvbnRpZXIubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGcm9udGllck5vZGUoKTtcbiAgICAgICAgLy8gQWRkIG5ldyBmcm9udGllciBub2RlcyBmb3IgYW55IG9wZW4gbm9kZXMgYXQgdGhlIGVuZC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGN1ciA9IGZyYWdtZW50OyBpIDwgb3BlbkVuZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gY3VyLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7IHR5cGU6IG5vZGUudHlwZSwgbWF0Y2g6IG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KSB9KTtcbiAgICAgICAgICAgIGN1ciA9IG5vZGUuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgYHRoaXMudW5wbGFjZWRgLiBEcm9wIHRoZSBlbnRpcmUgbm9kZSBmcm9tIHdoaWNoIHdlXG4gICAgICAgIC8vIHBsYWNlZCBpdCB3ZSBnb3QgdG8gaXRzIGVuZCwgb3RoZXJ3aXNlIGp1c3QgZHJvcCB0aGUgcGxhY2VkXG4gICAgICAgIC8vIG5vZGVzLlxuICAgICAgICB0aGlzLnVucGxhY2VkID0gIXRvRW5kID8gbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoc2xpY2UuY29udGVudCwgc2xpY2VEZXB0aCwgdGFrZW4pLCBzbGljZS5vcGVuU3RhcnQsIHNsaWNlLm9wZW5FbmQpXG4gICAgICAgICAgICA6IHNsaWNlRGVwdGggPT0gMCA/IFNsaWNlLmVtcHR5XG4gICAgICAgICAgICAgICAgOiBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChzbGljZS5jb250ZW50LCBzbGljZURlcHRoIC0gMSwgMSksIHNsaWNlRGVwdGggLSAxLCBvcGVuRW5kQ291bnQgPCAwID8gc2xpY2Uub3BlbkVuZCA6IHNsaWNlRGVwdGggLSAxKTtcbiAgICB9XG4gICAgbXVzdE1vdmVJbmxpbmUoKSB7XG4gICAgICAgIGlmICghdGhpcy4kdG8ucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBsZXQgdG9wID0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXSwgbGV2ZWw7XG4gICAgICAgIGlmICghdG9wLnR5cGUuaXNUZXh0YmxvY2sgfHwgIWNvbnRlbnRBZnRlckZpdHModGhpcy4kdG8sIHRoaXMuJHRvLmRlcHRoLCB0b3AudHlwZSwgdG9wLm1hdGNoLCBmYWxzZSkgfHxcbiAgICAgICAgICAgICh0aGlzLiR0by5kZXB0aCA9PSB0aGlzLmRlcHRoICYmIChsZXZlbCA9IHRoaXMuZmluZENsb3NlTGV2ZWwodGhpcy4kdG8pKSAmJiBsZXZlbC5kZXB0aCA9PSB0aGlzLmRlcHRoKSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgbGV0IHsgZGVwdGggfSA9IHRoaXMuJHRvLCBhZnRlciA9IHRoaXMuJHRvLmFmdGVyKGRlcHRoKTtcbiAgICAgICAgd2hpbGUgKGRlcHRoID4gMSAmJiBhZnRlciA9PSB0aGlzLiR0by5lbmQoLS1kZXB0aCkpXG4gICAgICAgICAgICArK2FmdGVyO1xuICAgICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgfVxuICAgIGZpbmRDbG9zZUxldmVsKCR0bykge1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBpID0gTWF0aC5taW4odGhpcy5kZXB0aCwgJHRvLmRlcHRoKTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB7IG1hdGNoLCB0eXBlIH0gPSB0aGlzLmZyb250aWVyW2ldO1xuICAgICAgICAgICAgbGV0IGRyb3BJbm5lciA9IGkgPCAkdG8uZGVwdGggJiYgJHRvLmVuZChpICsgMSkgPT0gJHRvLnBvcyArICgkdG8uZGVwdGggLSAoaSArIDEpKTtcbiAgICAgICAgICAgIGxldCBmaXQgPSBjb250ZW50QWZ0ZXJGaXRzKCR0bywgaSwgdHlwZSwgbWF0Y2gsIGRyb3BJbm5lcik7XG4gICAgICAgICAgICBpZiAoIWZpdClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSBpIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBtYXRjaCwgdHlwZSB9ID0gdGhpcy5mcm9udGllcltkXTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlcyA9IGNvbnRlbnRBZnRlckZpdHMoJHRvLCBkLCB0eXBlLCBtYXRjaCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRlcHRoOiBpLCBmaXQsIG1vdmU6IGRyb3BJbm5lciA/ICR0by5kb2MucmVzb2x2ZSgkdG8uYWZ0ZXIoaSArIDEpKSA6ICR0byB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCR0bykge1xuICAgICAgICBsZXQgY2xvc2UgPSB0aGlzLmZpbmRDbG9zZUxldmVsKCR0byk7XG4gICAgICAgIGlmICghY2xvc2UpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHRoaXMuZGVwdGggPiBjbG9zZS5kZXB0aClcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGcm9udGllck5vZGUoKTtcbiAgICAgICAgaWYgKGNsb3NlLmZpdC5jaGlsZENvdW50KVxuICAgICAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCBjbG9zZS5kZXB0aCwgY2xvc2UuZml0KTtcbiAgICAgICAgJHRvID0gY2xvc2UubW92ZTtcbiAgICAgICAgZm9yIChsZXQgZCA9IGNsb3NlLmRlcHRoICsgMTsgZCA8PSAkdG8uZGVwdGg7IGQrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSAkdG8ubm9kZShkKSwgYWRkID0gbm9kZS50eXBlLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKG5vZGUuY29udGVudCwgdHJ1ZSwgJHRvLmluZGV4KGQpKTtcbiAgICAgICAgICAgIHRoaXMub3BlbkZyb250aWVyTm9kZShub2RlLnR5cGUsIG5vZGUuYXR0cnMsIGFkZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0bztcbiAgICB9XG4gICAgb3BlbkZyb250aWVyTm9kZSh0eXBlLCBhdHRycyA9IG51bGwsIGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMuZnJvbnRpZXJbdGhpcy5kZXB0aF07XG4gICAgICAgIHRvcC5tYXRjaCA9IHRvcC5tYXRjaC5tYXRjaFR5cGUodHlwZSk7XG4gICAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgdGhpcy5kZXB0aCwgRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZShhdHRycywgY29udGVudCkpKTtcbiAgICAgICAgdGhpcy5mcm9udGllci5wdXNoKHsgdHlwZSwgbWF0Y2g6IHR5cGUuY29udGVudE1hdGNoIH0pO1xuICAgIH1cbiAgICBjbG9zZUZyb250aWVyTm9kZSgpIHtcbiAgICAgICAgbGV0IG9wZW4gPSB0aGlzLmZyb250aWVyLnBvcCgpO1xuICAgICAgICBsZXQgYWRkID0gb3Blbi5tYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgICAgaWYgKGFkZC5jaGlsZENvdW50KVxuICAgICAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCB0aGlzLmZyb250aWVyLmxlbmd0aCwgYWRkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkcm9wRnJvbUZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgY291bnQpIHtcbiAgICBpZiAoZGVwdGggPT0gMClcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LmN1dEJ5SW5kZXgoY291bnQsIGZyYWdtZW50LmNoaWxkQ291bnQpO1xuICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoMCwgZnJhZ21lbnQuZmlyc3RDaGlsZC5jb3B5KGRyb3BGcm9tRnJhZ21lbnQoZnJhZ21lbnQuZmlyc3RDaGlsZC5jb250ZW50LCBkZXB0aCAtIDEsIGNvdW50KSkpO1xufVxuZnVuY3Rpb24gYWRkVG9GcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIGNvbnRlbnQpIHtcbiAgICBpZiAoZGVwdGggPT0gMClcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LmFwcGVuZChjb250ZW50KTtcbiAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZUNoaWxkKGZyYWdtZW50LmNoaWxkQ291bnQgLSAxLCBmcmFnbWVudC5sYXN0Q2hpbGQuY29weShhZGRUb0ZyYWdtZW50KGZyYWdtZW50Lmxhc3RDaGlsZC5jb250ZW50LCBkZXB0aCAtIDEsIGNvbnRlbnQpKSk7XG59XG5mdW5jdGlvbiBjb250ZW50QXQoZnJhZ21lbnQsIGRlcHRoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXB0aDsgaSsrKVxuICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5mdW5jdGlvbiBjbG9zZU5vZGVTdGFydChub2RlLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBpZiAob3BlblN0YXJ0IDw9IDApXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIGxldCBmcmFnID0gbm9kZS5jb250ZW50O1xuICAgIGlmIChvcGVuU3RhcnQgPiAxKVxuICAgICAgICBmcmFnID0gZnJhZy5yZXBsYWNlQ2hpbGQoMCwgY2xvc2VOb2RlU3RhcnQoZnJhZy5maXJzdENoaWxkLCBvcGVuU3RhcnQgLSAxLCBmcmFnLmNoaWxkQ291bnQgPT0gMSA/IG9wZW5FbmQgLSAxIDogMCkpO1xuICAgIGlmIChvcGVuU3RhcnQgPiAwKSB7XG4gICAgICAgIGZyYWcgPSBub2RlLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoZnJhZykuYXBwZW5kKGZyYWcpO1xuICAgICAgICBpZiAob3BlbkVuZCA8PSAwKVxuICAgICAgICAgICAgZnJhZyA9IGZyYWcuYXBwZW5kKG5vZGUudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChmcmFnKS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLmNvcHkoZnJhZyk7XG59XG5mdW5jdGlvbiBjb250ZW50QWZ0ZXJGaXRzKCR0bywgZGVwdGgsIHR5cGUsIG1hdGNoLCBvcGVuKSB7XG4gICAgbGV0IG5vZGUgPSAkdG8ubm9kZShkZXB0aCksIGluZGV4ID0gb3BlbiA/ICR0by5pbmRleEFmdGVyKGRlcHRoKSA6ICR0by5pbmRleChkZXB0aCk7XG4gICAgaWYgKGluZGV4ID09IG5vZGUuY2hpbGRDb3VudCAmJiAhdHlwZS5jb21wYXRpYmxlQ29udGVudChub2RlLnR5cGUpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZml0ID0gbWF0Y2guZmlsbEJlZm9yZShub2RlLmNvbnRlbnQsIHRydWUsIGluZGV4KTtcbiAgICByZXR1cm4gZml0ICYmICFpbnZhbGlkTWFya3ModHlwZSwgbm9kZS5jb250ZW50LCBpbmRleCkgPyBmaXQgOiBudWxsO1xufVxuZnVuY3Rpb24gaW52YWxpZE1hcmtzKHR5cGUsIGZyYWdtZW50LCBzdGFydCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGZyYWdtZW50LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgaWYgKCF0eXBlLmFsbG93c01hcmtzKGZyYWdtZW50LmNoaWxkKGkpLm1hcmtzKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRlZmluZXNDb250ZW50KHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZS5zcGVjLmRlZmluaW5nIHx8IHR5cGUuc3BlYy5kZWZpbmluZ0ZvckNvbnRlbnQ7XG59XG5mdW5jdGlvbiByZXBsYWNlUmFuZ2UodHIsIGZyb20sIHRvLCBzbGljZSkge1xuICAgIGlmICghc2xpY2Uuc2l6ZSlcbiAgICAgICAgcmV0dXJuIHRyLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICBsZXQgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gdHIuZG9jLnJlc29sdmUodG8pO1xuICAgIGlmIChmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSlcbiAgICAgICAgcmV0dXJuIHRyLnN0ZXAobmV3IFJlcGxhY2VTdGVwKGZyb20sIHRvLCBzbGljZSkpO1xuICAgIGxldCB0YXJnZXREZXB0aHMgPSBjb3ZlcmVkRGVwdGhzKCRmcm9tLCB0ci5kb2MucmVzb2x2ZSh0bykpO1xuICAgIC8vIENhbid0IHJlcGxhY2UgdGhlIHdob2xlIGRvY3VtZW50LCBzbyByZW1vdmUgMCBpZiBpdCdzIHByZXNlbnRcbiAgICBpZiAodGFyZ2V0RGVwdGhzW3RhcmdldERlcHRocy5sZW5ndGggLSAxXSA9PSAwKVxuICAgICAgICB0YXJnZXREZXB0aHMucG9wKCk7XG4gICAgLy8gTmVnYXRpdmUgbnVtYmVycyByZXByZXNlbnQgbm90IGV4cGFuc2lvbiBvdmVyIHRoZSB3aG9sZSBub2RlIGF0XG4gICAgLy8gdGhhdCBkZXB0aCwgYnV0IHJlcGxhY2luZyBmcm9tICRmcm9tLmJlZm9yZSgtRCkgdG8gJHRvLnBvcy5cbiAgICBsZXQgcHJlZmVycmVkVGFyZ2V0ID0gLSgkZnJvbS5kZXB0aCArIDEpO1xuICAgIHRhcmdldERlcHRocy51bnNoaWZ0KHByZWZlcnJlZFRhcmdldCk7XG4gICAgLy8gVGhpcyBsb29wIHBpY2tzIGEgcHJlZmVycmVkIHRhcmdldCBkZXB0aCwgaWYgb25lIG9mIHRoZSBjb3ZlcmluZ1xuICAgIC8vIGRlcHRocyBpcyBub3Qgb3V0c2lkZSBvZiBhIGRlZmluaW5nIG5vZGUsIGFuZCBhZGRzIG5lZ2F0aXZlXG4gICAgLy8gZGVwdGhzIGZvciBhbnkgZGVwdGggdGhhdCBoYXMgJGZyb20gYXQgaXRzIHN0YXJ0IGFuZCBkb2VzIG5vdFxuICAgIC8vIGNyb3NzIGEgZGVmaW5pbmcgbm9kZS5cbiAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGgsIHBvcyA9ICRmcm9tLnBvcyAtIDE7IGQgPiAwOyBkLS0sIHBvcy0tKSB7XG4gICAgICAgIGxldCBzcGVjID0gJGZyb20ubm9kZShkKS50eXBlLnNwZWM7XG4gICAgICAgIGlmIChzcGVjLmRlZmluaW5nIHx8IHNwZWMuZGVmaW5pbmdBc0NvbnRleHQgfHwgc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHRhcmdldERlcHRocy5pbmRleE9mKGQpID4gLTEpXG4gICAgICAgICAgICBwcmVmZXJyZWRUYXJnZXQgPSBkO1xuICAgICAgICBlbHNlIGlmICgkZnJvbS5iZWZvcmUoZCkgPT0gcG9zKVxuICAgICAgICAgICAgdGFyZ2V0RGVwdGhzLnNwbGljZSgxLCAwLCAtZCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byBmaXQgZWFjaCBwb3NzaWJsZSBkZXB0aCBvZiB0aGUgc2xpY2UgaW50byBlYWNoIHBvc3NpYmxlXG4gICAgLy8gdGFyZ2V0IGRlcHRoLCBzdGFydGluZyB3aXRoIHRoZSBwcmVmZXJyZWQgZGVwdGhzLlxuICAgIGxldCBwcmVmZXJyZWRUYXJnZXRJbmRleCA9IHRhcmdldERlcHRocy5pbmRleE9mKHByZWZlcnJlZFRhcmdldCk7XG4gICAgbGV0IGxlZnROb2RlcyA9IFtdLCBwcmVmZXJyZWREZXB0aCA9IHNsaWNlLm9wZW5TdGFydDtcbiAgICBmb3IgKGxldCBjb250ZW50ID0gc2xpY2UuY29udGVudCwgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBjb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGxlZnROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoaSA9PSBzbGljZS5vcGVuU3RhcnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY29udGVudCA9IG5vZGUuY29udGVudDtcbiAgICB9XG4gICAgLy8gQmFjayB1cCBwcmVmZXJyZWREZXB0aCB0byBjb3ZlciBkZWZpbmluZyB0ZXh0YmxvY2tzIGRpcmVjdGx5XG4gICAgLy8gYWJvdmUgaXQsIHBvc3NpYmx5IHNraXBwaW5nIGEgbm9uLWRlZmluaW5nIHRleHRibG9jay5cbiAgICBmb3IgKGxldCBkID0gcHJlZmVycmVkRGVwdGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgbGVmdE5vZGUgPSBsZWZ0Tm9kZXNbZF0sIGRlZiA9IGRlZmluZXNDb250ZW50KGxlZnROb2RlLnR5cGUpO1xuICAgICAgICBpZiAoZGVmICYmICFsZWZ0Tm9kZS5zYW1lTWFya3VwKCRmcm9tLm5vZGUoTWF0aC5hYnMocHJlZmVycmVkVGFyZ2V0KSAtIDEpKSlcbiAgICAgICAgICAgIHByZWZlcnJlZERlcHRoID0gZDtcbiAgICAgICAgZWxzZSBpZiAoZGVmIHx8ICFsZWZ0Tm9kZS50eXBlLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBzbGljZS5vcGVuU3RhcnQ7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIGxldCBvcGVuRGVwdGggPSAoaiArIHByZWZlcnJlZERlcHRoICsgMSkgJSAoc2xpY2Uub3BlblN0YXJ0ICsgMSk7XG4gICAgICAgIGxldCBpbnNlcnQgPSBsZWZ0Tm9kZXNbb3BlbkRlcHRoXTtcbiAgICAgICAgaWYgKCFpbnNlcnQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXREZXB0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIExvb3Agb3ZlciBwb3NzaWJsZSBleHBhbnNpb24gbGV2ZWxzLCBzdGFydGluZyB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gcHJlZmVycmVkIG9uZVxuICAgICAgICAgICAgbGV0IHRhcmdldERlcHRoID0gdGFyZ2V0RGVwdGhzWyhpICsgcHJlZmVycmVkVGFyZ2V0SW5kZXgpICUgdGFyZ2V0RGVwdGhzLmxlbmd0aF0sIGV4cGFuZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RGVwdGggPCAwKSB7XG4gICAgICAgICAgICAgICAgZXhwYW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGVwdGggPSAtdGFyZ2V0RGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gJGZyb20ubm9kZSh0YXJnZXREZXB0aCAtIDEpLCBpbmRleCA9ICRmcm9tLmluZGV4KHRhcmdldERlcHRoIC0gMSk7XG4gICAgICAgICAgICBpZiAocGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgaW5zZXJ0LnR5cGUsIGluc2VydC5tYXJrcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyLnJlcGxhY2UoJGZyb20uYmVmb3JlKHRhcmdldERlcHRoKSwgZXhwYW5kID8gJHRvLmFmdGVyKHRhcmdldERlcHRoKSA6IHRvLCBuZXcgU2xpY2UoY2xvc2VGcmFnbWVudChzbGljZS5jb250ZW50LCAwLCBzbGljZS5vcGVuU3RhcnQsIG9wZW5EZXB0aCksIG9wZW5EZXB0aCwgc2xpY2Uub3BlbkVuZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdGFydFN0ZXBzID0gdHIuc3RlcHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSB0YXJnZXREZXB0aHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdHIucmVwbGFjZShmcm9tLCB0bywgc2xpY2UpO1xuICAgICAgICBpZiAodHIuc3RlcHMubGVuZ3RoID4gc3RhcnRTdGVwcylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgZGVwdGggPSB0YXJnZXREZXB0aHNbaV07XG4gICAgICAgIGlmIChkZXB0aCA8IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZnJvbSA9ICRmcm9tLmJlZm9yZShkZXB0aCk7XG4gICAgICAgIHRvID0gJHRvLmFmdGVyKGRlcHRoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbG9zZUZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgb2xkT3BlbiwgbmV3T3BlbiwgcGFyZW50KSB7XG4gICAgaWYgKGRlcHRoIDwgb2xkT3Blbikge1xuICAgICAgICBsZXQgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2VDaGlsZCgwLCBmaXJzdC5jb3B5KGNsb3NlRnJhZ21lbnQoZmlyc3QuY29udGVudCwgZGVwdGggKyAxLCBvbGRPcGVuLCBuZXdPcGVuLCBmaXJzdCkpKTtcbiAgICB9XG4gICAgaWYgKGRlcHRoID4gbmV3T3Blbikge1xuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJlbnQuY29udGVudE1hdGNoQXQoMCk7XG4gICAgICAgIGxldCBzdGFydCA9IG1hdGNoLmZpbGxCZWZvcmUoZnJhZ21lbnQpLmFwcGVuZChmcmFnbWVudCk7XG4gICAgICAgIGZyYWdtZW50ID0gc3RhcnQuYXBwZW5kKG1hdGNoLm1hdGNoRnJhZ21lbnQoc3RhcnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gcmVwbGFjZVJhbmdlV2l0aCh0ciwgZnJvbSwgdG8sIG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuaXNJbmxpbmUgJiYgZnJvbSA9PSB0byAmJiB0ci5kb2MucmVzb2x2ZShmcm9tKS5wYXJlbnQuY29udGVudC5zaXplKSB7XG4gICAgICAgIGxldCBwb2ludCA9IGluc2VydFBvaW50KHRyLmRvYywgZnJvbSwgbm9kZS50eXBlKTtcbiAgICAgICAgaWYgKHBvaW50ICE9IG51bGwpXG4gICAgICAgICAgICBmcm9tID0gdG8gPSBwb2ludDtcbiAgICB9XG4gICAgdHIucmVwbGFjZVJhbmdlKGZyb20sIHRvLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShub2RlKSwgMCwgMCkpO1xufVxuZnVuY3Rpb24gZGVsZXRlUmFuZ2UodHIsIGZyb20sIHRvKSB7XG4gICAgbGV0ICRmcm9tID0gdHIuZG9jLnJlc29sdmUoZnJvbSksICR0byA9IHRyLmRvYy5yZXNvbHZlKHRvKTtcbiAgICBsZXQgY292ZXJlZCA9IGNvdmVyZWREZXB0aHMoJGZyb20sICR0byk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3ZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBkZXB0aCA9IGNvdmVyZWRbaV0sIGxhc3QgPSBpID09IGNvdmVyZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKChsYXN0ICYmIGRlcHRoID09IDApIHx8ICRmcm9tLm5vZGUoZGVwdGgpLnR5cGUuY29udGVudE1hdGNoLnZhbGlkRW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRyLmRlbGV0ZSgkZnJvbS5zdGFydChkZXB0aCksICR0by5lbmQoZGVwdGgpKTtcbiAgICAgICAgaWYgKGRlcHRoID4gMCAmJiAobGFzdCB8fCAkZnJvbS5ub2RlKGRlcHRoIC0gMSkuY2FuUmVwbGFjZSgkZnJvbS5pbmRleChkZXB0aCAtIDEpLCAkdG8uaW5kZXhBZnRlcihkZXB0aCAtIDEpKSkpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLmJlZm9yZShkZXB0aCksICR0by5hZnRlcihkZXB0aCkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBkID0gMTsgZCA8PSAkZnJvbS5kZXB0aCAmJiBkIDw9ICR0by5kZXB0aDsgZCsrKSB7XG4gICAgICAgIGlmIChmcm9tIC0gJGZyb20uc3RhcnQoZCkgPT0gJGZyb20uZGVwdGggLSBkICYmIHRvID4gJGZyb20uZW5kKGQpICYmICR0by5lbmQoZCkgLSB0byAhPSAkdG8uZGVwdGggLSBkKVxuICAgICAgICAgICAgcmV0dXJuIHRyLmRlbGV0ZSgkZnJvbS5iZWZvcmUoZCksIHRvKTtcbiAgICB9XG4gICAgdHIuZGVsZXRlKGZyb20sIHRvKTtcbn1cbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGRlcHRocyBmb3Igd2hpY2ggJGZyb20gLSAkdG8gc3BhbnMgdGhlXG4vLyB3aG9sZSBjb250ZW50IG9mIHRoZSBub2RlcyBhdCB0aGF0IGRlcHRoLlxuZnVuY3Rpb24gY292ZXJlZERlcHRocygkZnJvbSwgJHRvKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdLCBtaW5EZXB0aCA9IE1hdGgubWluKCRmcm9tLmRlcHRoLCAkdG8uZGVwdGgpO1xuICAgIGZvciAobGV0IGQgPSBtaW5EZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gJGZyb20uc3RhcnQoZCk7XG4gICAgICAgIGlmIChzdGFydCA8ICRmcm9tLnBvcyAtICgkZnJvbS5kZXB0aCAtIGQpIHx8XG4gICAgICAgICAgICAkdG8uZW5kKGQpID4gJHRvLnBvcyArICgkdG8uZGVwdGggLSBkKSB8fFxuICAgICAgICAgICAgJGZyb20ubm9kZShkKS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8XG4gICAgICAgICAgICAkdG8ubm9kZShkKS50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChzdGFydCA9PSAkdG8uc3RhcnQoZCkgfHxcbiAgICAgICAgICAgIChkID09ICRmcm9tLmRlcHRoICYmIGQgPT0gJHRvLmRlcHRoICYmICRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50ICYmICR0by5wYXJlbnQuaW5saW5lQ29udGVudCAmJlxuICAgICAgICAgICAgICAgIGQgJiYgJHRvLnN0YXJ0KGQgLSAxKSA9PSBzdGFydCAtIDEpKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuVXBkYXRlIGFuIGF0dHJpYnV0ZSBpbiBhIHNwZWNpZmljIG5vZGUuXG4qL1xuY2xhc3MgQXR0clN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYW4gYXR0cmlidXRlIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBub2RlLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgYXR0cmlidXRlIHRvIHNldC5cbiAgICAqL1xuICAgIGF0dHIsIFxuICAgIC8vIFRoZSBhdHRyaWJ1dGUncyBuZXcgdmFsdWUuXG4gICAgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuYXR0ciA9IGF0dHI7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJObyBub2RlIGF0IGF0dHJpYnV0ZSBzdGVwJ3MgcG9zaXRpb25cIik7XG4gICAgICAgIGxldCBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gbm9kZS5hdHRycylcbiAgICAgICAgICAgIGF0dHJzW25hbWVdID0gbm9kZS5hdHRyc1tuYW1lXTtcbiAgICAgICAgYXR0cnNbdGhpcy5hdHRyXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbm9kZS50eXBlLmNyZWF0ZShhdHRycywgbnVsbCwgbm9kZS5tYXJrcyk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5wb3MsIHRoaXMucG9zICsgMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odXBkYXRlZCksIDAsIG5vZGUuaXNMZWFmID8gMCA6IDEpKTtcbiAgICB9XG4gICAgZ2V0TWFwKCkge1xuICAgICAgICByZXR1cm4gU3RlcE1hcC5lbXB0eTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJTdGVwKHRoaXMucG9zLCB0aGlzLmF0dHIsIGRvYy5ub2RlQXQodGhpcy5wb3MpLmF0dHJzW3RoaXMuYXR0cl0pO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgcG9zID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5wb3MsIDEpO1xuICAgICAgICByZXR1cm4gcG9zLmRlbGV0ZWRBZnRlciA/IG51bGwgOiBuZXcgQXR0clN0ZXAocG9zLnBvcywgdGhpcy5hdHRyLCB0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJhdHRyXCIsIHBvczogdGhpcy5wb3MsIGF0dHI6IHRoaXMuYXR0ciwgdmFsdWU6IHRoaXMudmFsdWUgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24ucG9zICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uYXR0ciAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBBdHRyU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyU3RlcChqc29uLnBvcywganNvbi5hdHRyLCBqc29uLnZhbHVlKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcImF0dHJcIiwgQXR0clN0ZXApO1xuLyoqXG5VcGRhdGUgYW4gYXR0cmlidXRlIGluIHRoZSBkb2Mgbm9kZS5cbiovXG5jbGFzcyBEb2NBdHRyU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhbiBhdHRyaWJ1dGUgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBhdHRyaWJ1dGUgdG8gc2V0LlxuICAgICovXG4gICAgYXR0ciwgXG4gICAgLy8gVGhlIGF0dHJpYnV0ZSdzIG5ldyB2YWx1ZS5cbiAgICB2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmF0dHIgPSBhdHRyO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGRvYy5hdHRycylcbiAgICAgICAgICAgIGF0dHJzW25hbWVdID0gZG9jLmF0dHJzW25hbWVdO1xuICAgICAgICBhdHRyc1t0aGlzLmF0dHJdID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBkb2MudHlwZS5jcmVhdGUoYXR0cnMsIGRvYy5jb250ZW50LCBkb2MubWFya3MpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5vayh1cGRhdGVkKTtcbiAgICB9XG4gICAgZ2V0TWFwKCkge1xuICAgICAgICByZXR1cm4gU3RlcE1hcC5lbXB0eTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IERvY0F0dHJTdGVwKHRoaXMuYXR0ciwgZG9jLmF0dHJzW3RoaXMuYXR0cl0pO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJkb2NBdHRyXCIsIGF0dHI6IHRoaXMuYXR0ciwgdmFsdWU6IHRoaXMudmFsdWUgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uYXR0ciAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBEb2NBdHRyU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2NBdHRyU3RlcChqc29uLmF0dHIsIGpzb24udmFsdWUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiZG9jQXR0clwiLCBEb2NBdHRyU3RlcCk7XG5cbi8qKlxuQGludGVybmFsXG4qL1xubGV0IFRyYW5zZm9ybUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG59O1xuVHJhbnNmb3JtRXJyb3IgPSBmdW5jdGlvbiBUcmFuc2Zvcm1FcnJvcihtZXNzYWdlKSB7XG4gICAgbGV0IGVyciA9IEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgZXJyLl9fcHJvdG9fXyA9IFRyYW5zZm9ybUVycm9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gZXJyO1xufTtcblRyYW5zZm9ybUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblRyYW5zZm9ybUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyYW5zZm9ybUVycm9yO1xuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIlRyYW5zZm9ybUVycm9yXCI7XG4vKipcbkFic3RyYWN0aW9uIHRvIGJ1aWxkIHVwIGFuZCB0cmFjayBhbiBhcnJheSBvZlxuW3N0ZXBzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXApIHJlcHJlc2VudGluZyBhIGRvY3VtZW50IHRyYW5zZm9ybWF0aW9uLlxuXG5Nb3N0IHRyYW5zZm9ybWluZyBtZXRob2RzIHJldHVybiB0aGUgYFRyYW5zZm9ybWAgb2JqZWN0IGl0c2VsZiwgc29cbnRoYXQgdGhleSBjYW4gYmUgY2hhaW5lZC5cbiovXG5jbGFzcyBUcmFuc2Zvcm0ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRyYW5zZm9ybSB0aGF0IHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGRvY3VtZW50ICh0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBzdGVwcyBpbiB0aGVcbiAgICB0cmFuc2Zvcm0pLlxuICAgICovXG4gICAgZG9jKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHN0ZXBzIGluIHRoaXMgdHJhbnNmb3JtLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0ZXBzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgZG9jdW1lbnRzIGJlZm9yZSBlYWNoIG9mIHRoZSBzdGVwcy5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb2NzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBBIG1hcHBpbmcgd2l0aCB0aGUgbWFwcyBmb3IgZWFjaCBvZiB0aGUgc3RlcHMgaW4gdGhpcyB0cmFuc2Zvcm0uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc3RhcnRpbmcgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgYmVmb3JlKCkgeyByZXR1cm4gdGhpcy5kb2NzLmxlbmd0aCA/IHRoaXMuZG9jc1swXSA6IHRoaXMuZG9jOyB9XG4gICAgLyoqXG4gICAgQXBwbHkgYSBuZXcgc3RlcCBpbiB0aGlzIHRyYW5zZm9ybSwgc2F2aW5nIHRoZSByZXN1bHQuIFRocm93cyBhblxuICAgIGVycm9yIHdoZW4gdGhlIHN0ZXAgZmFpbHMuXG4gICAgKi9cbiAgICBzdGVwKHN0ZXApIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubWF5YmVTdGVwKHN0ZXApO1xuICAgICAgICBpZiAocmVzdWx0LmZhaWxlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2Zvcm1FcnJvcihyZXN1bHQuZmFpbGVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBhcHBseSBhIHN0ZXAgaW4gdGhpcyB0cmFuc2Zvcm1hdGlvbiwgaWdub3JpbmcgaXQgaWYgaXRcbiAgICBmYWlscy4gUmV0dXJucyB0aGUgc3RlcCByZXN1bHQuXG4gICAgKi9cbiAgICBtYXliZVN0ZXAoc3RlcCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc3RlcC5hcHBseSh0aGlzLmRvYyk7XG4gICAgICAgIGlmICghcmVzdWx0LmZhaWxlZClcbiAgICAgICAgICAgIHRoaXMuYWRkU3RlcChzdGVwLCByZXN1bHQuZG9jKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoZSBkb2N1bWVudCBoYXMgYmVlbiBjaGFuZ2VkICh3aGVuIHRoZXJlIGFyZSBhbnlcbiAgICBzdGVwcykuXG4gICAgKi9cbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcHMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRTdGVwKHN0ZXAsIGRvYykge1xuICAgICAgICB0aGlzLmRvY3MucHVzaCh0aGlzLmRvYyk7XG4gICAgICAgIHRoaXMuc3RlcHMucHVzaChzdGVwKTtcbiAgICAgICAgdGhpcy5tYXBwaW5nLmFwcGVuZE1hcChzdGVwLmdldE1hcCgpKTtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIHdpdGggdGhlXG4gICAgZ2l2ZW4gYHNsaWNlYC5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8gPSBmcm9tLCBzbGljZSA9IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgIGxldCBzdGVwID0gcmVwbGFjZVN0ZXAodGhpcy5kb2MsIGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIGlmIChzdGVwKVxuICAgICAgICAgICAgdGhpcy5zdGVwKHN0ZXApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aCB0aGUgZ2l2ZW4gY29udGVudCwgd2hpY2ggbWF5IGJlIGFcbiAgICBmcmFnbWVudCwgbm9kZSwgb3IgYXJyYXkgb2Ygbm9kZXMuXG4gICAgKi9cbiAgICByZXBsYWNlV2l0aChmcm9tLCB0bywgY29udGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKGZyb20sIHRvLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShjb250ZW50KSwgMCwgMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9zaXRpb25zLlxuICAgICovXG4gICAgZGVsZXRlKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoZnJvbSwgdG8sIFNsaWNlLmVtcHR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5zZXJ0IHRoZSBnaXZlbiBjb250ZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGluc2VydChwb3MsIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVdpdGgocG9zLCBwb3MsIGNvbnRlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgcmFuZ2Ugb2YgdGhlIGRvY3VtZW50IHdpdGggYSBnaXZlbiBzbGljZSwgdXNpbmdcbiAgICBgZnJvbWAsIGB0b2AsIGFuZCB0aGUgc2xpY2Unc1xuICAgIFtgb3BlblN0YXJ0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlNsaWNlLm9wZW5TdGFydCkgcHJvcGVydHkgYXMgaGludHMsIHJhdGhlclxuICAgIHRoYW4gZml4ZWQgc3RhcnQgYW5kIGVuZCBwb2ludHMuIFRoaXMgbWV0aG9kIG1heSBncm93IHRoZVxuICAgIHJlcGxhY2VkIGFyZWEgb3IgY2xvc2Ugb3BlbiBub2RlcyBpbiB0aGUgc2xpY2UgaW4gb3JkZXIgdG8gZ2V0IGFcbiAgICBmaXQgdGhhdCBpcyBtb3JlIGluIGxpbmUgd2l0aCBXWVNJV1lHIGV4cGVjdGF0aW9ucywgYnkgZHJvcHBpbmdcbiAgICBmdWxseSBjb3ZlcmVkIHBhcmVudCBub2RlcyBvZiB0aGUgcmVwbGFjZWQgcmVnaW9uIHdoZW4gdGhleSBhcmVcbiAgICBtYXJrZWQgW25vbi1kZWZpbmluZyBhc1xuICAgIGNvbnRleHRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5kZWZpbmluZ0FzQ29udGV4dCksIG9yIGluY2x1ZGluZyBhblxuICAgIG9wZW4gcGFyZW50IG5vZGUgZnJvbSB0aGUgc2xpY2UgdGhhdCBfaXNfIG1hcmtlZCBhcyBbZGVmaW5pbmdcbiAgICBpdHMgY29udGVudF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmRlZmluaW5nRm9yQ29udGVudCkuXG4gICAgXG4gICAgVGhpcyBpcyB0aGUgbWV0aG9kLCBmb3IgZXhhbXBsZSwgdG8gaGFuZGxlIHBhc3RlLiBUaGUgc2ltaWxhclxuICAgIFtgcmVwbGFjZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uVHJhbnNmb3JtLnJlcGxhY2UpIG1ldGhvZCBpcyBhIG1vcmVcbiAgICBwcmltaXRpdmUgdG9vbCB3aGljaCB3aWxsIF9ub3RfIG1vdmUgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgaXRzIGdpdmVuXG4gICAgcmFuZ2UsIGFuZCBpcyB1c2VmdWwgaW4gc2l0dWF0aW9ucyB3aGVyZSB5b3UgbmVlZCBtb3JlIHByZWNpc2VcbiAgICBjb250cm9sIG92ZXIgd2hhdCBoYXBwZW5zLlxuICAgICovXG4gICAgcmVwbGFjZVJhbmdlKGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgICByZXBsYWNlUmFuZ2UodGhpcywgZnJvbSwgdG8sIHNsaWNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIGdpdmVuIHJhbmdlIHdpdGggYSBub2RlLCBidXQgdXNlIGBmcm9tYCBhbmQgYHRvYCBhc1xuICAgIGhpbnRzLCByYXRoZXIgdGhhbiBwcmVjaXNlIHBvc2l0aW9ucy4gV2hlbiBmcm9tIGFuZCB0byBhcmUgdGhlIHNhbWVcbiAgICBhbmQgYXJlIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgYSBwYXJlbnQgbm9kZSBpbiB3aGljaCB0aGUgZ2l2ZW5cbiAgICBub2RlIGRvZXNuJ3QgZml0LCB0aGlzIG1ldGhvZCBtYXkgX21vdmVfIHRoZW0gb3V0IHRvd2FyZHMgYSBwYXJlbnRcbiAgICB0aGF0IGRvZXMgYWxsb3cgdGhlIGdpdmVuIG5vZGUgdG8gYmUgcGxhY2VkLiBXaGVuIHRoZSBnaXZlbiByYW5nZVxuICAgIGNvbXBsZXRlbHkgY292ZXJzIGEgcGFyZW50IG5vZGUsIHRoaXMgbWV0aG9kIG1heSBjb21wbGV0ZWx5IHJlcGxhY2VcbiAgICB0aGF0IHBhcmVudCBub2RlLlxuICAgICovXG4gICAgcmVwbGFjZVJhbmdlV2l0aChmcm9tLCB0bywgbm9kZSkge1xuICAgICAgICByZXBsYWNlUmFuZ2VXaXRoKHRoaXMsIGZyb20sIHRvLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSB0aGUgZ2l2ZW4gcmFuZ2UsIGV4cGFuZGluZyBpdCB0byBjb3ZlciBmdWxseSBjb3ZlcmVkXG4gICAgcGFyZW50IG5vZGVzIHVudGlsIGEgdmFsaWQgcmVwbGFjZSBpcyBmb3VuZC5cbiAgICAqL1xuICAgIGRlbGV0ZVJhbmdlKGZyb20sIHRvKSB7XG4gICAgICAgIGRlbGV0ZVJhbmdlKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNwbGl0IHRoZSBjb250ZW50IGluIHRoZSBnaXZlbiByYW5nZSBvZmYgZnJvbSBpdHMgcGFyZW50LCBpZiB0aGVyZVxuICAgIGlzIHNpYmxpbmcgY29udGVudCBiZWZvcmUgb3IgYWZ0ZXIgaXQsIGFuZCBtb3ZlIGl0IHVwIHRoZSB0cmVlIHRvXG4gICAgdGhlIGRlcHRoIHNwZWNpZmllZCBieSBgdGFyZ2V0YC4gWW91J2xsIHByb2JhYmx5IHdhbnQgdG8gdXNlXG4gICAgW2BsaWZ0VGFyZ2V0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5saWZ0VGFyZ2V0KSB0byBjb21wdXRlIGB0YXJnZXRgLCB0byBtYWtlXG4gICAgc3VyZSB0aGUgbGlmdCBpcyB2YWxpZC5cbiAgICAqL1xuICAgIGxpZnQocmFuZ2UsIHRhcmdldCkge1xuICAgICAgICBsaWZ0KHRoaXMsIHJhbmdlLCB0YXJnZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgSm9pbiB0aGUgYmxvY2tzIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uIElmIGRlcHRoIGlzIDIsIHRoZWlyXG4gICAgbGFzdCBhbmQgZmlyc3Qgc2libGluZ3MgYXJlIGFsc28gam9pbmVkLCBhbmQgc28gb24uXG4gICAgKi9cbiAgICBqb2luKHBvcywgZGVwdGggPSAxKSB7XG4gICAgICAgIGpvaW4odGhpcywgcG9zLCBkZXB0aCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBXcmFwIHRoZSBnaXZlbiBbcmFuZ2VdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlUmFuZ2UpIGluIHRoZSBnaXZlbiBzZXQgb2Ygd3JhcHBlcnMuXG4gICAgVGhlIHdyYXBwZXJzIGFyZSBhc3N1bWVkIHRvIGJlIHZhbGlkIGluIHRoaXMgcG9zaXRpb24sIGFuZCBzaG91bGRcbiAgICBwcm9iYWJseSBiZSBjb21wdXRlZCB3aXRoIFtgZmluZFdyYXBwaW5nYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5maW5kV3JhcHBpbmcpLlxuICAgICovXG4gICAgd3JhcChyYW5nZSwgd3JhcHBlcnMpIHtcbiAgICAgICAgd3JhcCh0aGlzLCByYW5nZSwgd3JhcHBlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB0eXBlIG9mIGFsbCB0ZXh0YmxvY2tzIChwYXJ0bHkpIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIHRvXG4gICAgdGhlIGdpdmVuIG5vZGUgdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgc2V0QmxvY2tUeXBlKGZyb20sIHRvID0gZnJvbSwgdHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgICAgIHNldEJsb2NrVHlwZSh0aGlzLCBmcm9tLCB0bywgdHlwZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hhbmdlIHRoZSB0eXBlLCBhdHRyaWJ1dGVzLCBhbmQvb3IgbWFya3Mgb2YgdGhlIG5vZGUgYXQgYHBvc2AuXG4gICAgV2hlbiBgdHlwZWAgaXNuJ3QgZ2l2ZW4sIHRoZSBleGlzdGluZyBub2RlIHR5cGUgaXMgcHJlc2VydmVkLFxuICAgICovXG4gICAgc2V0Tm9kZU1hcmt1cChwb3MsIHR5cGUsIGF0dHJzID0gbnVsbCwgbWFya3MpIHtcbiAgICAgICAgc2V0Tm9kZU1hcmt1cCh0aGlzLCBwb3MsIHR5cGUsIGF0dHJzLCBtYXJrcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgYSBzaW5nbGUgYXR0cmlidXRlIG9uIGEgZ2l2ZW4gbm9kZSB0byBhIG5ldyB2YWx1ZS5cbiAgICBUaGUgYHBvc2AgYWRkcmVzc2VzIHRoZSBkb2N1bWVudCBjb250ZW50LiBVc2UgYHNldERvY0F0dHJpYnV0ZWBcbiAgICB0byBzZXQgYXR0cmlidXRlcyBvbiB0aGUgZG9jdW1lbnQgaXRzZWxmLlxuICAgICovXG4gICAgc2V0Tm9kZUF0dHJpYnV0ZShwb3MsIGF0dHIsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RlcChuZXcgQXR0clN0ZXAocG9zLCBhdHRyLCB2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IGEgc2luZ2xlIGF0dHJpYnV0ZSBvbiB0aGUgZG9jdW1lbnQgdG8gYSBuZXcgdmFsdWUuXG4gICAgKi9cbiAgICBzZXREb2NBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdGVwKG5ldyBEb2NBdHRyU3RlcChhdHRyLCB2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgbWFyayB0byB0aGUgbm9kZSBhdCBwb3NpdGlvbiBgcG9zYC5cbiAgICAqL1xuICAgIGFkZE5vZGVNYXJrKHBvcywgbWFyaykge1xuICAgICAgICB0aGlzLnN0ZXAobmV3IEFkZE5vZGVNYXJrU3RlcChwb3MsIG1hcmspKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZSBhIG1hcmsgKG9yIGEgbWFyayBvZiB0aGUgZ2l2ZW4gdHlwZSkgZnJvbSB0aGUgbm9kZSBhdFxuICAgIHBvc2l0aW9uIGBwb3NgLlxuICAgICovXG4gICAgcmVtb3ZlTm9kZU1hcmsocG9zLCBtYXJrKSB7XG4gICAgICAgIGlmICghKG1hcmsgaW5zdGFuY2VvZiBNYXJrKSkge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmRvYy5ub2RlQXQocG9zKTtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYXQgcG9zaXRpb24gXCIgKyBwb3MpO1xuICAgICAgICAgICAgbWFyayA9IG1hcmsuaXNJblNldChub2RlLm1hcmtzKTtcbiAgICAgICAgICAgIGlmICghbWFyaylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0ZXAobmV3IFJlbW92ZU5vZGVNYXJrU3RlcChwb3MsIG1hcmspKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNwbGl0IHRoZSBub2RlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgYW5kIG9wdGlvbmFsbHksIGlmIGBkZXB0aGAgaXNcbiAgICBncmVhdGVyIHRoYW4gb25lLCBhbnkgbnVtYmVyIG9mIG5vZGVzIGFib3ZlIHRoYXQuIEJ5IGRlZmF1bHQsIHRoZVxuICAgIHBhcnRzIHNwbGl0IG9mZiB3aWxsIGluaGVyaXQgdGhlIG5vZGUgdHlwZSBvZiB0aGUgb3JpZ2luYWwgbm9kZS5cbiAgICBUaGlzIGNhbiBiZSBjaGFuZ2VkIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgdHlwZXMgYW5kIGF0dHJpYnV0ZXMgdG9cbiAgICB1c2UgYWZ0ZXIgdGhlIHNwbGl0LlxuICAgICovXG4gICAgc3BsaXQocG9zLCBkZXB0aCA9IDEsIHR5cGVzQWZ0ZXIpIHtcbiAgICAgICAgc3BsaXQodGhpcywgcG9zLCBkZXB0aCwgdHlwZXNBZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgdGhlIGdpdmVuIG1hcmsgdG8gdGhlIGlubGluZSBjb250ZW50IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLlxuICAgICovXG4gICAgYWRkTWFyayhmcm9tLCB0bywgbWFyaykge1xuICAgICAgICBhZGRNYXJrKHRoaXMsIGZyb20sIHRvLCBtYXJrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZSBtYXJrcyBmcm9tIGlubGluZSBub2RlcyBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC4gV2hlblxuICAgIGBtYXJrYCBpcyBhIHNpbmdsZSBtYXJrLCByZW1vdmUgcHJlY2lzZWx5IHRoYXQgbWFyay4gV2hlbiBpdCBpc1xuICAgIGEgbWFyayB0eXBlLCByZW1vdmUgYWxsIG1hcmtzIG9mIHRoYXQgdHlwZS4gV2hlbiBpdCBpcyBudWxsLFxuICAgIHJlbW92ZSBhbGwgbWFya3Mgb2YgYW55IHR5cGUuXG4gICAgKi9cbiAgICByZW1vdmVNYXJrKGZyb20sIHRvLCBtYXJrKSB7XG4gICAgICAgIHJlbW92ZU1hcmsodGhpcywgZnJvbSwgdG8sIG1hcmspO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlcyBhbGwgbWFya3MgYW5kIG5vZGVzIGZyb20gdGhlIGNvbnRlbnQgb2YgdGhlIG5vZGUgYXRcbiAgICBgcG9zYCB0aGF0IGRvbid0IG1hdGNoIHRoZSBnaXZlbiBuZXcgcGFyZW50IG5vZGUgdHlwZS4gQWNjZXB0c1xuICAgIGFuIG9wdGlvbmFsIHN0YXJ0aW5nIFtjb250ZW50IG1hdGNoXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuQ29udGVudE1hdGNoKSBhc1xuICAgIHRoaXJkIGFyZ3VtZW50LlxuICAgICovXG4gICAgY2xlYXJJbmNvbXBhdGlibGUocG9zLCBwYXJlbnRUeXBlLCBtYXRjaCkge1xuICAgICAgICBjbGVhckluY29tcGF0aWJsZSh0aGlzLCBwb3MsIHBhcmVudFR5cGUsIG1hdGNoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5leHBvcnQgeyBBZGRNYXJrU3RlcCwgQWRkTm9kZU1hcmtTdGVwLCBBdHRyU3RlcCwgRG9jQXR0clN0ZXAsIE1hcFJlc3VsdCwgTWFwcGluZywgUmVtb3ZlTWFya1N0ZXAsIFJlbW92ZU5vZGVNYXJrU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIFJlcGxhY2VTdGVwLCBTdGVwLCBTdGVwTWFwLCBTdGVwUmVzdWx0LCBUcmFuc2Zvcm0sIFRyYW5zZm9ybUVycm9yLCBjYW5Kb2luLCBjYW5TcGxpdCwgZHJvcFBvaW50LCBmaW5kV3JhcHBpbmcsIGluc2VydFBvaW50LCBqb2luUG9pbnQsIGxpZnRUYXJnZXQsIHJlcGxhY2VTdGVwIH07XG4iLCAiaW1wb3J0IHsgU2xpY2UsIEZyYWdtZW50LCBNYXJrLCBOb2RlIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgUmVwbGFjZVN0ZXAsIFJlcGxhY2VBcm91bmRTdGVwLCBUcmFuc2Zvcm0gfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuXG5jb25zdCBjbGFzc2VzQnlJZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcblN1cGVyY2xhc3MgZm9yIGVkaXRvciBzZWxlY3Rpb25zLiBFdmVyeSBzZWxlY3Rpb24gdHlwZSBzaG91bGRcbmV4dGVuZCB0aGlzLiBTaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cbiovXG5jbGFzcyBTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIEluaXRpYWxpemUgYSBzZWxlY3Rpb24gd2l0aCB0aGUgaGVhZCBhbmQgYW5jaG9yIGFuZCByYW5nZXMuIElmIG5vXG4gICAgcmFuZ2VzIGFyZSBnaXZlbiwgY29uc3RydWN0cyBhIHNpbmdsZSByYW5nZSBhY3Jvc3MgYCRhbmNob3JgIGFuZFxuICAgIGAkaGVhZGAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcmVzb2x2ZWQgYW5jaG9yIG9mIHRoZSBzZWxlY3Rpb24gKHRoZSBzaWRlIHRoYXQgc3RheXMgaW5cbiAgICBwbGFjZSB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgbW9kaWZpZWQpLlxuICAgICovXG4gICAgJGFuY2hvciwgXG4gICAgLyoqXG4gICAgVGhlIHJlc29sdmVkIGhlYWQgb2YgdGhlIHNlbGVjdGlvbiAodGhlIHNpZGUgdGhhdCBtb3ZlcyB3aGVuXG4gICAgdGhlIHNlbGVjdGlvbiBpcyBtb2RpZmllZCkuXG4gICAgKi9cbiAgICAkaGVhZCwgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMuJGFuY2hvciA9ICRhbmNob3I7XG4gICAgICAgIHRoaXMuJGhlYWQgPSAkaGVhZDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXMgfHwgW25ldyBTZWxlY3Rpb25SYW5nZSgkYW5jaG9yLm1pbigkaGVhZCksICRhbmNob3IubWF4KCRoZWFkKSldO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2VsZWN0aW9uJ3MgYW5jaG9yLCBhcyBhbiB1bnJlc29sdmVkIHBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IGFuY2hvcigpIHsgcmV0dXJuIHRoaXMuJGFuY2hvci5wb3M7IH1cbiAgICAvKipcbiAgICBUaGUgc2VsZWN0aW9uJ3MgaGVhZC5cbiAgICAqL1xuICAgIGdldCBoZWFkKCkgeyByZXR1cm4gdGhpcy4kaGVhZC5wb3M7IH1cbiAgICAvKipcbiAgICBUaGUgbG93ZXIgYm91bmQgb2YgdGhlIHNlbGVjdGlvbidzIG1haW4gcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuJGZyb20ucG9zOyB9XG4gICAgLyoqXG4gICAgVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSBzZWxlY3Rpb24ncyBtYWluIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy4kdG8ucG9zOyB9XG4gICAgLyoqXG4gICAgVGhlIHJlc29sdmVkIGxvd2VyICBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbiAgICAqL1xuICAgIGdldCAkZnJvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzWzBdLiRmcm9tO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgcmVzb2x2ZWQgdXBwZXIgYm91bmQgb2YgdGhlIHNlbGVjdGlvbidzIG1haW4gcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgJHRvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXNbMF0uJHRvO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc2VsZWN0aW9uIGNvbnRhaW5zIGFueSBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkge1xuICAgICAgICBsZXQgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHJhbmdlc1tpXS4kZnJvbS5wb3MgIT0gcmFuZ2VzW2ldLiR0by5wb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb250ZW50IG9mIHRoaXMgc2VsZWN0aW9uIGFzIGEgc2xpY2UuXG4gICAgKi9cbiAgICBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kZnJvbS5kb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggYSBzbGljZSBvciwgaWYgbm8gc2xpY2UgaXMgZ2l2ZW4sXG4gICAgZGVsZXRlIHRoZSBzZWxlY3Rpb24uIFdpbGwgYXBwZW5kIHRvIHRoZSBnaXZlbiB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHJlcGxhY2UodHIsIGNvbnRlbnQgPSBTbGljZS5lbXB0eSkge1xuICAgICAgICAvLyBQdXQgdGhlIG5ldyBzZWxlY3Rpb24gYXQgdGhlIHBvc2l0aW9uIGFmdGVyIHRoZSBpbnNlcnRlZFxuICAgICAgICAvLyBjb250ZW50LiBXaGVuIHRoYXQgZW5kZWQgaW4gYW4gaW5saW5lIG5vZGUsIHNlYXJjaCBiYWNrd2FyZHMsXG4gICAgICAgIC8vIHRvIGdldCB0aGUgcG9zaXRpb24gYWZ0ZXIgdGhhdCBub2RlLiBJZiBub3QsIHNlYXJjaCBmb3J3YXJkLlxuICAgICAgICBsZXQgbGFzdE5vZGUgPSBjb250ZW50LmNvbnRlbnQubGFzdENoaWxkLCBsYXN0UGFyZW50ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50Lm9wZW5FbmQ7IGkrKykge1xuICAgICAgICAgICAgbGFzdFBhcmVudCA9IGxhc3ROb2RlO1xuICAgICAgICAgICAgbGFzdE5vZGUgPSBsYXN0Tm9kZS5sYXN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hcEZyb20gPSB0ci5zdGVwcy5sZW5ndGgsIHJhbmdlcyA9IHRoaXMucmFuZ2VzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldLCBtYXBwaW5nID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKTtcbiAgICAgICAgICAgIHRyLnJlcGxhY2VSYW5nZShtYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCBtYXBwaW5nLm1hcCgkdG8ucG9zKSwgaSA/IFNsaWNlLmVtcHR5IDogY29udGVudCk7XG4gICAgICAgICAgICBpZiAoaSA9PSAwKVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBtYXBGcm9tLCAobGFzdE5vZGUgPyBsYXN0Tm9kZS5pc0lubGluZSA6IGxhc3RQYXJlbnQgJiYgbGFzdFBhcmVudC5pc1RleHRibG9jaykgPyAtMSA6IDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIHRoZSBnaXZlbiBub2RlLCBhcHBlbmRpbmcgdGhlIGNoYW5nZXNcbiAgICB0byB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICByZXBsYWNlV2l0aCh0ciwgbm9kZSkge1xuICAgICAgICBsZXQgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aCwgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV0sIG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCB0byA9IG1hcHBpbmcubWFwKCR0by5wb3MpO1xuICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICB0ci5kZWxldGVSYW5nZShmcm9tLCB0byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ci5yZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBub2RlKTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgbWFwRnJvbSwgbm9kZS5pc0lubGluZSA/IC0xIDogMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBhIHZhbGlkIGN1cnNvciBvciBsZWFmIG5vZGUgc2VsZWN0aW9uIHN0YXJ0aW5nIGF0IHRoZSBnaXZlblxuICAgIHBvc2l0aW9uIGFuZCBzZWFyY2hpbmcgYmFjayBpZiBgZGlyYCBpcyBuZWdhdGl2ZSwgYW5kIGZvcndhcmQgaWZcbiAgICBwb3NpdGl2ZS4gV2hlbiBgdGV4dE9ubHlgIGlzIHRydWUsIG9ubHkgY29uc2lkZXIgY3Vyc29yXG4gICAgc2VsZWN0aW9ucy4gV2lsbCByZXR1cm4gbnVsbCB3aGVuIG5vIHZhbGlkIHNlbGVjdGlvbiBwb3NpdGlvbiBpc1xuICAgIGZvdW5kLlxuICAgICovXG4gICAgc3RhdGljIGZpbmRGcm9tKCRwb3MsIGRpciwgdGV4dE9ubHkgPSBmYWxzZSkge1xuICAgICAgICBsZXQgaW5uZXIgPSAkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50ID8gbmV3IFRleHRTZWxlY3Rpb24oJHBvcylcbiAgICAgICAgICAgIDogZmluZFNlbGVjdGlvbkluKCRwb3Mubm9kZSgwKSwgJHBvcy5wYXJlbnQsICRwb3MucG9zLCAkcG9zLmluZGV4KCksIGRpciwgdGV4dE9ubHkpO1xuICAgICAgICBpZiAoaW5uZXIpXG4gICAgICAgICAgICByZXR1cm4gaW5uZXI7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gJHBvcy5kZXB0aCAtIDE7IGRlcHRoID49IDA7IGRlcHRoLS0pIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGRpciA8IDBcbiAgICAgICAgICAgICAgICA/IGZpbmRTZWxlY3Rpb25JbigkcG9zLm5vZGUoMCksICRwb3Mubm9kZShkZXB0aCksICRwb3MuYmVmb3JlKGRlcHRoICsgMSksICRwb3MuaW5kZXgoZGVwdGgpLCBkaXIsIHRleHRPbmx5KVxuICAgICAgICAgICAgICAgIDogZmluZFNlbGVjdGlvbkluKCRwb3Mubm9kZSgwKSwgJHBvcy5ub2RlKGRlcHRoKSwgJHBvcy5hZnRlcihkZXB0aCArIDEpLCAkcG9zLmluZGV4KGRlcHRoKSArIDEsIGRpciwgdGV4dE9ubHkpO1xuICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBhIHZhbGlkIGN1cnNvciBvciBsZWFmIG5vZGUgc2VsZWN0aW9uIG5lYXIgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24uIFNlYXJjaGVzIGZvcndhcmQgZmlyc3QgYnkgZGVmYXVsdCwgYnV0IGlmIGBiaWFzYCBpc1xuICAgIG5lZ2F0aXZlLCBpdCB3aWxsIHNlYXJjaCBiYWNrd2FyZHMgZmlyc3QuXG4gICAgKi9cbiAgICBzdGF0aWMgbmVhcigkcG9zLCBiaWFzID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kRnJvbSgkcG9zLCBiaWFzKSB8fCB0aGlzLmZpbmRGcm9tKCRwb3MsIC1iaWFzKSB8fCBuZXcgQWxsU2VsZWN0aW9uKCRwb3Mubm9kZSgwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGN1cnNvciBvciBsZWFmIG5vZGUgc2VsZWN0aW9uIGNsb3Nlc3QgdG8gdGhlIHN0YXJ0IG9mXG4gICAgdGhlIGdpdmVuIGRvY3VtZW50LiBXaWxsIHJldHVybiBhblxuICAgIFtgQWxsU2VsZWN0aW9uYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkFsbFNlbGVjdGlvbikgaWYgbm8gdmFsaWQgcG9zaXRpb25cbiAgICBleGlzdHMuXG4gICAgKi9cbiAgICBzdGF0aWMgYXRTdGFydChkb2MpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRTZWxlY3Rpb25Jbihkb2MsIGRvYywgMCwgMCwgMSkgfHwgbmV3IEFsbFNlbGVjdGlvbihkb2MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBjdXJzb3Igb3IgbGVhZiBub2RlIHNlbGVjdGlvbiBjbG9zZXN0IHRvIHRoZSBlbmQgb2YgdGhlXG4gICAgZ2l2ZW4gZG9jdW1lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgYXRFbmQoZG9jKSB7XG4gICAgICAgIHJldHVybiBmaW5kU2VsZWN0aW9uSW4oZG9jLCBkb2MsIGRvYy5jb250ZW50LnNpemUsIGRvYy5jaGlsZENvdW50LCAtMSkgfHwgbmV3IEFsbFNlbGVjdGlvbihkb2MpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHNlbGVjdGlvbi4gTXVzdCBiZVxuICAgIGltcGxlbWVudGVkIGZvciBjdXN0b20gY2xhc3NlcyAoYXMgYSBzdGF0aWMgY2xhc3MgbWV0aG9kKS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8ICFqc29uLnR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFNlbGVjdGlvbi5mcm9tSlNPTlwiKTtcbiAgICAgICAgbGV0IGNscyA9IGNsYXNzZXNCeUlkW2pzb24udHlwZV07XG4gICAgICAgIGlmICghY2xzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE5vIHNlbGVjdGlvbiB0eXBlICR7anNvbi50eXBlfSBkZWZpbmVkYCk7XG4gICAgICAgIHJldHVybiBjbHMuZnJvbUpTT04oZG9jLCBqc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVG8gYmUgYWJsZSB0byBkZXNlcmlhbGl6ZSBzZWxlY3Rpb25zIGZyb20gSlNPTiwgY3VzdG9tIHNlbGVjdGlvblxuICAgIGNsYXNzZXMgbXVzdCByZWdpc3RlciB0aGVtc2VsdmVzIHdpdGggYW4gSUQgc3RyaW5nLCBzbyB0aGF0IHRoZXlcbiAgICBjYW4gYmUgZGlzYW1iaWd1YXRlZC4gVHJ5IHRvIHBpY2sgc29tZXRoaW5nIHRoYXQncyB1bmxpa2VseSB0b1xuICAgIGNsYXNoIHdpdGggY2xhc3NlcyBmcm9tIG90aGVyIG1vZHVsZXMuXG4gICAgKi9cbiAgICBzdGF0aWMganNvbklEKGlkLCBzZWxlY3Rpb25DbGFzcykge1xuICAgICAgICBpZiAoaWQgaW4gY2xhc3Nlc0J5SWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkR1cGxpY2F0ZSB1c2Ugb2Ygc2VsZWN0aW9uIEpTT04gSUQgXCIgKyBpZCk7XG4gICAgICAgIGNsYXNzZXNCeUlkW2lkXSA9IHNlbGVjdGlvbkNsYXNzO1xuICAgICAgICBzZWxlY3Rpb25DbGFzcy5wcm90b3R5cGUuanNvbklEID0gaWQ7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25DbGFzcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW2Jvb2ttYXJrXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uQm9va21hcmspIGZvciB0aGlzIHNlbGVjdGlvbixcbiAgICB3aGljaCBpcyBhIHZhbHVlIHRoYXQgY2FuIGJlIG1hcHBlZCB3aXRob3V0IGhhdmluZyBhY2Nlc3MgdG8gYVxuICAgIGN1cnJlbnQgZG9jdW1lbnQsIGFuZCBsYXRlciByZXNvbHZlZCB0byBhIHJlYWwgc2VsZWN0aW9uIGZvciBhXG4gICAgZ2l2ZW4gZG9jdW1lbnQgYWdhaW4uIChUaGlzIGlzIHVzZWQgbW9zdGx5IGJ5IHRoZSBoaXN0b3J5IHRvXG4gICAgdHJhY2sgYW5kIHJlc3RvcmUgb2xkIHNlbGVjdGlvbnMuKSBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZlxuICAgIHRoaXMgbWV0aG9kIGp1c3QgY29udmVydHMgdGhlIHNlbGVjdGlvbiB0byBhIHRleHQgc2VsZWN0aW9uIGFuZFxuICAgIHJldHVybnMgdGhlIGJvb2ttYXJrIGZvciB0aGF0LlxuICAgICovXG4gICAgZ2V0Qm9va21hcmsoKSB7XG4gICAgICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmJldHdlZW4odGhpcy4kYW5jaG9yLCB0aGlzLiRoZWFkKS5nZXRCb29rbWFyaygpO1xuICAgIH1cbn1cblNlbGVjdGlvbi5wcm90b3R5cGUudmlzaWJsZSA9IHRydWU7XG4vKipcblJlcHJlc2VudHMgYSBzZWxlY3RlZCByYW5nZSBpbiBhIGRvY3VtZW50LlxuKi9cbmNsYXNzIFNlbGVjdGlvblJhbmdlIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSByYW5nZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsb3dlciBib3VuZCBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICAkZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgICR0bykge1xuICAgICAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgICAgIHRoaXMuJHRvID0gJHRvO1xuICAgIH1cbn1cbmxldCB3YXJuZWRBYm91dFRleHRTZWxlY3Rpb24gPSBmYWxzZTtcbmZ1bmN0aW9uIGNoZWNrVGV4dFNlbGVjdGlvbigkcG9zKSB7XG4gICAgaWYgKCF3YXJuZWRBYm91dFRleHRTZWxlY3Rpb24gJiYgISRwb3MucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgd2FybmVkQWJvdXRUZXh0U2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZVtcIndhcm5cIl0oXCJUZXh0U2VsZWN0aW9uIGVuZHBvaW50IG5vdCBwb2ludGluZyBpbnRvIGEgbm9kZSB3aXRoIGlubGluZSBjb250ZW50IChcIiArICRwb3MucGFyZW50LnR5cGUubmFtZSArIFwiKVwiKTtcbiAgICB9XG59XG4vKipcbkEgdGV4dCBzZWxlY3Rpb24gcmVwcmVzZW50cyBhIGNsYXNzaWNhbCBlZGl0b3Igc2VsZWN0aW9uLCB3aXRoIGFcbmhlYWQgKHRoZSBtb3Zpbmcgc2lkZSkgYW5kIGFuY2hvciAoaW1tb2JpbGUgc2lkZSksIGJvdGggb2Ygd2hpY2hcbnBvaW50IGludG8gdGV4dGJsb2NrIG5vZGVzLiBJdCBjYW4gYmUgZW1wdHkgKGEgcmVndWxhciBjdXJzb3JcbnBvc2l0aW9uKS5cbiovXG5jbGFzcyBUZXh0U2VsZWN0aW9uIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSB0ZXh0IHNlbGVjdGlvbiBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludHMuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigkYW5jaG9yLCAkaGVhZCA9ICRhbmNob3IpIHtcbiAgICAgICAgY2hlY2tUZXh0U2VsZWN0aW9uKCRhbmNob3IpO1xuICAgICAgICBjaGVja1RleHRTZWxlY3Rpb24oJGhlYWQpO1xuICAgICAgICBzdXBlcigkYW5jaG9yLCAkaGVhZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYSByZXNvbHZlZCBwb3NpdGlvbiBpZiB0aGlzIGlzIGEgY3Vyc29yIHNlbGVjdGlvbiAoYW5cbiAgICBlbXB0eSB0ZXh0IHNlbGVjdGlvbiksIGFuZCBudWxsIG90aGVyd2lzZS5cbiAgICAqL1xuICAgIGdldCAkY3Vyc29yKCkgeyByZXR1cm4gdGhpcy4kYW5jaG9yLnBvcyA9PSB0aGlzLiRoZWFkLnBvcyA/IHRoaXMuJGhlYWQgOiBudWxsOyB9XG4gICAgbWFwKGRvYywgbWFwcGluZykge1xuICAgICAgICBsZXQgJGhlYWQgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLmhlYWQpKTtcbiAgICAgICAgaWYgKCEkaGVhZC5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkaGVhZCk7XG4gICAgICAgIGxldCAkYW5jaG9yID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAodGhpcy5hbmNob3IpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0U2VsZWN0aW9uKCRhbmNob3IucGFyZW50LmlubGluZUNvbnRlbnQgPyAkYW5jaG9yIDogJGhlYWQsICRoZWFkKTtcbiAgICB9XG4gICAgcmVwbGFjZSh0ciwgY29udGVudCA9IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgIHN1cGVyLnJlcGxhY2UodHIsIGNvbnRlbnQpO1xuICAgICAgICBpZiAoY29udGVudCA9PSBTbGljZS5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IG1hcmtzID0gdGhpcy4kZnJvbS5tYXJrc0Fjcm9zcyh0aGlzLiR0byk7XG4gICAgICAgICAgICBpZiAobWFya3MpXG4gICAgICAgICAgICAgICAgdHIuZW5zdXJlTWFya3MobWFya3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgb3RoZXIuYW5jaG9yID09IHRoaXMuYW5jaG9yICYmIG90aGVyLmhlYWQgPT0gdGhpcy5oZWFkO1xuICAgIH1cbiAgICBnZXRCb29rbWFyaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Qm9va21hcmsodGhpcy5hbmNob3IsIHRoaXMuaGVhZCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0ZXh0XCIsIGFuY2hvcjogdGhpcy5hbmNob3IsIGhlYWQ6IHRoaXMuaGVhZCB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmFuY2hvciAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmhlYWQgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgVGV4dFNlbGVjdGlvbi5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0U2VsZWN0aW9uKGRvYy5yZXNvbHZlKGpzb24uYW5jaG9yKSwgZG9jLnJlc29sdmUoanNvbi5oZWFkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRleHQgc2VsZWN0aW9uIGZyb20gbm9uLXJlc29sdmVkIHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZG9jLCBhbmNob3IsIGhlYWQgPSBhbmNob3IpIHtcbiAgICAgICAgbGV0ICRhbmNob3IgPSBkb2MucmVzb2x2ZShhbmNob3IpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoJGFuY2hvciwgaGVhZCA9PSBhbmNob3IgPyAkYW5jaG9yIDogZG9jLnJlc29sdmUoaGVhZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSB0ZXh0IHNlbGVjdGlvbiB0aGF0IHNwYW5zIHRoZSBnaXZlbiBwb3NpdGlvbnMgb3IsIGlmXG4gICAgdGhleSBhcmVuJ3QgdGV4dCBwb3NpdGlvbnMsIGZpbmQgYSB0ZXh0IHNlbGVjdGlvbiBuZWFyIHRoZW0uXG4gICAgYGJpYXNgIGRldGVybWluZXMgd2hldGhlciB0aGUgbWV0aG9kIHNlYXJjaGVzIGZvcndhcmQgKGRlZmF1bHQpXG4gICAgb3IgYmFja3dhcmRzIChuZWdhdGl2ZSBudW1iZXIpIGZpcnN0LiBXaWxsIGZhbGwgYmFjayB0byBjYWxsaW5nXG4gICAgW2BTZWxlY3Rpb24ubmVhcmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25ebmVhcikgd2hlbiB0aGUgZG9jdW1lbnRcbiAgICBkb2Vzbid0IGNvbnRhaW4gYSB2YWxpZCB0ZXh0IHBvc2l0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGJldHdlZW4oJGFuY2hvciwgJGhlYWQsIGJpYXMpIHtcbiAgICAgICAgbGV0IGRQb3MgPSAkYW5jaG9yLnBvcyAtICRoZWFkLnBvcztcbiAgICAgICAgaWYgKCFiaWFzIHx8IGRQb3MpXG4gICAgICAgICAgICBiaWFzID0gZFBvcyA+PSAwID8gMSA6IC0xO1xuICAgICAgICBpZiAoISRoZWFkLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBTZWxlY3Rpb24uZmluZEZyb20oJGhlYWQsIGJpYXMsIHRydWUpIHx8IFNlbGVjdGlvbi5maW5kRnJvbSgkaGVhZCwgLWJpYXMsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICRoZWFkID0gZm91bmQuJGhlYWQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRoZWFkLCBiaWFzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISRhbmNob3IucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmIChkUG9zID09IDApIHtcbiAgICAgICAgICAgICAgICAkYW5jaG9yID0gJGhlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAkYW5jaG9yID0gKFNlbGVjdGlvbi5maW5kRnJvbSgkYW5jaG9yLCAtYmlhcywgdHJ1ZSkgfHwgU2VsZWN0aW9uLmZpbmRGcm9tKCRhbmNob3IsIGJpYXMsIHRydWUpKS4kYW5jaG9yO1xuICAgICAgICAgICAgICAgIGlmICgoJGFuY2hvci5wb3MgPCAkaGVhZC5wb3MpICE9IChkUG9zIDwgMCkpXG4gICAgICAgICAgICAgICAgICAgICRhbmNob3IgPSAkaGVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oJGFuY2hvciwgJGhlYWQpO1xuICAgIH1cbn1cblNlbGVjdGlvbi5qc29uSUQoXCJ0ZXh0XCIsIFRleHRTZWxlY3Rpb24pO1xuY2xhc3MgVGV4dEJvb2ttYXJrIHtcbiAgICBjb25zdHJ1Y3RvcihhbmNob3IsIGhlYWQpIHtcbiAgICAgICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgICAgIHRoaXMuaGVhZCA9IGhlYWQ7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEJvb2ttYXJrKG1hcHBpbmcubWFwKHRoaXMuYW5jaG9yKSwgbWFwcGluZy5tYXAodGhpcy5oZWFkKSk7XG4gICAgfVxuICAgIHJlc29sdmUoZG9jKSB7XG4gICAgICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmJldHdlZW4oZG9jLnJlc29sdmUodGhpcy5hbmNob3IpLCBkb2MucmVzb2x2ZSh0aGlzLmhlYWQpKTtcbiAgICB9XG59XG4vKipcbkEgbm9kZSBzZWxlY3Rpb24gaXMgYSBzZWxlY3Rpb24gdGhhdCBwb2ludHMgYXQgYSBzaW5nbGUgbm9kZS4gQWxsXG5ub2RlcyBtYXJrZWQgW3NlbGVjdGFibGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5zZWxlY3RhYmxlKSBjYW4gYmUgdGhlXG50YXJnZXQgb2YgYSBub2RlIHNlbGVjdGlvbi4gSW4gc3VjaCBhIHNlbGVjdGlvbiwgYGZyb21gIGFuZCBgdG9gXG5wb2ludCBkaXJlY3RseSBiZWZvcmUgYW5kIGFmdGVyIHRoZSBzZWxlY3RlZCBub2RlLCBgYW5jaG9yYCBlcXVhbHNcbmBmcm9tYCwgYW5kIGBoZWFkYCBlcXVhbHMgYHRvYC4uXG4qL1xuY2xhc3MgTm9kZVNlbGVjdGlvbiBleHRlbmRzIFNlbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBzZWxlY3Rpb24uIERvZXMgbm90IHZlcmlmeSB0aGUgdmFsaWRpdHkgb2YgaXRzXG4gICAgYXJndW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigkcG9zKSB7XG4gICAgICAgIGxldCBub2RlID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgICAgIGxldCAkZW5kID0gJHBvcy5ub2RlKDApLnJlc29sdmUoJHBvcy5wb3MgKyBub2RlLm5vZGVTaXplKTtcbiAgICAgICAgc3VwZXIoJHBvcywgJGVuZCk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgfVxuICAgIG1hcChkb2MsIG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHsgZGVsZXRlZCwgcG9zIH0gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmFuY2hvcik7XG4gICAgICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgICAgICAgaWYgKGRlbGV0ZWQpXG4gICAgICAgICAgICByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJHBvcyk7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbigkcG9zKTtcbiAgICB9XG4gICAgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHRoaXMubm9kZSksIDAsIDApO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIG90aGVyLmFuY2hvciA9PSB0aGlzLmFuY2hvcjtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm5vZGVcIiwgYW5jaG9yOiB0aGlzLmFuY2hvciB9O1xuICAgIH1cbiAgICBnZXRCb29rbWFyaygpIHsgcmV0dXJuIG5ldyBOb2RlQm9va21hcmsodGhpcy5hbmNob3IpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5hbmNob3IgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgTm9kZVNlbGVjdGlvbi5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKGRvYy5yZXNvbHZlKGpzb24uYW5jaG9yKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5vZGUgc2VsZWN0aW9uIGZyb20gbm9uLXJlc29sdmVkIHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZG9jLCBmcm9tKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbihkb2MucmVzb2x2ZShmcm9tKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gbm9kZSBtYXkgYmUgc2VsZWN0ZWQgYXMgYSBub2RlXG4gICAgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGlzU2VsZWN0YWJsZShub2RlKSB7XG4gICAgICAgIHJldHVybiAhbm9kZS5pc1RleHQgJiYgbm9kZS50eXBlLnNwZWMuc2VsZWN0YWJsZSAhPT0gZmFsc2U7XG4gICAgfVxufVxuTm9kZVNlbGVjdGlvbi5wcm90b3R5cGUudmlzaWJsZSA9IGZhbHNlO1xuU2VsZWN0aW9uLmpzb25JRChcIm5vZGVcIiwgTm9kZVNlbGVjdGlvbik7XG5jbGFzcyBOb2RlQm9va21hcmsge1xuICAgIGNvbnN0cnVjdG9yKGFuY2hvcikge1xuICAgICAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHsgZGVsZXRlZCwgcG9zIH0gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmFuY2hvcik7XG4gICAgICAgIHJldHVybiBkZWxldGVkID8gbmV3IFRleHRCb29rbWFyayhwb3MsIHBvcykgOiBuZXcgTm9kZUJvb2ttYXJrKHBvcyk7XG4gICAgfVxuICAgIHJlc29sdmUoZG9jKSB7XG4gICAgICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUodGhpcy5hbmNob3IpLCBub2RlID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgICAgIGlmIChub2RlICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpO1xuICAgICAgICByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJHBvcyk7XG4gICAgfVxufVxuLyoqXG5BIHNlbGVjdGlvbiB0eXBlIHRoYXQgcmVwcmVzZW50cyBzZWxlY3RpbmcgdGhlIHdob2xlIGRvY3VtZW50XG4od2hpY2ggY2FuIG5vdCBuZWNlc3NhcmlseSBiZSBleHByZXNzZWQgd2l0aCBhIHRleHQgc2VsZWN0aW9uLCB3aGVuXG50aGVyZSBhcmUgZm9yIGV4YW1wbGUgbGVhZiBibG9jayBub2RlcyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZVxuZG9jdW1lbnQpLlxuKi9cbmNsYXNzIEFsbFNlbGVjdGlvbiBleHRlbmRzIFNlbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGFsbC1zZWxlY3Rpb24gb3ZlciB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihkb2MpIHtcbiAgICAgICAgc3VwZXIoZG9jLnJlc29sdmUoMCksIGRvYy5yZXNvbHZlKGRvYy5jb250ZW50LnNpemUpKTtcbiAgICB9XG4gICAgcmVwbGFjZSh0ciwgY29udGVudCA9IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgIGlmIChjb250ZW50ID09IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgICAgICB0ci5kZWxldGUoMCwgdHIuZG9jLmNvbnRlbnQuc2l6ZSk7XG4gICAgICAgICAgICBsZXQgc2VsID0gU2VsZWN0aW9uLmF0U3RhcnQodHIuZG9jKTtcbiAgICAgICAgICAgIGlmICghc2VsLmVxKHRyLnNlbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5yZXBsYWNlKHRyLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7IHJldHVybiB7IHR5cGU6IFwiYWxsXCIgfTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYykgeyByZXR1cm4gbmV3IEFsbFNlbGVjdGlvbihkb2MpOyB9XG4gICAgbWFwKGRvYykgeyByZXR1cm4gbmV3IEFsbFNlbGVjdGlvbihkb2MpOyB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uOyB9XG4gICAgZ2V0Qm9va21hcmsoKSB7IHJldHVybiBBbGxCb29rbWFyazsgfVxufVxuU2VsZWN0aW9uLmpzb25JRChcImFsbFwiLCBBbGxTZWxlY3Rpb24pO1xuY29uc3QgQWxsQm9va21hcmsgPSB7XG4gICAgbWFwKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICByZXNvbHZlKGRvYykgeyByZXR1cm4gbmV3IEFsbFNlbGVjdGlvbihkb2MpOyB9XG59O1xuLy8gRklYTUUgd2UnbGwgbmVlZCBzb21lIGF3YXJlbmVzcyBvZiB0ZXh0IGRpcmVjdGlvbiB3aGVuIHNjYW5uaW5nIGZvciBzZWxlY3Rpb25zXG4vLyBUcnkgdG8gZmluZCBhIHNlbGVjdGlvbiBpbnNpZGUgdGhlIGdpdmVuIG5vZGUuIGBwb3NgIHBvaW50cyBhdCB0aGVcbi8vIHBvc2l0aW9uIHdoZXJlIHRoZSBzZWFyY2ggc3RhcnRzLiBXaGVuIGB0ZXh0YCBpcyB0cnVlLCBvbmx5IHJldHVyblxuLy8gdGV4dCBzZWxlY3Rpb25zLlxuZnVuY3Rpb24gZmluZFNlbGVjdGlvbkluKGRvYywgbm9kZSwgcG9zLCBpbmRleCwgZGlyLCB0ZXh0ID0gZmFsc2UpIHtcbiAgICBpZiAobm9kZS5pbmxpbmVDb250ZW50KVxuICAgICAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBwb3MpO1xuICAgIGZvciAobGV0IGkgPSBpbmRleCAtIChkaXIgPiAwID8gMCA6IDEpOyBkaXIgPiAwID8gaSA8IG5vZGUuY2hpbGRDb3VudCA6IGkgPj0gMDsgaSArPSBkaXIpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gbm9kZS5jaGlsZChpKTtcbiAgICAgICAgaWYgKCFjaGlsZC5pc0F0b20pIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGZpbmRTZWxlY3Rpb25Jbihkb2MsIGNoaWxkLCBwb3MgKyBkaXIsIGRpciA8IDAgPyBjaGlsZC5jaGlsZENvdW50IDogMCwgZGlyLCB0ZXh0KTtcbiAgICAgICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRleHQgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoY2hpbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gTm9kZVNlbGVjdGlvbi5jcmVhdGUoZG9jLCBwb3MgLSAoZGlyIDwgMCA/IGNoaWxkLm5vZGVTaXplIDogMCkpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBjaGlsZC5ub2RlU2l6ZSAqIGRpcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgc3RhcnRMZW4sIGJpYXMpIHtcbiAgICBsZXQgbGFzdCA9IHRyLnN0ZXBzLmxlbmd0aCAtIDE7XG4gICAgaWYgKGxhc3QgPCBzdGFydExlbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBzdGVwID0gdHIuc3RlcHNbbGFzdF07XG4gICAgaWYgKCEoc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwIHx8IHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlQXJvdW5kU3RlcCkpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbWFwID0gdHIubWFwcGluZy5tYXBzW2xhc3RdLCBlbmQ7XG4gICAgbWFwLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4geyBpZiAoZW5kID09IG51bGwpXG4gICAgICAgIGVuZCA9IG5ld1RvOyB9KTtcbiAgICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoZW5kKSwgYmlhcykpO1xufVxuXG5jb25zdCBVUERBVEVEX1NFTCA9IDEsIFVQREFURURfTUFSS1MgPSAyLCBVUERBVEVEX1NDUk9MTCA9IDQ7XG4vKipcbkFuIGVkaXRvciBzdGF0ZSB0cmFuc2FjdGlvbiwgd2hpY2ggY2FuIGJlIGFwcGxpZWQgdG8gYSBzdGF0ZSB0b1xuY3JlYXRlIGFuIHVwZGF0ZWQgc3RhdGUuIFVzZVxuW2BFZGl0b3JTdGF0ZS50cmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50cikgdG8gY3JlYXRlIGFuIGluc3RhbmNlLlxuXG5UcmFuc2FjdGlvbnMgdHJhY2sgY2hhbmdlcyB0byB0aGUgZG9jdW1lbnQgKHRoZXkgYXJlIGEgc3ViY2xhc3Mgb2ZcbltgVHJhbnNmb3JtYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5UcmFuc2Zvcm0pKSwgYnV0IGFsc28gb3RoZXIgc3RhdGUgY2hhbmdlcyxcbmxpa2Ugc2VsZWN0aW9uIHVwZGF0ZXMgYW5kIGFkanVzdG1lbnRzIG9mIHRoZSBzZXQgb2YgW3N0b3JlZFxubWFya3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5zdG9yZWRNYXJrcykuIEluIGFkZGl0aW9uLCB5b3UgY2FuIHN0b3JlXG5tZXRhZGF0YSBwcm9wZXJ0aWVzIGluIGEgdHJhbnNhY3Rpb24sIHdoaWNoIGFyZSBleHRyYSBwaWVjZXMgb2ZcbmluZm9ybWF0aW9uIHRoYXQgY2xpZW50IGNvZGUgb3IgcGx1Z2lucyBjYW4gdXNlIHRvIGRlc2NyaWJlIHdoYXQgYVxudHJhbnNhY3Rpb24gcmVwcmVzZW50cywgc28gdGhhdCB0aGV5IGNhbiB1cGRhdGUgdGhlaXIgW293blxuc3RhdGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUZpZWxkKSBhY2NvcmRpbmdseS5cblxuVGhlIFtlZGl0b3Igdmlld10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldykgdXNlcyBhIGZldyBtZXRhZGF0YVxucHJvcGVydGllczogaXQgd2lsbCBhdHRhY2ggYSBwcm9wZXJ0eSBgXCJwb2ludGVyXCJgIHdpdGggdGhlIHZhbHVlXG5gdHJ1ZWAgdG8gc2VsZWN0aW9uIHRyYW5zYWN0aW9ucyBkaXJlY3RseSBjYXVzZWQgYnkgbW91c2Ugb3IgdG91Y2hcbmlucHV0LCBhIGBcImNvbXBvc2l0aW9uXCJgIHByb3BlcnR5IGhvbGRpbmcgYW4gSUQgaWRlbnRpZnlpbmcgdGhlXG5jb21wb3NpdGlvbiB0aGF0IGNhdXNlZCBpdCB0byB0cmFuc2FjdGlvbnMgY2F1c2VkIGJ5IGNvbXBvc2VkIERPTVxuaW5wdXQsIGFuZCBhIGBcInVpRXZlbnRcImAgcHJvcGVydHkgb2YgdGhhdCBtYXkgYmUgYFwicGFzdGVcImAsXG5gXCJjdXRcImAsIG9yIGBcImRyb3BcImAuXG4qL1xuY2xhc3MgVHJhbnNhY3Rpb24gZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoc3RhdGUuZG9jKTtcbiAgICAgICAgLy8gVGhlIHN0ZXAgY291bnQgZm9yIHdoaWNoIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyB2YWxpZC5cbiAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb25Gb3IgPSAwO1xuICAgICAgICAvLyBCaXRmaWVsZCB0byB0cmFjayB3aGljaCBhc3BlY3RzIG9mIHRoZSBzdGF0ZSB3ZXJlIHVwZGF0ZWQgYnlcbiAgICAgICAgLy8gdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgICAgdGhpcy51cGRhdGVkID0gMDtcbiAgICAgICAgLy8gT2JqZWN0IHVzZWQgdG8gc3RvcmUgbWV0YWRhdGEgcHJvcGVydGllcyBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICB0aGlzLm1ldGEgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLmN1clNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgdHJhbnNhY3Rpb24ncyBjdXJyZW50IHNlbGVjdGlvbi4gVGhpcyBkZWZhdWx0cyB0byB0aGUgZWRpdG9yXG4gICAgc2VsZWN0aW9uIFttYXBwZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb24ubWFwKSB0aHJvdWdoIHRoZSBzdGVwcyBpbiB0aGVcbiAgICB0cmFuc2FjdGlvbiwgYnV0IGNhbiBiZSBvdmVyd3JpdHRlbiB3aXRoXG4gICAgW2BzZXRTZWxlY3Rpb25gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc2V0U2VsZWN0aW9uKS5cbiAgICAqL1xuICAgIGdldCBzZWxlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmN1clNlbGVjdGlvbkZvciA8IHRoaXMuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1clNlbGVjdGlvbiA9IHRoaXMuY3VyU2VsZWN0aW9uLm1hcCh0aGlzLmRvYywgdGhpcy5tYXBwaW5nLnNsaWNlKHRoaXMuY3VyU2VsZWN0aW9uRm9yKSk7XG4gICAgICAgICAgICB0aGlzLmN1clNlbGVjdGlvbkZvciA9IHRoaXMuc3RlcHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmN1clNlbGVjdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB0cmFuc2FjdGlvbidzIGN1cnJlbnQgc2VsZWN0aW9uLiBXaWxsIGRldGVybWluZSB0aGVcbiAgICBzZWxlY3Rpb24gdGhhdCB0aGUgZWRpdG9yIGdldHMgd2hlbiB0aGUgdHJhbnNhY3Rpb24gaXMgYXBwbGllZC5cbiAgICAqL1xuICAgIHNldFNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbi4kZnJvbS5kb2MgIT0gdGhpcy5kb2MpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlNlbGVjdGlvbiBwYXNzZWQgdG8gc2V0U2VsZWN0aW9uIG11c3QgcG9pbnQgYXQgdGhlIGN1cnJlbnQgZG9jdW1lbnRcIik7XG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmN1clNlbGVjdGlvbkZvciA9IHRoaXMuc3RlcHMubGVuZ3RoO1xuICAgICAgICB0aGlzLnVwZGF0ZWQgPSAodGhpcy51cGRhdGVkIHwgVVBEQVRFRF9TRUwpICYgflVQREFURURfTUFSS1M7XG4gICAgICAgIHRoaXMuc3RvcmVkTWFya3MgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc2VsZWN0aW9uIHdhcyBleHBsaWNpdGx5IHVwZGF0ZWQgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGdldCBzZWxlY3Rpb25TZXQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy51cGRhdGVkICYgVVBEQVRFRF9TRUwpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSBjdXJyZW50IHN0b3JlZCBtYXJrcy5cbiAgICAqL1xuICAgIHNldFN0b3JlZE1hcmtzKG1hcmtzKSB7XG4gICAgICAgIHRoaXMuc3RvcmVkTWFya3MgPSBtYXJrcztcbiAgICAgICAgdGhpcy51cGRhdGVkIHw9IFVQREFURURfTUFSS1M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBNYWtlIHN1cmUgdGhlIGN1cnJlbnQgc3RvcmVkIG1hcmtzIG9yLCBpZiB0aGF0IGlzIG51bGwsIHRoZSBtYXJrc1xuICAgIGF0IHRoZSBzZWxlY3Rpb24sIG1hdGNoIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MuIERvZXMgbm90aGluZyBpZlxuICAgIHRoaXMgaXMgYWxyZWFkeSB0aGUgY2FzZS5cbiAgICAqL1xuICAgIGVuc3VyZU1hcmtzKG1hcmtzKSB7XG4gICAgICAgIGlmICghTWFyay5zYW1lU2V0KHRoaXMuc3RvcmVkTWFya3MgfHwgdGhpcy5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSwgbWFya3MpKVxuICAgICAgICAgICAgdGhpcy5zZXRTdG9yZWRNYXJrcyhtYXJrcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSBtYXJrIHRvIHRoZSBzZXQgb2Ygc3RvcmVkIG1hcmtzLlxuICAgICovXG4gICAgYWRkU3RvcmVkTWFyayhtYXJrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuc3VyZU1hcmtzKG1hcmsuYWRkVG9TZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kaGVhZC5tYXJrcygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZSBhIG1hcmsgb3IgbWFyayB0eXBlIGZyb20gdGhlIHNldCBvZiBzdG9yZWQgbWFya3MuXG4gICAgKi9cbiAgICByZW1vdmVTdG9yZWRNYXJrKG1hcmspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlTWFya3MobWFyay5yZW1vdmVGcm9tU2V0KHRoaXMuc3RvcmVkTWFya3MgfHwgdGhpcy5zZWxlY3Rpb24uJGhlYWQubWFya3MoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzdG9yZWQgbWFya3Mgd2VyZSBleHBsaWNpdGx5IHNldCBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGdldCBzdG9yZWRNYXJrc1NldCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnVwZGF0ZWQgJiBVUERBVEVEX01BUktTKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkU3RlcChzdGVwLCBkb2MpIHtcbiAgICAgICAgc3VwZXIuYWRkU3RlcChzdGVwLCBkb2MpO1xuICAgICAgICB0aGlzLnVwZGF0ZWQgPSB0aGlzLnVwZGF0ZWQgJiB+VVBEQVRFRF9NQVJLUztcbiAgICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdGltZXN0YW1wIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBzZXRUaW1lKHRpbWUpIHtcbiAgICAgICAgdGhpcy50aW1lID0gdGltZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIHNsaWNlLlxuICAgICovXG4gICAgcmVwbGFjZVNlbGVjdGlvbihzbGljZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5yZXBsYWNlKHRoaXMsIHNsaWNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIHRoZSBnaXZlbiBub2RlLiBXaGVuIGBpbmhlcml0TWFya3NgIGlzXG4gICAgdHJ1ZSBhbmQgdGhlIGNvbnRlbnQgaXMgaW5saW5lLCBpdCBpbmhlcml0cyB0aGUgbWFya3MgZnJvbSB0aGVcbiAgICBwbGFjZSB3aGVyZSBpdCBpcyBpbnNlcnRlZC5cbiAgICAqL1xuICAgIHJlcGxhY2VTZWxlY3Rpb25XaXRoKG5vZGUsIGluaGVyaXRNYXJrcyA9IHRydWUpIHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoaW5oZXJpdE1hcmtzKVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubWFyayh0aGlzLnN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uZW1wdHkgPyBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSA6IChzZWxlY3Rpb24uJGZyb20ubWFya3NBY3Jvc3Moc2VsZWN0aW9uLiR0bykgfHwgTWFyay5ub25lKSkpO1xuICAgICAgICBzZWxlY3Rpb24ucmVwbGFjZVdpdGgodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgdGhlIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIGRlbGV0ZVNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ucmVwbGFjZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIGdpdmVuIHJhbmdlLCBvciB0aGUgc2VsZWN0aW9uIGlmIG5vIHJhbmdlIGlzIGdpdmVuLFxuICAgIHdpdGggYSB0ZXh0IG5vZGUgY29udGFpbmluZyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgaW5zZXJ0VGV4dCh0ZXh0LCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgc2NoZW1hID0gdGhpcy5kb2MudHlwZS5zY2hlbWE7XG4gICAgICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghdGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHNjaGVtYS50ZXh0KHRleHQpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRvID0gZnJvbTtcbiAgICAgICAgICAgIHRvID0gdG8gPT0gbnVsbCA/IGZyb20gOiB0bztcbiAgICAgICAgICAgIGlmICghdGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxldGVSYW5nZShmcm9tLCB0byk7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSB0aGlzLnN0b3JlZE1hcmtzO1xuICAgICAgICAgICAgaWYgKCFtYXJrcykge1xuICAgICAgICAgICAgICAgIGxldCAkZnJvbSA9IHRoaXMuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgICAgICAgICAgICAgbWFya3MgPSB0byA9PSBmcm9tID8gJGZyb20ubWFya3MoKSA6ICRmcm9tLm1hcmtzQWNyb3NzKHRoaXMuZG9jLnJlc29sdmUodG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVJhbmdlV2l0aChmcm9tLCB0bywgc2NoZW1hLnRleHQodGV4dCwgbWFya3MpKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24uZW1wdHkpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodGhpcy5zZWxlY3Rpb24uJHRvKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBTdG9yZSBhIG1ldGFkYXRhIHByb3BlcnR5IGluIHRoaXMgdHJhbnNhY3Rpb24sIGtleWVkIGVpdGhlciBieVxuICAgIG5hbWUgb3IgYnkgcGx1Z2luLlxuICAgICovXG4gICAgc2V0TWV0YShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWV0YVt0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgPyBrZXkgOiBrZXkua2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgYSBtZXRhZGF0YSBwcm9wZXJ0eSBmb3IgYSBnaXZlbiBuYW1lIG9yIHBsdWdpbi5cbiAgICAqL1xuICAgIGdldE1ldGEoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGFbdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiID8ga2V5IDoga2V5LmtleV07XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGRvZXNuJ3QgY29udGFpbiBhbnkgbWV0YWRhdGEsXG4gICAgYW5kIGNhbiB0aHVzIHNhZmVseSBiZSBleHRlbmRlZC5cbiAgICAqL1xuICAgIGdldCBpc0dlbmVyaWMoKSB7XG4gICAgICAgIGZvciAobGV0IF8gaW4gdGhpcy5tZXRhKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGUgdGhhdCB0aGUgZWRpdG9yIHNob3VsZCBzY3JvbGwgdGhlIHNlbGVjdGlvbiBpbnRvIHZpZXdcbiAgICB3aGVuIHVwZGF0ZWQgdG8gdGhlIHN0YXRlIHByb2R1Y2VkIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBzY3JvbGxJbnRvVmlldygpIHtcbiAgICAgICAgdGhpcy51cGRhdGVkIHw9IFVQREFURURfU0NST0xMO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGhhZCBgc2Nyb2xsSW50b1ZpZXdgIGNhbGxlZCBvbiBpdC5cbiAgICAqL1xuICAgIGdldCBzY3JvbGxlZEludG9WaWV3KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudXBkYXRlZCAmIFVQREFURURfU0NST0xMKSA+IDA7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBiaW5kKGYsIHNlbGYpIHtcbiAgICByZXR1cm4gIXNlbGYgfHwgIWYgPyBmIDogZi5iaW5kKHNlbGYpO1xufVxuY2xhc3MgRmllbGREZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBkZXNjLCBzZWxmKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaW5pdCA9IGJpbmQoZGVzYy5pbml0LCBzZWxmKTtcbiAgICAgICAgdGhpcy5hcHBseSA9IGJpbmQoZGVzYy5hcHBseSwgc2VsZik7XG4gICAgfVxufVxuY29uc3QgYmFzZUZpZWxkcyA9IFtcbiAgICBuZXcgRmllbGREZXNjKFwiZG9jXCIsIHtcbiAgICAgICAgaW5pdChjb25maWcpIHsgcmV0dXJuIGNvbmZpZy5kb2MgfHwgY29uZmlnLnNjaGVtYS50b3BOb2RlVHlwZS5jcmVhdGVBbmRGaWxsKCk7IH0sXG4gICAgICAgIGFwcGx5KHRyKSB7IHJldHVybiB0ci5kb2M7IH1cbiAgICB9KSxcbiAgICBuZXcgRmllbGREZXNjKFwic2VsZWN0aW9uXCIsIHtcbiAgICAgICAgaW5pdChjb25maWcsIGluc3RhbmNlKSB7IHJldHVybiBjb25maWcuc2VsZWN0aW9uIHx8IFNlbGVjdGlvbi5hdFN0YXJ0KGluc3RhbmNlLmRvYyk7IH0sXG4gICAgICAgIGFwcGx5KHRyKSB7IHJldHVybiB0ci5zZWxlY3Rpb247IH1cbiAgICB9KSxcbiAgICBuZXcgRmllbGREZXNjKFwic3RvcmVkTWFya3NcIiwge1xuICAgICAgICBpbml0KGNvbmZpZykgeyByZXR1cm4gY29uZmlnLnN0b3JlZE1hcmtzIHx8IG51bGw7IH0sXG4gICAgICAgIGFwcGx5KHRyLCBfbWFya3MsIF9vbGQsIHN0YXRlKSB7IHJldHVybiBzdGF0ZS5zZWxlY3Rpb24uJGN1cnNvciA/IHRyLnN0b3JlZE1hcmtzIDogbnVsbDsgfVxuICAgIH0pLFxuICAgIG5ldyBGaWVsZERlc2MoXCJzY3JvbGxUb1NlbGVjdGlvblwiLCB7XG4gICAgICAgIGluaXQoKSB7IHJldHVybiAwOyB9LFxuICAgICAgICBhcHBseSh0ciwgcHJldikgeyByZXR1cm4gdHIuc2Nyb2xsZWRJbnRvVmlldyA/IHByZXYgKyAxIDogcHJldjsgfVxuICAgIH0pXG5dO1xuLy8gT2JqZWN0IHdyYXBwaW5nIHRoZSBwYXJ0IG9mIGEgc3RhdGUgb2JqZWN0IHRoYXQgc3RheXMgdGhlIHNhbWVcbi8vIGFjcm9zcyB0cmFuc2FjdGlvbnMuIFN0b3JlZCBpbiB0aGUgc3RhdGUncyBgY29uZmlnYCBwcm9wZXJ0eS5cbmNsYXNzIENvbmZpZ3VyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSwgcGx1Z2lucykge1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMucGx1Z2luc0J5S2V5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBiYXNlRmllbGRzLnNsaWNlKCk7XG4gICAgICAgIGlmIChwbHVnaW5zKVxuICAgICAgICAgICAgcGx1Z2lucy5mb3JFYWNoKHBsdWdpbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGx1Z2luc0J5S2V5W3BsdWdpbi5rZXldKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFkZGluZyBkaWZmZXJlbnQgaW5zdGFuY2VzIG9mIGEga2V5ZWQgcGx1Z2luIChcIiArIHBsdWdpbi5rZXkgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbnNCeUtleVtwbHVnaW4ua2V5XSA9IHBsdWdpbjtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMuc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmllbGRzLnB1c2gobmV3IEZpZWxkRGVzYyhwbHVnaW4ua2V5LCBwbHVnaW4uc3BlYy5zdGF0ZSwgcGx1Z2luKSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcblRoZSBzdGF0ZSBvZiBhIFByb3NlTWlycm9yIGVkaXRvciBpcyByZXByZXNlbnRlZCBieSBhbiBvYmplY3Qgb2ZcbnRoaXMgdHlwZS4gQSBzdGF0ZSBpcyBhIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVcdTIwMTRpdCBpc24ndFxudXBkYXRlZCwgYnV0IHJhdGhlciBhIG5ldyBzdGF0ZSB2YWx1ZSBpcyBjb21wdXRlZCBmcm9tIGFuIG9sZCBvbmVcbnVzaW5nIHRoZSBbYGFwcGx5YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmFwcGx5KSBtZXRob2QuXG5cbkEgc3RhdGUgaG9sZHMgYSBudW1iZXIgb2YgYnVpbHQtaW4gZmllbGRzLCBhbmQgcGx1Z2lucyBjYW5cbltkZWZpbmVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5QbHVnaW5TcGVjLnN0YXRlKSBhZGRpdGlvbmFsIGZpZWxkcy5cbiovXG5jbGFzcyBFZGl0b3JTdGF0ZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNjaGVtYSBvZiB0aGUgc3RhdGUncyBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5zY2hlbWE7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBwbHVnaW5zIHRoYXQgYXJlIGFjdGl2ZSBpbiB0aGlzIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5wbHVnaW5zO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBseSB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24gdG8gcHJvZHVjZSBhIG5ldyBzdGF0ZS5cbiAgICAqL1xuICAgIGFwcGx5KHRyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5VHJhbnNhY3Rpb24odHIpLnN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbHRlclRyYW5zYWN0aW9uKHRyLCBpZ25vcmUgPSAtMSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlnLnBsdWdpbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoaSAhPSBpZ25vcmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5jb25maWcucGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMuZmlsdGVyVHJhbnNhY3Rpb24gJiYgIXBsdWdpbi5zcGVjLmZpbHRlclRyYW5zYWN0aW9uLmNhbGwocGx1Z2luLCB0ciwgdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFZlcmJvc2UgdmFyaWFudCBvZiBbYGFwcGx5YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmFwcGx5KSB0aGF0XG4gICAgcmV0dXJucyB0aGUgcHJlY2lzZSB0cmFuc2FjdGlvbnMgdGhhdCB3ZXJlIGFwcGxpZWQgKHdoaWNoIG1pZ2h0XG4gICAgYmUgaW5mbHVlbmNlZCBieSB0aGUgW3RyYW5zYWN0aW9uXG4gICAgaG9va3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5QbHVnaW5TcGVjLmZpbHRlclRyYW5zYWN0aW9uKSBvZlxuICAgIHBsdWdpbnMpIGFsb25nIHdpdGggdGhlIG5ldyBzdGF0ZS5cbiAgICAqL1xuICAgIGFwcGx5VHJhbnNhY3Rpb24ocm9vdFRyKSB7XG4gICAgICAgIGlmICghdGhpcy5maWx0ZXJUcmFuc2FjdGlvbihyb290VHIpKVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IHRoaXMsIHRyYW5zYWN0aW9uczogW10gfTtcbiAgICAgICAgbGV0IHRycyA9IFtyb290VHJdLCBuZXdTdGF0ZSA9IHRoaXMuYXBwbHlJbm5lcihyb290VHIpLCBzZWVuID0gbnVsbDtcbiAgICAgICAgLy8gVGhpcyBsb29wIHJlcGVhdGVkbHkgZ2l2ZXMgcGx1Z2lucyBhIGNoYW5jZSB0byByZXNwb25kIHRvXG4gICAgICAgIC8vIHRyYW5zYWN0aW9ucyBhcyBuZXcgdHJhbnNhY3Rpb25zIGFyZSBhZGRlZCwgbWFraW5nIHN1cmUgdG8gb25seVxuICAgICAgICAvLyBwYXNzIHRoZSB0cmFuc2FjdGlvbnMgdGhlIHBsdWdpbiBkaWQgbm90IHNlZSBiZWZvcmUuXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBoYXZlTmV3ID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlnLnBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5jb25maWcucGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMuYXBwZW5kVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG4gPSBzZWVuID8gc2VlbltpXS5uIDogMCwgb2xkU3RhdGUgPSBzZWVuID8gc2VlbltpXS5zdGF0ZSA6IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ciA9IG4gPCB0cnMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW4uc3BlYy5hcHBlbmRUcmFuc2FjdGlvbi5jYWxsKHBsdWdpbiwgbiA/IHRycy5zbGljZShuKSA6IHRycywgb2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyICYmIG5ld1N0YXRlLmZpbHRlclRyYW5zYWN0aW9uKHRyLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcImFwcGVuZGVkVHJhbnNhY3Rpb25cIiwgcm9vdFRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2Vlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZW4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29uZmlnLnBsdWdpbnMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZW4ucHVzaChqIDwgaSA/IHsgc3RhdGU6IG5ld1N0YXRlLCBuOiB0cnMubGVuZ3RoIH0gOiB7IHN0YXRlOiB0aGlzLCBuOiAwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJzLnB1c2godHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSBuZXdTdGF0ZS5hcHBseUlubmVyKHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVOZXcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VlbltpXSA9IHsgc3RhdGU6IG5ld1N0YXRlLCBuOiB0cnMubGVuZ3RoIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXZlTmV3KVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBuZXdTdGF0ZSwgdHJhbnNhY3Rpb25zOiB0cnMgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFwcGx5SW5uZXIodHIpIHtcbiAgICAgICAgaWYgKCF0ci5iZWZvcmUuZXEodGhpcy5kb2MpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBcHBseWluZyBhIG1pc21hdGNoZWQgdHJhbnNhY3Rpb25cIik7XG4gICAgICAgIGxldCBuZXdJbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSh0aGlzLmNvbmZpZyksIGZpZWxkcyA9IHRoaXMuY29uZmlnLmZpZWxkcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgICAgIG5ld0luc3RhbmNlW2ZpZWxkLm5hbWVdID0gZmllbGQuYXBwbHkodHIsIHRoaXNbZmllbGQubmFtZV0sIHRoaXMsIG5ld0luc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3SW5zdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFN0YXJ0IGEgW3RyYW5zYWN0aW9uXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24pIGZyb20gdGhpcyBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCB0cigpIHsgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbih0aGlzKTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnKSB7XG4gICAgICAgIGxldCAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24oY29uZmlnLmRvYyA/IGNvbmZpZy5kb2MudHlwZS5zY2hlbWEgOiBjb25maWcuc2NoZW1hLCBjb25maWcucGx1Z2lucyk7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSgkY29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAkY29uZmlnLmZpZWxkcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGluc3RhbmNlWyRjb25maWcuZmllbGRzW2ldLm5hbWVdID0gJGNvbmZpZy5maWVsZHNbaV0uaW5pdChjb25maWcsIGluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgc3RhdGUgYmFzZWQgb24gdGhpcyBvbmUsIGJ1dCB3aXRoIGFuIGFkanVzdGVkIHNldFxuICAgIG9mIGFjdGl2ZSBwbHVnaW5zLiBTdGF0ZSBmaWVsZHMgdGhhdCBleGlzdCBpbiBib3RoIHNldHMgb2ZcbiAgICBwbHVnaW5zIGFyZSBrZXB0IHVuY2hhbmdlZC4gVGhvc2UgdGhhdCBubyBsb25nZXIgZXhpc3QgYXJlXG4gICAgZHJvcHBlZCwgYW5kIHRob3NlIHRoYXQgYXJlIG5ldyBhcmUgaW5pdGlhbGl6ZWQgdXNpbmcgdGhlaXJcbiAgICBbYGluaXRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuU3RhdGVGaWVsZC5pbml0KSBtZXRob2QsIHBhc3NpbmcgaW4gdGhlIG5ld1xuICAgIGNvbmZpZ3VyYXRpb24gb2JqZWN0Li5cbiAgICAqL1xuICAgIHJlY29uZmlndXJlKGNvbmZpZykge1xuICAgICAgICBsZXQgJGNvbmZpZyA9IG5ldyBDb25maWd1cmF0aW9uKHRoaXMuc2NoZW1hLCBjb25maWcucGx1Z2lucyk7XG4gICAgICAgIGxldCBmaWVsZHMgPSAkY29uZmlnLmZpZWxkcywgaW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUoJGNvbmZpZyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGZpZWxkc1tpXS5uYW1lO1xuICAgICAgICAgICAgaW5zdGFuY2VbbmFtZV0gPSB0aGlzLmhhc093blByb3BlcnR5KG5hbWUpID8gdGhpc1tuYW1lXSA6IGZpZWxkc1tpXS5pbml0KGNvbmZpZywgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgc3RhdGUgdG8gSlNPTi4gSWYgeW91IHdhbnQgdG8gc2VyaWFsaXplIHRoZSBzdGF0ZVxuICAgIG9mIHBsdWdpbnMsIHBhc3MgYW4gb2JqZWN0IG1hcHBpbmcgcHJvcGVydHkgbmFtZXMgdG8gdXNlIGluIHRoZVxuICAgIHJlc3VsdGluZyBKU09OIG9iamVjdCB0byBwbHVnaW4gb2JqZWN0cy4gVGhlIGFyZ3VtZW50IG1heSBhbHNvIGJlXG4gICAgYSBzdHJpbmcgb3IgbnVtYmVyLCBpbiB3aGljaCBjYXNlIGl0IGlzIGlnbm9yZWQsIHRvIHN1cHBvcnQgdGhlXG4gICAgd2F5IGBKU09OLnN0cmluZ2lmeWAgY2FsbHMgYHRvU3RyaW5nYCBtZXRob2RzLlxuICAgICovXG4gICAgdG9KU09OKHBsdWdpbkZpZWxkcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBkb2M6IHRoaXMuZG9jLnRvSlNPTigpLCBzZWxlY3Rpb246IHRoaXMuc2VsZWN0aW9uLnRvSlNPTigpIH07XG4gICAgICAgIGlmICh0aGlzLnN0b3JlZE1hcmtzKVxuICAgICAgICAgICAgcmVzdWx0LnN0b3JlZE1hcmtzID0gdGhpcy5zdG9yZWRNYXJrcy5tYXAobSA9PiBtLnRvSlNPTigpKTtcbiAgICAgICAgaWYgKHBsdWdpbkZpZWxkcyAmJiB0eXBlb2YgcGx1Z2luRmllbGRzID09ICdvYmplY3QnKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwbHVnaW5GaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PSBcImRvY1wiIHx8IHByb3AgPT0gXCJzZWxlY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgSlNPTiBmaWVsZHMgYGRvY2AgYW5kIGBzZWxlY3Rpb25gIGFyZSByZXNlcnZlZFwiKTtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gcGx1Z2luRmllbGRzW3Byb3BdLCBzdGF0ZSA9IHBsdWdpbi5zcGVjLnN0YXRlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS50b0pTT04pXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IHN0YXRlLnRvSlNPTi5jYWxsKHBsdWdpbiwgdGhpc1twbHVnaW4ua2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHN0YXRlLiBgY29uZmlnYCBzaG91bGRcbiAgICBoYXZlIGF0IGxlYXN0IGEgYHNjaGVtYWAgZmllbGQsIGFuZCBzaG91bGQgY29udGFpbiBhcnJheSBvZlxuICAgIHBsdWdpbnMgdG8gaW5pdGlhbGl6ZSB0aGUgc3RhdGUgd2l0aC4gYHBsdWdpbkZpZWxkc2AgY2FuIGJlIHVzZWRcbiAgICB0byBkZXNlcmlhbGl6ZSB0aGUgc3RhdGUgb2YgcGx1Z2lucywgYnkgYXNzb2NpYXRpbmcgcGx1Z2luXG4gICAgaW5zdGFuY2VzIHdpdGggdGhlIHByb3BlcnR5IG5hbWVzIHRoZXkgdXNlIGluIHRoZSBKU09OIG9iamVjdC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihjb25maWcsIGpzb24sIHBsdWdpbkZpZWxkcykge1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEVkaXRvclN0YXRlLmZyb21KU09OXCIpO1xuICAgICAgICBpZiAoIWNvbmZpZy5zY2hlbWEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlcXVpcmVkIGNvbmZpZyBmaWVsZCAnc2NoZW1hJyBtaXNzaW5nXCIpO1xuICAgICAgICBsZXQgJGNvbmZpZyA9IG5ldyBDb25maWd1cmF0aW9uKGNvbmZpZy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKCRjb25maWcpO1xuICAgICAgICAkY29uZmlnLmZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5uYW1lID09IFwiZG9jXCIpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5kb2MgPSBOb2RlLmZyb21KU09OKGNvbmZpZy5zY2hlbWEsIGpzb24uZG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLm5hbWUgPT0gXCJzZWxlY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLnNlbGVjdGlvbiA9IFNlbGVjdGlvbi5mcm9tSlNPTihpbnN0YW5jZS5kb2MsIGpzb24uc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLm5hbWUgPT0gXCJzdG9yZWRNYXJrc1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpzb24uc3RvcmVkTWFya3MpXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnN0b3JlZE1hcmtzID0ganNvbi5zdG9yZWRNYXJrcy5tYXAoY29uZmlnLnNjaGVtYS5tYXJrRnJvbUpTT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbkZpZWxkcylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwbHVnaW5GaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSBwbHVnaW5GaWVsZHNbcHJvcF0sIHN0YXRlID0gcGx1Z2luLnNwZWMuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGx1Z2luLmtleSA9PSBmaWVsZC5uYW1lICYmIHN0YXRlICYmIHN0YXRlLmZyb21KU09OICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGpzb24sIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VbZmllbGQubmFtZV0gPSBzdGF0ZS5mcm9tSlNPTi5jYWxsKHBsdWdpbiwgY29uZmlnLCBqc29uW3Byb3BdLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VbZmllbGQubmFtZV0gPSBmaWVsZC5pbml0KGNvbmZpZywgaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYmluZFByb3BzKG9iaiwgc2VsZiwgdGFyZ2V0KSB7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgbGV0IHZhbCA9IG9ialtwcm9wXTtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgICAgICAgdmFsID0gdmFsLmJpbmQoc2VsZik7XG4gICAgICAgIGVsc2UgaWYgKHByb3AgPT0gXCJoYW5kbGVET01FdmVudHNcIilcbiAgICAgICAgICAgIHZhbCA9IGJpbmRQcm9wcyh2YWwsIHNlbGYsIHt9KTtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuLyoqXG5QbHVnaW5zIGJ1bmRsZSBmdW5jdGlvbmFsaXR5IHRoYXQgY2FuIGJlIGFkZGVkIHRvIGFuIGVkaXRvci5cblRoZXkgYXJlIHBhcnQgb2YgdGhlIFtlZGl0b3Igc3RhdGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZSkgYW5kXG5tYXkgaW5mbHVlbmNlIHRoYXQgc3RhdGUgYW5kIHRoZSB2aWV3IHRoYXQgY29udGFpbnMgaXQuXG4qL1xuY2xhc3MgUGx1Z2luIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBwbHVnaW4uXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcGx1Z2luJ3MgW3NwZWMgb2JqZWN0XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuUGx1Z2luU3BlYykuXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgW3Byb3BzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcykgZXhwb3J0ZWQgYnkgdGhpcyBwbHVnaW4uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucHJvcHMgPSB7fTtcbiAgICAgICAgaWYgKHNwZWMucHJvcHMpXG4gICAgICAgICAgICBiaW5kUHJvcHMoc3BlYy5wcm9wcywgdGhpcywgdGhpcy5wcm9wcyk7XG4gICAgICAgIHRoaXMua2V5ID0gc3BlYy5rZXkgPyBzcGVjLmtleS5rZXkgOiBjcmVhdGVLZXkoXCJwbHVnaW5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dHJhY3QgdGhlIHBsdWdpbidzIHN0YXRlIGZpZWxkIGZyb20gYW4gZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgZ2V0U3RhdGUoc3RhdGUpIHsgcmV0dXJuIHN0YXRlW3RoaXMua2V5XTsgfVxufVxuY29uc3Qga2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBjcmVhdGVLZXkobmFtZSkge1xuICAgIGlmIChuYW1lIGluIGtleXMpXG4gICAgICAgIHJldHVybiBuYW1lICsgXCIkXCIgKyArK2tleXNbbmFtZV07XG4gICAga2V5c1tuYW1lXSA9IDA7XG4gICAgcmV0dXJuIG5hbWUgKyBcIiRcIjtcbn1cbi8qKlxuQSBrZXkgaXMgdXNlZCB0byBbdGFnXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuUGx1Z2luU3BlYy5rZXkpIHBsdWdpbnMgaW4gYSB3YXlcbnRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG8gZmluZCB0aGVtLCBnaXZlbiBhbiBlZGl0b3Igc3RhdGUuXG5Bc3NpZ25pbmcgYSBrZXkgZG9lcyBtZWFuIG9ubHkgb25lIHBsdWdpbiBvZiB0aGF0IHR5cGUgY2FuIGJlXG5hY3RpdmUgaW4gYSBzdGF0ZS5cbiovXG5jbGFzcyBQbHVnaW5LZXkge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBsdWdpbiBrZXkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lID0gXCJrZXlcIikgeyB0aGlzLmtleSA9IGNyZWF0ZUtleShuYW1lKTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgYWN0aXZlIHBsdWdpbiB3aXRoIHRoaXMga2V5LCBpZiBhbnksIGZyb20gYW4gZWRpdG9yXG4gICAgc3RhdGUuXG4gICAgKi9cbiAgICBnZXQoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLmNvbmZpZy5wbHVnaW5zQnlLZXlbdGhpcy5rZXldOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwbHVnaW4ncyBzdGF0ZSBmcm9tIGFuIGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIGdldFN0YXRlKHN0YXRlKSB7IHJldHVybiBzdGF0ZVt0aGlzLmtleV07IH1cbn1cblxuZXhwb3J0IHsgQWxsU2VsZWN0aW9uLCBFZGl0b3JTdGF0ZSwgTm9kZVNlbGVjdGlvbiwgUGx1Z2luLCBQbHVnaW5LZXksIFNlbGVjdGlvbiwgU2VsZWN0aW9uUmFuZ2UsIFRleHRTZWxlY3Rpb24sIFRyYW5zYWN0aW9uIH07XG4iLCAiaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiwgTm9kZVNlbGVjdGlvbiwgQWxsU2VsZWN0aW9uLCBTZWxlY3Rpb24gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBET01TZXJpYWxpemVyLCBGcmFnbWVudCwgTWFyaywgU2xpY2UsIERPTVBhcnNlciB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IGRyb3BQb2ludCB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbmNvbnN0IGRvbUluZGV4ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7OyBpbmRleCsrKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn07XG5jb25zdCBwYXJlbnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBsZXQgcGFyZW50ID0gbm9kZS5hc3NpZ25lZFNsb3QgfHwgbm9kZS5wYXJlbnROb2RlO1xuICAgIHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09IDExID8gcGFyZW50Lmhvc3QgOiBwYXJlbnQ7XG59O1xubGV0IHJldXNlZFJhbmdlID0gbnVsbDtcbi8vIE5vdGUgdGhhdCB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiB0aGUgc2FtZSByYW5nZSwgYmVjYXVzZSBET00gcmFuZ2Vcbi8vIG9iamVjdHMgYXJlIGV2ZXJ5IGV4cGVuc2l2ZSwgYW5kIGtlZXAgc2xvd2luZyBkb3duIHN1YnNlcXVlbnQgRE9NXG4vLyB1cGRhdGVzLCBmb3Igc29tZSByZWFzb24uXG5jb25zdCB0ZXh0UmFuZ2UgPSBmdW5jdGlvbiAobm9kZSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgcmFuZ2UgPSByZXVzZWRSYW5nZSB8fCAocmV1c2VkUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpKTtcbiAgICByYW5nZS5zZXRFbmQobm9kZSwgdG8gPT0gbnVsbCA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IHRvKTtcbiAgICByYW5nZS5zZXRTdGFydChub2RlLCBmcm9tIHx8IDApO1xuICAgIHJldHVybiByYW5nZTtcbn07XG4vLyBTY2FucyBmb3J3YXJkIGFuZCBiYWNrd2FyZCB0aHJvdWdoIERPTSBwb3NpdGlvbnMgZXF1aXZhbGVudCB0byB0aGVcbi8vIGdpdmVuIG9uZSB0byBzZWUgaWYgdGhlIHR3byBhcmUgaW4gdGhlIHNhbWUgcGxhY2UgKGkuZS4gYWZ0ZXIgYVxuLy8gdGV4dCBub2RlIHZzIGF0IHRoZSBlbmQgb2YgdGhhdCB0ZXh0IG5vZGUpXG5jb25zdCBpc0VxdWl2YWxlbnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZikge1xuICAgIHJldHVybiB0YXJnZXROb2RlICYmIChzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAtMSkgfHxcbiAgICAgICAgc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgMSkpO1xufTtcbmNvbnN0IGF0b21FbGVtZW50cyA9IC9eKGltZ3xicnxpbnB1dHx0ZXh0YXJlYXxocikkL2k7XG5mdW5jdGlvbiBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCBkaXIpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlID09IHRhcmdldE5vZGUgJiYgb2ZmID09IHRhcmdldE9mZilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob2ZmID09IChkaXIgPCAwID8gMCA6IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxIHx8IGhhc0Jsb2NrRGVzYyhub2RlKSB8fCBhdG9tRWxlbWVudHMudGVzdChub2RlLm5vZGVOYW1lKSB8fFxuICAgICAgICAgICAgICAgIG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkb21JbmRleChub2RlKSArIChkaXIgPCAwID8gMCA6IDEpO1xuICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2ZmICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgb2ZmID0gZGlyIDwgMCA/IG5vZGVTaXplKG5vZGUpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG5vZGVTaXplKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGlzT25FZGdlKG5vZGUsIG9mZnNldCwgcGFyZW50KSB7XG4gICAgZm9yIChsZXQgYXRTdGFydCA9IG9mZnNldCA9PSAwLCBhdEVuZCA9IG9mZnNldCA9PSBub2RlU2l6ZShub2RlKTsgYXRTdGFydCB8fCBhdEVuZDspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCBpbmRleCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGF0U3RhcnQgPSBhdFN0YXJ0ICYmIGluZGV4ID09IDA7XG4gICAgICAgIGF0RW5kID0gYXRFbmQgJiYgaW5kZXggPT0gbm9kZVNpemUobm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQmxvY2tEZXNjKGRvbSkge1xuICAgIGxldCBkZXNjO1xuICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKGRlc2MgPSBjdXIucG1WaWV3RGVzYylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIHJldHVybiBkZXNjICYmIGRlc2Mubm9kZSAmJiBkZXNjLm5vZGUuaXNCbG9jayAmJiAoZGVzYy5kb20gPT0gZG9tIHx8IGRlc2MuY29udGVudERPTSA9PSBkb20pO1xufVxuLy8gV29yayBhcm91bmQgQ2hyb21lIGlzc3VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NzUyM1xuLy8gKGlzQ29sbGFwc2VkIGluYXBwcm9wcmlhdGVseSByZXR1cm5zIHRydWUgaW4gc2hhZG93IGRvbSlcbmNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IGZ1bmN0aW9uIChkb21TZWwpIHtcbiAgICByZXR1cm4gZG9tU2VsLmZvY3VzTm9kZSAmJiBpc0VxdWl2YWxlbnRQb3NpdGlvbihkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbn07XG5mdW5jdGlvbiBrZXlFdmVudChrZXlDb2RlLCBrZXkpIHtcbiAgICBsZXQgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGV2ZW50LmluaXRFdmVudChcImtleWRvd25cIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZXZlbnQua2V5Q29kZSA9IGtleUNvZGU7XG4gICAgZXZlbnQua2V5ID0gZXZlbnQuY29kZSA9IGtleTtcbiAgICByZXR1cm4gZXZlbnQ7XG59XG5mdW5jdGlvbiBkZWVwQWN0aXZlRWxlbWVudChkb2MpIHtcbiAgICBsZXQgZWx0ID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gICAgd2hpbGUgKGVsdCAmJiBlbHQuc2hhZG93Um9vdClcbiAgICAgICAgZWx0ID0gZWx0LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgICByZXR1cm4gZWx0O1xufVxuZnVuY3Rpb24gY2FyZXRGcm9tUG9pbnQoZG9jLCB4LCB5KSB7XG4gICAgaWYgKGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KSB7XG4gICAgICAgIHRyeSB7IC8vIEZpcmVmb3ggdGhyb3dzIGZvciB0aGlzIGNhbGwgaW4gaGFyZC10by1wcmVkaWN0IGNpcmN1bXN0YW5jZXMgKCM5OTQpXG4gICAgICAgICAgICBsZXQgcG9zID0gZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBpZiAocG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHBvcy5vZmZzZXROb2RlLCBvZmZzZXQ6IHBvcy5vZmZzZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgfVxuICAgIGlmIChkb2MuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBkb2MuY2FyZXRSYW5nZUZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogcmFuZ2Uuc3RhcnRDb250YWluZXIsIG9mZnNldDogcmFuZ2Uuc3RhcnRPZmZzZXQgfTtcbiAgICB9XG59XG5cbmNvbnN0IG5hdiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IG5hdmlnYXRvciA6IG51bGw7XG5jb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogbnVsbDtcbmNvbnN0IGFnZW50ID0gKG5hdiAmJiBuYXYudXNlckFnZW50KSB8fCBcIlwiO1xuY29uc3QgaWVfZWRnZSA9IC9FZGdlXFwvKFxcZCspLy5leGVjKGFnZW50KTtcbmNvbnN0IGllX3VwdG8xMCA9IC9NU0lFIFxcZC8uZXhlYyhhZ2VudCk7XG5jb25zdCBpZV8xMXVwID0gL1RyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKGFnZW50KTtcbmNvbnN0IGllID0gISEoaWVfdXB0bzEwIHx8IGllXzExdXAgfHwgaWVfZWRnZSk7XG5jb25zdCBpZV92ZXJzaW9uID0gaWVfdXB0bzEwID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogaWVfMTF1cCA/ICtpZV8xMXVwWzFdIDogaWVfZWRnZSA/ICtpZV9lZGdlWzFdIDogMDtcbmNvbnN0IGdlY2tvID0gIWllICYmIC9nZWNrb1xcLyhcXGQrKS9pLnRlc3QoYWdlbnQpO1xuZ2Vja28gJiYgKygvRmlyZWZveFxcLyhcXGQrKS8uZXhlYyhhZ2VudCkgfHwgWzAsIDBdKVsxXTtcbmNvbnN0IF9jaHJvbWUgPSAhaWUgJiYgL0Nocm9tZVxcLyhcXGQrKS8uZXhlYyhhZ2VudCk7XG5jb25zdCBjaHJvbWUgPSAhIV9jaHJvbWU7XG5jb25zdCBjaHJvbWVfdmVyc2lvbiA9IF9jaHJvbWUgPyArX2Nocm9tZVsxXSA6IDA7XG5jb25zdCBzYWZhcmkgPSAhaWUgJiYgISFuYXYgJiYgL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdi52ZW5kb3IpO1xuLy8gSXMgdHJ1ZSBmb3IgYm90aCBpT1MgYW5kIGlQYWRPUyBmb3IgY29udmVuaWVuY2VcbmNvbnN0IGlvcyA9IHNhZmFyaSAmJiAoL01vYmlsZVxcL1xcdysvLnRlc3QoYWdlbnQpIHx8ICEhbmF2ICYmIG5hdi5tYXhUb3VjaFBvaW50cyA+IDIpO1xuY29uc3QgbWFjID0gaW9zIHx8IChuYXYgPyAvTWFjLy50ZXN0KG5hdi5wbGF0Zm9ybSkgOiBmYWxzZSk7XG5jb25zdCB3aW5kb3dzID0gbmF2ID8gL1dpbi8udGVzdChuYXYucGxhdGZvcm0pIDogZmFsc2U7XG5jb25zdCBhbmRyb2lkID0gL0FuZHJvaWQgXFxkLy50ZXN0KGFnZW50KTtcbmNvbnN0IHdlYmtpdCA9ICEhZG9jICYmIFwid2Via2l0Rm9udFNtb290aGluZ1wiIGluIGRvYy5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5jb25zdCB3ZWJraXRfdmVyc2lvbiA9IHdlYmtpdCA/ICsoL1xcYkFwcGxlV2ViS2l0XFwvKFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwO1xuXG5mdW5jdGlvbiB3aW5kb3dSZWN0KGRvYykge1xuICAgIHJldHVybiB7IGxlZnQ6IDAsIHJpZ2h0OiBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLFxuICAgICAgICB0b3A6IDAsIGJvdHRvbTogZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfTtcbn1cbmZ1bmN0aW9uIGdldFNpZGUodmFsdWUsIHNpZGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyB2YWx1ZSA6IHZhbHVlW3NpZGVdO1xufVxuZnVuY3Rpb24gY2xpZW50UmVjdChub2RlKSB7XG4gICAgbGV0IHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIEFkanVzdCBmb3IgZWxlbWVudHMgd2l0aCBzdHlsZSBcInRyYW5zZm9ybTogc2NhbGUoKVwiXG4gICAgbGV0IHNjYWxlWCA9IChyZWN0LndpZHRoIC8gbm9kZS5vZmZzZXRXaWR0aCkgfHwgMTtcbiAgICBsZXQgc2NhbGVZID0gKHJlY3QuaGVpZ2h0IC8gbm9kZS5vZmZzZXRIZWlnaHQpIHx8IDE7XG4gICAgLy8gTWFrZSBzdXJlIHNjcm9sbGJhciB3aWR0aCBpc24ndCBpbmNsdWRlZCBpbiB0aGUgcmVjdGFuZ2xlXG4gICAgcmV0dXJuIHsgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5sZWZ0ICsgbm9kZS5jbGllbnRXaWR0aCAqIHNjYWxlWCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LnRvcCArIG5vZGUuY2xpZW50SGVpZ2h0ICogc2NhbGVZIH07XG59XG5mdW5jdGlvbiBzY3JvbGxSZWN0SW50b1ZpZXcodmlldywgcmVjdCwgc3RhcnRET00pIHtcbiAgICBsZXQgc2Nyb2xsVGhyZXNob2xkID0gdmlldy5zb21lUHJvcChcInNjcm9sbFRocmVzaG9sZFwiKSB8fCAwLCBzY3JvbGxNYXJnaW4gPSB2aWV3LnNvbWVQcm9wKFwic2Nyb2xsTWFyZ2luXCIpIHx8IDU7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgZm9yIChsZXQgcGFyZW50ID0gc3RhcnRET00gfHwgdmlldy5kb207OyBwYXJlbnQgPSBwYXJlbnROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBlbHQgPSBwYXJlbnQ7XG4gICAgICAgIGxldCBhdFRvcCA9IGVsdCA9PSBkb2MuYm9keTtcbiAgICAgICAgbGV0IGJvdW5kaW5nID0gYXRUb3AgPyB3aW5kb3dSZWN0KGRvYykgOiBjbGllbnRSZWN0KGVsdCk7XG4gICAgICAgIGxldCBtb3ZlWCA9IDAsIG1vdmVZID0gMDtcbiAgICAgICAgaWYgKHJlY3QudG9wIDwgYm91bmRpbmcudG9wICsgZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwidG9wXCIpKVxuICAgICAgICAgICAgbW92ZVkgPSAtKGJvdW5kaW5nLnRvcCAtIHJlY3QudG9wICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwidG9wXCIpKTtcbiAgICAgICAgZWxzZSBpZiAocmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20gLSBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJib3R0b21cIikpXG4gICAgICAgICAgICBtb3ZlWSA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3AgPiBib3VuZGluZy5ib3R0b20gLSBib3VuZGluZy50b3BcbiAgICAgICAgICAgICAgICA/IHJlY3QudG9wICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwidG9wXCIpIC0gYm91bmRpbmcudG9wXG4gICAgICAgICAgICAgICAgOiByZWN0LmJvdHRvbSAtIGJvdW5kaW5nLmJvdHRvbSArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcImJvdHRvbVwiKTtcbiAgICAgICAgaWYgKHJlY3QubGVmdCA8IGJvdW5kaW5nLmxlZnQgKyBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJsZWZ0XCIpKVxuICAgICAgICAgICAgbW92ZVggPSAtKGJvdW5kaW5nLmxlZnQgLSByZWN0LmxlZnQgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJsZWZ0XCIpKTtcbiAgICAgICAgZWxzZSBpZiAocmVjdC5yaWdodCA+IGJvdW5kaW5nLnJpZ2h0IC0gZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwicmlnaHRcIikpXG4gICAgICAgICAgICBtb3ZlWCA9IHJlY3QucmlnaHQgLSBib3VuZGluZy5yaWdodCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInJpZ2h0XCIpO1xuICAgICAgICBpZiAobW92ZVggfHwgbW92ZVkpIHtcbiAgICAgICAgICAgIGlmIChhdFRvcCkge1xuICAgICAgICAgICAgICAgIGRvYy5kZWZhdWx0Vmlldy5zY3JvbGxCeShtb3ZlWCwgbW92ZVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0WCA9IGVsdC5zY3JvbGxMZWZ0LCBzdGFydFkgPSBlbHQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlWSlcbiAgICAgICAgICAgICAgICAgICAgZWx0LnNjcm9sbFRvcCArPSBtb3ZlWTtcbiAgICAgICAgICAgICAgICBpZiAobW92ZVgpXG4gICAgICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxMZWZ0ICs9IG1vdmVYO1xuICAgICAgICAgICAgICAgIGxldCBkWCA9IGVsdC5zY3JvbGxMZWZ0IC0gc3RhcnRYLCBkWSA9IGVsdC5zY3JvbGxUb3AgLSBzdGFydFk7XG4gICAgICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogcmVjdC5sZWZ0IC0gZFgsIHRvcDogcmVjdC50b3AgLSBkWSwgcmlnaHQ6IHJlY3QucmlnaHQgLSBkWCwgYm90dG9tOiByZWN0LmJvdHRvbSAtIGRZIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0VG9wIHx8IC9eKGZpeGVkfHN0aWNreSkkLy50ZXN0KGdldENvbXB1dGVkU3R5bGUocGFyZW50KS5wb3NpdGlvbikpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG4vLyBTdG9yZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBlZGl0b3IncyBwYXJlbnQgbm9kZXMsIGFsb25nIHdpdGhcbi8vIHRoZSB0b3AgcG9zaXRpb24gb2YgYW4gZWxlbWVudCBuZWFyIHRoZSB0b3Agb2YgdGhlIGVkaXRvciwgd2hpY2hcbi8vIHdpbGwgYmUgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHZpc2libGUgdmlld3BvcnQgcmVtYWlucyBzdGFibGUgZXZlblxuLy8gd2hlbiB0aGUgc2l6ZSBvZiB0aGUgY29udGVudCBhYm92ZSBjaGFuZ2VzLlxuZnVuY3Rpb24gc3RvcmVTY3JvbGxQb3Modmlldykge1xuICAgIGxldCByZWN0ID0gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHN0YXJ0WSA9IE1hdGgubWF4KDAsIHJlY3QudG9wKTtcbiAgICBsZXQgcmVmRE9NLCByZWZUb3A7XG4gICAgZm9yIChsZXQgeCA9IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsIHkgPSBzdGFydFkgKyAxOyB5IDwgTWF0aC5taW4oaW5uZXJIZWlnaHQsIHJlY3QuYm90dG9tKTsgeSArPSA1KSB7XG4gICAgICAgIGxldCBkb20gPSB2aWV3LnJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKCFkb20gfHwgZG9tID09IHZpZXcuZG9tIHx8ICF2aWV3LmRvbS5jb250YWlucyhkb20pKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBsb2NhbFJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChsb2NhbFJlY3QudG9wID49IHN0YXJ0WSAtIDIwKSB7XG4gICAgICAgICAgICByZWZET00gPSBkb207XG4gICAgICAgICAgICByZWZUb3AgPSBsb2NhbFJlY3QudG9wO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgcmVmRE9NOiByZWZET00sIHJlZlRvcDogcmVmVG9wLCBzdGFjazogc2Nyb2xsU3RhY2sodmlldy5kb20pIH07XG59XG5mdW5jdGlvbiBzY3JvbGxTdGFjayhkb20pIHtcbiAgICBsZXQgc3RhY2sgPSBbXSwgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7IGN1ciA9IHBhcmVudE5vZGUoY3VyKSkge1xuICAgICAgICBzdGFjay5wdXNoKHsgZG9tOiBjdXIsIHRvcDogY3VyLnNjcm9sbFRvcCwgbGVmdDogY3VyLnNjcm9sbExlZnQgfSk7XG4gICAgICAgIGlmIChkb20gPT0gZG9jKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBzdGFjaztcbn1cbi8vIFJlc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGVkaXRvcidzIHBhcmVudCBub2RlcyB0byB0aGF0IHdoYXRcbi8vIGl0IHdhcyBiZWZvcmUsIHdoZW4gc3RvcmVTY3JvbGxQb3Mgd2FzIGNhbGxlZC5cbmZ1bmN0aW9uIHJlc2V0U2Nyb2xsUG9zKHsgcmVmRE9NLCByZWZUb3AsIHN0YWNrIH0pIHtcbiAgICBsZXQgbmV3UmVmVG9wID0gcmVmRE9NID8gcmVmRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA6IDA7XG4gICAgcmVzdG9yZVNjcm9sbFN0YWNrKHN0YWNrLCBuZXdSZWZUb3AgPT0gMCA/IDAgOiBuZXdSZWZUb3AgLSByZWZUb3ApO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcm9sbFN0YWNrKHN0YWNrLCBkVG9wKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgeyBkb20sIHRvcCwgbGVmdCB9ID0gc3RhY2tbaV07XG4gICAgICAgIGlmIChkb20uc2Nyb2xsVG9wICE9IHRvcCArIGRUb3ApXG4gICAgICAgICAgICBkb20uc2Nyb2xsVG9wID0gdG9wICsgZFRvcDtcbiAgICAgICAgaWYgKGRvbS5zY3JvbGxMZWZ0ICE9IGxlZnQpXG4gICAgICAgICAgICBkb20uc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgfVxufVxubGV0IHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBudWxsO1xuLy8gRmVhdHVyZS1kZXRlY3RzIHN1cHBvcnQgZm9yIC5mb2N1cyh7cHJldmVudFNjcm9sbDogdHJ1ZX0pLCBhbmQgdXNlc1xuLy8gYSBmYWxsYmFjayBrbHVkZ2Ugd2hlbiBub3Qgc3VwcG9ydGVkLlxuZnVuY3Rpb24gZm9jdXNQcmV2ZW50U2Nyb2xsKGRvbSkge1xuICAgIGlmIChkb20uc2V0QWN0aXZlKVxuICAgICAgICByZXR1cm4gZG9tLnNldEFjdGl2ZSgpOyAvLyBpbiBJRVxuICAgIGlmIChwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpO1xuICAgIGxldCBzdG9yZWQgPSBzY3JvbGxTdGFjayhkb20pO1xuICAgIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID09IG51bGwgPyB7XG4gICAgICAgIGdldCBwcmV2ZW50U2Nyb2xsKCkge1xuICAgICAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IDogdW5kZWZpbmVkKTtcbiAgICBpZiAoIXByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpIHtcbiAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICByZXN0b3JlU2Nyb2xsU3RhY2soc3RvcmVkLCAwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kT2Zmc2V0SW5Ob2RlKG5vZGUsIGNvb3Jkcykge1xuICAgIGxldCBjbG9zZXN0LCBkeENsb3Nlc3QgPSAyZTgsIGNvb3Jkc0Nsb3Nlc3QsIG9mZnNldCA9IDA7XG4gICAgbGV0IHJvd0JvdCA9IGNvb3Jkcy50b3AsIHJvd1RvcCA9IGNvb3Jkcy50b3A7XG4gICAgbGV0IGZpcnN0QmVsb3csIGNvb3Jkc0JlbG93O1xuICAgIGZvciAobGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkLCBjaGlsZEluZGV4ID0gMDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcsIGNoaWxkSW5kZXgrKykge1xuICAgICAgICBsZXQgcmVjdHM7XG4gICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgcmVjdHMgPSBjaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgcmVjdHMgPSB0ZXh0UmFuZ2UoY2hpbGQpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICAgICAgaWYgKHJlY3QudG9wIDw9IHJvd0JvdCAmJiByZWN0LmJvdHRvbSA+PSByb3dUb3ApIHtcbiAgICAgICAgICAgICAgICByb3dCb3QgPSBNYXRoLm1heChyZWN0LmJvdHRvbSwgcm93Qm90KTtcbiAgICAgICAgICAgICAgICByb3dUb3AgPSBNYXRoLm1pbihyZWN0LnRvcCwgcm93VG9wKTtcbiAgICAgICAgICAgICAgICBsZXQgZHggPSByZWN0LmxlZnQgPiBjb29yZHMubGVmdCA/IHJlY3QubGVmdCAtIGNvb3Jkcy5sZWZ0XG4gICAgICAgICAgICAgICAgICAgIDogcmVjdC5yaWdodCA8IGNvb3Jkcy5sZWZ0ID8gY29vcmRzLmxlZnQgLSByZWN0LnJpZ2h0IDogMDtcbiAgICAgICAgICAgICAgICBpZiAoZHggPCBkeENsb3Nlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBkeENsb3Nlc3QgPSBkeDtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzQ2xvc2VzdCA9IGR4ICYmIGNsb3Nlc3Qubm9kZVR5cGUgPT0gMyA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCA/IHJlY3QucmlnaHQgOiByZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGNvb3Jkcy50b3BcbiAgICAgICAgICAgICAgICAgICAgfSA6IGNvb3JkcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEgJiYgZHgpXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBjaGlsZEluZGV4ICsgKGNvb3Jkcy5sZWZ0ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QudG9wID4gY29vcmRzLnRvcCAmJiAhZmlyc3RCZWxvdyAmJiByZWN0LmxlZnQgPD0gY29vcmRzLmxlZnQgJiYgcmVjdC5yaWdodCA+PSBjb29yZHMubGVmdCkge1xuICAgICAgICAgICAgICAgIGZpcnN0QmVsb3cgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBjb29yZHNCZWxvdyA9IHsgbGVmdDogTWF0aC5tYXgocmVjdC5sZWZ0LCBNYXRoLm1pbihyZWN0LnJpZ2h0LCBjb29yZHMubGVmdCkpLCB0b3A6IHJlY3QudG9wIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNsb3Nlc3QgJiYgKGNvb3Jkcy5sZWZ0ID49IHJlY3QucmlnaHQgJiYgY29vcmRzLnRvcCA+PSByZWN0LnRvcCB8fFxuICAgICAgICAgICAgICAgIGNvb3Jkcy5sZWZ0ID49IHJlY3QubGVmdCAmJiBjb29yZHMudG9wID49IHJlY3QuYm90dG9tKSlcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBjaGlsZEluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNsb3Nlc3QgJiYgZmlyc3RCZWxvdykge1xuICAgICAgICBjbG9zZXN0ID0gZmlyc3RCZWxvdztcbiAgICAgICAgY29vcmRzQ2xvc2VzdCA9IGNvb3Jkc0JlbG93O1xuICAgICAgICBkeENsb3Nlc3QgPSAwO1xuICAgIH1cbiAgICBpZiAoY2xvc2VzdCAmJiBjbG9zZXN0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgIHJldHVybiBmaW5kT2Zmc2V0SW5UZXh0KGNsb3Nlc3QsIGNvb3Jkc0Nsb3Nlc3QpO1xuICAgIGlmICghY2xvc2VzdCB8fCAoZHhDbG9zZXN0ICYmIGNsb3Nlc3Qubm9kZVR5cGUgPT0gMSkpXG4gICAgICAgIHJldHVybiB7IG5vZGUsIG9mZnNldCB9O1xuICAgIHJldHVybiBmaW5kT2Zmc2V0SW5Ob2RlKGNsb3Nlc3QsIGNvb3Jkc0Nsb3Nlc3QpO1xufVxuZnVuY3Rpb24gZmluZE9mZnNldEluVGV4dChub2RlLCBjb29yZHMpIHtcbiAgICBsZXQgbGVuID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgaSArIDEpO1xuICAgICAgICByYW5nZS5zZXRTdGFydChub2RlLCBpKTtcbiAgICAgICAgbGV0IHJlY3QgPSBzaW5nbGVSZWN0KHJhbmdlLCAxKTtcbiAgICAgICAgaWYgKHJlY3QudG9wID09IHJlY3QuYm90dG9tKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChpblJlY3QoY29vcmRzLCByZWN0KSlcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogaSArIChjb29yZHMubGVmdCA+PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyID8gMSA6IDApIH07XG4gICAgfVxuICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogMCB9O1xufVxuZnVuY3Rpb24gaW5SZWN0KGNvb3JkcywgcmVjdCkge1xuICAgIHJldHVybiBjb29yZHMubGVmdCA+PSByZWN0LmxlZnQgLSAxICYmIGNvb3Jkcy5sZWZ0IDw9IHJlY3QucmlnaHQgKyAxICYmXG4gICAgICAgIGNvb3Jkcy50b3AgPj0gcmVjdC50b3AgLSAxICYmIGNvb3Jkcy50b3AgPD0gcmVjdC5ib3R0b20gKyAxO1xufVxuZnVuY3Rpb24gdGFyZ2V0S2x1ZGdlKGRvbSwgY29vcmRzKSB7XG4gICAgbGV0IHBhcmVudCA9IGRvbS5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQgJiYgL15saSQvaS50ZXN0KHBhcmVudC5ub2RlTmFtZSkgJiYgY29vcmRzLmxlZnQgPCBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdClcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICByZXR1cm4gZG9tO1xufVxuZnVuY3Rpb24gcG9zRnJvbUVsZW1lbnQodmlldywgZWx0LCBjb29yZHMpIHtcbiAgICBsZXQgeyBub2RlLCBvZmZzZXQgfSA9IGZpbmRPZmZzZXRJbk5vZGUoZWx0LCBjb29yZHMpLCBiaWFzID0gLTE7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiAhbm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIGxldCByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgYmlhcyA9IHJlY3QubGVmdCAhPSByZWN0LnJpZ2h0ICYmIGNvb3Jkcy5sZWZ0ID4gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiA/IDEgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgYmlhcyk7XG59XG5mdW5jdGlvbiBwb3NGcm9tQ2FyZXQodmlldywgbm9kZSwgb2Zmc2V0LCBjb29yZHMpIHtcbiAgICAvLyBCcm93c2VyIChpbiBjYXJldFBvc2l0aW9uL1JhbmdlRnJvbVBvaW50KSB3aWxsIGFncmVzc2l2ZWx5XG4gICAgLy8gbm9ybWFsaXplIHRvd2FyZHMgbmVhcmJ5IGlubGluZSBub2Rlcy4gU2luY2Ugd2UgYXJlIGludGVyZXN0ZWQgaW5cbiAgICAvLyBwb3NpdGlvbnMgYmV0d2VlbiBibG9jayBub2RlcyB0b28sIHdlIGZpcnN0IHdhbGsgdXAgdGhlIGhpZXJhcmNoeVxuICAgIC8vIG9mIG5vZGVzIHRvIHNlZSBpZiB0aGVyZSBhcmUgYmxvY2sgbm9kZXMgdGhhdCB0aGUgY29vcmRpbmF0ZXNcbiAgICAvLyBmYWxsIG91dHNpZGUgb2YuIElmIHNvLCB3ZSB0YWtlIHRoZSBwb3NpdGlvbiBiZWZvcmUvYWZ0ZXIgdGhhdFxuICAgIC8vIGJsb2NrLiBJZiBub3QsIHdlIGNhbGwgYHBvc0Zyb21ET01gIG9uIHRoZSByYXcgbm9kZS9vZmZzZXQuXG4gICAgbGV0IG91dHNpZGVCbG9jayA9IC0xO1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGUsIHNhd0Jsb2NrID0gZmFsc2U7Oykge1xuICAgICAgICBpZiAoY3VyID09IHZpZXcuZG9tKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGN1ciwgdHJ1ZSk7XG4gICAgICAgIGlmICghZGVzYylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoZGVzYy5kb20ubm9kZVR5cGUgPT0gMSAmJiAoZGVzYy5ub2RlLmlzQmxvY2sgJiYgZGVzYy5wYXJlbnQgJiYgIXNhd0Jsb2NrIHx8ICFkZXNjLmNvbnRlbnRET00pKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IGRlc2MuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgaWYgKGRlc2Mubm9kZS5pc0Jsb2NrICYmIGRlc2MucGFyZW50ICYmICFzYXdCbG9jaykge1xuICAgICAgICAgICAgICAgIHNhd0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC5sZWZ0ID4gY29vcmRzLmxlZnQgfHwgcmVjdC50b3AgPiBjb29yZHMudG9wKVxuICAgICAgICAgICAgICAgICAgICBvdXRzaWRlQmxvY2sgPSBkZXNjLnBvc0JlZm9yZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgfHwgcmVjdC5ib3R0b20gPCBjb29yZHMudG9wKVxuICAgICAgICAgICAgICAgICAgICBvdXRzaWRlQmxvY2sgPSBkZXNjLnBvc0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZXNjLmNvbnRlbnRET00gJiYgb3V0c2lkZUJsb2NrIDwgMCAmJiAhZGVzYy5ub2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBpbnNpZGUgYSBsZWFmLCByZXR1cm4gdGhlIHNpZGUgb2YgdGhlIGxlYWYgY2xvc2VyIHRvIHRoZSBjb29yZHNcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gZGVzYy5ub2RlLmlzQmxvY2sgPyBjb29yZHMudG9wIDwgKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMlxuICAgICAgICAgICAgICAgICAgICA6IGNvb3Jkcy5sZWZ0IDwgKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlID8gZGVzYy5wb3NCZWZvcmUgOiBkZXNjLnBvc0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1ciA9IGRlc2MuZG9tLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBvdXRzaWRlQmxvY2sgPiAtMSA/IG91dHNpZGVCbG9jayA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgLTEpO1xufVxuZnVuY3Rpb24gZWxlbWVudEZyb21Qb2ludChlbGVtZW50LCBjb29yZHMsIGJveCkge1xuICAgIGxldCBsZW4gPSBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIGlmIChsZW4gJiYgYm94LnRvcCA8IGJveC5ib3R0b20pIHtcbiAgICAgICAgZm9yIChsZXQgc3RhcnRJID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obGVuIC0gMSwgTWF0aC5mbG9vcihsZW4gKiAoY29vcmRzLnRvcCAtIGJveC50b3ApIC8gKGJveC5ib3R0b20gLSBib3gudG9wKSkgLSAyKSksIGkgPSBzdGFydEk7Oykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdHMgPSBjaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluUmVjdChjb29yZHMsIHJlY3QpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRGcm9tUG9pbnQoY2hpbGQsIGNvb3JkcywgcmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpID0gKGkgKyAxKSAlIGxlbikgPT0gc3RhcnRJKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufVxuLy8gR2l2ZW4gYW4geCx5IHBvc2l0aW9uIG9uIHRoZSBlZGl0b3IsIGdldCB0aGUgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LlxuZnVuY3Rpb24gcG9zQXRDb29yZHModmlldywgY29vcmRzKSB7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQsIG5vZGUsIG9mZnNldCA9IDA7XG4gICAgbGV0IGNhcmV0ID0gY2FyZXRGcm9tUG9pbnQoZG9jLCBjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgaWYgKGNhcmV0KVxuICAgICAgICAoeyBub2RlLCBvZmZzZXQgfSA9IGNhcmV0KTtcbiAgICBsZXQgZWx0ID0gKHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50ID8gdmlldy5yb290IDogZG9jKVxuICAgICAgICAuZWxlbWVudEZyb21Qb2ludChjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgbGV0IHBvcztcbiAgICBpZiAoIWVsdCB8fCAhdmlldy5kb20uY29udGFpbnMoZWx0Lm5vZGVUeXBlICE9IDEgPyBlbHQucGFyZW50Tm9kZSA6IGVsdCkpIHtcbiAgICAgICAgbGV0IGJveCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoIWluUmVjdChjb29yZHMsIGJveCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZWx0ID0gZWxlbWVudEZyb21Qb2ludCh2aWV3LmRvbSwgY29vcmRzLCBib3gpO1xuICAgICAgICBpZiAoIWVsdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBTYWZhcmkncyBjYXJldFJhbmdlRnJvbVBvaW50IHJldHVybnMgbm9uc2Vuc2Ugd2hlbiBvbiBhIGRyYWdnYWJsZSBlbGVtZW50XG4gICAgaWYgKHNhZmFyaSkge1xuICAgICAgICBmb3IgKGxldCBwID0gZWx0OyBub2RlICYmIHA7IHAgPSBwYXJlbnROb2RlKHApKVxuICAgICAgICAgICAgaWYgKHAuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsdCA9IHRhcmdldEtsdWRnZShlbHQsIGNvb3Jkcyk7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKGdlY2tvICYmIG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgLy8gRmlyZWZveCB3aWxsIHNvbWV0aW1lcyByZXR1cm4gb2Zmc2V0cyBpbnRvIDxpbnB1dD4gbm9kZXMsIHdoaWNoXG4gICAgICAgICAgICAvLyBoYXZlIG5vIGFjdHVhbCBjaGlsZHJlbiwgZnJvbSBjYXJldFBvc2l0aW9uRnJvbVBvaW50ICgjOTUzKVxuICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0LCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIEl0J2xsIGFsc28gbW92ZSB0aGUgcmV0dXJuZWQgcG9zaXRpb24gYmVmb3JlIGltYWdlIG5vZGVzLFxuICAgICAgICAgICAgLy8gZXZlbiBpZiB0aG9zZSBhcmUgYmVoaW5kIGl0LlxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLCBib3g7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubm9kZU5hbWUgPT0gXCJJTUdcIiAmJiAoYm94ID0gbmV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkucmlnaHQgPD0gY29vcmRzLmxlZnQgJiZcbiAgICAgICAgICAgICAgICAgICAgYm94LmJvdHRvbSA+IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBwcmV2O1xuICAgICAgICAvLyBXaGVuIGNsaWNraW5nIGFib3ZlIHRoZSByaWdodCBzaWRlIG9mIGFuIHVuZWRpdGFibGUgbm9kZSwgQ2hyb21lIHdpbGwgcmVwb3J0IGEgY3Vyc29yIHBvc2l0aW9uIGFmdGVyIHRoYXQgbm9kZS5cbiAgICAgICAgaWYgKHdlYmtpdCAmJiBvZmZzZXQgJiYgbm9kZS5ub2RlVHlwZSA9PSAxICYmIChwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdKS5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICBwcmV2LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIgJiYgcHJldi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgPj0gY29vcmRzLnRvcClcbiAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAvLyBTdXNwaWNpb3VzbHkgc3BlY2lmaWMga2x1ZGdlIHRvIHdvcmsgYXJvdW5kIGNhcmV0KkZyb21Qb2ludFxuICAgICAgICAvLyBuZXZlciByZXR1cm5pbmcgYSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSAmJiBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEgJiYgbm9kZS5sYXN0Q2hpbGQubm9kZVR5cGUgPT0gMSAmJlxuICAgICAgICAgICAgY29vcmRzLnRvcCA+IG5vZGUubGFzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSlcbiAgICAgICAgICAgIHBvcyA9IHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgLy8gSWdub3JlIHBvc2l0aW9ucyBkaXJlY3RseSBhZnRlciBhIEJSLCBzaW5jZSBjYXJldCpGcm9tUG9pbnRcbiAgICAgICAgLy8gJ3JvdW5kIHVwJyBwb3NpdGlvbnMgdGhhdCB3b3VsZCBiZSBtb3JlIGFjY3VyYXRlbHkgcGxhY2VkXG4gICAgICAgIC8vIGJlZm9yZSB0aGUgQlIgbm9kZS5cbiAgICAgICAgZWxzZSBpZiAob2Zmc2V0ID09IDAgfHwgbm9kZS5ub2RlVHlwZSAhPSAxIHx8IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXS5ub2RlTmFtZSAhPSBcIkJSXCIpXG4gICAgICAgICAgICBwb3MgPSBwb3NGcm9tQ2FyZXQodmlldywgbm9kZSwgb2Zmc2V0LCBjb29yZHMpO1xuICAgIH1cbiAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgIHBvcyA9IHBvc0Zyb21FbGVtZW50KHZpZXcsIGVsdCwgY29vcmRzKTtcbiAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhlbHQsIHRydWUpO1xuICAgIHJldHVybiB7IHBvcywgaW5zaWRlOiBkZXNjID8gZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIgOiAtMSB9O1xufVxuZnVuY3Rpb24gbm9uWmVybyhyZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QudG9wIDwgcmVjdC5ib3R0b20gfHwgcmVjdC5sZWZ0IDwgcmVjdC5yaWdodDtcbn1cbmZ1bmN0aW9uIHNpbmdsZVJlY3QodGFyZ2V0LCBiaWFzKSB7XG4gICAgbGV0IHJlY3RzID0gdGFyZ2V0LmdldENsaWVudFJlY3RzKCk7XG4gICAgaWYgKHJlY3RzLmxlbmd0aCkge1xuICAgICAgICBsZXQgZmlyc3QgPSByZWN0c1tiaWFzIDwgMCA/IDAgOiByZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKG5vblplcm8oZmlyc3QpKVxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChyZWN0cywgbm9uWmVybykgfHwgdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuY29uc3QgQklESSA9IC9bXFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MDcwMC1cXHUwOGFjXS87XG4vLyBHaXZlbiBhIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCBtb2RlbCwgZ2V0IGEgYm91bmRpbmcgYm94IG9mIHRoZVxuLy8gY2hhcmFjdGVyIGF0IHRoYXQgcG9zaXRpb24sIHJlbGF0aXZlIHRvIHRoZSB3aW5kb3cuXG5mdW5jdGlvbiBjb29yZHNBdFBvcyh2aWV3LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgeyBub2RlLCBvZmZzZXQsIGF0b20gfSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgc2lkZSA8IDAgPyAtMSA6IDEpO1xuICAgIGxldCBzdXBwb3J0RW1wdHlSYW5nZSA9IHdlYmtpdCB8fCBnZWNrbztcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgIC8vIFRoZXNlIGJyb3dzZXJzIHN1cHBvcnQgcXVlcnlpbmcgZW1wdHkgdGV4dCByYW5nZXMuIFByZWZlciB0aGF0IGluXG4gICAgICAgIC8vIGJpZGkgY29udGV4dCBvciB3aGVuIGF0IHRoZSBlbmQgb2YgYSBub2RlLlxuICAgICAgICBpZiAoc3VwcG9ydEVtcHR5UmFuZ2UgJiYgKEJJREkudGVzdChub2RlLm5vZGVWYWx1ZSkgfHwgKHNpZGUgPCAwID8gIW9mZnNldCA6IG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpKSkge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCksIHNpZGUpO1xuICAgICAgICAgICAgLy8gRmlyZWZveCByZXR1cm5zIGJhZCByZXN1bHRzICh0aGUgcG9zaXRpb24gYmVmb3JlIHRoZSBzcGFjZSlcbiAgICAgICAgICAgIC8vIHdoZW4gcXVlcnlpbmcgYSBwb3NpdGlvbiBkaXJlY3RseSBhZnRlciBsaW5lLWJyb2tlblxuICAgICAgICAgICAgLy8gd2hpdGVzcGFjZS4gRGV0ZWN0IHRoaXMgc2l0dWF0aW9uIGFuZCBhbmQga2x1ZGdlIGFyb3VuZCBpdFxuICAgICAgICAgICAgaWYgKGdlY2tvICYmIG9mZnNldCAmJiAvXFxzLy50ZXN0KG5vZGUubm9kZVZhbHVlW29mZnNldCAtIDFdKSAmJiBvZmZzZXQgPCBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdEJlZm9yZSA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCAtIDEsIG9mZnNldCAtIDEpLCAtMSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3RCZWZvcmUudG9wID09IHJlY3QudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0QWZ0ZXIgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCArIDEpLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0QWZ0ZXIudG9wICE9IHJlY3QudG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5WKHJlY3RBZnRlciwgcmVjdEFmdGVyLmxlZnQgPCByZWN0QmVmb3JlLmxlZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBvZmZzZXQsIHRvID0gb2Zmc2V0LCB0YWtlU2lkZSA9IHNpZGUgPCAwID8gMSA6IC0xO1xuICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmICFvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIHRha2VTaWRlID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaWRlID49IDAgJiYgb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgICAgICB0YWtlU2lkZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaWRlIDwgMCkge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8pLCB0YWtlU2lkZSksIHRha2VTaWRlIDwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0ICRkb20gPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyAtIChhdG9tIHx8IDApKTtcbiAgICAvLyBSZXR1cm4gYSBob3Jpem9udGFsIGxpbmUgaW4gYmxvY2sgY29udGV4dFxuICAgIGlmICghJGRvbS5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCAmJiAoc2lkZSA8IDAgfHwgb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlbkgoYmVmb3JlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0b20gPT0gbnVsbCAmJiBvZmZzZXQgPCBub2RlU2l6ZShub2RlKSkge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBpZiAoYWZ0ZXIubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlbkgoYWZ0ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGF0dGVuSChub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzaWRlID49IDApO1xuICAgIH1cbiAgICAvLyBJbmxpbmUsIG5vdCBpbiB0ZXh0IG5vZGUgKHRoaXMgaXMgbm90IEJpZGktc2FmZSlcbiAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCAmJiAoc2lkZSA8IDAgfHwgb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gYmVmb3JlLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2UoYmVmb3JlLCBub2RlU2l6ZShiZWZvcmUpIC0gKHN1cHBvcnRFbXB0eVJhbmdlID8gMCA6IDEpKVxuICAgICAgICAgICAgLy8gQlIgbm9kZXMgdGVuZCB0byBvbmx5IHJldHVybiB0aGUgcmVjdGFuZ2xlIGJlZm9yZSB0aGVtLlxuICAgICAgICAgICAgLy8gT25seSB1c2UgdGhlbSBpZiB0aGV5IGFyZSB0aGUgbGFzdCBlbGVtZW50IGluIHRoZWlyIHBhcmVudFxuICAgICAgICAgICAgOiBiZWZvcmUubm9kZVR5cGUgPT0gMSAmJiAoYmVmb3JlLm5vZGVOYW1lICE9IFwiQlJcIiB8fCAhYmVmb3JlLm5leHRTaWJsaW5nKSA/IGJlZm9yZSA6IG51bGw7XG4gICAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIDEpLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0IDwgbm9kZVNpemUobm9kZSkpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgIHdoaWxlIChhZnRlci5wbVZpZXdEZXNjICYmIGFmdGVyLnBtVmlld0Rlc2MuaWdub3JlRm9yQ29vcmRzKVxuICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZztcbiAgICAgICAgbGV0IHRhcmdldCA9ICFhZnRlciA/IG51bGwgOiBhZnRlci5ub2RlVHlwZSA9PSAzID8gdGV4dFJhbmdlKGFmdGVyLCAwLCAoc3VwcG9ydEVtcHR5UmFuZ2UgPyAwIDogMSkpXG4gICAgICAgICAgICA6IGFmdGVyLm5vZGVUeXBlID09IDEgPyBhZnRlciA6IG51bGw7XG4gICAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIC0xKSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIEFsbCBlbHNlIGZhaWxlZCwganVzdCB0cnkgdG8gZ2V0IGEgcmVjdGFuZ2xlIGZvciB0aGUgdGFyZ2V0IG5vZGVcbiAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdChub2RlLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2Uobm9kZSkgOiBub2RlLCAtc2lkZSksIHNpZGUgPj0gMCk7XG59XG5mdW5jdGlvbiBmbGF0dGVuVihyZWN0LCBsZWZ0KSB7XG4gICAgaWYgKHJlY3Qud2lkdGggPT0gMClcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgbGV0IHggPSBsZWZ0ID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgICByZXR1cm4geyB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QuYm90dG9tLCBsZWZ0OiB4LCByaWdodDogeCB9O1xufVxuZnVuY3Rpb24gZmxhdHRlbkgocmVjdCwgdG9wKSB7XG4gICAgaWYgKHJlY3QuaGVpZ2h0ID09IDApXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIGxldCB5ID0gdG9wID8gcmVjdC50b3AgOiByZWN0LmJvdHRvbTtcbiAgICByZXR1cm4geyB0b3A6IHksIGJvdHRvbTogeSwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCB9O1xufVxuZnVuY3Rpb24gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgZikge1xuICAgIGxldCB2aWV3U3RhdGUgPSB2aWV3LnN0YXRlLCBhY3RpdmUgPSB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAodmlld1N0YXRlICE9IHN0YXRlKVxuICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICBpZiAoYWN0aXZlICE9IHZpZXcuZG9tKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmICh2aWV3U3RhdGUgIT0gc3RhdGUpXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHZpZXdTdGF0ZSk7XG4gICAgICAgIGlmIChhY3RpdmUgIT0gdmlldy5kb20gJiYgYWN0aXZlKVxuICAgICAgICAgICAgYWN0aXZlLmZvY3VzKCk7XG4gICAgfVxufVxuLy8gV2hldGhlciB2ZXJ0aWNhbCBwb3NpdGlvbiBtb3Rpb24gaW4gYSBnaXZlbiBkaXJlY3Rpb25cbi8vIGZyb20gYSBwb3NpdGlvbiB3b3VsZCBsZWF2ZSBhIHRleHQgYmxvY2suXG5mdW5jdGlvbiBlbmRPZlRleHRibG9ja1ZlcnRpY2FsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCAkcG9zID0gZGlyID09IFwidXBcIiA/IHNlbC4kZnJvbSA6IHNlbC4kdG87XG4gICAgcmV0dXJuIHdpdGhGbHVzaGVkU3RhdGUodmlldywgc3RhdGUsICgpID0+IHtcbiAgICAgICAgbGV0IHsgbm9kZTogZG9tIH0gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcygkcG9zLnBvcywgZGlyID09IFwidXBcIiA/IC0xIDogMSk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZWFyZXN0ID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGRvbSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIW5lYXJlc3QpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobmVhcmVzdC5ub2RlLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICBkb20gPSBuZWFyZXN0LmNvbnRlbnRET00gfHwgbmVhcmVzdC5kb207XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb20gPSBuZWFyZXN0LmRvbS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb29yZHMgPSBjb29yZHNBdFBvcyh2aWV3LCAkcG9zLnBvcywgMSk7XG4gICAgICAgIGZvciAobGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBsZXQgYm94ZXM7XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICBib3hlcyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIGJveGVzID0gdGV4dFJhbmdlKGNoaWxkLCAwLCBjaGlsZC5ub2RlVmFsdWUubGVuZ3RoKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYm94LmJvdHRvbSA+IGJveC50b3AgKyAxICYmXG4gICAgICAgICAgICAgICAgICAgIChkaXIgPT0gXCJ1cFwiID8gY29vcmRzLnRvcCAtIGJveC50b3AgPiAoYm94LmJvdHRvbSAtIGNvb3Jkcy50b3ApICogMlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBib3guYm90dG9tIC0gY29vcmRzLmJvdHRvbSA+IChjb29yZHMuYm90dG9tIC0gYm94LnRvcCkgKiAyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xufVxuY29uc3QgbWF5YmVSVEwgPSAvW1xcdTA1OTAtXFx1MDhhY10vO1xuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2tIb3Jpem9udGFsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgeyAkaGVhZCB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9ICRoZWFkLnBhcmVudE9mZnNldCwgYXRTdGFydCA9ICFvZmZzZXQsIGF0RW5kID0gb2Zmc2V0ID09ICRoZWFkLnBhcmVudC5jb250ZW50LnNpemU7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgLy8gSWYgdGhlIHRleHRibG9jayBpcyBhbGwgTFRSLCBvciB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnRcbiAgICAvLyBTZWxlY3Rpb24ubW9kaWZ5IChFZGdlKSwgZmFsbCBiYWNrIHRvIGEgcHJpbWl0aXZlIGFwcHJvYWNoXG4gICAgaWYgKCFtYXliZVJUTC50ZXN0KCRoZWFkLnBhcmVudC50ZXh0Q29udGVudCkgfHwgIXNlbC5tb2RpZnkpXG4gICAgICAgIHJldHVybiBkaXIgPT0gXCJsZWZ0XCIgfHwgZGlyID09IFwiYmFja3dhcmRcIiA/IGF0U3RhcnQgOiBhdEVuZDtcbiAgICByZXR1cm4gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgKCkgPT4ge1xuICAgICAgICAvLyBUaGlzIGlzIGEgaHVnZSBoYWNrLCBidXQgYXBwZWFycyB0byBiZSB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gY3VycmVudGx5IGRvOiB1c2UgYFNlbGVjdGlvbi5tb2RpZnlgIHRvIG1vdmUgdGhlIHNlbGVjdGlvbiBieVxuICAgICAgICAvLyBvbmUgY2hhcmFjdGVyLCBhbmQgc2VlIGlmIHRoYXQgbW92ZXMgdGhlIGN1cnNvciBvdXQgb2YgdGhlXG4gICAgICAgIC8vIHRleHRibG9jayAob3IgZG9lc24ndCBtb3ZlIGl0IGF0IGFsbCwgd2hlbiBhdCB0aGUgc3RhcnQvZW5kIG9mXG4gICAgICAgIC8vIHRoZSBkb2N1bWVudCkuXG4gICAgICAgIGxldCB7IGZvY3VzTm9kZTogb2xkTm9kZSwgZm9jdXNPZmZzZXQ6IG9sZE9mZiwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0IH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBvbGRCaWRpTGV2ZWwgPSBzZWwuY2FyZXRCaWRpTGV2ZWwgLy8gT25seSBmb3IgRmlyZWZveFxuICAgICAgICA7XG4gICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGRpciwgXCJjaGFyYWN0ZXJcIik7XG4gICAgICAgIGxldCBwYXJlbnRET00gPSAkaGVhZC5kZXB0aCA/IHZpZXcuZG9jVmlldy5kb21BZnRlclBvcygkaGVhZC5iZWZvcmUoKSkgOiB2aWV3LmRvbTtcbiAgICAgICAgbGV0IHsgZm9jdXNOb2RlOiBuZXdOb2RlLCBmb2N1c09mZnNldDogbmV3T2ZmIH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXdOb2RlICYmICFwYXJlbnRET00uY29udGFpbnMobmV3Tm9kZS5ub2RlVHlwZSA9PSAxID8gbmV3Tm9kZSA6IG5ld05vZGUucGFyZW50Tm9kZSkgfHxcbiAgICAgICAgICAgIChvbGROb2RlID09IG5ld05vZGUgJiYgb2xkT2ZmID09IG5ld09mZik7XG4gICAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIHNlbGVjdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VsLmNvbGxhcHNlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICBpZiAob2xkTm9kZSAmJiAob2xkTm9kZSAhPSBhbmNob3JOb2RlIHx8IG9sZE9mZiAhPSBhbmNob3JPZmZzZXQpICYmIHNlbC5leHRlbmQpXG4gICAgICAgICAgICAgICAgc2VsLmV4dGVuZChvbGROb2RlLCBvbGRPZmYpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgaWYgKG9sZEJpZGlMZXZlbCAhPSBudWxsKVxuICAgICAgICAgICAgc2VsLmNhcmV0QmlkaUxldmVsID0gb2xkQmlkaUxldmVsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxubGV0IGNhY2hlZFN0YXRlID0gbnVsbDtcbmxldCBjYWNoZWREaXIgPSBudWxsO1xubGV0IGNhY2hlZFJlc3VsdCA9IGZhbHNlO1xuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2sodmlldywgc3RhdGUsIGRpcikge1xuICAgIGlmIChjYWNoZWRTdGF0ZSA9PSBzdGF0ZSAmJiBjYWNoZWREaXIgPT0gZGlyKVxuICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICAgIGNhY2hlZFN0YXRlID0gc3RhdGU7XG4gICAgY2FjaGVkRGlyID0gZGlyO1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQgPSBkaXIgPT0gXCJ1cFwiIHx8IGRpciA9PSBcImRvd25cIlxuICAgICAgICA/IGVuZE9mVGV4dGJsb2NrVmVydGljYWwodmlldywgc3RhdGUsIGRpcilcbiAgICAgICAgOiBlbmRPZlRleHRibG9ja0hvcml6b250YWwodmlldywgc3RhdGUsIGRpcik7XG59XG5cbi8vIFZpZXcgZGVzY3JpcHRpb25zIGFyZSBkYXRhIHN0cnVjdHVyZXMgdGhhdCBkZXNjcmliZSB0aGUgRE9NIHRoYXQgaXNcbi8vIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBlZGl0b3IncyBjb250ZW50LiBUaGV5IGFyZSB1c2VkIGZvcjpcbi8vXG4vLyAtIEluY3JlbWVudGFsIHJlZHJhd2luZyB3aGVuIHRoZSBkb2N1bWVudCBjaGFuZ2VzXG4vL1xuLy8gLSBGaWd1cmluZyBvdXQgd2hhdCBwYXJ0IG9mIHRoZSBkb2N1bWVudCBhIGdpdmVuIERPTSBwb3NpdGlvblxuLy8gICBjb3JyZXNwb25kcyB0b1xuLy9cbi8vIC0gV2lyaW5nIGluIGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIGVkaXRpbmcgaW50ZXJmYWNlIGZvciBhXG4vLyAgIGdpdmVuIG5vZGVcbi8vXG4vLyBUaGV5IGZvcm0gYSBkb3VibHktbGlua2VkIG11dGFibGUgdHJlZSwgc3RhcnRpbmcgYXQgYHZpZXcuZG9jVmlld2AuXG5jb25zdCBOT1RfRElSVFkgPSAwLCBDSElMRF9ESVJUWSA9IDEsIENPTlRFTlRfRElSVFkgPSAyLCBOT0RFX0RJUlRZID0gMztcbi8vIFN1cGVyY2xhc3MgZm9yIHRoZSB2YXJpb3VzIGtpbmRzIG9mIGRlc2NyaXB0aW9ucy4gRGVmaW5lcyB0aGVpclxuLy8gYmFzaWMgc3RydWN0dXJlIGFuZCBzaGFyZWQgbWV0aG9kcy5cbmNsYXNzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGNoaWxkcmVuLCBkb20sIFxuICAgIC8vIFRoaXMgaXMgdGhlIG5vZGUgdGhhdCBob2xkcyB0aGUgY2hpbGQgdmlld3MuIEl0IG1heSBiZSBudWxsIGZvclxuICAgIC8vIGRlc2NzIHRoYXQgZG9uJ3QgaGF2ZSBjaGlsZHJlbi5cbiAgICBjb250ZW50RE9NKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICB0aGlzLmNvbnRlbnRET00gPSBjb250ZW50RE9NO1xuICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAvLyBBbiBleHBhbmRvIHByb3BlcnR5IG9uIHRoZSBET00gbm9kZSBwcm92aWRlcyBhIGxpbmsgYmFjayB0byBpdHNcbiAgICAgICAgLy8gZGVzY3JpcHRpb24uXG4gICAgICAgIGRvbS5wbVZpZXdEZXNjID0gdGhpcztcbiAgICB9XG4gICAgLy8gVXNlZCB0byBjaGVjayB3aGV0aGVyIGEgZ2l2ZW4gZGVzY3JpcHRpb24gY29ycmVzcG9uZHMgdG8gYVxuICAgIC8vIHdpZGdldC9tYXJrL25vZGUuXG4gICAgbWF0Y2hlc1dpZGdldCh3aWRnZXQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgbWF0Y2hlc01hcmsobWFyaykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzSGFjayhub2RlTmFtZSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvLyBXaGVuIHBhcnNpbmcgaW4tZWRpdG9yIGNvbnRlbnQgKGluIGRvbWNoYW5nZS5qcyksIHdlIGFsbG93XG4gICAgLy8gZGVzY3JpcHRpb25zIHRvIGRldGVybWluZSB0aGUgcGFyc2UgcnVsZXMgdGhhdCBzaG91bGQgYmUgdXNlZCB0b1xuICAgIC8vIHBhcnNlIHRoZW0uXG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8vIFVzZWQgYnkgdGhlIGVkaXRvcidzIGV2ZW50IGhhbmRsZXIgdG8gaWdub3JlIGV2ZW50cyB0aGF0IGNvbWVcbiAgICAvLyBmcm9tIGNlcnRhaW4gZGVzY3MuXG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIFRoZSBzaXplIG9mIHRoZSBjb250ZW50IHJlcHJlc2VudGVkIGJ5IHRoaXMgZGVzYy5cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBzaXplICs9IHRoaXMuY2hpbGRyZW5baV0uc2l6ZTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIC8vIEZvciBibG9jayBub2RlcywgdGhpcyByZXByZXNlbnRzIHRoZSBzcGFjZSB0YWtlbiB1cCBieSB0aGVpclxuICAgIC8vIHN0YXJ0L2VuZCB0b2tlbnMuXG4gICAgZ2V0IGJvcmRlcigpIHsgcmV0dXJuIDA7IH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuZG9tLnBtVmlld0Rlc2MgPT0gdGhpcylcbiAgICAgICAgICAgIHRoaXMuZG9tLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICBwb3NCZWZvcmVDaGlsZChjaGlsZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gdGhpcy5wb3NBdFN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjdXIgPT0gY2hpbGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIHBvcyArPSBjdXIuc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcG9zQmVmb3JlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucG9zQmVmb3JlQ2hpbGQodGhpcyk7XG4gICAgfVxuICAgIGdldCBwb3NBdFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5wb3NCZWZvcmVDaGlsZCh0aGlzKSArIHRoaXMuYm9yZGVyIDogMDtcbiAgICB9XG4gICAgZ2V0IHBvc0FmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NCZWZvcmUgKyB0aGlzLnNpemU7XG4gICAgfVxuICAgIGdldCBwb3NBdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIHRoaXMuc2l6ZSAtIDIgKiB0aGlzLmJvcmRlcjtcbiAgICB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIC8vIElmIHRoZSBET00gcG9zaXRpb24gaXMgaW4gdGhlIGNvbnRlbnQsIHVzZSB0aGUgY2hpbGQgZGVzYyBhZnRlclxuICAgICAgICAvLyBpdCB0byBmaWd1cmUgb3V0IGEgcG9zaXRpb24uXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKGRvbS5ub2RlVHlwZSA9PSAxID8gZG9tIDogZG9tLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoYmlhcyA8IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9tQmVmb3JlLCBkZXNjO1xuICAgICAgICAgICAgICAgIGlmIChkb20gPT0gdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBkb21CZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoZG9tQmVmb3JlICYmICEoKGRlc2MgPSBkb21CZWZvcmUucG1WaWV3RGVzYykgJiYgZGVzYy5wYXJlbnQgPT0gdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbUJlZm9yZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbUJlZm9yZSA/IHRoaXMucG9zQmVmb3JlQ2hpbGQoZGVzYykgKyBkZXNjLnNpemUgOiB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9tQWZ0ZXIsIGRlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb20uY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBkb21BZnRlciA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRvbUFmdGVyICYmICEoKGRlc2MgPSBkb21BZnRlci5wbVZpZXdEZXNjKSAmJiBkZXNjLnBhcmVudCA9PSB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb21BZnRlci5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQWZ0ZXIgPyB0aGlzLnBvc0JlZm9yZUNoaWxkKGRlc2MpIDogdGhpcy5wb3NBdEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHVzZSB2YXJpb3VzIGhldXJpc3RpY3MsIGZhbGxpbmcgYmFjayBvbiB0aGUgYmlhc1xuICAgICAgICAvLyBwYXJhbWV0ZXIsIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldHVybiB0aGUgcG9zaXRpb24gYXQgdGhlXG4gICAgICAgIC8vIHN0YXJ0IG9yIGF0IHRoZSBlbmQgb2YgdGhpcyB2aWV3IGRlc2MuXG4gICAgICAgIGxldCBhdEVuZDtcbiAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmRvbSAmJiB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIGF0RW5kID0gb2Zmc2V0ID4gZG9tSW5kZXgodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NICE9IHRoaXMuZG9tICYmIHRoaXMuZG9tLmNvbnRhaW5zKHRoaXMuY29udGVudERPTSkpIHtcbiAgICAgICAgICAgIGF0RW5kID0gZG9tLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuY29udGVudERPTSkgJiAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZG9tLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gMClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzZWFyY2ggPSBkb207OyBzZWFyY2ggPSBzZWFyY2gucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdEVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5wcmV2aW91c1NpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXRFbmQgPT0gbnVsbCAmJiBvZmZzZXQgPT0gZG9tLmNoaWxkTm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNlYXJjaCA9IGRvbTs7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2ggPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0RW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2gubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChhdEVuZCA9PSBudWxsID8gYmlhcyA+IDAgOiBhdEVuZCkgPyB0aGlzLnBvc0F0RW5kIDogdGhpcy5wb3NBdFN0YXJ0O1xuICAgIH1cbiAgICBuZWFyZXN0RGVzYyhkb20sIG9ubHlOb2RlcyA9IGZhbHNlKSB7XG4gICAgICAgIGZvciAobGV0IGZpcnN0ID0gdHJ1ZSwgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBsZXQgZGVzYyA9IHRoaXMuZ2V0RGVzYyhjdXIpLCBub2RlRE9NO1xuICAgICAgICAgICAgaWYgKGRlc2MgJiYgKCFvbmx5Tm9kZXMgfHwgZGVzYy5ub2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGRvbSBpcyBvdXRzaWRlIG9mIHRoaXMgZGVzYydzIG5vZGVET00sIGRvbid0IGNvdW50IGl0LlxuICAgICAgICAgICAgICAgIGlmIChmaXJzdCAmJiAobm9kZURPTSA9IGRlc2Mubm9kZURPTSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShub2RlRE9NLm5vZGVUeXBlID09IDEgPyBub2RlRE9NLmNvbnRhaW5zKGRvbS5ub2RlVHlwZSA9PSAxID8gZG9tIDogZG9tLnBhcmVudE5vZGUpIDogbm9kZURPTSA9PSBkb20pKVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVzYyhkb20pIHtcbiAgICAgICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICAgICAgZm9yIChsZXQgY3VyID0gZGVzYzsgY3VyOyBjdXIgPSBjdXIucGFyZW50KVxuICAgICAgICAgICAgaWYgKGN1ciA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgIH1cbiAgICBwb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBkb207IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gdGhpcy5nZXREZXNjKHNjYW4pO1xuICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MubG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGRlc2MgZm9yIHRoZSBub2RlIGFmdGVyIHRoZSBnaXZlbiBwb3MsIGlmIGFueS4gKFdoZW4gYVxuICAgIC8vIHBhcmVudCBub2RlIG92ZXJyb2RlIHJlbmRlcmluZywgdGhlcmUgbWlnaHQgbm90IGJlIG9uZS4pXG4gICAgZGVzY0F0KHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IHBvcyAmJiBlbmQgIT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFjaGlsZC5ib3JkZXIgJiYgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPCBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRlc2NBdChwb3MgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvbUZyb21Qb3MocG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5kb20sIG9mZnNldDogMCwgYXRvbTogcG9zICsgMSB9O1xuICAgICAgICAvLyBGaXJzdCBmaW5kIHRoZSBwb3NpdGlvbiBpbiB0aGUgY2hpbGQgYXJyYXlcbiAgICAgICAgbGV0IGkgPSAwLCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBjdXJQb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gY3VyUG9zICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChlbmQgPiBwb3MgfHwgY2hpbGQgaW5zdGFuY2VvZiBUcmFpbGluZ0hhY2tWaWV3RGVzYykge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHBvcyAtIGN1clBvcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1clBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGlzIHBvaW50cyBpbnRvIHRoZSBtaWRkbGUgb2YgYSBjaGlsZCwgY2FsbCB0aHJvdWdoXG4gICAgICAgIGlmIChvZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXS5kb21Gcm9tUG9zKG9mZnNldCAtIHRoaXMuY2hpbGRyZW5baV0uYm9yZGVyLCBzaWRlKTtcbiAgICAgICAgLy8gR28gYmFjayBpZiB0aGVyZSB3ZXJlIGFueSB6ZXJvLWxlbmd0aCB3aWRnZXRzIHdpdGggc2lkZSA+PSAwIGJlZm9yZSB0aGlzIHBvaW50XG4gICAgICAgIGZvciAobGV0IHByZXY7IGkgJiYgIShwcmV2ID0gdGhpcy5jaGlsZHJlbltpIC0gMV0pLnNpemUgJiYgcHJldiBpbnN0YW5jZW9mIFdpZGdldFZpZXdEZXNjICYmIHByZXYuc2lkZSA+PSAwOyBpLS0pIHsgfVxuICAgICAgICAvLyBTY2FuIHRvd2FyZHMgdGhlIGZpcnN0IHVzZWFibGUgbm9kZVxuICAgICAgICBpZiAoc2lkZSA8PSAwKSB7XG4gICAgICAgICAgICBsZXQgcHJldiwgZW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7OyBpLS0sIGVudGVyID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gaSA/IHRoaXMuY2hpbGRyZW5baSAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXYgfHwgcHJldi5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXYgJiYgc2lkZSAmJiBlbnRlciAmJiAhcHJldi5ib3JkZXIgJiYgIXByZXYuZG9tQXRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldi5kb21Gcm9tUG9zKHByZXYuc2l6ZSwgc2lkZSk7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIG9mZnNldDogcHJldiA/IGRvbUluZGV4KHByZXYuZG9tKSArIDEgOiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV4dCwgZW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7OyBpKyssIGVudGVyID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID8gdGhpcy5jaGlsZHJlbltpXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ICYmIGVudGVyICYmICFuZXh0LmJvcmRlciAmJiAhbmV4dC5kb21BdG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbUZyb21Qb3MoMCwgc2lkZSk7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIG9mZnNldDogbmV4dCA/IGRvbUluZGV4KG5leHQuZG9tKSA6IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZWQgdG8gZmluZCBhIERPTSByYW5nZSBpbiBhIHNpbmdsZSBwYXJlbnQgZm9yIGEgZ2l2ZW4gY2hhbmdlZFxuICAgIC8vIHJhbmdlLlxuICAgIHBhcnNlUmFuZ2UoZnJvbSwgdG8sIGJhc2UgPSAwKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50RE9NLCBmcm9tLCB0bywgZnJvbU9mZnNldDogMCwgdG9PZmZzZXQ6IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aCB9O1xuICAgICAgICBsZXQgZnJvbU9mZnNldCA9IC0xLCB0b09mZnNldCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSBiYXNlLCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xICYmIGZyb20gPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkQmFzZSA9IG9mZnNldCArIGNoaWxkLmJvcmRlcjtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBtYXliZSBkZXNjZW5kIG1hcmsgdmlld3MgdG8gcGFyc2UgYSBuYXJyb3dlciByYW5nZT9cbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBjaGlsZEJhc2UgJiYgdG8gPD0gZW5kIC0gY2hpbGQuYm9yZGVyICYmIGNoaWxkLm5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00uY29udGFpbnMoY2hpbGQuY29udGVudERPTSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5wYXJzZVJhbmdlKGZyb20sIHRvLCBjaGlsZEJhc2UpO1xuICAgICAgICAgICAgICAgIGZyb20gPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXYgPSB0aGlzLmNoaWxkcmVuW2ogLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYuc2l6ZSAmJiBwcmV2LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSAmJiAhcHJldi5lbXB0eUNoaWxkQXQoMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21PZmZzZXQgPSBkb21JbmRleChwcmV2LmRvbSkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnJvbSAtPSBwcmV2LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBmcm9tT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID4gLTEgJiYgKGVuZCA+IHRvIHx8IGkgPT0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgIHRvID0gZW5kO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5zaXplICYmIG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFuZXh0LmVtcHR5Q2hpbGRBdCgtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gZG9tSW5kZXgobmV4dC5kb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG8gKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9PZmZzZXQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgZnJvbSwgdG8sIGZyb21PZmZzZXQsIHRvT2Zmc2V0IH07XG4gICAgfVxuICAgIGVtcHR5Q2hpbGRBdChzaWRlKSB7XG4gICAgICAgIGlmICh0aGlzLmJvcmRlciB8fCAhdGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltzaWRlIDwgMCA/IDAgOiB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gY2hpbGQuc2l6ZSA9PSAwIHx8IGNoaWxkLmVtcHR5Q2hpbGRBdChzaWRlKTtcbiAgICB9XG4gICAgZG9tQWZ0ZXJQb3MocG9zKSB7XG4gICAgICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gdGhpcy5kb21Gcm9tUG9zKHBvcywgMCk7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEgfHwgb2Zmc2V0ID09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYWZ0ZXIgcG9zIFwiICsgcG9zKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgIH1cbiAgICAvLyBWaWV3IGRlc2NzIGFyZSByZXNwb25zaWJsZSBmb3Igc2V0dGluZyBhbnkgc2VsZWN0aW9uIHRoYXQgZmFsbHNcbiAgICAvLyBlbnRpcmVseSBpbnNpZGUgb2YgdGhlbSwgc28gdGhhdCBjdXN0b20gaW1wbGVtZW50YXRpb25zIGNhbiBkb1xuICAgIC8vIGN1c3RvbSB0aGluZ3Mgd2l0aCB0aGUgc2VsZWN0aW9uLiBOb3RlIHRoYXQgdGhpcyBmYWxscyBhcGFydCB3aGVuXG4gICAgLy8gYSBzZWxlY3Rpb24gc3RhcnRzIGluIHN1Y2ggYSBub2RlIGFuZCBlbmRzIGluIGFub3RoZXIsIGluIHdoaWNoXG4gICAgLy8gY2FzZSB3ZSBqdXN0IHVzZSB3aGF0ZXZlciBkb21Gcm9tUG9zIHByb2R1Y2VzIGFzIGEgYmVzdCBlZmZvcnQuXG4gICAgc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgcm9vdCwgZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGZhbGxzIGVudGlyZWx5IGluIGEgY2hpbGQsIGdpdmUgaXQgdG8gdGhhdCBjaGlsZFxuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKGFuY2hvciwgaGVhZCksIHRvID0gTWF0aC5tYXgoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKGZyb20gPiBvZmZzZXQgJiYgdG8gPCBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNldFNlbGVjdGlvbihhbmNob3IgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIsIGhlYWQgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIsIHJvb3QsIGZvcmNlKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5jaG9yRE9NID0gdGhpcy5kb21Gcm9tUG9zKGFuY2hvciwgYW5jaG9yID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IGhlYWRET00gPSBoZWFkID09IGFuY2hvciA/IGFuY2hvckRPTSA6IHRoaXMuZG9tRnJvbVBvcyhoZWFkLCBoZWFkID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IGRvbVNlbCA9IHJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGxldCBicktsdWRnZSA9IGZhbHNlO1xuICAgICAgICAvLyBPbiBGaXJlZm94LCB1c2luZyBTZWxlY3Rpb24uY29sbGFwc2UgdG8gcHV0IHRoZSBjdXJzb3IgYWZ0ZXIgYVxuICAgICAgICAvLyBCUiBub2RlIGZvciBzb21lIHJlYXNvbiBkb2Vzbid0IGFsd2F5cyB3b3JrICgjMTA3MykuIE9uIFNhZmFyaSxcbiAgICAgICAgLy8gdGhlIGN1cnNvciBzb21ldGltZXMgaW5leHBsaWNhYmxlIHZpc3VhbGx5IGxhZ3MgYmVoaW5kIGl0c1xuICAgICAgICAvLyByZXBvcnRlZCBwb3NpdGlvbiBpbiBzdWNoIHNpdHVhdGlvbnMgKCMxMDkyKS5cbiAgICAgICAgaWYgKChnZWNrbyB8fCBzYWZhcmkpICYmIGFuY2hvciA9PSBoZWFkKSB7XG4gICAgICAgICAgICBsZXQgeyBub2RlLCBvZmZzZXQgfSA9IGFuY2hvckRPTTtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICBicktsdWRnZSA9ICEhKG9mZnNldCAmJiBub2RlLm5vZGVWYWx1ZVtvZmZzZXQgLSAxXSA9PSBcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAvLyBJc3N1ZSAjMTEyOFxuICAgICAgICAgICAgICAgIGlmIChicktsdWRnZSAmJiBvZmZzZXQgPT0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNjYW4gPSBub2RlLCBhZnRlcjsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFmdGVyID0gc2Nhbi5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZnRlci5ub2RlTmFtZSA9PSBcIkJSXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvckRPTSA9IGhlYWRET00gPSB7IG5vZGU6IGFmdGVyLnBhcmVudE5vZGUsIG9mZnNldDogZG9tSW5kZXgoYWZ0ZXIpICsgMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRlc2MgPSBzY2FuLnBtVmlld0Rlc2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2spXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJldiA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgICAgICBicktsdWRnZSA9IHByZXYgJiYgKHByZXYubm9kZU5hbWUgPT0gXCJCUlwiIHx8IHByZXYuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlyZWZveCBjYW4gYWN0IHN0cmFuZ2VseSB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgaW4gZnJvbnQgb2YgYW5cbiAgICAgICAgLy8gdW5lZGl0YWJsZSBub2RlLiBTZWUgIzExNjMgYW5kIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE3MDk1MzZcbiAgICAgICAgaWYgKGdlY2tvICYmIGRvbVNlbC5mb2N1c05vZGUgJiYgZG9tU2VsLmZvY3VzTm9kZSAhPSBoZWFkRE9NLm5vZGUgJiYgZG9tU2VsLmZvY3VzTm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBkb21TZWwuZm9jdXNOb2RlLmNoaWxkTm9kZXNbZG9tU2VsLmZvY3VzT2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChhZnRlciAmJiBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShmb3JjZSB8fCBicktsdWRnZSAmJiBzYWZhcmkpICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0LCBkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBTZWxlY3Rpb24uZXh0ZW5kIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhbiAnaW52ZXJ0ZWQnIHNlbGVjdGlvblxuICAgICAgICAvLyAob25lIHdoZXJlIHRoZSBmb2N1cyBpcyBiZWZvcmUgdGhlIGFuY2hvciksIGJ1dCBub3QgYWxsXG4gICAgICAgIC8vIGJyb3dzZXJzIHN1cHBvcnQgaXQgeWV0LlxuICAgICAgICBsZXQgZG9tU2VsRXh0ZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKChkb21TZWwuZXh0ZW5kIHx8IGFuY2hvciA9PSBoZWFkKSAmJiAhYnJLbHVkZ2UpIHtcbiAgICAgICAgICAgIGRvbVNlbC5jb2xsYXBzZShhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChhbmNob3IgIT0gaGVhZClcbiAgICAgICAgICAgICAgICAgICAgZG9tU2VsLmV4dGVuZChoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBkb21TZWxFeHRlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIC8vIEluIHNvbWUgY2FzZXMgd2l0aCBDaHJvbWUgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhZnRlciBjYWxsaW5nXG4gICAgICAgICAgICAgICAgLy8gY29sbGFwc2UsIGV2ZW4gd2hlbiBpdCBzaG91bGQgYmUgdmFsaWQuIFRoaXMgYXBwZWFycyB0byBiZSBhIGJ1ZywgYnV0XG4gICAgICAgICAgICAgICAgLy8gaXQgaXMgZGlmZmljdWx0IHRvIGlzb2xhdGUuIElmIHRoaXMgaGFwcGVucyBmYWxsYmFjayB0byB0aGUgb2xkIHBhdGhcbiAgICAgICAgICAgICAgICAvLyB3aXRob3V0IHVzaW5nIGV4dGVuZC5cbiAgICAgICAgICAgICAgICAvLyBTaW1pbGFybHksIHRoaXMgY291bGQgY3Jhc2ggb24gU2FmYXJpIGlmIHRoZSBlZGl0b3IgaXMgaGlkZGVuLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSB3YXMgbm8gc2VsZWN0aW9uLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZG9tU2VsRXh0ZW5kZWQpIHtcbiAgICAgICAgICAgIGlmIChhbmNob3IgPiBoZWFkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRtcCA9IGFuY2hvckRPTTtcbiAgICAgICAgICAgICAgICBhbmNob3JET00gPSBoZWFkRE9NO1xuICAgICAgICAgICAgICAgIGhlYWRET00gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQpO1xuICAgICAgICAgICAgZG9tU2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgZG9tU2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29udGVudERPTSAmJiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCI7XG4gICAgfVxuICAgIGdldCBjb250ZW50TG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00gIT0gdGhpcy5kb20gJiYgIXRoaXMuZG9tLmNvbnRhaW5zKHRoaXMuY29udGVudERPTSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhIHN1YnRyZWUgb2YgdGhlIGVsZW1lbnQgdHJlZSB0aGF0IGhhcyBiZWVuIHRvdWNoZWRcbiAgICAvLyBieSBhIERPTSBjaGFuZ2UsIHNvIHRoYXQgdGhlIG5leHQgdXBkYXRlIHdpbGwgcmVkcmF3IGl0LlxuICAgIG1hcmtEaXJ0eShmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwLCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IGVuZCA/IGZyb20gPD0gZW5kICYmIHRvID49IG9mZnNldCA6IGZyb20gPCBlbmQgJiYgdG8gPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbnNpZGUgPSBvZmZzZXQgKyBjaGlsZC5ib3JkZXIsIGVuZEluc2lkZSA9IGVuZCAtIGNoaWxkLmJvcmRlcjtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBzdGFydEluc2lkZSAmJiB0byA8PSBlbmRJbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZyb20gPT0gb2Zmc2V0IHx8IHRvID09IGVuZCA/IENPTlRFTlRfRElSVFkgOiBDSElMRF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gc3RhcnRJbnNpZGUgJiYgdG8gPT0gZW5kSW5zaWRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2hpbGQuY29udGVudExvc3QgfHwgY2hpbGQuZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gTk9ERV9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQubWFya0RpcnR5KGZyb20gLSBzdGFydEluc2lkZSwgdG8gLSBzdGFydEluc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gY2hpbGQuZG9tID09IGNoaWxkLmNvbnRlbnRET00gJiYgY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFjaGlsZC5jaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gQ09OVEVOVF9ESVJUWSA6IE5PREVfRElSVFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlydHkgPSBDT05URU5UX0RJUlRZO1xuICAgIH1cbiAgICBtYXJrUGFyZW50c0RpcnR5KCkge1xuICAgICAgICBsZXQgbGV2ZWwgPSAxO1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdGhpcy5wYXJlbnQ7IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudCwgbGV2ZWwrKykge1xuICAgICAgICAgICAgbGV0IGRpcnR5ID0gbGV2ZWwgPT0gMSA/IENPTlRFTlRfRElSVFkgOiBDSElMRF9ESVJUWTtcbiAgICAgICAgICAgIGlmIChub2RlLmRpcnR5IDwgZGlydHkpXG4gICAgICAgICAgICAgICAgbm9kZS5kaXJ0eSA9IGRpcnR5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkb21BdG9tKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaWdub3JlRm9yQ29vcmRzKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbi8vIEEgd2lkZ2V0IGRlc2MgcmVwcmVzZW50cyBhIHdpZGdldCBkZWNvcmF0aW9uLCB3aGljaCBpcyBhIERPTSBub2RlXG4vLyBkcmF3biBiZXR3ZWVuIHRoZSBkb2N1bWVudCBub2Rlcy5cbmNsYXNzIFdpZGdldFZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgd2lkZ2V0LCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IHNlbGYsIGRvbSA9IHdpZGdldC50eXBlLnRvRE9NO1xuICAgICAgICBpZiAodHlwZW9mIGRvbSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBkb20gPSBkb20odmlldywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnBhcmVudC5wb3NCZWZvcmVDaGlsZChzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoIXdpZGdldC50eXBlLnNwZWMucmF3KSB7XG4gICAgICAgICAgICBpZiAoZG9tLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgICAgICBkb20gPSB3cmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3Itd2lkZ2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgbnVsbCk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgfVxuICAgIG1hdGNoZXNXaWRnZXQod2lkZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiB3aWRnZXQudHlwZS5lcSh0aGlzLndpZGdldC50eXBlKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4geyBpZ25vcmU6IHRydWUgfTsgfVxuICAgIHN0b3BFdmVudChldmVudCkge1xuICAgICAgICBsZXQgc3RvcCA9IHRoaXMud2lkZ2V0LnNwZWMuc3RvcEV2ZW50O1xuICAgICAgICByZXR1cm4gc3RvcCA/IHN0b3AoZXZlbnQpIDogZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCIgfHwgdGhpcy53aWRnZXQuc3BlYy5pZ25vcmVTZWxlY3Rpb247XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMud2lkZ2V0LnR5cGUuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IHNpZGUoKSB7IHJldHVybiB0aGlzLndpZGdldC50eXBlLnNpZGU7IH1cbn1cbmNsYXNzIENvbXBvc2l0aW9uVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBkb20sIHRleHRET00sIHRleHQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBudWxsKTtcbiAgICAgICAgdGhpcy50ZXh0RE9NID0gdGV4dERPTTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChkb20gIT0gdGhpcy50ZXh0RE9NKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIChvZmZzZXQgPyB0aGlzLnNpemUgOiAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIG9mZnNldDtcbiAgICB9XG4gICAgZG9tRnJvbVBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy50ZXh0RE9NLCBvZmZzZXQ6IHBvcyB9O1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXQpIHtcbiAgICAgICAgcmV0dXJuIG11dC50eXBlID09PSAnY2hhcmFjdGVyRGF0YScgJiYgbXV0LnRhcmdldC5ub2RlVmFsdWUgPT0gbXV0Lm9sZFZhbHVlO1xuICAgIH1cbn1cbi8vIEEgbWFyayBkZXNjIHJlcHJlc2VudHMgYSBtYXJrLiBNYXkgaGF2ZSBtdWx0aXBsZSBjaGlsZHJlbixcbi8vIGRlcGVuZGluZyBvbiBob3cgdGhlIG1hcmsgaXMgc3BsaXQuIE5vdGUgdGhhdCBtYXJrcyBhcmUgZHJhd24gdXNpbmdcbi8vIGEgZml4ZWQgbmVzdGluZyBvcmRlciwgZm9yIHNpbXBsaWNpdHkgYW5kIHByZWRpY3RhYmlsaXR5LCBzbyBpblxuLy8gc29tZSBjYXNlcyB0aGV5IHdpbGwgYmUgc3BsaXQgbW9yZSBvZnRlbiB0aGFuIHdvdWxkIGFwcGVhclxuLy8gbmVjZXNzYXJ5LlxuY2xhc3MgTWFya1ZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbWFyaywgZG9tLCBjb250ZW50RE9NKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgY29udGVudERPTSk7XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUocGFyZW50LCBtYXJrLCBpbmxpbmUsIHZpZXcpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHZpZXcubm9kZVZpZXdzW21hcmsudHlwZS5uYW1lXTtcbiAgICAgICAgbGV0IHNwZWMgPSBjdXN0b20gJiYgY3VzdG9tKG1hcmssIHZpZXcsIGlubGluZSk7XG4gICAgICAgIGlmICghc3BlYyB8fCAhc3BlYy5kb20pXG4gICAgICAgICAgICBzcGVjID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBtYXJrLnR5cGUuc3BlYy50b0RPTShtYXJrLCBpbmxpbmUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrVmlld0Rlc2MocGFyZW50LCBtYXJrLCBzcGVjLmRvbSwgc3BlYy5jb250ZW50RE9NIHx8IHNwZWMuZG9tKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkge1xuICAgICAgICBpZiAoKHRoaXMuZGlydHkgJiBOT0RFX0RJUlRZKSB8fCB0aGlzLm1hcmsudHlwZS5zcGVjLnJlcGFyc2VJblZpZXcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHsgbWFyazogdGhpcy5tYXJrLnR5cGUubmFtZSwgYXR0cnM6IHRoaXMubWFyay5hdHRycywgY29udGVudEVsZW1lbnQ6IHRoaXMuY29udGVudERPTSB9O1xuICAgIH1cbiAgICBtYXRjaGVzTWFyayhtYXJrKSB7IHJldHVybiB0aGlzLmRpcnR5ICE9IE5PREVfRElSVFkgJiYgdGhpcy5tYXJrLmVxKG1hcmspOyB9XG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgIC8vIE1vdmUgZGlydHkgaW5mbyB0byBuZWFyZXN0IG5vZGUgdmlld1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSAhPSBOT1RfRElSVFkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlICghcGFyZW50Lm5vZGUpXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuZGlydHkgPCB0aGlzLmRpcnR5KVxuICAgICAgICAgICAgICAgIHBhcmVudC5kaXJ0eSA9IHRoaXMuZGlydHk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICAgIGxldCBjb3B5ID0gTWFya1ZpZXdEZXNjLmNyZWF0ZSh0aGlzLnBhcmVudCwgdGhpcy5tYXJrLCB0cnVlLCB2aWV3KTtcbiAgICAgICAgbGV0IG5vZGVzID0gdGhpcy5jaGlsZHJlbiwgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgaWYgKHRvIDwgc2l6ZSlcbiAgICAgICAgICAgIG5vZGVzID0gcmVwbGFjZU5vZGVzKG5vZGVzLCB0bywgc2l6ZSwgdmlldyk7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIG5vZGVzID0gcmVwbGFjZU5vZGVzKG5vZGVzLCAwLCBmcm9tLCB2aWV3KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIG5vZGVzW2ldLnBhcmVudCA9IGNvcHk7XG4gICAgICAgIGNvcHkuY2hpbGRyZW4gPSBub2RlcztcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxufVxuLy8gTm9kZSB2aWV3IGRlc2NzIGFyZSB0aGUgbWFpbiwgbW9zdCBjb21tb24gdHlwZSBvZiB2aWV3IGRlc2MsIGFuZFxuLy8gY29ycmVzcG9uZCB0byBhbiBhY3R1YWwgbm9kZSBpbiB0aGUgZG9jdW1lbnQuIFVubGlrZSBtYXJrIGRlc2NzLFxuLy8gdGhleSBwb3B1bGF0ZSB0aGVpciBjaGlsZCBhcnJheSB0aGVtc2VsdmVzLlxuY2xhc3MgTm9kZVZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgdmlldywgcG9zKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgY29udGVudERPTSk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub3V0ZXJEZWNvID0gb3V0ZXJEZWNvO1xuICAgICAgICB0aGlzLmlubmVyRGVjbyA9IGlubmVyRGVjbztcbiAgICAgICAgdGhpcy5ub2RlRE9NID0gbm9kZURPTTtcbiAgICB9XG4gICAgLy8gQnkgZGVmYXVsdCwgYSBub2RlIGlzIHJlbmRlcmVkIHVzaW5nIHRoZSBgdG9ET01gIG1ldGhvZCBmcm9tIHRoZVxuICAgIC8vIG5vZGUgdHlwZSBzcGVjLiBCdXQgY2xpZW50IGNvZGUgY2FuIHVzZSB0aGUgYG5vZGVWaWV3c2Agc3BlYyB0b1xuICAgIC8vIHN1cHBseSBhIGN1c3RvbSBub2RlIHZpZXcsIHdoaWNoIGNhbiBpbmZsdWVuY2UgdmFyaW91cyBhc3BlY3RzIG9mXG4gICAgLy8gdGhlIHdheSB0aGUgbm9kZSB3b3Jrcy5cbiAgICAvL1xuICAgIC8vIChVc2luZyBzdWJjbGFzc2luZyBmb3IgdGhpcyB3YXMgaW50ZW50aW9uYWxseSBkZWNpZGVkIGFnYWluc3QsXG4gICAgLy8gc2luY2UgaXQnZCByZXF1aXJlIGV4cG9zaW5nIGEgd2hvbGUgc2xldyBvZiBmaW5pY2t5XG4gICAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscyB0byB0aGUgdXNlciBjb2RlIHRoYXQgdGhleSBwcm9iYWJseSB3aWxsXG4gICAgLy8gbmV2ZXIgbmVlZC4pXG4gICAgc3RhdGljIGNyZWF0ZShwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHZpZXcubm9kZVZpZXdzW25vZGUudHlwZS5uYW1lXSwgZGVzY09iajtcbiAgICAgICAgbGV0IHNwZWMgPSBjdXN0b20gJiYgY3VzdG9tKG5vZGUsIHZpZXcsICgpID0+IHtcbiAgICAgICAgICAgIC8vIChUaGlzIGlzIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGN1c3RvbSB2aWV3IHRvIGZpbmQgaXRzXG4gICAgICAgICAgICAvLyBvd24gcG9zaXRpb24pXG4gICAgICAgICAgICBpZiAoIWRlc2NPYmopXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIGlmIChkZXNjT2JqLnBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY09iai5wYXJlbnQucG9zQmVmb3JlQ2hpbGQoZGVzY09iaik7XG4gICAgICAgIH0sIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgICAgbGV0IGRvbSA9IHNwZWMgJiYgc3BlYy5kb20sIGNvbnRlbnRET00gPSBzcGVjICYmIHNwZWMuY29udGVudERPTTtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICBpZiAoIWRvbSlcbiAgICAgICAgICAgICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlLnRleHQpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlICE9IDMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUZXh0IG11c3QgYmUgcmVuZGVyZWQgYXMgYSBET00gdGV4dCBub2RlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkb20pIHtcbiAgICAgICAgICAgICh7IGRvbSwgY29udGVudERPTSB9ID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBub2RlLnR5cGUuc3BlYy50b0RPTShub2RlKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGVudERPTSAmJiAhbm9kZS5pc1RleHQgJiYgZG9tLm5vZGVOYW1lICE9IFwiQlJcIikgeyAvLyBDaHJvbWUgZ2V0cyBjb25mdXNlZCBieSA8YnIgY29udGVudGVkaXRhYmxlPWZhbHNlPlxuICAgICAgICAgICAgaWYgKCFkb20uaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpKVxuICAgICAgICAgICAgICAgIGRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIGRvbS5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlRE9NID0gZG9tO1xuICAgICAgICBkb20gPSBhcHBseU91dGVyRGVjbyhkb20sIG91dGVyRGVjbywgbm9kZSk7XG4gICAgICAgIGlmIChzcGVjKVxuICAgICAgICAgICAgcmV0dXJuIGRlc2NPYmogPSBuZXcgQ3VzdG9tTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSB8fCBudWxsLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZS5pc1RleHQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIG5vZGVET00sIHZpZXcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00gfHwgbnVsbCwgbm9kZURPTSwgdmlldywgcG9zICsgMSk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgLy8gRXhwZXJpbWVudGFsIGtsdWRnZSB0byBhbGxvdyBvcHQtaW4gcmUtcGFyc2luZyBvZiBub2Rlc1xuICAgICAgICBpZiAodGhpcy5ub2RlLnR5cGUuc3BlYy5yZXBhcnNlSW5WaWV3KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIEZJWE1FIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBjYW4gYWx3YXlzIHJldHVybiB0aGUgY3VycmVudFxuICAgICAgICAvLyBhdHRycyBtZWFucyB0aGF0IGlmIHRoZSB1c2VyIHNvbWVob3cgbWFuYWdlcyB0byBjaGFuZ2UgdGhlXG4gICAgICAgIC8vIGF0dHJzIGluIHRoZSBkb20sIHRoYXQgd29uJ3QgYmUgcGlja2VkIHVwLiBOb3QgZW50aXJlbHkgc3VyZVxuICAgICAgICAvLyB3aGV0aGVyIHRoaXMgaXMgYSBwcm9ibGVtXG4gICAgICAgIGxldCBydWxlID0geyBub2RlOiB0aGlzLm5vZGUudHlwZS5uYW1lLCBhdHRyczogdGhpcy5ub2RlLmF0dHJzIH07XG4gICAgICAgIGlmICh0aGlzLm5vZGUudHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIpXG4gICAgICAgICAgICBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSA9IFwiZnVsbFwiO1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgcnVsZS5nZXRDb250ZW50ID0gKCkgPT4gdGhpcy5ub2RlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGVudExvc3QpIHtcbiAgICAgICAgICAgIHJ1bGUuY29udGVudEVsZW1lbnQgPSB0aGlzLmNvbnRlbnRET007XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgbGlrZXMgdG8gcmFuZG9tbHkgcmVjcmVhdGUgcGFyZW50IG5vZGVzIHdoZW5cbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIHRoaW5ncy4gV2hlbiB0aGF0IGhhcHBlbnMsIHRoaXMgdHJpZXMgdG8gZmluZCB0aGVcbiAgICAgICAgICAgIC8vIG5ldyBwYXJlbnQuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9tLmNvbnRhaW5zKGNoaWxkLmRvbS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBydWxlLmNvbnRlbnRFbGVtZW50ID0gY2hpbGQuZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcnVsZS5jb250ZW50RWxlbWVudClcbiAgICAgICAgICAgICAgICBydWxlLmdldENvbnRlbnQgPSAoKSA9PiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICB9XG4gICAgbWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIG5vZGUuZXEodGhpcy5ub2RlKSAmJlxuICAgICAgICAgICAgc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSAmJiBpbm5lckRlY28uZXEodGhpcy5pbm5lckRlY28pO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMubm9kZS5ub2RlU2l6ZTsgfVxuICAgIGdldCBib3JkZXIoKSB7IHJldHVybiB0aGlzLm5vZGUuaXNMZWFmID8gMCA6IDE7IH1cbiAgICAvLyBTeW5jcyBgdGhpcy5jaGlsZHJlbmAgdG8gbWF0Y2ggYHRoaXMubm9kZS5jb250ZW50YCBhbmQgdGhlIGxvY2FsXG4gICAgLy8gZGVjb3JhdGlvbnMsIHBvc3NpYmx5IGludHJvZHVjaW5nIG5lc3RpbmcgZm9yIG1hcmtzLiBUaGVuLCBpbiBhXG4gICAgLy8gc2VwYXJhdGUgc3RlcCwgc3luY3MgdGhlIERPTSBpbnNpZGUgYHRoaXMuY29udGVudERPTWAgdG9cbiAgICAvLyBgdGhpcy5jaGlsZHJlbmAuXG4gICAgdXBkYXRlQ2hpbGRyZW4odmlldywgcG9zKSB7XG4gICAgICAgIGxldCBpbmxpbmUgPSB0aGlzLm5vZGUuaW5saW5lQ29udGVudCwgb2ZmID0gcG9zO1xuICAgICAgICBsZXQgY29tcG9zaXRpb24gPSB2aWV3LmNvbXBvc2luZyA/IHRoaXMubG9jYWxDb21wb3NpdGlvbkluZm8odmlldywgcG9zKSA6IG51bGw7XG4gICAgICAgIGxldCBsb2NhbENvbXBvc2l0aW9uID0gY29tcG9zaXRpb24gJiYgY29tcG9zaXRpb24ucG9zID4gLTEgPyBjb21wb3NpdGlvbiA6IG51bGw7XG4gICAgICAgIGxldCBjb21wb3NpdGlvbkluQ2hpbGQgPSBjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi5wb3MgPCAwO1xuICAgICAgICBsZXQgdXBkYXRlciA9IG5ldyBWaWV3VHJlZVVwZGF0ZXIodGhpcywgbG9jYWxDb21wb3NpdGlvbiAmJiBsb2NhbENvbXBvc2l0aW9uLm5vZGUsIHZpZXcpO1xuICAgICAgICBpdGVyRGVjbyh0aGlzLm5vZGUsIHRoaXMuaW5uZXJEZWNvLCAod2lkZ2V0LCBpLCBpbnNpZGVOb2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAod2lkZ2V0LnNwZWMubWFya3MpXG4gICAgICAgICAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyh3aWRnZXQuc3BlYy5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHdpZGdldC50eXBlLnNpZGUgPj0gMCAmJiAhaW5zaWRlTm9kZSlcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKGkgPT0gdGhpcy5ub2RlLmNoaWxkQ291bnQgPyBNYXJrLm5vbmUgOiB0aGlzLm5vZGUuY2hpbGQoaSkubWFya3MsIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbmV4dCBub2RlIGlzIGEgZGVzYyBtYXRjaGluZyB0aGlzIHdpZGdldCwgcmV1c2UgaXQsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaW5zZXJ0IHRoZSB3aWRnZXQgYXMgYSBuZXcgdmlldyBkZXNjLlxuICAgICAgICAgICAgdXBkYXRlci5wbGFjZVdpZGdldCh3aWRnZXQsIHZpZXcsIG9mZik7XG4gICAgICAgIH0sIChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGkpID0+IHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgd3JhcHBpbmcgbWFyayBkZXNjcyBtYXRjaCB0aGUgbm9kZSdzIG1hcmtzLlxuICAgICAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyhjaGlsZC5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgIC8vIFRyeSBzZXZlcmFsIHN0cmF0ZWdpZXMgZm9yIGRyYXdpbmcgdGhpcyBub2RlXG4gICAgICAgICAgICBsZXQgY29tcEluZGV4O1xuICAgICAgICAgICAgaWYgKHVwZGF0ZXIuZmluZE5vZGVNYXRjaChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGkpKSA7XG4gICAgICAgICAgICBlbHNlIGlmIChjb21wb3NpdGlvbkluQ2hpbGQgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+IG9mZiAmJlxuICAgICAgICAgICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIDwgb2ZmICsgY2hpbGQubm9kZVNpemUgJiZcbiAgICAgICAgICAgICAgICAoY29tcEluZGV4ID0gdXBkYXRlci5maW5kSW5kZXhXaXRoQ2hpbGQoY29tcG9zaXRpb24ubm9kZSkpID4gLTEgJiZcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnVwZGF0ZU5vZGVBdChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGNvbXBJbmRleCwgdmlldykpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHVwZGF0ZXIudXBkYXRlTmV4dE5vZGUoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBpLCBvZmYpKSA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgaXQgYXMgYSBuZXcgdmlld1xuICAgICAgICAgICAgICAgIHVwZGF0ZXIuYWRkTm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIG9mZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBEcm9wIGFsbCByZW1haW5pbmcgZGVzY3MgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3MoW10sIGlubGluZSwgdmlldyk7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICB1cGRhdGVyLmFkZFRleHRibG9ja0hhY2tzKCk7XG4gICAgICAgIHVwZGF0ZXIuZGVzdHJveVJlc3QoKTtcbiAgICAgICAgLy8gU3luYyB0aGUgRE9NIGlmIGFueXRoaW5nIGNoYW5nZWRcbiAgICAgICAgaWYgKHVwZGF0ZXIuY2hhbmdlZCB8fCB0aGlzLmRpcnR5ID09IENPTlRFTlRfRElSVFkpIHtcbiAgICAgICAgICAgIC8vIE1heSBoYXZlIHRvIHByb3RlY3QgZm9jdXNlZCBET00gZnJvbSBiZWluZyBjaGFuZ2VkIGlmIGEgY29tcG9zaXRpb24gaXMgYWN0aXZlXG4gICAgICAgICAgICBpZiAobG9jYWxDb21wb3NpdGlvbilcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RlY3RMb2NhbENvbXBvc2l0aW9uKHZpZXcsIGxvY2FsQ29tcG9zaXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyRGVzY3ModGhpcy5jb250ZW50RE9NLCB0aGlzLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgICAgICAgIGlmIChpb3MpXG4gICAgICAgICAgICAgICAgaW9zSGFja3ModGhpcy5kb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvY2FsQ29tcG9zaXRpb25JbmZvKHZpZXcsIHBvcykge1xuICAgICAgICAvLyBPbmx5IGRvIHNvbWV0aGluZyBpZiBib3RoIHRoZSBzZWxlY3Rpb24gYW5kIGEgZm9jdXNlZCB0ZXh0IG5vZGVcbiAgICAgICAgLy8gYXJlIGluc2lkZSBvZiB0aGlzIG5vZGVcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHx8IGZyb20gPCBwb3MgfHwgdG8gPiBwb3MgKyB0aGlzLm5vZGUuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCB0ZXh0Tm9kZSA9IG5lYXJieVRleHROb2RlKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgICAgIGlmICghdGV4dE5vZGUgfHwgIXRoaXMuZG9tLmNvbnRhaW5zKHRleHROb2RlLnBhcmVudE5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgdGV4dCBpbiB0aGUgZm9jdXNlZCBub2RlIGluIHRoZSBub2RlLCBzdG9wIGlmIGl0J3Mgbm90XG4gICAgICAgICAgICAvLyB0aGVyZSAobWF5IGhhdmUgYmVlbiBtb2RpZmllZCB0aHJvdWdoIG90aGVyIG1lYW5zLCBpbiB3aGljaFxuICAgICAgICAgICAgLy8gY2FzZSBpdCBzaG91bGQgb3ZlcndyaXR0ZW4pXG4gICAgICAgICAgICBsZXQgdGV4dCA9IHRleHROb2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIGxldCB0ZXh0UG9zID0gZmluZFRleHRJbkZyYWdtZW50KHRoaXMubm9kZS5jb250ZW50LCB0ZXh0LCBmcm9tIC0gcG9zLCB0byAtIHBvcyk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dFBvcyA8IDAgPyBudWxsIDogeyBub2RlOiB0ZXh0Tm9kZSwgcG9zOiB0ZXh0UG9zLCB0ZXh0IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0ZXh0Tm9kZSwgcG9zOiAtMSwgdGV4dDogXCJcIiB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3RlY3RMb2NhbENvbXBvc2l0aW9uKHZpZXcsIHsgbm9kZSwgcG9zLCB0ZXh0IH0pIHtcbiAgICAgICAgLy8gVGhlIG5vZGUgaXMgYWxyZWFkeSBwYXJ0IG9mIGEgbG9jYWwgdmlldyBkZXNjLCBsZWF2ZSBpdCB0aGVyZVxuICAgICAgICBpZiAodGhpcy5nZXREZXNjKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBDcmVhdGUgYSBjb21wb3NpdGlvbiB2aWV3IGZvciB0aGUgb3JwaGFuZWQgbm9kZXNcbiAgICAgICAgbGV0IHRvcE5vZGUgPSBub2RlO1xuICAgICAgICBmb3IgKDs7IHRvcE5vZGUgPSB0b3BOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmICh0b3BOb2RlLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgd2hpbGUgKHRvcE5vZGUucHJldmlvdXNTaWJsaW5nKVxuICAgICAgICAgICAgICAgIHRvcE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0b3BOb2RlLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICB3aGlsZSAodG9wTm9kZS5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICB0b3BOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9wTm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICBpZiAodG9wTm9kZS5wbVZpZXdEZXNjKVxuICAgICAgICAgICAgICAgIHRvcE5vZGUucG1WaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVzYyA9IG5ldyBDb21wb3NpdGlvblZpZXdEZXNjKHRoaXMsIHRvcE5vZGUsIG5vZGUsIHRleHQpO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMucHVzaChkZXNjKTtcbiAgICAgICAgLy8gUGF0Y2ggdXAgdGhpcy5jaGlsZHJlbiB0byBjb250YWluIHRoZSBjb21wb3NpdGlvbiB2aWV3XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSByZXBsYWNlTm9kZXModGhpcy5jaGlsZHJlbiwgcG9zLCBwb3MgKyB0ZXh0Lmxlbmd0aCwgdmlldywgZGVzYyk7XG4gICAgfVxuICAgIC8vIElmIHRoaXMgZGVzYyBtdXN0IGJlIHVwZGF0ZWQgdG8gbWF0Y2ggdGhlIGdpdmVuIG5vZGUgZGVjb3JhdGlvbixcbiAgICAvLyBkbyBzbyBhbmQgcmV0dXJuIHRydWUuXG4gICAgdXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IE5PREVfRElSVFkgfHxcbiAgICAgICAgICAgICFub2RlLnNhbWVNYXJrdXAodGhpcy5ub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB1cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmlubmVyRGVjbyA9IGlubmVyRGVjbztcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4odmlldywgdGhpcy5wb3NBdFN0YXJ0KTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICB9XG4gICAgdXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbykge1xuICAgICAgICBpZiAoc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG5lZWRzV3JhcCA9IHRoaXMubm9kZURPTS5ub2RlVHlwZSAhPSAxO1xuICAgICAgICBsZXQgb2xkRE9NID0gdGhpcy5kb207XG4gICAgICAgIHRoaXMuZG9tID0gcGF0Y2hPdXRlckRlY28odGhpcy5kb20sIHRoaXMubm9kZURPTSwgY29tcHV0ZU91dGVyRGVjbyh0aGlzLm91dGVyRGVjbywgdGhpcy5ub2RlLCBuZWVkc1dyYXApLCBjb21wdXRlT3V0ZXJEZWNvKG91dGVyRGVjbywgdGhpcy5ub2RlLCBuZWVkc1dyYXApKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tICE9IG9sZERPTSkge1xuICAgICAgICAgICAgb2xkRE9NLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmRvbS5wbVZpZXdEZXNjID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dGVyRGVjbyA9IG91dGVyRGVjbztcbiAgICB9XG4gICAgLy8gTWFyayB0aGlzIG5vZGUgYXMgYmVpbmcgdGhlIHNlbGVjdGVkIG5vZGUuXG4gICAgc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZURPTS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgdGhpcy5ub2RlRE9NLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVcIik7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgdGhpcy5kb20uZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHNlbGVjdGVkIG5vZGUgbWFya2luZyBmcm9tIHRoaXMgbm9kZS5cbiAgICBkZXNlbGVjdE5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVET00ubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgIHRoaXMubm9kZURPTS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlXCIpO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSlcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZUF0dHJpYnV0ZShcImRyYWdnYWJsZVwiKTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0aGlzLm5vZGUuaXNBdG9tOyB9XG59XG4vLyBDcmVhdGUgYSB2aWV3IGRlc2MgZm9yIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQgbm9kZSwgdG8gYmUgZXhwb3J0ZWRcbi8vIGFuZCB1c2VkIGJ5IHRoZSB2aWV3IGNsYXNzLlxuZnVuY3Rpb24gZG9jVmlld0Rlc2MoZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCB2aWV3KSB7XG4gICAgYXBwbHlPdXRlckRlY28oZG9tLCBvdXRlckRlY28sIGRvYyk7XG4gICAgbGV0IGRvY1ZpZXcgPSBuZXcgTm9kZVZpZXdEZXNjKHVuZGVmaW5lZCwgZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBkb20sIGRvbSwgdmlldywgMCk7XG4gICAgaWYgKGRvY1ZpZXcuY29udGVudERPTSlcbiAgICAgICAgZG9jVmlldy51cGRhdGVDaGlsZHJlbih2aWV3LCAwKTtcbiAgICByZXR1cm4gZG9jVmlldztcbn1cbmNsYXNzIFRleHRWaWV3RGVzYyBleHRlbmRzIE5vZGVWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBub2RlRE9NLCB2aWV3KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbnVsbCwgbm9kZURPTSwgdmlldywgMCk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgbGV0IHNraXAgPSB0aGlzLm5vZGVET00ucGFyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKHNraXAgJiYgc2tpcCAhPSB0aGlzLmRvbSAmJiAhc2tpcC5wbUlzRGVjbylcbiAgICAgICAgICAgIHNraXAgPSBza2lwLnBhcmVudE5vZGU7XG4gICAgICAgIHJldHVybiB7IHNraXA6IChza2lwIHx8IHRydWUpIH07XG4gICAgfVxuICAgIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZIHx8ICh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSAmJiAhdGhpcy5pblBhcmVudCgpKSB8fFxuICAgICAgICAgICAgIW5vZGUuc2FtZU1hcmt1cCh0aGlzLm5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgICAgICBpZiAoKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZIHx8IG5vZGUudGV4dCAhPSB0aGlzLm5vZGUudGV4dCkgJiYgbm9kZS50ZXh0ICE9IHRoaXMubm9kZURPTS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZURPTS5ub2RlVmFsdWUgPSBub2RlLnRleHQ7XG4gICAgICAgICAgICBpZiAodmlldy50cmFja1dyaXRlcyA9PSB0aGlzLm5vZGVET00pXG4gICAgICAgICAgICAgICAgdmlldy50cmFja1dyaXRlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluUGFyZW50KCkge1xuICAgICAgICBsZXQgcGFyZW50RE9NID0gdGhpcy5wYXJlbnQuY29udGVudERPTTtcbiAgICAgICAgZm9yIChsZXQgbiA9IHRoaXMubm9kZURPTTsgbjsgbiA9IG4ucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIGlmIChuID09IHBhcmVudERPTSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkb21Gcm9tUG9zKHBvcykge1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLm5vZGVET00sIG9mZnNldDogcG9zIH07XG4gICAgfVxuICAgIGxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcykge1xuICAgICAgICBpZiAoZG9tID09IHRoaXMubm9kZURPTSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyBNYXRoLm1pbihvZmZzZXQsIHRoaXMubm9kZS50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzdXBlci5sb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gbXV0YXRpb24udHlwZSAhPSBcImNoYXJhY3RlckRhdGFcIiAmJiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCI7XG4gICAgfVxuICAgIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlLmN1dChmcm9tLCB0byksIGRvbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUudGV4dCk7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFZpZXdEZXNjKHRoaXMucGFyZW50LCBub2RlLCB0aGlzLm91dGVyRGVjbywgdGhpcy5pbm5lckRlY28sIGRvbSwgZG9tLCB2aWV3KTtcbiAgICB9XG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgIGlmICh0aGlzLmRvbSAhPSB0aGlzLm5vZGVET00gJiYgKGZyb20gPT0gMCB8fCB0byA9PSB0aGlzLm5vZGVET00ubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gTk9ERV9ESVJUWTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiBmYWxzZTsgfVxufVxuLy8gQSBkdW1teSBkZXNjIHVzZWQgdG8gdGFnIHRyYWlsaW5nIEJSIG9yIElNRyBub2RlcyBjcmVhdGVkIHRvIHdvcmtcbi8vIGFyb3VuZCBjb250ZW50RWRpdGFibGUgdGVycmlibGVuZXNzLlxuY2xhc3MgVHJhaWxpbmdIYWNrVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4geyBpZ25vcmU6IHRydWUgfTsgfVxuICAgIG1hdGNoZXNIYWNrKG5vZGVOYW1lKSB7IHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiB0aGlzLmRvbS5ub2RlTmFtZSA9PSBub2RlTmFtZTsgfVxuICAgIGdldCBkb21BdG9tKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBpZ25vcmVGb3JDb29yZHMoKSB7IHJldHVybiB0aGlzLmRvbS5ub2RlTmFtZSA9PSBcIklNR1wiOyB9XG59XG4vLyBBIHNlcGFyYXRlIHN1YmNsYXNzIGlzIHVzZWQgZm9yIGN1c3RvbWl6ZWQgbm9kZSB2aWV3cywgc28gdGhhdCB0aGVcbi8vIGV4dHJhIGNoZWNrcyBvbmx5IGhhdmUgdG8gYmUgbWFkZSBmb3Igbm9kZXMgdGhhdCBhcmUgYWN0dWFsbHlcbi8vIGN1c3RvbWl6ZWQuXG5jbGFzcyBDdXN0b21Ob2RlVmlld0Rlc2MgZXh0ZW5kcyBOb2RlVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgc3BlYywgdmlldywgcG9zKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgdmlldywgcG9zKTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICB9XG4gICAgLy8gQSBjdXN0b20gYHVwZGF0ZWAgbWV0aG9kIGdldHMgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHVwZGF0ZSBnb2VzXG4gICAgLy8gdGhyb3VnaC4gSWYgaXQgZG9lcywgYW5kIHRoZXJlJ3MgYSBgY29udGVudERPTWAgbm9kZSwgb3VyIGxvZ2ljXG4gICAgLy8gdXBkYXRlcyB0aGUgY2hpbGRyZW4uXG4gICAgdXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IE5PREVfRElSVFkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnNwZWMudXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zcGVjLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5jb250ZW50RE9NICYmICFub2RlLmlzTGVhZikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgdGhpcy5zcGVjLnNlbGVjdE5vZGUgPyB0aGlzLnNwZWMuc2VsZWN0Tm9kZSgpIDogc3VwZXIuc2VsZWN0Tm9kZSgpO1xuICAgIH1cbiAgICBkZXNlbGVjdE5vZGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYy5kZXNlbGVjdE5vZGUgPyB0aGlzLnNwZWMuZGVzZWxlY3ROb2RlKCkgOiBzdXBlci5kZXNlbGVjdE5vZGUoKTtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgcm9vdCwgZm9yY2UpIHtcbiAgICAgICAgdGhpcy5zcGVjLnNldFNlbGVjdGlvbiA/IHRoaXMuc3BlYy5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290KVxuICAgICAgICAgICAgOiBzdXBlci5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290LCBmb3JjZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnNwZWMuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMuc3BlYy5kZXN0cm95KCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMuc3RvcEV2ZW50ID8gdGhpcy5zcGVjLnN0b3BFdmVudChldmVudCkgOiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbiA/IHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbikgOiBzdXBlci5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbik7XG4gICAgfVxufVxuLy8gU3luYyB0aGUgY29udGVudCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUgd2l0aCB0aGUgbm9kZXMgYXNzb2NpYXRlZFxuLy8gd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgdmlldyBkZXNjcywgcmVjdXJzaW5nIGludG8gbWFyayBkZXNjc1xuLy8gYmVjYXVzZSB0aGlzIHNob3VsZCBzeW5jIHRoZSBzdWJ0cmVlIGZvciBhIHdob2xlIG5vZGUgYXQgYSB0aW1lLlxuZnVuY3Rpb24gcmVuZGVyRGVzY3MocGFyZW50RE9NLCBkZXNjcywgdmlldykge1xuICAgIGxldCBkb20gPSBwYXJlbnRET00uZmlyc3RDaGlsZCwgd3JpdHRlbiA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlc2MgPSBkZXNjc1tpXSwgY2hpbGRET00gPSBkZXNjLmRvbTtcbiAgICAgICAgaWYgKGNoaWxkRE9NLnBhcmVudE5vZGUgPT0gcGFyZW50RE9NKSB7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGRET00gIT0gZG9tKSB7XG4gICAgICAgICAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgICAgICAgICB3cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbSA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgcGFyZW50RE9NLmluc2VydEJlZm9yZShjaGlsZERPTSwgZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzYyBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgICAgbGV0IHBvcyA9IGRvbSA/IGRvbS5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnRET00ubGFzdENoaWxkO1xuICAgICAgICAgICAgcmVuZGVyRGVzY3MoZGVzYy5jb250ZW50RE9NLCBkZXNjLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgICAgICAgIGRvbSA9IHBvcyA/IHBvcy5uZXh0U2libGluZyA6IHBhcmVudERPTS5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChkb20pIHtcbiAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgd3JpdHRlbiA9IHRydWU7XG4gICAgfVxuICAgIGlmICh3cml0dGVuICYmIHZpZXcudHJhY2tXcml0ZXMgPT0gcGFyZW50RE9NKVxuICAgICAgICB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDtcbn1cbmNvbnN0IE91dGVyRGVjb0xldmVsID0gZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG4gICAgaWYgKG5vZGVOYW1lKVxuICAgICAgICB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG59O1xuT3V0ZXJEZWNvTGV2ZWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IG5vRGVjbyA9IFtuZXcgT3V0ZXJEZWNvTGV2ZWxdO1xuZnVuY3Rpb24gY29tcHV0ZU91dGVyRGVjbyhvdXRlckRlY28sIG5vZGUsIG5lZWRzV3JhcCkge1xuICAgIGlmIChvdXRlckRlY28ubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBub0RlY287XG4gICAgbGV0IHRvcCA9IG5lZWRzV3JhcCA/IG5vRGVjb1swXSA6IG5ldyBPdXRlckRlY29MZXZlbCwgcmVzdWx0ID0gW3RvcF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRlckRlY28ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGF0dHJzID0gb3V0ZXJEZWNvW2ldLnR5cGUuYXR0cnM7XG4gICAgICAgIGlmICghYXR0cnMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGF0dHJzLm5vZGVOYW1lKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godG9wID0gbmV3IE91dGVyRGVjb0xldmVsKGF0dHJzLm5vZGVOYW1lKSk7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChuZWVkc1dyYXAgJiYgcmVzdWx0Lmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRvcCA9IG5ldyBPdXRlckRlY29MZXZlbChub2RlLmlzSW5saW5lID8gXCJzcGFuXCIgOiBcImRpdlwiKSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcImNsYXNzXCIpXG4gICAgICAgICAgICAgICAgdG9wLmNsYXNzID0gKHRvcC5jbGFzcyA/IHRvcC5jbGFzcyArIFwiIFwiIDogXCJcIikgKyB2YWw7XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICB0b3Auc3R5bGUgPSAodG9wLnN0eWxlID8gdG9wLnN0eWxlICsgXCI7XCIgOiBcIlwiKSArIHZhbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgIT0gXCJub2RlTmFtZVwiKVxuICAgICAgICAgICAgICAgIHRvcFtuYW1lXSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGF0Y2hPdXRlckRlY28ob3V0ZXJET00sIG5vZGVET00sIHByZXZDb21wdXRlZCwgY3VyQ29tcHV0ZWQpIHtcbiAgICAvLyBTaG9ydGN1dCBmb3IgdHJpdmlhbCBjYXNlXG4gICAgaWYgKHByZXZDb21wdXRlZCA9PSBub0RlY28gJiYgY3VyQ29tcHV0ZWQgPT0gbm9EZWNvKVxuICAgICAgICByZXR1cm4gbm9kZURPTTtcbiAgICBsZXQgY3VyRE9NID0gbm9kZURPTTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ckNvbXB1dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBkZWNvID0gY3VyQ29tcHV0ZWRbaV0sIHByZXYgPSBwcmV2Q29tcHV0ZWRbaV07XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50O1xuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldi5ub2RlTmFtZSA9PSBkZWNvLm5vZGVOYW1lICYmIGN1ckRPTSAhPSBvdXRlckRPTSAmJlxuICAgICAgICAgICAgICAgIChwYXJlbnQgPSBjdXJET00ucGFyZW50Tm9kZSkgJiYgcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gZGVjby5ub2RlTmFtZSkge1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZGVjby5ub2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50LnBtSXNEZWNvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY3VyRE9NKTtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbm9EZWNvWzBdO1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXRjaEF0dHJpYnV0ZXMoY3VyRE9NLCBwcmV2IHx8IG5vRGVjb1swXSwgZGVjbyk7XG4gICAgfVxuICAgIHJldHVybiBjdXJET007XG59XG5mdW5jdGlvbiBwYXRjaEF0dHJpYnV0ZXMoZG9tLCBwcmV2LCBjdXIpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgIGlmIChuYW1lICE9IFwiY2xhc3NcIiAmJiBuYW1lICE9IFwic3R5bGVcIiAmJiBuYW1lICE9IFwibm9kZU5hbWVcIiAmJiAhKG5hbWUgaW4gY3VyKSlcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBjdXIpXG4gICAgICAgIGlmIChuYW1lICE9IFwiY2xhc3NcIiAmJiBuYW1lICE9IFwic3R5bGVcIiAmJiBuYW1lICE9IFwibm9kZU5hbWVcIiAmJiBjdXJbbmFtZV0gIT0gcHJldltuYW1lXSlcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgY3VyW25hbWVdKTtcbiAgICBpZiAocHJldi5jbGFzcyAhPSBjdXIuY2xhc3MpIHtcbiAgICAgICAgbGV0IHByZXZMaXN0ID0gcHJldi5jbGFzcyA/IHByZXYuY2xhc3Muc3BsaXQoXCIgXCIpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICBsZXQgY3VyTGlzdCA9IGN1ci5jbGFzcyA/IGN1ci5jbGFzcy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY3VyTGlzdC5pbmRleE9mKHByZXZMaXN0W2ldKSA9PSAtMSlcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NMaXN0LnJlbW92ZShwcmV2TGlzdFtpXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyTGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChwcmV2TGlzdC5pbmRleE9mKGN1ckxpc3RbaV0pID09IC0xKVxuICAgICAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKGN1ckxpc3RbaV0pO1xuICAgICAgICBpZiAoZG9tLmNsYXNzTGlzdC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICB9XG4gICAgaWYgKHByZXYuc3R5bGUgIT0gY3VyLnN0eWxlKSB7XG4gICAgICAgIGlmIChwcmV2LnN0eWxlKSB7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IC9cXHMqKFtcXHdcXC1cXHhhMS1cXHVmZmZmXSspXFxzKjooPzpcIig/OlxcXFwufFteXCJdKSpcInwnKD86XFxcXC58W14nXSkqJ3xcXCguKj9cXCl8W147XSkqL2csIG07XG4gICAgICAgICAgICB3aGlsZSAobSA9IHByb3AuZXhlYyhwcmV2LnN0eWxlKSlcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUucmVtb3ZlUHJvcGVydHkobVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci5zdHlsZSlcbiAgICAgICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ICs9IGN1ci5zdHlsZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseU91dGVyRGVjbyhkb20sIGRlY28sIG5vZGUpIHtcbiAgICByZXR1cm4gcGF0Y2hPdXRlckRlY28oZG9tLCBkb20sIG5vRGVjbywgY29tcHV0ZU91dGVyRGVjbyhkZWNvLCBub2RlLCBkb20ubm9kZVR5cGUgIT0gMSkpO1xufVxuZnVuY3Rpb24gc2FtZU91dGVyRGVjbyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0udHlwZS5lcShiW2ldLnR5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gUmVtb3ZlIGEgRE9NIG5vZGUgYW5kIHJldHVybiBpdHMgbmV4dCBzaWJsaW5nLlxuZnVuY3Rpb24gcm0oZG9tKSB7XG4gICAgbGV0IG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbi8vIEhlbHBlciBjbGFzcyBmb3IgaW5jcmVtZW50YWxseSB1cGRhdGluZyBhIHRyZWUgb2YgbWFyayBkZXNjcyBhbmRcbi8vIHRoZSB3aWRnZXQgYW5kIG5vZGUgZGVzY3MgaW5zaWRlIG9mIHRoZW0uXG5jbGFzcyBWaWV3VHJlZVVwZGF0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRvcCwgbG9jaywgdmlldykge1xuICAgICAgICB0aGlzLmxvY2sgPSBsb2NrO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAvLyBJbmRleCBpbnRvIGB0aGlzLnRvcGAncyBjaGlsZCBhcnJheSwgcmVwcmVzZW50cyB0aGUgY3VycmVudFxuICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24uXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAvLyBXaGVuIGVudGVyaW5nIGEgbWFyaywgdGhlIGN1cnJlbnQgdG9wIGFuZCBpbmRleCBhcmUgcHVzaGVkXG4gICAgICAgIC8vIG9udG8gdGhpcy5cbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciBhbnl0aGluZyB3YXMgY2hhbmdlZFxuICAgICAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMucHJlTWF0Y2ggPSBwcmVNYXRjaCh0b3Aubm9kZS5jb250ZW50LCB0b3ApO1xuICAgIH1cbiAgICAvLyBEZXN0cm95IGFuZCByZW1vdmUgdGhlIGNoaWxkcmVuIGJldHdlZW4gdGhlIGdpdmVuIGluZGljZXMgaW5cbiAgICAvLyBgdGhpcy50b3BgLlxuICAgIGRlc3Ryb3lCZXR3ZWVuKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbltpXS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBEZXN0cm95IGFsbCByZW1haW5pbmcgY2hpbGRyZW4gaW4gYHRoaXMudG9wYC5cbiAgICBkZXN0cm95UmVzdCgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTeW5jIHRoZSBjdXJyZW50IHN0YWNrIG9mIG1hcmsgZGVzY3Mgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2ZcbiAgICAvLyBtYXJrcywgcmV1c2luZyBleGlzdGluZyBtYXJrIGRlc2NzIHdoZW4gcG9zc2libGUuXG4gICAgc3luY1RvTWFya3MobWFya3MsIGlubGluZSwgdmlldykge1xuICAgICAgICBsZXQga2VlcCA9IDAsIGRlcHRoID0gdGhpcy5zdGFjay5sZW5ndGggPj4gMTtcbiAgICAgICAgbGV0IG1heEtlZXAgPSBNYXRoLm1pbihkZXB0aCwgbWFya3MubGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBtYXhLZWVwICYmXG4gICAgICAgICAgICAoa2VlcCA9PSBkZXB0aCAtIDEgPyB0aGlzLnRvcCA6IHRoaXMuc3RhY2tbKGtlZXAgKyAxKSA8PCAxXSlcbiAgICAgICAgICAgICAgICAubWF0Y2hlc01hcmsobWFya3Nba2VlcF0pICYmIG1hcmtzW2tlZXBdLnR5cGUuc3BlYy5zcGFubmluZyAhPT0gZmFsc2UpXG4gICAgICAgICAgICBrZWVwKys7XG4gICAgICAgIHdoaWxlIChrZWVwIDwgZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVJlc3QoKTtcbiAgICAgICAgICAgIHRoaXMudG9wLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChkZXB0aCA8IG1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMudG9wLCB0aGlzLmluZGV4ICsgMSk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4OyBpIDwgTWF0aC5taW4odGhpcy5pbmRleCArIDMsIHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy50b3AuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubWF0Y2hlc01hcmsobWFya3NbZGVwdGhdKSAmJiAhdGhpcy5pc0xvY2tlZChuZXh0LmRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudG9wID0gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFya0Rlc2MgPSBNYXJrVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBtYXJrc1tkZXB0aF0sIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgsIDAsIG1hcmtEZXNjKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvcCA9IG1hcmtEZXNjO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSBub2RlIGRlc2MgbWF0Y2hpbmcgdGhlIGdpdmVuIGRhdGEuIFNraXAgb3ZlciBpdCBhbmRcbiAgICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHN1Y2Nlc3NmdWwuXG4gICAgZmluZE5vZGVNYXRjaChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gLTEsIHRhcmdldERlc2M7XG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLnByZU1hdGNoLmluZGV4ICYmXG4gICAgICAgICAgICAodGFyZ2V0RGVzYyA9IHRoaXMucHJlTWF0Y2gubWF0Y2hlc1tpbmRleCAtIHRoaXMucHJlTWF0Y2guaW5kZXhdKS5wYXJlbnQgPT0gdGhpcy50b3AgJiZcbiAgICAgICAgICAgIHRhcmdldERlc2MubWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRoaXMudG9wLmNoaWxkcmVuLmluZGV4T2YodGFyZ2V0RGVzYywgdGhpcy5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleCwgZSA9IE1hdGgubWluKHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCwgaSArIDUpOyBpIDwgZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSAmJiAhdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHVwZGF0ZU5vZGVBdChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgsIHZpZXcpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGQuZGlydHkgPT0gTk9ERV9ESVJUWSAmJiBjaGlsZC5kb20gPT0gY2hpbGQuY29udGVudERPTSlcbiAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICAgICAgaWYgKCFjaGlsZC51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGluZGV4KTtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZmluZEluZGV4V2l0aENoaWxkKGRvbU5vZGUpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy50b3AuY29udGVudERPTSkge1xuICAgICAgICAgICAgICAgIGxldCBkZXNjID0gZG9tTm9kZS5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgICAgIGlmIChkZXNjKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b3AuY2hpbGRyZW5baV0gPT0gZGVzYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbU5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIHVwZGF0ZSB0aGUgbmV4dCBub2RlLCBpZiBhbnksIHRvIHRoZSBnaXZlbiBkYXRhLiBDaGVja3NcbiAgICAvLyBwcmUtbWF0Y2hlcyB0byBhdm9pZCBvdmVyd3JpdGluZyBub2RlcyB0aGF0IGNvdWxkIHN0aWxsIGJlIHVzZWQuXG4gICAgdXBkYXRlTmV4dE5vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIGluZGV4LCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5kZXg7IGkgPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgTm9kZVZpZXdEZXNjKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZU1hdGNoID0gdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmdldChuZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAocHJlTWF0Y2ggIT0gbnVsbCAmJiBwcmVNYXRjaCAhPSBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0RE9NID0gbmV4dC5kb20sIHVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgLy8gQ2FuJ3QgdXBkYXRlIGlmIG5leHRET00gaXMgb3IgY29udGFpbnMgdGhpcy5sb2NrLCBleGNlcHQgaWZcbiAgICAgICAgICAgICAgICAvLyBpdCdzIGEgdGV4dCBub2RlIHdob3NlIGNvbnRlbnQgYWxyZWFkeSBtYXRjaGVzIHRoZSBuZXcgdGV4dFxuICAgICAgICAgICAgICAgIC8vIGFuZCB3aG9zZSBkZWNvcmF0aW9ucyBtYXRjaCB0aGUgbmV3IG9uZXMuXG4gICAgICAgICAgICAgICAgbGV0IGxvY2tlZCA9IHRoaXMuaXNMb2NrZWQobmV4dERPTSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGUgJiYgbmV4dC5ub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGVET00ubm9kZVZhbHVlID09IG5vZGUudGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5kaXJ0eSAhPSBOT0RFX0RJUlRZICYmIHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCBuZXh0Lm91dGVyRGVjbykpO1xuICAgICAgICAgICAgICAgIGlmICghbG9ja2VkICYmIG5leHQudXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5kb20gIT0gbmV4dERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFsb2NrZWQgJiYgKHVwZGF0ZWQgPSB0aGlzLnJlY3JlYXRlV3JhcHBlcihuZXh0LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF0gPSB1cGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZC5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQudXBkYXRlQ2hpbGRyZW4odmlldywgcG9zICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gV2hlbiBhIG5vZGUgd2l0aCBjb250ZW50IGlzIHJlcGxhY2VkIGJ5IGEgZGlmZmVyZW50IG5vZGUgd2l0aFxuICAgIC8vIGlkZW50aWNhbCBjb250ZW50LCBtb3ZlIG92ZXIgaXRzIGNoaWxkcmVuLlxuICAgIHJlY3JlYXRlV3JhcHBlcihuZXh0LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSB7XG4gICAgICAgIGlmIChuZXh0LmRpcnR5IHx8IG5vZGUuaXNBdG9tIHx8ICFuZXh0LmNoaWxkcmVuLmxlbmd0aCB8fFxuICAgICAgICAgICAgIW5leHQubm9kZS5jb250ZW50LmVxKG5vZGUuY29udGVudCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHdyYXBwZXIgPSBOb2RlVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKTtcbiAgICAgICAgaWYgKHdyYXBwZXIuY29udGVudERPTSkge1xuICAgICAgICAgICAgd3JhcHBlci5jaGlsZHJlbiA9IG5leHQuY2hpbGRyZW47XG4gICAgICAgICAgICBuZXh0LmNoaWxkcmVuID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjaCBvZiB3cmFwcGVyLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoLnBhcmVudCA9IHdyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dC5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cbiAgICAvLyBJbnNlcnQgdGhlIG5vZGUgYXMgYSBuZXdseSBjcmVhdGVkIG5vZGUgZGVzYy5cbiAgICBhZGROb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGRlc2MgPSBOb2RlVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKTtcbiAgICAgICAgaWYgKGRlc2MuY29udGVudERPTSlcbiAgICAgICAgICAgIGRlc2MudXBkYXRlQ2hpbGRyZW4odmlldywgcG9zICsgMSk7XG4gICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4KyssIDAsIGRlc2MpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICBwbGFjZVdpZGdldCh3aWRnZXQsIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuaW5kZXggPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGggPyB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XSA6IG51bGw7XG4gICAgICAgIGlmIChuZXh0ICYmIG5leHQubWF0Y2hlc1dpZGdldCh3aWRnZXQpICYmXG4gICAgICAgICAgICAod2lkZ2V0ID09IG5leHQud2lkZ2V0IHx8ICFuZXh0LndpZGdldC50eXBlLnRvRE9NLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGVzYyA9IG5ldyBXaWRnZXRWaWV3RGVzYyh0aGlzLnRvcCwgd2lkZ2V0LCB2aWV3LCBwb3MpO1xuICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgZGVzYyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBhIHRleHRibG9jayBsb29rcyBhbmQgYmVoYXZlcyBjb3JyZWN0bHkgaW5cbiAgICAvLyBjb250ZW50RWRpdGFibGUuXG4gICAgYWRkVGV4dGJsb2NrSGFja3MoKSB7XG4gICAgICAgIGxldCBsYXN0Q2hpbGQgPSB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4IC0gMV0sIHBhcmVudCA9IHRoaXMudG9wO1xuICAgICAgICB3aGlsZSAobGFzdENoaWxkIGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBsYXN0Q2hpbGQ7XG4gICAgICAgICAgICBsYXN0Q2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5bcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGFzdENoaWxkIHx8IC8vIEVtcHR5IHRleHRibG9ja1xuICAgICAgICAgICAgIShsYXN0Q2hpbGQgaW5zdGFuY2VvZiBUZXh0Vmlld0Rlc2MpIHx8XG4gICAgICAgICAgICAvXFxuJC8udGVzdChsYXN0Q2hpbGQubm9kZS50ZXh0KSB8fFxuICAgICAgICAgICAgKHRoaXMudmlldy5yZXF1aXJlc0dlY2tvSGFja05vZGUgJiYgL1xccyQvLnRlc3QobGFzdENoaWxkLm5vZGUudGV4dCkpKSB7XG4gICAgICAgICAgICAvLyBBdm9pZCBidWdzIGluIFNhZmFyaSdzIGN1cnNvciBkcmF3aW5nICgjMTE2NSkgYW5kIENocm9tZSdzIG1vdXNlIHNlbGVjdGlvbiAoIzExNTIpXG4gICAgICAgICAgICBpZiAoKHNhZmFyaSB8fCBjaHJvbWUpICYmIGxhc3RDaGlsZCAmJiBsYXN0Q2hpbGQuZG9tLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRIYWNrTm9kZShcIklNR1wiLCBwYXJlbnQpO1xuICAgICAgICAgICAgdGhpcy5hZGRIYWNrTm9kZShcIkJSXCIsIHRoaXMudG9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRIYWNrTm9kZShub2RlTmFtZSwgcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy50b3AgJiYgdGhpcy5pbmRleCA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGggJiYgcGFyZW50LmNoaWxkcmVuW3RoaXMuaW5kZXhdLm1hdGNoZXNIYWNrKG5vZGVOYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09IFwiSU1HXCIpIHtcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIjtcbiAgICAgICAgICAgICAgICBkb20uYWx0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PSBcIkJSXCIpXG4gICAgICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3ItdHJhaWxpbmdCcmVha1wiO1xuICAgICAgICAgICAgbGV0IGhhY2sgPSBuZXcgVHJhaWxpbmdIYWNrVmlld0Rlc2ModGhpcy50b3AsIFtdLCBkb20sIG51bGwpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCAhPSB0aGlzLnRvcClcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChoYWNrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgaGFjayk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzTG9ja2VkKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jayAmJiAobm9kZSA9PSB0aGlzLmxvY2sgfHwgbm9kZS5ub2RlVHlwZSA9PSAxICYmIG5vZGUuY29udGFpbnModGhpcy5sb2NrLnBhcmVudE5vZGUpKTtcbiAgICB9XG59XG4vLyBJdGVyYXRlIGZyb20gdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnQgYW5kIGFycmF5IG9mIGRlc2NzIHRvIGZpbmRcbi8vIGRpcmVjdGx5IG1hdGNoaW5nIG9uZXMsIGluIG9yZGVyIHRvIGF2b2lkIG92ZXJlYWdlcmx5IHJldXNpbmcgdGhvc2Vcbi8vIGZvciBvdGhlciBub2Rlcy4gUmV0dXJucyB0aGUgZnJhZ21lbnQgaW5kZXggb2YgdGhlIGZpcnN0IG5vZGUgdGhhdFxuLy8gaXMgcGFydCBvZiB0aGUgc2VxdWVuY2Ugb2YgbWF0Y2hlZCBub2RlcyBhdCB0aGUgZW5kIG9mIHRoZVxuLy8gZnJhZ21lbnQuXG5mdW5jdGlvbiBwcmVNYXRjaChmcmFnLCBwYXJlbnREZXNjKSB7XG4gICAgbGV0IGN1ckRlc2MgPSBwYXJlbnREZXNjLCBkZXNjSSA9IGN1ckRlc2MuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGxldCBmSSA9IGZyYWcuY2hpbGRDb3VudCwgbWF0Y2hlZCA9IG5ldyBNYXAsIG1hdGNoZXMgPSBbXTtcbiAgICBvdXRlcjogd2hpbGUgKGZJID4gMCkge1xuICAgICAgICBsZXQgZGVzYztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKGRlc2NJKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjdXJEZXNjLmNoaWxkcmVuW2Rlc2NJIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBNYXJrVmlld0Rlc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyRGVzYyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NJID0gbmV4dC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZXNjID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZGVzY0ktLTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VyRGVzYyA9PSBwYXJlbnREZXNjKSB7XG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgIGRlc2NJID0gY3VyRGVzYy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihjdXJEZXNjKTtcbiAgICAgICAgICAgICAgICBjdXJEZXNjID0gY3VyRGVzYy5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGUgPSBkZXNjLm5vZGU7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAobm9kZSAhPSBmcmFnLmNoaWxkKGZJIC0gMSkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLS1mSTtcbiAgICAgICAgbWF0Y2hlZC5zZXQoZGVzYywgZkkpO1xuICAgICAgICBtYXRjaGVzLnB1c2goZGVzYyk7XG4gICAgfVxuICAgIHJldHVybiB7IGluZGV4OiBmSSwgbWF0Y2hlZCwgbWF0Y2hlczogbWF0Y2hlcy5yZXZlcnNlKCkgfTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVTaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gYS50eXBlLnNpZGUgLSBiLnR5cGUuc2lkZTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gYWJzdHJhY3RzIGl0ZXJhdGluZyBvdmVyIHRoZSBub2RlcyBhbmQgZGVjb3JhdGlvbnMgaW5cbi8vIGEgZnJhZ21lbnQuIENhbGxzIGBvbk5vZGVgIGZvciBlYWNoIG5vZGUsIHdpdGggaXRzIGxvY2FsIGFuZCBjaGlsZFxuLy8gZGVjb3JhdGlvbnMuIFNwbGl0cyB0ZXh0IG5vZGVzIHdoZW4gdGhlcmUgaXMgYSBkZWNvcmF0aW9uIHN0YXJ0aW5nXG4vLyBvciBlbmRpbmcgaW5zaWRlIG9mIHRoZW0uIENhbGxzIGBvbldpZGdldGAgZm9yIGVhY2ggd2lkZ2V0LlxuZnVuY3Rpb24gaXRlckRlY28ocGFyZW50LCBkZWNvLCBvbldpZGdldCwgb25Ob2RlKSB7XG4gICAgbGV0IGxvY2FscyA9IGRlY28ubG9jYWxzKHBhcmVudCksIG9mZnNldCA9IDA7XG4gICAgLy8gU2ltcGxlLCBjaGVhcCB2YXJpYW50IGZvciB3aGVuIHRoZXJlIGFyZSBubyBsb2NhbCBkZWNvcmF0aW9uc1xuICAgIGlmIChsb2NhbHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQuY2hpbGQoaSk7XG4gICAgICAgICAgICBvbk5vZGUoY2hpbGQsIGxvY2FscywgZGVjby5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKSwgaSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZGVjb0luZGV4ID0gMCwgYWN0aXZlID0gW10sIHJlc3ROb2RlID0gbnVsbDtcbiAgICBmb3IgKGxldCBwYXJlbnRJbmRleCA9IDA7Oykge1xuICAgICAgICBsZXQgd2lkZ2V0LCB3aWRnZXRzO1xuICAgICAgICB3aGlsZSAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS50byA9PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbG9jYWxzW2RlY29JbmRleCsrXTtcbiAgICAgICAgICAgIGlmIChuZXh0LndpZGdldCkge1xuICAgICAgICAgICAgICAgIGlmICghd2lkZ2V0KVxuICAgICAgICAgICAgICAgICAgICB3aWRnZXQgPSBuZXh0O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgKHdpZGdldHMgfHwgKHdpZGdldHMgPSBbd2lkZ2V0XSkpLnB1c2gobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZGdldCkge1xuICAgICAgICAgICAgaWYgKHdpZGdldHMpIHtcbiAgICAgICAgICAgICAgICB3aWRnZXRzLnNvcnQoY29tcGFyZVNpZGUpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkZ2V0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgb25XaWRnZXQod2lkZ2V0c1tpXSwgcGFyZW50SW5kZXgsICEhcmVzdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb25XaWRnZXQod2lkZ2V0LCBwYXJlbnRJbmRleCwgISFyZXN0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoaWxkLCBpbmRleDtcbiAgICAgICAgaWYgKHJlc3ROb2RlKSB7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY2hpbGQgPSByZXN0Tm9kZTtcbiAgICAgICAgICAgIHJlc3ROb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJlbnRJbmRleCA8IHBhcmVudC5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgICAgICAgICAgY2hpbGQgPSBwYXJlbnQuY2hpbGQocGFyZW50SW5kZXgrKyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChhY3RpdmVbaV0udG8gPD0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgIGFjdGl2ZS5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgd2hpbGUgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0uZnJvbSA8PSBvZmZzZXQgJiYgbG9jYWxzW2RlY29JbmRleF0udG8gPiBvZmZzZXQpXG4gICAgICAgICAgICBhY3RpdmUucHVzaChsb2NhbHNbZGVjb0luZGV4KytdKTtcbiAgICAgICAgbGV0IGVuZCA9IG9mZnNldCArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBpZiAoY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgICAgICBsZXQgY3V0QXQgPSBlbmQ7XG4gICAgICAgICAgICBpZiAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS5mcm9tIDwgY3V0QXQpXG4gICAgICAgICAgICAgICAgY3V0QXQgPSBsb2NhbHNbZGVjb0luZGV4XS5mcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVtpXS50byA8IGN1dEF0KVxuICAgICAgICAgICAgICAgICAgICBjdXRBdCA9IGFjdGl2ZVtpXS50bztcbiAgICAgICAgICAgIGlmIChjdXRBdCA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHJlc3ROb2RlID0gY2hpbGQuY3V0KGN1dEF0IC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmN1dCgwLCBjdXRBdCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgZW5kID0gY3V0QXQ7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvIDwgZW5kKVxuICAgICAgICAgICAgICAgIGRlY29JbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdXRlckRlY28gPSBjaGlsZC5pc0lubGluZSAmJiAhY2hpbGQuaXNMZWFmID8gYWN0aXZlLmZpbHRlcihkID0+ICFkLmlubGluZSkgOiBhY3RpdmUuc2xpY2UoKTtcbiAgICAgICAgb25Ob2RlKGNoaWxkLCBvdXRlckRlY28sIGRlY28uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCksIGluZGV4KTtcbiAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgIH1cbn1cbi8vIExpc3QgbWFya2VycyBpbiBNb2JpbGUgU2FmYXJpIHdpbGwgbXlzdGVyaW91c2x5IGRpc2FwcGVhclxuLy8gc29tZXRpbWVzLiBUaGlzIHdvcmtzIGFyb3VuZCB0aGF0LlxuZnVuY3Rpb24gaW9zSGFja3MoZG9tKSB7XG4gICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIlVMXCIgfHwgZG9tLm5vZGVOYW1lID09IFwiT0xcIikge1xuICAgICAgICBsZXQgb2xkQ1NTID0gZG9tLnN0eWxlLmNzc1RleHQ7XG4gICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTICsgXCI7IGxpc3Qtc3R5bGU6IHNxdWFyZSAhaW1wb3J0YW50XCI7XG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbSkubGlzdFN0eWxlO1xuICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IG9sZENTUztcbiAgICB9XG59XG5mdW5jdGlvbiBuZWFyYnlUZXh0Tm9kZShub2RlLCBvZmZzZXQpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IG9mZnNldCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBvZmZzZXQgPSBub2RlU2l6ZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gRmluZCBhIHBpZWNlIG9mIHRleHQgaW4gYW4gaW5saW5lIGZyYWdtZW50LCBvdmVybGFwcGluZyBmcm9tLXRvXG5mdW5jdGlvbiBmaW5kVGV4dEluRnJhZ21lbnQoZnJhZywgdGV4dCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IGZyYWcuY2hpbGRDb3VudCAmJiBwb3MgPD0gdG87KSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGZyYWcuY2hpbGQoaSsrKSwgY2hpbGRTdGFydCA9IHBvcztcbiAgICAgICAgcG9zICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBpZiAoIWNoaWxkLmlzVGV4dClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgc3RyID0gY2hpbGQudGV4dDtcbiAgICAgICAgd2hpbGUgKGkgPCBmcmFnLmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZnJhZy5jaGlsZChpKyspO1xuICAgICAgICAgICAgcG9zICs9IG5leHQubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoIW5leHQuaXNUZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RyICs9IG5leHQudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IGZyb20pIHtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdG8gJiYgc3RyLnNsaWNlKHRvIC0gdGV4dC5sZW5ndGggLSBjaGlsZFN0YXJ0LCB0byAtIGNoaWxkU3RhcnQpID09IHRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvIC0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBjaGlsZFN0YXJ0IDwgdG8gPyBzdHIubGFzdEluZGV4T2YodGV4dCwgdG8gLSBjaGlsZFN0YXJ0IC0gMSkgOiAtMTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA+PSAwICYmIGZvdW5kICsgdGV4dC5sZW5ndGggKyBjaGlsZFN0YXJ0ID49IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkU3RhcnQgKyBmb3VuZDtcbiAgICAgICAgICAgIGlmIChmcm9tID09IHRvICYmIHN0ci5sZW5ndGggPj0gKHRvICsgdGV4dC5sZW5ndGgpIC0gY2hpbGRTdGFydCAmJlxuICAgICAgICAgICAgICAgIHN0ci5zbGljZSh0byAtIGNoaWxkU3RhcnQsIHRvIC0gY2hpbGRTdGFydCArIHRleHQubGVuZ3RoKSA9PSB0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0bztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4vLyBSZXBsYWNlIHJhbmdlIGZyb20tdG8gaW4gYW4gYXJyYXkgb2YgdmlldyBkZXNjcyB3aXRoIHJlcGxhY2VtZW50XG4vLyAobWF5IGJlIG51bGwgdG8ganVzdCBkZWxldGUpLiBUaGlzIGdvZXMgdmVyeSBtdWNoIGFnYWluc3QgdGhlIGdyYWluXG4vLyBvZiB0aGUgcmVzdCBvZiB0aGlzIGNvZGUsIHdoaWNoIHRlbmRzIHRvIGNyZWF0ZSBub2RlcyB3aXRoIHRoZVxuLy8gcmlnaHQgc2hhcGUgaW4gb25lIGdvLCByYXRoZXIgdGhhbiBtZXNzaW5nIHdpdGggdGhlbSBhZnRlclxuLy8gY3JlYXRpb24sIGJ1dCBpcyBuZWNlc3NhcnkgaW4gdGhlIGNvbXBvc2l0aW9uIGhhY2suXG5mdW5jdGlvbiByZXBsYWNlTm9kZXMobm9kZXMsIGZyb20sIHRvLCB2aWV3LCByZXBsYWNlbWVudCkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IG5vZGVzW2ldLCBzdGFydCA9IG9mZiwgZW5kID0gb2ZmICs9IGNoaWxkLnNpemU7XG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZC5zbGljZSgwLCBmcm9tIC0gc3RhcnQsIHZpZXcpKTtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlcGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZC5zbGljZSh0byAtIHN0YXJ0LCBjaGlsZC5zaXplLCB2aWV3KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uRnJvbURPTSh2aWV3LCBvcmlnaW4gPSBudWxsKSB7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKSwgZG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgaWYgKCFkb21TZWwuZm9jdXNOb2RlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbmVhcmVzdERlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZG9tU2VsLmZvY3VzTm9kZSksIGluV2lkZ2V0ID0gbmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2Muc2l6ZSA9PSAwO1xuICAgIGxldCBoZWFkID0gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCAxKTtcbiAgICBpZiAoaGVhZCA8IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCAkaGVhZCA9IGRvYy5yZXNvbHZlKGhlYWQpLCAkYW5jaG9yLCBzZWxlY3Rpb247XG4gICAgaWYgKHNlbGVjdGlvbkNvbGxhcHNlZChkb21TZWwpKSB7XG4gICAgICAgICRhbmNob3IgPSAkaGVhZDtcbiAgICAgICAgd2hpbGUgKG5lYXJlc3REZXNjICYmICFuZWFyZXN0RGVzYy5ub2RlKVxuICAgICAgICAgICAgbmVhcmVzdERlc2MgPSBuZWFyZXN0RGVzYy5wYXJlbnQ7XG4gICAgICAgIGxldCBuZWFyZXN0RGVzY05vZGUgPSBuZWFyZXN0RGVzYy5ub2RlO1xuICAgICAgICBpZiAobmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2NOb2RlLmlzQXRvbSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShuZWFyZXN0RGVzY05vZGUpICYmIG5lYXJlc3REZXNjLnBhcmVudFxuICAgICAgICAgICAgJiYgIShuZWFyZXN0RGVzY05vZGUuaXNJbmxpbmUgJiYgaXNPbkVkZ2UoZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCBuZWFyZXN0RGVzYy5kb20pKSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IG5lYXJlc3REZXNjLnBvc0JlZm9yZTtcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IG5ldyBOb2RlU2VsZWN0aW9uKGhlYWQgPT0gcG9zID8gJGhlYWQgOiBkb2MucmVzb2x2ZShwb3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGFuY2hvciA9IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0LCAxKTtcbiAgICAgICAgaWYgKGFuY2hvciA8IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgJGFuY2hvciA9IGRvYy5yZXNvbHZlKGFuY2hvcik7XG4gICAgfVxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBiaWFzID0gb3JpZ2luID09IFwicG9pbnRlclwiIHx8ICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5oZWFkIDwgJGhlYWQucG9zICYmICFpbldpZGdldCkgPyAxIDogLTE7XG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbkJldHdlZW4odmlldywgJGFuY2hvciwgJGhlYWQsIGJpYXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSB7XG4gICAgcmV0dXJuIHZpZXcuZWRpdGFibGUgPyB2aWV3Lmhhc0ZvY3VzKCkgOlxuICAgICAgICBoYXNTZWxlY3Rpb24odmlldykgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNvbnRhaW5zKHZpZXcuZG9tKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvblRvRE9NKHZpZXcsIGZvcmNlID0gZmFsc2UpIHtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgc3luY05vZGVTZWxlY3Rpb24odmlldywgc2VsKTtcbiAgICBpZiAoIWVkaXRvck93bnNTZWxlY3Rpb24odmlldykpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBUaGUgZGVsYXllZCBkcmFnIHNlbGVjdGlvbiBjYXVzZXMgaXNzdWVzIHdpdGggQ2VsbCBTZWxlY3Rpb25zXG4gICAgLy8gaW4gU2FmYXJpLiBBbmQgdGhlIGRyYWcgc2VsZWN0aW9uIGRlbGF5IGlzIHRvIHdvcmthcm9uZCBpc3N1ZXNcbiAgICAvLyB3aGljaCBvbmx5IHByZXNlbnQgaW4gQ2hyb21lLlxuICAgIGlmICghZm9yY2UgJiYgdmlldy5pbnB1dC5tb3VzZURvd24gJiYgdmlldy5pbnB1dC5tb3VzZURvd24uYWxsb3dEZWZhdWx0ICYmIGNocm9tZSkge1xuICAgICAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpLCBjdXJTZWwgPSB2aWV3LmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgIGlmIChkb21TZWwuYW5jaG9yTm9kZSAmJiBjdXJTZWwuYW5jaG9yTm9kZSAmJlxuICAgICAgICAgICAgaXNFcXVpdmFsZW50UG9zaXRpb24oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQsIGN1clNlbC5hbmNob3JOb2RlLCBjdXJTZWwuYW5jaG9yT2Zmc2V0KSkge1xuICAgICAgICAgICAgdmlldy5pbnB1dC5tb3VzZURvd24uZGVsYXllZFNlbGVjdGlvblN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aWV3LmRvbU9ic2VydmVyLmRpc2Nvbm5lY3RTZWxlY3Rpb24oKTtcbiAgICBpZiAodmlldy5jdXJzb3JXcmFwcGVyKSB7XG4gICAgICAgIHNlbGVjdEN1cnNvcldyYXBwZXIodmlldyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgeyBhbmNob3IsIGhlYWQgfSA9IHNlbCwgcmVzZXRFZGl0YWJsZUZyb20sIHJlc2V0RWRpdGFibGVUbztcbiAgICAgICAgaWYgKGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlICYmICEoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmICghc2VsLiRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGVGcm9tID0gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgc2VsLmZyb20pO1xuICAgICAgICAgICAgaWYgKCFzZWwuZW1wdHkgJiYgIXNlbC4kZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgICAgICByZXNldEVkaXRhYmxlVG8gPSB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBzZWwudG8pO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcuZG9jVmlldy5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCB2aWV3LnJvb3QsIGZvcmNlKTtcbiAgICAgICAgaWYgKGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlKSB7XG4gICAgICAgICAgICBpZiAocmVzZXRFZGl0YWJsZUZyb20pXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZShyZXNldEVkaXRhYmxlRnJvbSk7XG4gICAgICAgICAgICBpZiAocmVzZXRFZGl0YWJsZVRvKVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGUocmVzZXRFZGl0YWJsZVRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsLnZpc2libGUpIHtcbiAgICAgICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICAgICAgICBpZiAoXCJvbnNlbGVjdGlvbmNoYW5nZVwiIGluIGRvY3VtZW50KVxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzT25TZWxlY3Rpb25DaGFuZ2Uodmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICB2aWV3LmRvbU9ic2VydmVyLmNvbm5lY3RTZWxlY3Rpb24oKTtcbn1cbi8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBXZWJraXQgbm90IGFsbG93aW5nIGEgc2VsZWN0aW9uIHRvIHN0YXJ0L2VuZFxuLy8gYmV0d2VlbiBub24tZWRpdGFibGUgYmxvY2sgbm9kZXMuIFdlIGJyaWVmbHkgbWFrZSBzb21ldGhpbmdcbi8vIGVkaXRhYmxlLCBzZXQgdGhlIHNlbGVjdGlvbiwgdGhlbiBzZXQgaXQgdW5lZGl0YWJsZSBhZ2Fpbi5cbmNvbnN0IGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlID0gc2FmYXJpIHx8IGNocm9tZSAmJiBjaHJvbWVfdmVyc2lvbiA8IDYzO1xuZnVuY3Rpb24gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgcG9zKSB7XG4gICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcyhwb3MsIDApO1xuICAgIGxldCBhZnRlciA9IG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPyBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSA6IG51bGw7XG4gICAgbGV0IGJlZm9yZSA9IG9mZnNldCA/IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXSA6IG51bGw7XG4gICAgaWYgKHNhZmFyaSAmJiBhZnRlciAmJiBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYWZ0ZXIpO1xuICAgIGlmICgoIWFmdGVyIHx8IGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpICYmXG4gICAgICAgICghYmVmb3JlIHx8IGJlZm9yZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSkge1xuICAgICAgICBpZiAoYWZ0ZXIpXG4gICAgICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYWZ0ZXIpO1xuICAgICAgICBlbHNlIGlmIChiZWZvcmUpXG4gICAgICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYmVmb3JlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRFZGl0YWJsZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPSBcInRydWVcIjtcbiAgICBpZiAoc2FmYXJpICYmIGVsZW1lbnQuZHJhZ2dhYmxlKSB7XG4gICAgICAgIGVsZW1lbnQuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIGVsZW1lbnQud2FzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiByZXNldEVkaXRhYmxlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICBpZiAoZWxlbWVudC53YXNEcmFnZ2FibGUpIHtcbiAgICAgICAgZWxlbWVudC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICBlbGVtZW50Lndhc0RyYWdnYWJsZSA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NPblNlbGVjdGlvbkNoYW5nZSh2aWV3KSB7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5pbnB1dC5oaWRlU2VsZWN0aW9uR3VhcmQpO1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSBkb21TZWwuYW5jaG9yTm9kZSwgb2Zmc2V0ID0gZG9tU2VsLmFuY2hvck9mZnNldDtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB2aWV3LmlucHV0LmhpZGVTZWxlY3Rpb25HdWFyZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGRvbVNlbC5hbmNob3JOb2RlICE9IG5vZGUgfHwgZG9tU2VsLmFuY2hvck9mZnNldCAhPSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaW5wdXQuaGlkZVNlbGVjdGlvbkd1YXJkKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi52aXNpYmxlKVxuICAgICAgICAgICAgICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICAgICAgICAgIH0sIDIwKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KSB7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCksIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IHZpZXcuY3Vyc29yV3JhcHBlci5kb20sIGltZyA9IG5vZGUubm9kZU5hbWUgPT0gXCJJTUdcIjtcbiAgICBpZiAoaW1nKVxuICAgICAgICByYW5nZS5zZXRFbmQobm9kZS5wYXJlbnROb2RlLCBkb21JbmRleChub2RlKSArIDEpO1xuICAgIGVsc2VcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIDApO1xuICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICBkb21TZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgZG9tU2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAvLyBLbHVkZ2UgdG8ga2lsbCAnY29udHJvbCBzZWxlY3Rpb24nIGluIElFMTEgd2hlbiBzZWxlY3RpbmcgYW5cbiAgICAvLyBpbnZpc2libGUgY3Vyc29yIHdyYXBwZXIsIHNpbmNlIHRoYXQgd291bGQgcmVzdWx0IGluIHRob3NlIHdlaXJkXG4gICAgLy8gcmVzaXplIGhhbmRsZXMgYW5kIGEgc2VsZWN0aW9uIHRoYXQgY29uc2lkZXJzIHRoZSBhYnNvbHV0ZWx5XG4gICAgLy8gcG9zaXRpb25lZCB3cmFwcGVyLCByYXRoZXIgdGhhbiB0aGUgcm9vdCBlZGl0YWJsZSBub2RlLCB0aGVcbiAgICAvLyBmb2N1c2VkIGVsZW1lbnQuXG4gICAgaWYgKCFpbWcgJiYgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLnZpc2libGUgJiYgaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSkge1xuICAgICAgICBub2RlLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN5bmNOb2RlU2VsZWN0aW9uKHZpZXcsIHNlbCkge1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3LmRlc2NBdChzZWwuZnJvbSk7XG4gICAgICAgIGlmIChkZXNjICE9IHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MpIHtcbiAgICAgICAgICAgIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KTtcbiAgICAgICAgICAgIGlmIChkZXNjKVxuICAgICAgICAgICAgICAgIGRlc2Muc2VsZWN0Tm9kZSgpO1xuICAgICAgICAgICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IGRlc2M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KTtcbiAgICB9XG59XG4vLyBDbGVhciBhbGwgRE9NIHN0YXRlZnVsbmVzcyBvZiB0aGUgbGFzdCBub2RlIHNlbGVjdGlvbi5cbmZ1bmN0aW9uIGNsZWFyTm9kZVNlbGVjdGlvbih2aWV3KSB7XG4gICAgaWYgKHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MpIHtcbiAgICAgICAgaWYgKHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MucGFyZW50KVxuICAgICAgICAgICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYy5kZXNlbGVjdE5vZGUoKTtcbiAgICAgICAgdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsICRhbmNob3IsICRoZWFkLCBiaWFzKSB7XG4gICAgcmV0dXJuIHZpZXcuc29tZVByb3AoXCJjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuXCIsIGYgPT4gZih2aWV3LCAkYW5jaG9yLCAkaGVhZCkpXG4gICAgICAgIHx8IFRleHRTZWxlY3Rpb24uYmV0d2VlbigkYW5jaG9yLCAkaGVhZCwgYmlhcyk7XG59XG5mdW5jdGlvbiBoYXNGb2N1c0FuZFNlbGVjdGlvbih2aWV3KSB7XG4gICAgaWYgKHZpZXcuZWRpdGFibGUgJiYgIXZpZXcuaGFzRm9jdXMoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBoYXNTZWxlY3Rpb24odmlldyk7XG59XG5mdW5jdGlvbiBoYXNTZWxlY3Rpb24odmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgaWYgKCFzZWwuYW5jaG9yTm9kZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEZpcmVmb3ggd2lsbCByYWlzZSAncGVybWlzc2lvbiBkZW5pZWQnIGVycm9ycyB3aGVuIGFjY2Vzc2luZ1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIG9mIGBzZWwuYW5jaG9yTm9kZWAgd2hlbiBpdCdzIGluIGEgZ2VuZXJhdGVkIENTU1xuICAgICAgICAvLyBlbGVtZW50LlxuICAgICAgICByZXR1cm4gdmlldy5kb20uY29udGFpbnMoc2VsLmFuY2hvck5vZGUubm9kZVR5cGUgPT0gMyA/IHNlbC5hbmNob3JOb2RlLnBhcmVudE5vZGUgOiBzZWwuYW5jaG9yTm9kZSkgJiZcbiAgICAgICAgICAgICh2aWV3LmVkaXRhYmxlIHx8IHZpZXcuZG9tLmNvbnRhaW5zKHNlbC5mb2N1c05vZGUubm9kZVR5cGUgPT0gMyA/IHNlbC5mb2N1c05vZGUucGFyZW50Tm9kZSA6IHNlbC5mb2N1c05vZGUpKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFuY2hvckluUmlnaHRQbGFjZSh2aWV3KSB7XG4gICAgbGV0IGFuY2hvckRPTSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciwgMCk7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICByZXR1cm4gaXNFcXVpdmFsZW50UG9zaXRpb24oYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQsIGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbn1cblxuZnVuY3Rpb24gbW92ZVNlbGVjdGlvbkJsb2NrKHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgeyAkYW5jaG9yLCAkaGVhZCB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCAkc2lkZSA9IGRpciA+IDAgPyAkYW5jaG9yLm1heCgkaGVhZCkgOiAkYW5jaG9yLm1pbigkaGVhZCk7XG4gICAgbGV0ICRzdGFydCA9ICEkc2lkZS5wYXJlbnQuaW5saW5lQ29udGVudCA/ICRzaWRlIDogJHNpZGUuZGVwdGggPyBzdGF0ZS5kb2MucmVzb2x2ZShkaXIgPiAwID8gJHNpZGUuYWZ0ZXIoKSA6ICRzaWRlLmJlZm9yZSgpKSA6IG51bGw7XG4gICAgcmV0dXJuICRzdGFydCAmJiBTZWxlY3Rpb24uZmluZEZyb20oJHN0YXJ0LCBkaXIpO1xufVxuZnVuY3Rpb24gYXBwbHkodmlldywgc2VsKSB7XG4gICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2VsZWN0SG9yaXpvbnRhbGx5KHZpZXcsIGRpciwgbW9kcykge1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikge1xuICAgICAgICBpZiAobW9kcy5pbmRleE9mKFwic1wiKSA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgeyAkaGVhZCB9ID0gc2VsLCBub2RlID0gJGhlYWQudGV4dE9mZnNldCA/IG51bGwgOiBkaXIgPCAwID8gJGhlYWQubm9kZUJlZm9yZSA6ICRoZWFkLm5vZGVBZnRlcjtcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCBub2RlLmlzVGV4dCB8fCAhbm9kZS5pc0xlYWYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0ICRuZXdIZWFkID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgkaGVhZC5wb3MgKyBub2RlLm5vZGVTaXplICogKGRpciA8IDAgPyAtMSA6IDEpKTtcbiAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgVGV4dFNlbGVjdGlvbihzZWwuJGFuY2hvciwgJG5ld0hlYWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghc2VsLmVtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmlldy5lbmRPZlRleHRibG9jayhkaXIgPiAwID8gXCJmb3J3YXJkXCIgOiBcImJhY2t3YXJkXCIpKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuICAgICAgICAgICAgaWYgKG5leHQgJiYgKG5leHQgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShtYWMgJiYgbW9kcy5pbmRleE9mKFwibVwiKSA+IC0xKSkge1xuICAgICAgICAgICAgbGV0ICRoZWFkID0gc2VsLiRoZWFkLCBub2RlID0gJGhlYWQudGV4dE9mZnNldCA/IG51bGwgOiBkaXIgPCAwID8gJGhlYWQubm9kZUJlZm9yZSA6ICRoZWFkLm5vZGVBZnRlciwgZGVzYztcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCBub2RlLmlzVGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbm9kZVBvcyA9IGRpciA8IDAgPyAkaGVhZC5wb3MgLSBub2RlLm5vZGVTaXplIDogJGhlYWQucG9zO1xuICAgICAgICAgICAgaWYgKCEobm9kZS5pc0F0b20gfHwgKGRlc2MgPSB2aWV3LmRvY1ZpZXcuZGVzY0F0KG5vZGVQb3MpKSAmJiAhZGVzYy5jb250ZW50RE9NKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IE5vZGVTZWxlY3Rpb24oZGlyIDwgMCA/IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoJGhlYWQucG9zIC0gbm9kZS5ub2RlU2l6ZSkgOiAkaGVhZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod2Via2l0KSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIGFuZCBTYWZhcmkgd2lsbCBpbnRyb2R1Y2UgZXh0cmEgcG9pbnRsZXNzIGN1cnNvclxuICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9ucyBhcm91bmQgaW5saW5lIHVuZWRpdGFibGUgbm9kZXMsIHNvIHdlIGhhdmUgdG9cbiAgICAgICAgICAgICAgICAvLyB0YWtlIG92ZXIgYW5kIG1vdmUgdGhlIGN1cnNvciBwYXN0IHRoZW0gKCM5MzcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBUZXh0U2VsZWN0aW9uKHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZGlyIDwgMCA/IG5vZGVQb3MgOiBub2RlUG9zICsgbm9kZS5ub2RlU2l6ZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbC5ub2RlLmlzSW5saW5lKSB7XG4gICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgVGV4dFNlbGVjdGlvbihkaXIgPiAwID8gc2VsLiR0byA6IHNlbC4kZnJvbSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IG5leHQgPSBtb3ZlU2VsZWN0aW9uQmxvY2sodmlldy5zdGF0ZSwgZGlyKTtcbiAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV4dCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBub2RlTGVuKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGlzSWdub3JhYmxlKGRvbSwgZGlyKSB7XG4gICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICByZXR1cm4gZGVzYyAmJiBkZXNjLnNpemUgPT0gMCAmJiAoZGlyIDwgMCB8fCBkb20ubmV4dFNpYmxpbmcgfHwgZG9tLm5vZGVOYW1lICE9IFwiQlJcIik7XG59XG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzKHZpZXcsIGRpcikge1xuICAgIHJldHVybiBkaXIgPCAwID8gc2tpcElnbm9yZWROb2Rlc0JlZm9yZSh2aWV3KSA6IHNraXBJZ25vcmVkTm9kZXNBZnRlcih2aWV3KTtcbn1cbi8vIE1ha2Ugc3VyZSB0aGUgY3Vyc29yIGlzbid0IGRpcmVjdGx5IGFmdGVyIG9uZSBvciBtb3JlIGlnbm9yZWRcbi8vIG5vZGVzLCB3aGljaCB3aWxsIGNvbmZ1c2UgdGhlIGJyb3dzZXIncyBjdXJzb3IgbW90aW9uIGxvZ2ljLlxuZnVuY3Rpb24gc2tpcElnbm9yZWROb2Rlc0JlZm9yZSh2aWV3KSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IHNlbC5mb2N1c05vZGUsIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbW92ZU5vZGUsIG1vdmVPZmZzZXQsIGZvcmNlID0gZmFsc2U7XG4gICAgLy8gR2Vja28gd2lsbCBkbyBvZGQgdGhpbmdzIHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBkaXJlY3RseSBpbiBmcm9udFxuICAgIC8vIG9mIGEgbm9uLWVkaXRhYmxlIG5vZGUsIHNvIGluIHRoYXQgY2FzZSwgbW92ZSBpdCBpbnRvIHRoZSBuZXh0XG4gICAgLy8gbm9kZSBpZiBwb3NzaWJsZS4gSXNzdWUgcHJvc2VtaXJyb3IvcHJvc2VtaXJyb3IjODMyLlxuICAgIGlmIChnZWNrbyAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZUxlbihub2RlKSAmJiBpc0lnbm9yYWJsZShub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSwgLTEpKVxuICAgICAgICBmb3JjZSA9IHRydWU7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNJZ25vcmFibGUoYmVmb3JlLCAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZU5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gLS1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJlZm9yZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBiZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Jsb2NrTm9kZShub2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgd2hpbGUgKHByZXYgJiYgaXNJZ25vcmFibGUocHJldiwgLTEpKSB7XG4gICAgICAgICAgICAgICAgbW92ZU5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9IGRvbUluZGV4KHByZXYpO1xuICAgICAgICAgICAgICAgIHByZXYgPSBwcmV2LnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJldikge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gdmlldy5kb20pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gcHJldjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBub2RlTGVuKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmb3JjZSlcbiAgICAgICAgc2V0U2VsRm9jdXModmlldywgbm9kZSwgb2Zmc2V0KTtcbiAgICBlbHNlIGlmIChtb3ZlTm9kZSlcbiAgICAgICAgc2V0U2VsRm9jdXModmlldywgbW92ZU5vZGUsIG1vdmVPZmZzZXQpO1xufVxuLy8gTWFrZSBzdXJlIHRoZSBjdXJzb3IgaXNuJ3QgZGlyZWN0bHkgYmVmb3JlIG9uZSBvciBtb3JlIGlnbm9yZWRcbi8vIG5vZGVzLlxuZnVuY3Rpb24gc2tpcElnbm9yZWROb2Rlc0FmdGVyKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGxldCBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBsZW4gPSBub2RlTGVuKG5vZGUpO1xuICAgIGxldCBtb3ZlTm9kZSwgbW92ZU9mZnNldDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChpc0lnbm9yYWJsZShhZnRlciwgMSkpIHtcbiAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9ICsrb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQmxvY2tOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICYmIGlzSWdub3JhYmxlKG5leHQsIDEpKSB7XG4gICAgICAgICAgICAgICAgbW92ZU5vZGUgPSBuZXh0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9IGRvbUluZGV4KG5leHQpICsgMTtcbiAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gdmlldy5kb20pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGxlbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIGxlbiA9IG5vZGVMZW4obm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1vdmVOb2RlKVxuICAgICAgICBzZXRTZWxGb2N1cyh2aWV3LCBtb3ZlTm9kZSwgbW92ZU9mZnNldCk7XG59XG5mdW5jdGlvbiBpc0Jsb2NrTm9kZShkb20pIHtcbiAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgIHJldHVybiBkZXNjICYmIGRlc2Mubm9kZSAmJiBkZXNjLm5vZGUuaXNCbG9jaztcbn1cbmZ1bmN0aW9uIHRleHROb2RlQWZ0ZXIobm9kZSwgb2Zmc2V0KSB7XG4gICAgd2hpbGUgKG5vZGUgJiYgb2Zmc2V0ID09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggJiYgIWhhc0Jsb2NrRGVzYyhub2RlKSkge1xuICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKSArIDE7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHdoaWxlIChub2RlICYmIG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IG5leHQgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PSAxICYmIG5leHQuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG59XG5mdW5jdGlvbiB0ZXh0Tm9kZUJlZm9yZShub2RlLCBvZmZzZXQpIHtcbiAgICB3aGlsZSAobm9kZSAmJiAhb2Zmc2V0ICYmICFoYXNCbG9ja0Rlc2Mobm9kZSkpIHtcbiAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHdoaWxlIChub2RlICYmIG9mZnNldCkge1xuICAgICAgICBsZXQgbmV4dCA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PSAxICYmIG5leHQuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgb2Zmc2V0ID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRTZWxGb2N1cyh2aWV3LCBub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAzKSB7XG4gICAgICAgIGxldCBiZWZvcmUsIGFmdGVyO1xuICAgICAgICBpZiAoYWZ0ZXIgPSB0ZXh0Tm9kZUFmdGVyKG5vZGUsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBhZnRlcjtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmVmb3JlID0gdGV4dE5vZGVCZWZvcmUobm9kZSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICAgIG9mZnNldCA9IGJlZm9yZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpO1xuICAgIGlmIChzZWxlY3Rpb25Db2xsYXBzZWQoc2VsKSkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWwuZXh0ZW5kKSB7XG4gICAgICAgIHNlbC5leHRlbmQobm9kZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldztcbiAgICAvLyBJZiBubyBzdGF0ZSB1cGRhdGUgZW5kcyB1cCBoYXBwZW5pbmcsIHJlc2V0IHRoZSBzZWxlY3Rpb24uXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3LnN0YXRlID09IHN0YXRlKVxuICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gZmluZERpcmVjdGlvbih2aWV3LCBwb3MpIHtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoIShjaHJvbWUgfHwgd2luZG93cykgJiYgJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICBsZXQgY29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgICAgICBpZiAocG9zID4gJHBvcy5zdGFydCgpKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gdmlldy5jb29yZHNBdFBvcyhwb3MgLSAxKTtcbiAgICAgICAgICAgIGxldCBtaWQgPSAoYmVmb3JlLnRvcCArIGJlZm9yZS5ib3R0b20pIC8gMjtcbiAgICAgICAgICAgIGlmIChtaWQgPiBjb29yZHMudG9wICYmIG1pZCA8IGNvb3Jkcy5ib3R0b20gJiYgTWF0aC5hYnMoYmVmb3JlLmxlZnQgLSBjb29yZHMubGVmdCkgPiAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBiZWZvcmUubGVmdCA8IGNvb3Jkcy5sZWZ0ID8gXCJsdHJcIiA6IFwicnRsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA8ICRwb3MuZW5kKCkpIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IHZpZXcuY29vcmRzQXRQb3MocG9zICsgMSk7XG4gICAgICAgICAgICBsZXQgbWlkID0gKGFmdGVyLnRvcCArIGFmdGVyLmJvdHRvbSkgLyAyO1xuICAgICAgICAgICAgaWYgKG1pZCA+IGNvb3Jkcy50b3AgJiYgbWlkIDwgY29vcmRzLmJvdHRvbSAmJiBNYXRoLmFicyhhZnRlci5sZWZ0IC0gY29vcmRzLmxlZnQpID4gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYWZ0ZXIubGVmdCA+IGNvb3Jkcy5sZWZ0ID8gXCJsdHJcIiA6IFwicnRsXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNvbXB1dGVkID0gZ2V0Q29tcHV0ZWRTdHlsZSh2aWV3LmRvbSkuZGlyZWN0aW9uO1xuICAgIHJldHVybiBjb21wdXRlZCA9PSBcInJ0bFwiID8gXCJydGxcIiA6IFwibHRyXCI7XG59XG4vLyBDaGVjayB3aGV0aGVyIHZlcnRpY2FsIHNlbGVjdGlvbiBtb3Rpb24gd291bGQgaW52b2x2ZSBub2RlXG4vLyBzZWxlY3Rpb25zLiBJZiBzbywgYXBwbHkgaXQgKGlmIG5vdCwgdGhlIHJlc3VsdCBpcyBsZWZ0IHRvIHRoZVxuLy8gYnJvd3NlcilcbmZ1bmN0aW9uIHNlbGVjdFZlcnRpY2FsbHkodmlldywgZGlyLCBtb2RzKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmICFzZWwuZW1wdHkgfHwgbW9kcy5pbmRleE9mKFwic1wiKSA+IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG1hYyAmJiBtb2RzLmluZGV4T2YoXCJtXCIpID4gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzZWw7XG4gICAgaWYgKCEkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCB8fCB2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA8IDAgPyBcInVwXCIgOiBcImRvd25cIikpIHtcbiAgICAgICAgbGV0IG5leHQgPSBtb3ZlU2VsZWN0aW9uQmxvY2sodmlldy5zdGF0ZSwgZGlyKTtcbiAgICAgICAgaWYgKG5leHQgJiYgKG5leHQgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICB9XG4gICAgaWYgKCEkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICBsZXQgc2lkZSA9IGRpciA8IDAgPyAkZnJvbSA6ICR0bztcbiAgICAgICAgbGV0IGJleW9uZCA9IHNlbCBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbiA/IFNlbGVjdGlvbi5uZWFyKHNpZGUsIGRpcikgOiBTZWxlY3Rpb24uZmluZEZyb20oc2lkZSwgZGlyKTtcbiAgICAgICAgcmV0dXJuIGJleW9uZCA/IGFwcGx5KHZpZXcsIGJleW9uZCkgOiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgZGlyKSB7XG4gICAgaWYgKCEodmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IHsgJGhlYWQsICRhbmNob3IsIGVtcHR5IH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAodmlldy5lbmRPZlRleHRibG9jayhkaXIgPiAwID8gXCJmb3J3YXJkXCIgOiBcImJhY2t3YXJkXCIpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgbmV4dE5vZGUgPSAhJGhlYWQudGV4dE9mZnNldCAmJiAoZGlyIDwgMCA/ICRoZWFkLm5vZGVCZWZvcmUgOiAkaGVhZC5ub2RlQWZ0ZXIpO1xuICAgIGlmIChuZXh0Tm9kZSAmJiAhbmV4dE5vZGUuaXNUZXh0KSB7XG4gICAgICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgdHIuZGVsZXRlKCRoZWFkLnBvcyAtIG5leHROb2RlLm5vZGVTaXplLCAkaGVhZC5wb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ci5kZWxldGUoJGhlYWQucG9zLCAkaGVhZC5wb3MgKyBuZXh0Tm9kZS5ub2RlU2l6ZSk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc3dpdGNoRWRpdGFibGUodmlldywgbm9kZSwgc3RhdGUpIHtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICBub2RlLmNvbnRlbnRFZGl0YWJsZSA9IHN0YXRlO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbn1cbi8vIElzc3VlICM4NjcgLyAjMTA5MCAvIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTkwMzgyMVxuLy8gSW4gd2hpY2ggU2FmYXJpIChhbmQgYXQgc29tZSBwb2ludCBpbiB0aGUgcGFzdCwgQ2hyb21lKSBkb2VzIHJlYWxseVxuLy8gd3JvbmcgdGhpbmdzIHdoZW4gdGhlIGRvd24gYXJyb3cgaXMgcHJlc3NlZCB3aGVuIHRoZSBjdXJzb3IgaXNcbi8vIGRpcmVjdGx5IGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jayBhbmQgaGFzIGFuIHVuZWRpdGFibGUgbm9kZVxuLy8gYWZ0ZXIgaXRcbmZ1bmN0aW9uIHNhZmFyaURvd25BcnJvd0J1Zyh2aWV3KSB7XG4gICAgaWYgKCFzYWZhcmkgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGhlYWQucGFyZW50T2Zmc2V0ID4gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfSA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBpZiAoZm9jdXNOb2RlICYmIGZvY3VzTm9kZS5ub2RlVHlwZSA9PSAxICYmIGZvY3VzT2Zmc2V0ID09IDAgJiZcbiAgICAgICAgZm9jdXNOb2RlLmZpcnN0Q2hpbGQgJiYgZm9jdXNOb2RlLmZpcnN0Q2hpbGQuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikge1xuICAgICAgICBsZXQgY2hpbGQgPSBmb2N1c05vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgc3dpdGNoRWRpdGFibGUodmlldywgY2hpbGQsIFwidHJ1ZVwiKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzd2l0Y2hFZGl0YWJsZSh2aWV3LCBjaGlsZCwgXCJmYWxzZVwiKSwgMjApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBBIGJhY2tkcm9wIGtleSBtYXBwaW5nIHVzZWQgdG8gbWFrZSBzdXJlIHdlIGFsd2F5cyBzdXBwcmVzcyBrZXlzXG4vLyB0aGF0IGhhdmUgYSBkYW5nZXJvdXMgZGVmYXVsdCBlZmZlY3QsIGV2ZW4gaWYgdGhlIGNvbW1hbmRzIHRoZXkgYXJlXG4vLyBib3VuZCB0byByZXR1cm4gZmFsc2UsIGFuZCB0byBtYWtlIHN1cmUgdGhhdCBjdXJzb3ItbW90aW9uIGtleXNcbi8vIGZpbmQgYSBjdXJzb3IgKGFzIG9wcG9zZWQgdG8gYSBub2RlIHNlbGVjdGlvbikgd2hlbiBwcmVzc2VkLiBGb3Jcbi8vIGN1cnNvci1tb3Rpb24ga2V5cywgdGhlIGNvZGUgaW4gdGhlIGhhbmRsZXJzIGFsc28gdGFrZXMgY2FyZSBvZlxuLy8gYmxvY2sgc2VsZWN0aW9ucy5cbmZ1bmN0aW9uIGdldE1vZHMoZXZlbnQpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBpZiAoZXZlbnQuY3RybEtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwiY1wiO1xuICAgIGlmIChldmVudC5tZXRhS2V5KVxuICAgICAgICByZXN1bHQgKz0gXCJtXCI7XG4gICAgaWYgKGV2ZW50LmFsdEtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwiYVwiO1xuICAgIGlmIChldmVudC5zaGlmdEtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwic1wiO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjYXB0dXJlS2V5RG93bih2aWV3LCBldmVudCkge1xuICAgIGxldCBjb2RlID0gZXZlbnQua2V5Q29kZSwgbW9kcyA9IGdldE1vZHMoZXZlbnQpO1xuICAgIGlmIChjb2RlID09IDggfHwgKG1hYyAmJiBjb2RlID09IDcyICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIEJhY2tzcGFjZSwgQ3RybC1oIG9uIE1hY1xuICAgICAgICByZXR1cm4gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgLTEpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgLTEpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoY29kZSA9PSA0NiAmJiAhZXZlbnQuc2hpZnRLZXkpIHx8IChtYWMgJiYgY29kZSA9PSA2OCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBEZWxldGUsIEN0cmwtZCBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIDEpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMTMgfHwgY29kZSA9PSAyNykgeyAvLyBFbnRlciwgRXNjXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDM3IHx8IChtYWMgJiYgY29kZSA9PSA2NiAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBMZWZ0IGFycm93LCBDdHJsLWIgb24gTWFjXG4gICAgICAgIGxldCBkaXIgPSBjb2RlID09IDM3ID8gKGZpbmREaXJlY3Rpb24odmlldywgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSkgPT0gXCJsdHJcIiA/IC0xIDogMSkgOiAtMTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCBkaXIsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgZGlyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAzOSB8fCAobWFjICYmIGNvZGUgPT0gNzAgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gUmlnaHQgYXJyb3csIEN0cmwtZiBvbiBNYWNcbiAgICAgICAgbGV0IGRpciA9IGNvZGUgPT0gMzkgPyAoZmluZERpcmVjdGlvbih2aWV3LCB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tKSA9PSBcImx0clwiID8gMSA6IC0xKSA6IDE7XG4gICAgICAgIHJldHVybiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIGRpcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMzggfHwgKG1hYyAmJiBjb2RlID09IDgwICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIFVwIGFycm93LCBDdHJsLXAgb24gTWFjXG4gICAgICAgIHJldHVybiBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIC0xLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIC0xKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSA0MCB8fCAobWFjICYmIGNvZGUgPT0gNzggJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gRG93biBhcnJvdywgQ3RybC1uIG9uIE1hY1xuICAgICAgICByZXR1cm4gc2FmYXJpRG93bkFycm93QnVnKHZpZXcpIHx8IHNlbGVjdFZlcnRpY2FsbHkodmlldywgMSwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCAxKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobW9kcyA9PSAobWFjID8gXCJtXCIgOiBcImNcIikgJiZcbiAgICAgICAgKGNvZGUgPT0gNjYgfHwgY29kZSA9PSA3MyB8fCBjb2RlID09IDg5IHx8IGNvZGUgPT0gOTApKSB7IC8vIE1vZC1bYml5el1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHZpZXcsIHNsaWNlKSB7XG4gICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybUNvcGllZFwiLCBmID0+IHsgc2xpY2UgPSBmKHNsaWNlLCB2aWV3KTsgfSk7XG4gICAgbGV0IGNvbnRleHQgPSBbXSwgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHNsaWNlO1xuICAgIHdoaWxlIChvcGVuU3RhcnQgPiAxICYmIG9wZW5FbmQgPiAxICYmIGNvbnRlbnQuY2hpbGRDb3VudCA9PSAxICYmIGNvbnRlbnQuZmlyc3RDaGlsZC5jaGlsZENvdW50ID09IDEpIHtcbiAgICAgICAgb3BlblN0YXJ0LS07XG4gICAgICAgIG9wZW5FbmQtLTtcbiAgICAgICAgbGV0IG5vZGUgPSBjb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGNvbnRleHQucHVzaChub2RlLnR5cGUubmFtZSwgbm9kZS5hdHRycyAhPSBub2RlLnR5cGUuZGVmYXVsdEF0dHJzID8gbm9kZS5hdHRycyA6IG51bGwpO1xuICAgICAgICBjb250ZW50ID0gbm9kZS5jb250ZW50O1xuICAgIH1cbiAgICBsZXQgc2VyaWFsaXplciA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRTZXJpYWxpemVyXCIpIHx8IERPTVNlcmlhbGl6ZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gICAgbGV0IGRvYyA9IGRldGFjaGVkRG9jKCksIHdyYXAgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB3cmFwLmFwcGVuZENoaWxkKHNlcmlhbGl6ZXIuc2VyaWFsaXplRnJhZ21lbnQoY29udGVudCwgeyBkb2N1bWVudDogZG9jIH0pKTtcbiAgICBsZXQgZmlyc3RDaGlsZCA9IHdyYXAuZmlyc3RDaGlsZCwgbmVlZHNXcmFwLCB3cmFwcGVycyA9IDA7XG4gICAgd2hpbGUgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAxICYmIChuZWVkc1dyYXAgPSB3cmFwTWFwW2ZpcnN0Q2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBuZWVkc1dyYXAubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB3cmFwcGVyID0gZG9jLmNyZWF0ZUVsZW1lbnQobmVlZHNXcmFwW2ldKTtcbiAgICAgICAgICAgIHdoaWxlICh3cmFwLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZCh3cmFwLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgICAgIHdyYXBwZXJzKys7XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3RDaGlsZCA9IHdyYXAuZmlyc3RDaGlsZDtcbiAgICB9XG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICBmaXJzdENoaWxkLnNldEF0dHJpYnV0ZShcImRhdGEtcG0tc2xpY2VcIiwgYCR7b3BlblN0YXJ0fSAke29wZW5FbmR9JHt3cmFwcGVycyA/IGAgLSR7d3JhcHBlcnN9YCA6IFwiXCJ9ICR7SlNPTi5zdHJpbmdpZnkoY29udGV4dCl9YCk7XG4gICAgbGV0IHRleHQgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXJcIiwgZiA9PiBmKHNsaWNlLCB2aWV3KSkgfHxcbiAgICAgICAgc2xpY2UuY29udGVudC50ZXh0QmV0d2VlbigwLCBzbGljZS5jb250ZW50LnNpemUsIFwiXFxuXFxuXCIpO1xuICAgIHJldHVybiB7IGRvbTogd3JhcCwgdGV4dCB9O1xufVxuLy8gUmVhZCBhIHNsaWNlIG9mIGNvbnRlbnQgZnJvbSB0aGUgY2xpcGJvYXJkIChvciBkcm9wIGRhdGEpLlxuZnVuY3Rpb24gcGFyc2VGcm9tQ2xpcGJvYXJkKHZpZXcsIHRleHQsIGh0bWwsIHBsYWluVGV4dCwgJGNvbnRleHQpIHtcbiAgICBsZXQgaW5Db2RlID0gJGNvbnRleHQucGFyZW50LnR5cGUuc3BlYy5jb2RlO1xuICAgIGxldCBkb20sIHNsaWNlO1xuICAgIGlmICghaHRtbCAmJiAhdGV4dClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGFzVGV4dCA9IHRleHQgJiYgKHBsYWluVGV4dCB8fCBpbkNvZGUgfHwgIWh0bWwpO1xuICAgIGlmIChhc1RleHQpIHtcbiAgICAgICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFRleHRcIiwgZiA9PiB7IHRleHQgPSBmKHRleHQsIGluQ29kZSB8fCBwbGFpblRleHQsIHZpZXcpOyB9KTtcbiAgICAgICAgaWYgKGluQ29kZSlcbiAgICAgICAgICAgIHJldHVybiB0ZXh0ID8gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odmlldy5zdGF0ZS5zY2hlbWEudGV4dCh0ZXh0LnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIikpKSwgMCwgMCkgOiBTbGljZS5lbXB0eTtcbiAgICAgICAgbGV0IHBhcnNlZCA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRUZXh0UGFyc2VyXCIsIGYgPT4gZih0ZXh0LCAkY29udGV4dCwgcGxhaW5UZXh0LCB2aWV3KSk7XG4gICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgIHNsaWNlID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1hcmtzID0gJGNvbnRleHQubWFya3MoKTtcbiAgICAgICAgICAgIGxldCB7IHNjaGVtYSB9ID0gdmlldy5zdGF0ZSwgc2VyaWFsaXplciA9IERPTVNlcmlhbGl6ZXIuZnJvbVNjaGVtYShzY2hlbWEpO1xuICAgICAgICAgICAgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRleHQuc3BsaXQoLyg/Olxcclxcbj98XFxuKSsvKS5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcCA9IGRvbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrKVxuICAgICAgICAgICAgICAgICAgICBwLmFwcGVuZENoaWxkKHNlcmlhbGl6ZXIuc2VyaWFsaXplTm9kZShzY2hlbWEudGV4dChibG9jaywgbWFya3MpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZEhUTUxcIiwgZiA9PiB7IGh0bWwgPSBmKGh0bWwsIHZpZXcpOyB9KTtcbiAgICAgICAgZG9tID0gcmVhZEhUTUwoaHRtbCk7XG4gICAgICAgIGlmICh3ZWJraXQpXG4gICAgICAgICAgICByZXN0b3JlUmVwbGFjZWRTcGFjZXMoZG9tKTtcbiAgICB9XG4gICAgbGV0IGNvbnRleHROb2RlID0gZG9tICYmIGRvbS5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtcG0tc2xpY2VdXCIpO1xuICAgIGxldCBzbGljZURhdGEgPSBjb250ZXh0Tm9kZSAmJiAvXihcXGQrKSAoXFxkKykoPzogLShcXGQrKSk/ICguKikvLmV4ZWMoY29udGV4dE5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1wbS1zbGljZVwiKSB8fCBcIlwiKTtcbiAgICBpZiAoc2xpY2VEYXRhICYmIHNsaWNlRGF0YVszXSlcbiAgICAgICAgZm9yIChsZXQgaSA9ICtzbGljZURhdGFbM107IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IGRvbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkb20gPSBjaGlsZDtcbiAgICAgICAgfVxuICAgIGlmICghc2xpY2UpIHtcbiAgICAgICAgbGV0IHBhcnNlciA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRQYXJzZXJcIikgfHwgdmlldy5zb21lUHJvcChcImRvbVBhcnNlclwiKSB8fCBET01QYXJzZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gICAgICAgIHNsaWNlID0gcGFyc2VyLnBhcnNlU2xpY2UoZG9tLCB7XG4gICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICEhKGFzVGV4dCB8fCBzbGljZURhdGEpLFxuICAgICAgICAgICAgY29udGV4dDogJGNvbnRleHQsXG4gICAgICAgICAgICBydWxlRnJvbU5vZGUoZG9tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgIWRvbS5uZXh0U2libGluZyAmJlxuICAgICAgICAgICAgICAgICAgICBkb20ucGFyZW50Tm9kZSAmJiAhaW5saW5lUGFyZW50cy50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2xpY2VEYXRhKSB7XG4gICAgICAgIHNsaWNlID0gYWRkQ29udGV4dChjbG9zZVNsaWNlKHNsaWNlLCArc2xpY2VEYXRhWzFdLCArc2xpY2VEYXRhWzJdKSwgc2xpY2VEYXRhWzRdKTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIEhUTUwgd2Fzbid0IGNyZWF0ZWQgYnkgUHJvc2VNaXJyb3IuIE1ha2Ugc3VyZSB0b3AtbGV2ZWwgc2libGluZ3MgYXJlIGNvaGVyZW50XG4gICAgICAgIHNsaWNlID0gU2xpY2UubWF4T3Blbihub3JtYWxpemVTaWJsaW5ncyhzbGljZS5jb250ZW50LCAkY29udGV4dCksIHRydWUpO1xuICAgICAgICBpZiAoc2xpY2Uub3BlblN0YXJ0IHx8IHNsaWNlLm9wZW5FbmQpIHtcbiAgICAgICAgICAgIGxldCBvcGVuU3RhcnQgPSAwLCBvcGVuRW5kID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IG5vZGUgPSBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQ7IG9wZW5TdGFydCA8IHNsaWNlLm9wZW5TdGFydCAmJiAhbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nOyBvcGVuU3RhcnQrKywgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZCkgeyB9XG4gICAgICAgICAgICBmb3IgKGxldCBub2RlID0gc2xpY2UuY29udGVudC5sYXN0Q2hpbGQ7IG9wZW5FbmQgPCBzbGljZS5vcGVuRW5kICYmICFub2RlLnR5cGUuc3BlYy5pc29sYXRpbmc7IG9wZW5FbmQrKywgbm9kZSA9IG5vZGUubGFzdENoaWxkKSB7IH1cbiAgICAgICAgICAgIHNsaWNlID0gY2xvc2VTbGljZShzbGljZSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkXCIsIGYgPT4geyBzbGljZSA9IGYoc2xpY2UsIHZpZXcpOyB9KTtcbiAgICByZXR1cm4gc2xpY2U7XG59XG5jb25zdCBpbmxpbmVQYXJlbnRzID0gL14oYXxhYmJyfGFjcm9ueW18YnxjaXRlfGNvZGV8ZGVsfGVtfGl8aW5zfGtiZHxsYWJlbHxvdXRwdXR8cXxydWJ5fHN8c2FtcHxzcGFufHN0cm9uZ3xzdWJ8c3VwfHRpbWV8dXx0dHx2YXIpJC9pO1xuLy8gVGFrZXMgYSBzbGljZSBwYXJzZWQgd2l0aCBwYXJzZVNsaWNlLCB3aGljaCBtZWFucyB0aGVyZSBoYXNuJ3QgYmVlblxuLy8gYW55IGNvbnRlbnQtZXhwcmVzc2lvbiBjaGVja2luZyBkb25lIG9uIHRoZSB0b3Agbm9kZXMsIHRyaWVzIHRvXG4vLyBmaW5kIGEgcGFyZW50IG5vZGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dCB0aGF0IG1pZ2h0IGZpdCB0aGUgbm9kZXMsXG4vLyBhbmQgaWYgc3VjY2Vzc2Z1bCwgcmVidWlsZHMgdGhlIHNsaWNlIHNvIHRoYXQgaXQgZml0cyBpbnRvIHRoYXQgcGFyZW50LlxuLy9cbi8vIFRoaXMgYWRkcmVzc2VzIHRoZSBwcm9ibGVtIHRoYXQgVHJhbnNmb3JtLnJlcGxhY2UgZXhwZWN0cyBhXG4vLyBjb2hlcmVudCBzbGljZSwgYW5kIHdpbGwgZmFpbCB0byBwbGFjZSBhIHNldCBvZiBzaWJsaW5ncyB0aGF0IGRvbid0XG4vLyBmaXQgYW55d2hlcmUgaW4gdGhlIHNjaGVtYS5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpYmxpbmdzKGZyYWdtZW50LCAkY29udGV4dCkge1xuICAgIGlmIChmcmFnbWVudC5jaGlsZENvdW50IDwgMilcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIGZvciAobGV0IGQgPSAkY29udGV4dC5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICRjb250ZXh0Lm5vZGUoZCk7XG4gICAgICAgIGxldCBtYXRjaCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdCgkY29udGV4dC5pbmRleChkKSk7XG4gICAgICAgIGxldCBsYXN0V3JhcCwgcmVzdWx0ID0gW107XG4gICAgICAgIGZyYWdtZW50LmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgd3JhcCA9IG1hdGNoLmZpbmRXcmFwcGluZyhub2RlLnR5cGUpLCBpbkxhc3Q7XG4gICAgICAgICAgICBpZiAoIXdyYXApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaW5MYXN0ID0gcmVzdWx0Lmxlbmd0aCAmJiBsYXN0V3JhcC5sZW5ndGggJiYgYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCAwKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBpbkxhc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IGNsb3NlUmlnaHQocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSwgbGFzdFdyYXAubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcHBlZCA9IHdpdGhXcmFwcGVycyhub2RlLCB3cmFwKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh3cmFwcGVkKTtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoLm1hdGNoVHlwZSh3cmFwcGVkLnR5cGUpO1xuICAgICAgICAgICAgICAgIGxhc3RXcmFwID0gd3JhcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbShyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5mdW5jdGlvbiB3aXRoV3JhcHBlcnMobm9kZSwgd3JhcCwgZnJvbSA9IDApIHtcbiAgICBmb3IgKGxldCBpID0gd3JhcC5sZW5ndGggLSAxOyBpID49IGZyb207IGktLSlcbiAgICAgICAgbm9kZSA9IHdyYXBbaV0uY3JlYXRlKG51bGwsIEZyYWdtZW50LmZyb20obm9kZSkpO1xuICAgIHJldHVybiBub2RlO1xufVxuLy8gVXNlZCB0byBncm91cCBhZGphY2VudCBub2RlcyB3cmFwcGVkIGluIHNpbWlsYXIgcGFyZW50cyBieVxuLy8gbm9ybWFsaXplU2libGluZ3MgaW50byB0aGUgc2FtZSBwYXJlbnQgbm9kZVxuZnVuY3Rpb24gYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCBzaWJsaW5nLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA8IHdyYXAubGVuZ3RoICYmIGRlcHRoIDwgbGFzdFdyYXAubGVuZ3RoICYmIHdyYXBbZGVwdGhdID09IGxhc3RXcmFwW2RlcHRoXSkge1xuICAgICAgICBsZXQgaW5uZXIgPSBhZGRUb1NpYmxpbmcod3JhcCwgbGFzdFdyYXAsIG5vZGUsIHNpYmxpbmcubGFzdENoaWxkLCBkZXB0aCArIDEpO1xuICAgICAgICBpZiAoaW5uZXIpXG4gICAgICAgICAgICByZXR1cm4gc2libGluZy5jb3B5KHNpYmxpbmcuY29udGVudC5yZXBsYWNlQ2hpbGQoc2libGluZy5jaGlsZENvdW50IC0gMSwgaW5uZXIpKTtcbiAgICAgICAgbGV0IG1hdGNoID0gc2libGluZy5jb250ZW50TWF0Y2hBdChzaWJsaW5nLmNoaWxkQ291bnQpO1xuICAgICAgICBpZiAobWF0Y2gubWF0Y2hUeXBlKGRlcHRoID09IHdyYXAubGVuZ3RoIC0gMSA/IG5vZGUudHlwZSA6IHdyYXBbZGVwdGggKyAxXSkpXG4gICAgICAgICAgICByZXR1cm4gc2libGluZy5jb3B5KHNpYmxpbmcuY29udGVudC5hcHBlbmQoRnJhZ21lbnQuZnJvbSh3aXRoV3JhcHBlcnMobm9kZSwgd3JhcCwgZGVwdGggKyAxKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbG9zZVJpZ2h0KG5vZGUsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID09IDApXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIGxldCBmcmFnbWVudCA9IG5vZGUuY29udGVudC5yZXBsYWNlQ2hpbGQobm9kZS5jaGlsZENvdW50IC0gMSwgY2xvc2VSaWdodChub2RlLmxhc3RDaGlsZCwgZGVwdGggLSAxKSk7XG4gICAgbGV0IGZpbGwgPSBub2RlLmNvbnRlbnRNYXRjaEF0KG5vZGUuY2hpbGRDb3VudCkuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG5vZGUuY29weShmcmFnbWVudC5hcHBlbmQoZmlsbCkpO1xufVxuZnVuY3Rpb24gY2xvc2VSYW5nZShmcmFnbWVudCwgc2lkZSwgZnJvbSwgdG8sIGRlcHRoLCBvcGVuRW5kKSB7XG4gICAgbGV0IG5vZGUgPSBzaWRlIDwgMCA/IGZyYWdtZW50LmZpcnN0Q2hpbGQgOiBmcmFnbWVudC5sYXN0Q2hpbGQsIGlubmVyID0gbm9kZS5jb250ZW50O1xuICAgIGlmIChmcmFnbWVudC5jaGlsZENvdW50ID4gMSlcbiAgICAgICAgb3BlbkVuZCA9IDA7XG4gICAgaWYgKGRlcHRoIDwgdG8gLSAxKVxuICAgICAgICBpbm5lciA9IGNsb3NlUmFuZ2UoaW5uZXIsIHNpZGUsIGZyb20sIHRvLCBkZXB0aCArIDEsIG9wZW5FbmQpO1xuICAgIGlmIChkZXB0aCA+PSBmcm9tKVxuICAgICAgICBpbm5lciA9IHNpZGUgPCAwID8gbm9kZS5jb250ZW50TWF0Y2hBdCgwKS5maWxsQmVmb3JlKGlubmVyLCBvcGVuRW5kIDw9IGRlcHRoKS5hcHBlbmQoaW5uZXIpXG4gICAgICAgICAgICA6IGlubmVyLmFwcGVuZChub2RlLmNvbnRlbnRNYXRjaEF0KG5vZGUuY2hpbGRDb3VudCkuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoc2lkZSA8IDAgPyAwIDogZnJhZ21lbnQuY2hpbGRDb3VudCAtIDEsIG5vZGUuY29weShpbm5lcikpO1xufVxuZnVuY3Rpb24gY2xvc2VTbGljZShzbGljZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgaWYgKG9wZW5TdGFydCA8IHNsaWNlLm9wZW5TdGFydClcbiAgICAgICAgc2xpY2UgPSBuZXcgU2xpY2UoY2xvc2VSYW5nZShzbGljZS5jb250ZW50LCAtMSwgb3BlblN0YXJ0LCBzbGljZS5vcGVuU3RhcnQsIDAsIHNsaWNlLm9wZW5FbmQpLCBvcGVuU3RhcnQsIHNsaWNlLm9wZW5FbmQpO1xuICAgIGlmIChvcGVuRW5kIDwgc2xpY2Uub3BlbkVuZClcbiAgICAgICAgc2xpY2UgPSBuZXcgU2xpY2UoY2xvc2VSYW5nZShzbGljZS5jb250ZW50LCAxLCBvcGVuRW5kLCBzbGljZS5vcGVuRW5kLCAwLCAwKSwgc2xpY2Uub3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICByZXR1cm4gc2xpY2U7XG59XG4vLyBUcmljayBmcm9tIGpRdWVyeSAtLSBzb21lIGVsZW1lbnRzIG11c3QgYmUgd3JhcHBlZCBpbiBvdGhlclxuLy8gZWxlbWVudHMgZm9yIGlubmVySFRNTCB0byB3b3JrLiBJLmUuIGlmIHlvdSBkbyBgZGl2LmlubmVySFRNTCA9XG4vLyBcIjx0ZD4uLjwvdGQ+XCJgIHRoZSB0YWJsZSBjZWxscyBhcmUgaWdub3JlZC5cbmNvbnN0IHdyYXBNYXAgPSB7XG4gICAgdGhlYWQ6IFtcInRhYmxlXCJdLFxuICAgIHRib2R5OiBbXCJ0YWJsZVwiXSxcbiAgICB0Zm9vdDogW1widGFibGVcIl0sXG4gICAgY2FwdGlvbjogW1widGFibGVcIl0sXG4gICAgY29sZ3JvdXA6IFtcInRhYmxlXCJdLFxuICAgIGNvbDogW1widGFibGVcIiwgXCJjb2xncm91cFwiXSxcbiAgICB0cjogW1widGFibGVcIiwgXCJ0Ym9keVwiXSxcbiAgICB0ZDogW1widGFibGVcIiwgXCJ0Ym9keVwiLCBcInRyXCJdLFxuICAgIHRoOiBbXCJ0YWJsZVwiLCBcInRib2R5XCIsIFwidHJcIl1cbn07XG5sZXQgX2RldGFjaGVkRG9jID0gbnVsbDtcbmZ1bmN0aW9uIGRldGFjaGVkRG9jKCkge1xuICAgIHJldHVybiBfZGV0YWNoZWREb2MgfHwgKF9kZXRhY2hlZERvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcInRpdGxlXCIpKTtcbn1cbmZ1bmN0aW9uIHJlYWRIVE1MKGh0bWwpIHtcbiAgICBsZXQgbWV0YXMgPSAvXihcXHMqPG1ldGEgW14+XSo+KSovLmV4ZWMoaHRtbCk7XG4gICAgaWYgKG1ldGFzKVxuICAgICAgICBodG1sID0gaHRtbC5zbGljZShtZXRhc1swXS5sZW5ndGgpO1xuICAgIGxldCBlbHQgPSBkZXRhY2hlZERvYygpLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbGV0IGZpcnN0VGFnID0gLzwoW2Etel1bXj5cXHNdKykvaS5leGVjKGh0bWwpLCB3cmFwO1xuICAgIGlmICh3cmFwID0gZmlyc3RUYWcgJiYgd3JhcE1hcFtmaXJzdFRhZ1sxXS50b0xvd2VyQ2FzZSgpXSlcbiAgICAgICAgaHRtbCA9IHdyYXAubWFwKG4gPT4gXCI8XCIgKyBuICsgXCI+XCIpLmpvaW4oXCJcIikgKyBodG1sICsgd3JhcC5tYXAobiA9PiBcIjwvXCIgKyBuICsgXCI+XCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgIGVsdC5pbm5lckhUTUwgPSBodG1sO1xuICAgIGlmICh3cmFwKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXAubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBlbHQgPSBlbHQucXVlcnlTZWxlY3Rvcih3cmFwW2ldKSB8fCBlbHQ7XG4gICAgcmV0dXJuIGVsdDtcbn1cbi8vIFdlYmtpdCBicm93c2VycyBkbyBzb21lIGhhcmQtdG8tcHJlZGljdCByZXBsYWNlbWVudCBvZiByZWd1bGFyXG4vLyBzcGFjZXMgd2l0aCBub24tYnJlYWtpbmcgc3BhY2VzIHdoZW4gcHV0dGluZyBjb250ZW50IG9uIHRoZVxuLy8gY2xpcGJvYXJkLiBUaGlzIHRyaWVzIHRvIGNvbnZlcnQgc3VjaCBub24tYnJlYWtpbmcgc3BhY2VzICh3aGljaFxuLy8gd2lsbCBiZSB3cmFwcGVkIGluIGEgcGxhaW4gc3BhbiBvbiBDaHJvbWUsIGEgc3BhbiB3aXRoIGNsYXNzXG4vLyBBcHBsZS1jb252ZXJ0ZWQtc3BhY2Ugb24gU2FmYXJpKSBiYWNrIHRvIHJlZ3VsYXIgc3BhY2VzLlxuZnVuY3Rpb24gcmVzdG9yZVJlcGxhY2VkU3BhY2VzKGRvbSkge1xuICAgIGxldCBub2RlcyA9IGRvbS5xdWVyeVNlbGVjdG9yQWxsKGNocm9tZSA/IFwic3Bhbjpub3QoW2NsYXNzXSk6bm90KFtzdHlsZV0pXCIgOiBcInNwYW4uQXBwbGUtY29udmVydGVkLXNwYWNlXCIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJiBub2RlLnRleHRDb250ZW50ID09IFwiXFx1MDBhMFwiICYmIG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZG9tLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIgXCIpLCBub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRDb250ZXh0KHNsaWNlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgbGV0IHNjaGVtYSA9IHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZC50eXBlLnNjaGVtYSwgYXJyYXk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXJyYXkgPSBKU09OLnBhcnNlKGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgfVxuICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gc2xpY2U7XG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIGxldCB0eXBlID0gc2NoZW1hLm5vZGVzW2FycmF5W2ldXTtcbiAgICAgICAgaWYgKCF0eXBlIHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGFycmF5W2kgKyAxXSwgY29udGVudCkpO1xuICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgb3BlbkVuZCsrO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG59XG5cbi8vIEEgY29sbGVjdGlvbiBvZiBET00gZXZlbnRzIHRoYXQgb2NjdXIgd2l0aGluIHRoZSBlZGl0b3IsIGFuZCBjYWxsYmFjayBmdW5jdGlvbnNcbi8vIHRvIGludm9rZSB3aGVuIHRoZSBldmVudCBmaXJlcy5cbmNvbnN0IGhhbmRsZXJzID0ge307XG5jb25zdCBlZGl0SGFuZGxlcnMgPSB7fTtcbmNvbnN0IHBhc3NpdmVIYW5kbGVycyA9IHsgdG91Y2hzdGFydDogdHJ1ZSwgdG91Y2htb3ZlOiB0cnVlIH07XG5jbGFzcyBJbnB1dFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zaGlmdEtleSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1vdXNlRG93biA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdENsaWNrID0geyB0aW1lOiAwLCB4OiAwLCB5OiAwLCB0eXBlOiBcIlwiIH07XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgIHRoaXMubGFzdElPU0VudGVyRmFsbGJhY2tUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdEZvY3VzID0gMDtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2ggPSAwO1xuICAgICAgICB0aGlzLmxhc3RBbmRyb2lkRGVsZXRlID0gMDtcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb21wb3NpbmdUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25Ob2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA9IC0yZTg7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25JRCA9IDE7XG4gICAgICAgIC8vIFNldCB0byBhIGNvbXBvc2l0aW9uIElEIHdoZW4gdGhlcmUgYXJlIHBlbmRpbmcgY2hhbmdlcyBhdCBjb21wb3NpdGlvbmVuZFxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgPSAwO1xuICAgICAgICB0aGlzLmRvbUNoYW5nZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5oaWRlU2VsZWN0aW9uR3VhcmQgPSBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluaXRJbnB1dCh2aWV3KSB7XG4gICAgZm9yIChsZXQgZXZlbnQgaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1tldmVudF0gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudEJlbG9uZ3NUb1ZpZXcodmlldywgZXZlbnQpICYmICFydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSAmJlxuICAgICAgICAgICAgICAgICh2aWV3LmVkaXRhYmxlIHx8ICEoZXZlbnQudHlwZSBpbiBlZGl0SGFuZGxlcnMpKSlcbiAgICAgICAgICAgICAgICBoYW5kbGVyKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgfSwgcGFzc2l2ZUhhbmRsZXJzW2V2ZW50XSA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLy8gT24gU2FmYXJpLCBmb3IgcmVhc29ucyBiZXlvbmQgbXkgdW5kZXJzdGFuZGluZywgYWRkaW5nIGFuIGlucHV0XG4gICAgLy8gZXZlbnQgaGFuZGxlciBtYWtlcyBhbiBpc3N1ZSB3aGVyZSB0aGUgY29tcG9zaXRpb24gdmFuaXNoZXMgd2hlblxuICAgIC8vIHlvdSBwcmVzcyBlbnRlciBnbyBhd2F5LlxuICAgIGlmIChzYWZhcmkpXG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoKSA9PiBudWxsKTtcbiAgICBlbnN1cmVMaXN0ZW5lcnModmlldyk7XG59XG5mdW5jdGlvbiBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgb3JpZ2luKSB7XG4gICAgdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uT3JpZ2luID0gb3JpZ2luO1xuICAgIHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvblRpbWUgPSBEYXRlLm5vdygpO1xufVxuZnVuY3Rpb24gZGVzdHJveUlucHV0KHZpZXcpIHtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICBmb3IgKGxldCB0eXBlIGluIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVycylcbiAgICAgICAgdmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbdHlwZV0pO1xuICAgIGNsZWFyVGltZW91dCh2aWV3LmlucHV0LmNvbXBvc2luZ1RpbWVvdXQpO1xuICAgIGNsZWFyVGltZW91dCh2aWV3LmlucHV0Lmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCk7XG59XG5mdW5jdGlvbiBlbnN1cmVMaXN0ZW5lcnModmlldykge1xuICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVET01FdmVudHNcIiwgY3VycmVudEhhbmRsZXJzID0+IHtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBjdXJyZW50SGFuZGxlcnMpXG4gICAgICAgICAgICBpZiAoIXZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSlcbiAgICAgICAgICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSA9IGV2ZW50ID0+IHJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpIHtcbiAgICByZXR1cm4gdmlldy5zb21lUHJvcChcImhhbmRsZURPTUV2ZW50c1wiLCBoYW5kbGVycyA9PiB7XG4gICAgICAgIGxldCBoYW5kbGVyID0gaGFuZGxlcnNbZXZlbnQudHlwZV07XG4gICAgICAgIHJldHVybiBoYW5kbGVyID8gaGFuZGxlcih2aWV3LCBldmVudCkgfHwgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IGZhbHNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZXZlbnRCZWxvbmdzVG9WaWV3KHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5idWJibGVzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IG5vZGUgPSBldmVudC50YXJnZXQ7IG5vZGUgIT0gdmlldy5kb207IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpXG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlID09IDExIHx8XG4gICAgICAgICAgICAobm9kZS5wbVZpZXdEZXNjICYmIG5vZGUucG1WaWV3RGVzYy5zdG9wRXZlbnQoZXZlbnQpKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIXJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpICYmIGhhbmRsZXJzW2V2ZW50LnR5cGVdICYmXG4gICAgICAgICh2aWV3LmVkaXRhYmxlIHx8ICEoZXZlbnQudHlwZSBpbiBlZGl0SGFuZGxlcnMpKSlcbiAgICAgICAgaGFuZGxlcnNbZXZlbnQudHlwZV0odmlldywgZXZlbnQpO1xufVxuZWRpdEhhbmRsZXJzLmtleWRvd24gPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBldmVudC5rZXlDb2RlID09IDE2IHx8IGV2ZW50LnNoaWZ0S2V5O1xuICAgIGlmIChpbk9yTmVhckNvbXBvc2l0aW9uKHZpZXcsIGV2ZW50KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAvLyBTdXBwcmVzcyBlbnRlciBrZXkgZXZlbnRzIG9uIENocm9tZSBBbmRyb2lkLCBiZWNhdXNlIHRob3NlIHRlbmRcbiAgICAvLyB0byBiZSBwYXJ0IG9mIGEgY29uZnVzZWQgc2VxdWVuY2Ugb2YgY29tcG9zaXRpb24gZXZlbnRzIGZpcmVkLFxuICAgIC8vIGFuZCBoYW5kbGluZyB0aGVtIGVhZ2VybHkgdGVuZHMgdG8gY29ycnVwdCB0aGUgaW5wdXQuXG4gICAgaWYgKGFuZHJvaWQgJiYgY2hyb21lICYmIGV2ZW50LmtleUNvZGUgPT0gMTMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSAhPSAyMjkpXG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgIC8vIE9uIGlPUywgaWYgd2UgcHJldmVudERlZmF1bHQgZW50ZXIga2V5IHByZXNzZXMsIHRoZSB2aXJ0dWFsXG4gICAgLy8ga2V5Ym9hcmQgZ2V0cyBjb25mdXNlZC4gU28gdGhlIGhhY2sgaGVyZSBpcyB0byBzZXQgYSBmbGFnIHRoYXRcbiAgICAvLyBtYWtlcyB0aGUgRE9NIGNoYW5nZSBjb2RlIHJlY29nbml6ZSB0aGF0IHdoYXQganVzdCBoYXBwZW5zIHNob3VsZFxuICAgIC8vIGJlIHJlcGxhY2VkIGJ5IHdoYXRldmVyIHRoZSBFbnRlciBrZXkgaGFuZGxlcnMgZG8uXG4gICAgaWYgKGlvcyAmJiBldmVudC5rZXlDb2RlID09IDEzICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgJiYgIWV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gbm93O1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXQubGFzdElPU0VudGVyID09IG5vdykge1xuICAgICAgICAgICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSkpO1xuICAgICAgICAgICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGV2ZW50KSkgfHwgY2FwdHVyZUtleURvd24odmlldywgZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJrZXlcIik7XG4gICAgfVxufTtcbmVkaXRIYW5kbGVycy5rZXl1cCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09IDE2KVxuICAgICAgICB2aWV3LmlucHV0LnNoaWZ0S2V5ID0gZmFsc2U7XG59O1xuZWRpdEhhbmRsZXJzLmtleXByZXNzID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBpZiAoaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkgfHwgIWV2ZW50LmNoYXJDb2RlIHx8XG4gICAgICAgIGV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmFsdEtleSB8fCBtYWMgJiYgZXZlbnQubWV0YUtleSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5UHJlc3NcIiwgZiA9PiBmKHZpZXcsIGV2ZW50KSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikgfHwgIXNlbC4kZnJvbS5zYW1lUGFyZW50KHNlbC4kdG8pKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5jaGFyQ29kZSk7XG4gICAgICAgIGlmICghL1tcXHJcXG5dLy50ZXN0KHRleHQpICYmICF2aWV3LnNvbWVQcm9wKFwiaGFuZGxlVGV4dElucHV0XCIsIGYgPT4gZih2aWV3LCBzZWwuJGZyb20ucG9zLCBzZWwuJHRvLnBvcywgdGV4dCkpKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLmluc2VydFRleHQodGV4dCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGV2ZW50Q29vcmRzKGV2ZW50KSB7IHJldHVybiB7IGxlZnQ6IGV2ZW50LmNsaWVudFgsIHRvcDogZXZlbnQuY2xpZW50WSB9OyB9XG5mdW5jdGlvbiBpc05lYXIoZXZlbnQsIGNsaWNrKSB7XG4gICAgbGV0IGR4ID0gY2xpY2sueCAtIGV2ZW50LmNsaWVudFgsIGR5ID0gY2xpY2sueSAtIGV2ZW50LmNsaWVudFk7XG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5IDwgMTAwO1xufVxuZnVuY3Rpb24gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBwcm9wTmFtZSwgcG9zLCBpbnNpZGUsIGV2ZW50KSB7XG4gICAgaWYgKGluc2lkZSA9PSAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShpbnNpZGUpO1xuICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoICsgMTsgaSA+IDA7IGktLSkge1xuICAgICAgICBpZiAodmlldy5zb21lUHJvcChwcm9wTmFtZSwgZiA9PiBpID4gJHBvcy5kZXB0aCA/IGYodmlldywgcG9zLCAkcG9zLm5vZGVBZnRlciwgJHBvcy5iZWZvcmUoaSksIGV2ZW50LCB0cnVlKVxuICAgICAgICAgICAgOiBmKHZpZXcsIHBvcywgJHBvcy5ub2RlKGkpLCAkcG9zLmJlZm9yZShpKSwgZXZlbnQsIGZhbHNlKSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uKHZpZXcsIHNlbGVjdGlvbiwgb3JpZ2luKSB7XG4gICAgaWYgKCF2aWV3LmZvY3VzZWQpXG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGlmIChvcmlnaW4gPT0gXCJwb2ludGVyXCIpXG4gICAgICAgIHRyLnNldE1ldGEoXCJwb2ludGVyXCIsIHRydWUpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xufVxuZnVuY3Rpb24gc2VsZWN0Q2xpY2tlZExlYWYodmlldywgaW5zaWRlKSB7XG4gICAgaWYgKGluc2lkZSA9PSAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShpbnNpZGUpLCBub2RlID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgaWYgKG5vZGUgJiYgbm9kZS5pc0F0b20gJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHtcbiAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RDbGlja2VkTm9kZSh2aWV3LCBpbnNpZGUpIHtcbiAgICBpZiAoaW5zaWRlID09IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLCBzZWxlY3RlZE5vZGUsIHNlbGVjdEF0O1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKVxuICAgICAgICBzZWxlY3RlZE5vZGUgPSBzZWwubm9kZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBpID4gJHBvcy5kZXB0aCA/ICRwb3Mubm9kZUFmdGVyIDogJHBvcy5ub2RlKGkpO1xuICAgICAgICBpZiAoTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGUgJiYgc2VsLiRmcm9tLmRlcHRoID4gMCAmJlxuICAgICAgICAgICAgICAgIGkgPj0gc2VsLiRmcm9tLmRlcHRoICYmICRwb3MuYmVmb3JlKHNlbC4kZnJvbS5kZXB0aCArIDEpID09IHNlbC4kZnJvbS5wb3MpXG4gICAgICAgICAgICAgICAgc2VsZWN0QXQgPSAkcG9zLmJlZm9yZShzZWwuJGZyb20uZGVwdGgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlbGVjdEF0ID0gJHBvcy5iZWZvcmUoaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsZWN0QXQgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIHNlbGVjdEF0KSwgXCJwb2ludGVyXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVTaW5nbGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQsIHNlbGVjdE5vZGUpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlQ2xpY2tcIiwgZiA9PiBmKHZpZXcsIHBvcywgZXZlbnQpKSB8fFxuICAgICAgICAoc2VsZWN0Tm9kZSA/IHNlbGVjdENsaWNrZWROb2RlKHZpZXcsIGluc2lkZSkgOiBzZWxlY3RDbGlja2VkTGVhZih2aWV3LCBpbnNpZGUpKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZURvdWJsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIHJldHVybiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIFwiaGFuZGxlRG91YmxlQ2xpY2tPblwiLCBwb3MsIGluc2lkZSwgZXZlbnQpIHx8XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVEb3VibGVDbGlja1wiLCBmID0+IGYodmlldywgcG9zLCBldmVudCkpO1xufVxuZnVuY3Rpb24gaGFuZGxlVHJpcGxlQ2xpY2sodmlldywgcG9zLCBpbnNpZGUsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVUcmlwbGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHxcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZVRyaXBsZUNsaWNrXCIsIGYgPT4gZih2aWV3LCBwb3MsIGV2ZW50KSkgfHxcbiAgICAgICAgZGVmYXVsdFRyaXBsZUNsaWNrKHZpZXcsIGluc2lkZSwgZXZlbnQpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFRyaXBsZUNsaWNrKHZpZXcsIGluc2lkZSwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgaWYgKGluc2lkZSA9PSAtMSkge1xuICAgICAgICBpZiAoZG9jLmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIDAsIGRvYy5jb250ZW50LnNpemUpLCBcInBvaW50ZXJcIik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBpID4gJHBvcy5kZXB0aCA/ICRwb3Mubm9kZUFmdGVyIDogJHBvcy5ub2RlKGkpO1xuICAgICAgICBsZXQgbm9kZVBvcyA9ICRwb3MuYmVmb3JlKGkpO1xuICAgICAgICBpZiAobm9kZS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgbm9kZVBvcyArIDEsIG5vZGVQb3MgKyAxICsgbm9kZS5jb250ZW50LnNpemUpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIGVsc2UgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIE5vZGVTZWxlY3Rpb24uY3JlYXRlKGRvYywgbm9kZVBvcyksIFwicG9pbnRlclwiKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcmNlRE9NRmx1c2godmlldykge1xuICAgIHJldHVybiBlbmRDb21wb3NpdGlvbih2aWV3KTtcbn1cbmNvbnN0IHNlbGVjdE5vZGVNb2RpZmllciA9IG1hYyA/IFwibWV0YUtleVwiIDogXCJjdHJsS2V5XCI7XG5oYW5kbGVycy5tb3VzZWRvd24gPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBldmVudC5zaGlmdEtleTtcbiAgICBsZXQgZmx1c2hlZCA9IGZvcmNlRE9NRmx1c2godmlldyk7XG4gICAgbGV0IG5vdyA9IERhdGUubm93KCksIHR5cGUgPSBcInNpbmdsZUNsaWNrXCI7XG4gICAgaWYgKG5vdyAtIHZpZXcuaW5wdXQubGFzdENsaWNrLnRpbWUgPCA1MDAgJiYgaXNOZWFyKGV2ZW50LCB2aWV3LmlucHV0Lmxhc3RDbGljaykgJiYgIWV2ZW50W3NlbGVjdE5vZGVNb2RpZmllcl0pIHtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXQubGFzdENsaWNrLnR5cGUgPT0gXCJzaW5nbGVDbGlja1wiKVxuICAgICAgICAgICAgdHlwZSA9IFwiZG91YmxlQ2xpY2tcIjtcbiAgICAgICAgZWxzZSBpZiAodmlldy5pbnB1dC5sYXN0Q2xpY2sudHlwZSA9PSBcImRvdWJsZUNsaWNrXCIpXG4gICAgICAgICAgICB0eXBlID0gXCJ0cmlwbGVDbGlja1wiO1xuICAgIH1cbiAgICB2aWV3LmlucHV0Lmxhc3RDbGljayA9IHsgdGltZTogbm93LCB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZLCB0eXBlIH07XG4gICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICBpZiAoIXBvcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlID09IFwic2luZ2xlQ2xpY2tcIikge1xuICAgICAgICBpZiAodmlldy5pbnB1dC5tb3VzZURvd24pXG4gICAgICAgICAgICB2aWV3LmlucHV0Lm1vdXNlRG93bi5kb25lKCk7XG4gICAgICAgIHZpZXcuaW5wdXQubW91c2VEb3duID0gbmV3IE1vdXNlRG93bih2aWV3LCBwb3MsIGV2ZW50LCAhIWZsdXNoZWQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgodHlwZSA9PSBcImRvdWJsZUNsaWNrXCIgPyBoYW5kbGVEb3VibGVDbGljayA6IGhhbmRsZVRyaXBsZUNsaWNrKSh2aWV3LCBwb3MucG9zLCBwb3MuaW5zaWRlLCBldmVudCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG4gICAgfVxufTtcbmNsYXNzIE1vdXNlRG93biB7XG4gICAgY29uc3RydWN0b3IodmlldywgcG9zLCBldmVudCwgZmx1c2hlZCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICB0aGlzLmZsdXNoZWQgPSBmbHVzaGVkO1xuICAgICAgICB0aGlzLmRlbGF5ZWRTZWxlY3Rpb25TeW5jID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWlnaHREcmFnID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFydERvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgICAgICB0aGlzLnNlbGVjdE5vZGUgPSAhIWV2ZW50W3NlbGVjdE5vZGVNb2RpZmllcl07XG4gICAgICAgIHRoaXMuYWxsb3dEZWZhdWx0ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIGxldCB0YXJnZXROb2RlLCB0YXJnZXRQb3M7XG4gICAgICAgIGlmIChwb3MuaW5zaWRlID4gLTEpIHtcbiAgICAgICAgICAgIHRhcmdldE5vZGUgPSB2aWV3LnN0YXRlLmRvYy5ub2RlQXQocG9zLmluc2lkZSk7XG4gICAgICAgICAgICB0YXJnZXRQb3MgPSBwb3MuaW5zaWRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcy5wb3MpO1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9ICRwb3MucGFyZW50O1xuICAgICAgICAgICAgdGFyZ2V0UG9zID0gJHBvcy5kZXB0aCA/ICRwb3MuYmVmb3JlKCkgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGZsdXNoZWQgPyBudWxsIDogZXZlbnQudGFyZ2V0O1xuICAgICAgICBjb25zdCB0YXJnZXREZXNjID0gdGFyZ2V0ID8gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKHRhcmdldCwgdHJ1ZSkgOiBudWxsO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldERlc2MgPyB0YXJnZXREZXNjLmRvbSA6IG51bGw7XG4gICAgICAgIGxldCB7IHNlbGVjdGlvbiB9ID0gdmlldy5zdGF0ZTtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PSAwICYmXG4gICAgICAgICAgICB0YXJnZXROb2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUgJiYgdGFyZ2V0Tm9kZS50eXBlLnNwZWMuc2VsZWN0YWJsZSAhPT0gZmFsc2UgfHxcbiAgICAgICAgICAgIHNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmZyb20gPD0gdGFyZ2V0UG9zICYmIHNlbGVjdGlvbi50byA+IHRhcmdldFBvcylcbiAgICAgICAgICAgIHRoaXMubWlnaHREcmFnID0ge1xuICAgICAgICAgICAgICAgIG5vZGU6IHRhcmdldE5vZGUsXG4gICAgICAgICAgICAgICAgcG9zOiB0YXJnZXRQb3MsXG4gICAgICAgICAgICAgICAgYWRkQXR0cjogISEodGhpcy50YXJnZXQgJiYgIXRoaXMudGFyZ2V0LmRyYWdnYWJsZSksXG4gICAgICAgICAgICAgICAgc2V0VW5lZGl0YWJsZTogISEodGhpcy50YXJnZXQgJiYgZ2Vja28gJiYgIXRoaXMudGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCAmJiB0aGlzLm1pZ2h0RHJhZyAmJiAodGhpcy5taWdodERyYWcuYWRkQXR0ciB8fCB0aGlzLm1pZ2h0RHJhZy5zZXRVbmVkaXRhYmxlKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5hZGRBdHRyKVxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSlcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmlldy5pbnB1dC5tb3VzZURvd24gPT0gdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnNldEF0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiLCBcImZhbHNlXCIpO1xuICAgICAgICAgICAgICAgIH0sIDIwKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwID0gdGhpcy51cC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlID0gdGhpcy5tb3ZlLmJpbmQodGhpcykpO1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xuICAgIH1cbiAgICBkb25lKCkge1xuICAgICAgICB0aGlzLnZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwKTtcbiAgICAgICAgdGhpcy52aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmUpO1xuICAgICAgICBpZiAodGhpcy5taWdodERyYWcgJiYgdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuYWRkQXR0cilcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSlcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIik7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWxheWVkU2VsZWN0aW9uU3luYylcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2VsZWN0aW9uVG9ET00odGhpcy52aWV3KSk7XG4gICAgICAgIHRoaXMudmlldy5pbnB1dC5tb3VzZURvd24gPSBudWxsO1xuICAgIH1cbiAgICB1cChldmVudCkge1xuICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5kb2MgIT0gdGhpcy5zdGFydERvYylcbiAgICAgICAgICAgIHBvcyA9IHRoaXMudmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpO1xuICAgICAgICB0aGlzLnVwZGF0ZUFsbG93RGVmYXVsdChldmVudCk7XG4gICAgICAgIGlmICh0aGlzLmFsbG93RGVmYXVsdCB8fCAhcG9zKSB7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFuZGxlU2luZ2xlQ2xpY2sodGhpcy52aWV3LCBwb3MucG9zLCBwb3MuaW5zaWRlLCBldmVudCwgdGhpcy5zZWxlY3ROb2RlKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC5idXR0b24gPT0gMCAmJlxuICAgICAgICAgICAgKHRoaXMuZmx1c2hlZCB8fFxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBpZ25vcmVzIGNsaWNrcyBvbiBkcmFnZ2FibGUgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAoc2FmYXJpICYmIHRoaXMubWlnaHREcmFnICYmICF0aGlzLm1pZ2h0RHJhZy5ub2RlLmlzQXRvbSkgfHxcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgd2lsbCBzb21ldGltZXMgdHJlYXQgYSBub2RlIHNlbGVjdGlvbiBhcyBhXG4gICAgICAgICAgICAgICAgLy8gY3Vyc29yLCBidXQgc3RpbGwgcmVwb3J0IHRoYXQgdGhlIG5vZGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGFza2VkIHRocm91Z2ggZ2V0U2VsZWN0aW9uLiBZb3UnbGwgdGhlbiBnZXQgYVxuICAgICAgICAgICAgICAgIC8vIHNpdHVhdGlvbiB3aGVyZSBjbGlja2luZyBhdCB0aGUgcG9pbnQgd2hlcmUgdGhhdFxuICAgICAgICAgICAgICAgIC8vIChoaWRkZW4pIGN1cnNvciBpcyBkb2Vzbid0IGNoYW5nZSB0aGUgc2VsZWN0aW9uLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB0aHVzIGRvZXNuJ3QgZ2V0IGEgcmVhY3Rpb24gZnJvbSBQcm9zZU1pcnJvci4gVGhpc1xuICAgICAgICAgICAgICAgIC8vIHdvcmtzIGFyb3VuZCB0aGF0LlxuICAgICAgICAgICAgICAgIChjaHJvbWUgJiYgIXRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihNYXRoLmFicyhwb3MucG9zIC0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tKSwgTWF0aC5hYnMocG9zLnBvcyAtIHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24udG8pKSA8PSAyKSkpIHtcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih0aGlzLnZpZXcsIFNlbGVjdGlvbi5uZWFyKHRoaXMudmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MucG9zKSksIFwicG9pbnRlclwiKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZShldmVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUFsbG93RGVmYXVsdChldmVudCk7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih0aGlzLnZpZXcsIFwicG9pbnRlclwiKTtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbnMgPT0gMClcbiAgICAgICAgICAgIHRoaXMuZG9uZSgpO1xuICAgIH1cbiAgICB1cGRhdGVBbGxvd0RlZmF1bHQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93RGVmYXVsdCAmJiAoTWF0aC5hYnModGhpcy5ldmVudC54IC0gZXZlbnQuY2xpZW50WCkgPiA0IHx8XG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLmV2ZW50LnkgLSBldmVudC5jbGllbnRZKSA+IDQpKVxuICAgICAgICAgICAgdGhpcy5hbGxvd0RlZmF1bHQgPSB0cnVlO1xuICAgIH1cbn1cbmhhbmRsZXJzLnRvdWNoc3RhcnQgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RUb3VjaCA9IERhdGUubm93KCk7XG4gICAgZm9yY2VET01GbHVzaCh2aWV3KTtcbiAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xufTtcbmhhbmRsZXJzLnRvdWNobW92ZSA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXQubGFzdFRvdWNoID0gRGF0ZS5ub3coKTtcbiAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJwb2ludGVyXCIpO1xufTtcbmhhbmRsZXJzLmNvbnRleHRtZW51ID0gdmlldyA9PiBmb3JjZURPTUZsdXNoKHZpZXcpO1xuZnVuY3Rpb24gaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkge1xuICAgIGlmICh2aWV3LmNvbXBvc2luZylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gU2VlIGh0dHBzOi8vd3d3LnN0dW0uZGUvMjAxNi8wNi8yNC9oYW5kbGluZy1pbWUtZXZlbnRzLWluLWphdmFzY3JpcHQvLlxuICAgIC8vIE9uIEphcGFuZXNlIGlucHV0IG1ldGhvZCBlZGl0b3JzIChJTUVzKSwgdGhlIEVudGVyIGtleSBpcyB1c2VkIHRvIGNvbmZpcm0gY2hhcmFjdGVyXG4gICAgLy8gc2VsZWN0aW9uLiBPbiBTYWZhcmksIHdoZW4gRW50ZXIgaXMgcHJlc3NlZCwgY29tcG9zaXRpb25lbmQgYW5kIGtleWRvd24gZXZlbnRzIGFyZVxuICAgIC8vIGVtaXR0ZWQuIFRoZSBrZXlkb3duIGV2ZW50IHRyaWdnZXJzIG5ld2xpbmUgaW5zZXJ0aW9uLCB3aGljaCB3ZSBkb24ndCB3YW50LlxuICAgIC8vIFRoaXMgbWV0aG9kIHJldHVybnMgdHJ1ZSBpZiB0aGUga2V5ZG93biBldmVudCBzaG91bGQgYmUgaWdub3JlZC5cbiAgICAvLyBXZSBvbmx5IGlnbm9yZSBpdCBvbmNlLCBhcyBwcmVzc2luZyBFbnRlciBhIHNlY29uZCB0aW1lICpzaG91bGQqIGluc2VydCBhIG5ld2xpbmUuXG4gICAgLy8gRnVydGhlcm1vcmUsIHRoZSBrZXlkb3duIGV2ZW50IHRpbWVzdGFtcCBtdXN0IGJlIGNsb3NlIHRvIHRoZSBjb21wb3NpdGlvbkVuZGVkQXQgdGltZXN0YW1wLlxuICAgIC8vIFRoaXMgZ3VhcmRzIGFnYWluc3QgdGhlIGNhc2Ugd2hlcmUgY29tcG9zaXRpb25lbmQgaXMgdHJpZ2dlcmVkIHdpdGhvdXQgdGhlIGtleWJvYXJkXG4gICAgLy8gKGUuZy4gY2hhcmFjdGVyIGNvbmZpcm1hdGlvbiBtYXkgYmUgZG9uZSB3aXRoIHRoZSBtb3VzZSksIGFuZCBrZXlkb3duIGlzIHRyaWdnZXJlZFxuICAgIC8vIGFmdGVyd2FyZHMtIHdlIHdvdWxkbid0IHdhbnQgdG8gaWdub3JlIHRoZSBrZXlkb3duIGV2ZW50IGluIHRoaXMgY2FzZS5cbiAgICBpZiAoc2FmYXJpICYmIE1hdGguYWJzKGV2ZW50LnRpbWVTdGFtcCAtIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0KSA8IDUwMCkge1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCA9IC0yZTg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBEcm9wIGFjdGl2ZSBjb21wb3NpdGlvbiBhZnRlciA1IHNlY29uZHMgb2YgaW5hY3Rpdml0eSBvbiBBbmRyb2lkXG5jb25zdCB0aW1lb3V0Q29tcG9zaXRpb24gPSBhbmRyb2lkID8gNTAwMCA6IC0xO1xuZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9uc3RhcnQgPSBlZGl0SGFuZGxlcnMuY29tcG9zaXRpb251cGRhdGUgPSB2aWV3ID0+IHtcbiAgICBpZiAoIXZpZXcuY29tcG9zaW5nKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2goKTtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsICRwb3MgPSBzdGF0ZS5zZWxlY3Rpb24uJGZyb207XG4gICAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiZcbiAgICAgICAgICAgIChzdGF0ZS5zdG9yZWRNYXJrcyB8fFxuICAgICAgICAgICAgICAgICghJHBvcy50ZXh0T2Zmc2V0ICYmICRwb3MucGFyZW50T2Zmc2V0ICYmICRwb3Mubm9kZUJlZm9yZS5tYXJrcy5zb21lKG0gPT4gbS50eXBlLnNwZWMuaW5jbHVzaXZlID09PSBmYWxzZSkpKSkge1xuICAgICAgICAgICAgLy8gTmVlZCB0byB3cmFwIHRoZSBjdXJzb3IgaW4gbWFyayBub2RlcyBkaWZmZXJlbnQgZnJvbSB0aGUgb25lcyBpbiB0aGUgRE9NIGNvbnRleHRcbiAgICAgICAgICAgIHZpZXcubWFya0N1cnNvciA9IHZpZXcuc3RhdGUuc3RvcmVkTWFya3MgfHwgJHBvcy5tYXJrcygpO1xuICAgICAgICAgICAgZW5kQ29tcG9zaXRpb24odmlldywgdHJ1ZSk7XG4gICAgICAgICAgICB2aWV3Lm1hcmtDdXJzb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kQ29tcG9zaXRpb24odmlldyk7XG4gICAgICAgICAgICAvLyBJbiBmaXJlZm94LCBpZiB0aGUgY3Vyc29yIGlzIGFmdGVyIGJ1dCBvdXRzaWRlIGEgbWFya2VkIG5vZGUsXG4gICAgICAgICAgICAvLyB0aGUgaW5zZXJ0ZWQgdGV4dCB3b24ndCBpbmhlcml0IHRoZSBtYXJrcy4gU28gdGhpcyBtb3ZlcyBpdFxuICAgICAgICAgICAgLy8gaW5zaWRlIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgIGlmIChnZWNrbyAmJiBzdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiYgJHBvcy5wYXJlbnRPZmZzZXQgJiYgISRwb3MudGV4dE9mZnNldCAmJiAkcG9zLm5vZGVCZWZvcmUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0OyBub2RlICYmIG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgIT0gMDspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IG9mZnNldCA8IDAgPyBub2RlLmxhc3RDaGlsZCA6IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRvbVNlbGVjdGlvbigpLmNvbGxhcHNlKGJlZm9yZSwgYmVmb3JlLm5vZGVWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBzY2hlZHVsZUNvbXBvc2VFbmQodmlldywgdGltZW91dENvbXBvc2l0aW9uKTtcbn07XG5lZGl0SGFuZGxlcnMuY29tcG9zaXRpb25lbmQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSBldmVudC50aW1lU3RhbXA7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcyA9IHZpZXcuZG9tT2JzZXJ2ZXIucGVuZGluZ1JlY29yZHMoKS5sZW5ndGggPyB2aWV3LmlucHV0LmNvbXBvc2l0aW9uSUQgOiAwO1xuICAgICAgICBpZiAodmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzKVxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB2aWV3LmRvbU9ic2VydmVyLmZsdXNoKCkpO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uSUQrKztcbiAgICAgICAgc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIDIwKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIGRlbGF5KSB7XG4gICAgY2xlYXJUaW1lb3V0KHZpZXcuaW5wdXQuY29tcG9zaW5nVGltZW91dCk7XG4gICAgaWYgKGRlbGF5ID4gLTEpXG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gZW5kQ29tcG9zaXRpb24odmlldyksIGRlbGF5KTtcbn1cbmZ1bmN0aW9uIGNsZWFyQ29tcG9zaXRpb24odmlldykge1xuICAgIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCA9IHRpbWVzdGFtcEZyb21DdXN0b21FdmVudCgpO1xuICAgIH1cbiAgICB3aGlsZSAodmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGVzLmxlbmd0aCA+IDApXG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2Rlcy5wb3AoKS5tYXJrUGFyZW50c0RpcnR5KCk7XG59XG5mdW5jdGlvbiB0aW1lc3RhbXBGcm9tQ3VzdG9tRXZlbnQoKSB7XG4gICAgbGV0IGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICBldmVudC5pbml0RXZlbnQoXCJldmVudFwiLCB0cnVlLCB0cnVlKTtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wO1xufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5mdW5jdGlvbiBlbmRDb21wb3NpdGlvbih2aWV3LCBmb3JjZVVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKGFuZHJvaWQgJiYgdmlldy5kb21PYnNlcnZlci5mbHVzaGluZ1Nvb24gPj0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgIGNsZWFyQ29tcG9zaXRpb24odmlldyk7XG4gICAgaWYgKGZvcmNlVXBkYXRlIHx8IHZpZXcuZG9jVmlldyAmJiB2aWV3LmRvY1ZpZXcuZGlydHkpIHtcbiAgICAgICAgbGV0IHNlbCA9IHNlbGVjdGlvbkZyb21ET00odmlldyk7XG4gICAgICAgIGlmIChzZWwgJiYgIXNlbC5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHZpZXcuc3RhdGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2FwdHVyZUNvcHkodmlldywgZG9tKSB7XG4gICAgLy8gVGhlIGV4dHJhIHdyYXBwZXIgaXMgc29tZWhvdyBuZWNlc3Nhcnkgb24gSUUvRWRnZSB0byBwcmV2ZW50IHRoZVxuICAgIC8vIGNvbnRlbnQgZnJvbSBiZWluZyBtYW5nbGVkIHdoZW4gaXQgaXMgcHV0IG9udG8gdGhlIGNsaXBib2FyZFxuICAgIGlmICghdmlldy5kb20ucGFyZW50Tm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB3cmFwID0gdmlldy5kb20ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICB3cmFwLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgd3JhcC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKCksIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoZG9tKTtcbiAgICAvLyBEb25lIGJlY2F1c2UgSUUgd2lsbCBmaXJlIGEgc2VsZWN0aW9uY2hhbmdlIG1vdmluZyB0aGUgc2VsZWN0aW9uXG4gICAgLy8gdG8gaXRzIHN0YXJ0IHdoZW4gcmVtb3ZlQWxsUmFuZ2VzIGlzIGNhbGxlZCBhbmQgdGhlIGVkaXRvciBzdGlsbFxuICAgIC8vIGhhcyBmb2N1cyAod2hpY2ggd2lsbCBtZXNzIHVwIHRoZSBlZGl0b3IncyBzZWxlY3Rpb24gc3RhdGUpLlxuICAgIHZpZXcuZG9tLmJsdXIoKTtcbiAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHdyYXAucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIHdyYXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3cmFwKTtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIH0sIDUwKTtcbn1cbi8vIFRoaXMgaXMgdmVyeSBjcnVkZSwgYnV0IHVuZm9ydHVuYXRlbHkgYm90aCB0aGVzZSBicm93c2VycyBfcHJldGVuZF9cbi8vIHRoYXQgdGhleSBoYXZlIGEgY2xpcGJvYXJkIEFQSVx1MjAxNGFsbCB0aGUgb2JqZWN0cyBhbmQgbWV0aG9kcyBhcmVcbi8vIHRoZXJlLCB0aGV5IGp1c3QgZG9uJ3Qgd29yaywgYW5kIHRoZXkgYXJlIGhhcmQgdG8gdGVzdC5cbmNvbnN0IGJyb2tlbkNsaXBib2FyZEFQSSA9IChpZSAmJiBpZV92ZXJzaW9uIDwgMTUpIHx8XG4gICAgKGlvcyAmJiB3ZWJraXRfdmVyc2lvbiA8IDYwNCk7XG5oYW5kbGVycy5jb3B5ID0gZWRpdEhhbmRsZXJzLmN1dCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLCBjdXQgPSBldmVudC50eXBlID09IFwiY3V0XCI7XG4gICAgaWYgKHNlbC5lbXB0eSlcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIElFIGFuZCBFZGdlJ3MgY2xpcGJvYXJkIGludGVyZmFjZSBpcyBjb21wbGV0ZWx5IGJyb2tlblxuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgbGV0IHNsaWNlID0gc2VsLmNvbnRlbnQoKSwgeyBkb20sIHRleHQgfSA9IHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBzbGljZSk7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGF0YS5jbGVhckRhdGEoKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9odG1sXCIsIGRvbS5pbm5lckhUTUwpO1xuICAgICAgICBkYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FwdHVyZUNvcHkodmlldywgZG9tKTtcbiAgICB9XG4gICAgaWYgKGN1dClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLmRlbGV0ZVNlbGVjdGlvbigpLnNjcm9sbEludG9WaWV3KCkuc2V0TWV0YShcInVpRXZlbnRcIiwgXCJjdXRcIikpO1xufTtcbmZ1bmN0aW9uIHNsaWNlU2luZ2xlTm9kZShzbGljZSkge1xuICAgIHJldHVybiBzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5vcGVuRW5kID09IDAgJiYgc2xpY2UuY29udGVudC5jaGlsZENvdW50ID09IDEgPyBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQgOiBudWxsO1xufVxuZnVuY3Rpb24gY2FwdHVyZVBhc3RlKHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCF2aWV3LmRvbS5wYXJlbnROb2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHBsYWluVGV4dCA9IHZpZXcuaW5wdXQuc2hpZnRLZXkgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20ucGFyZW50LnR5cGUuc3BlYy5jb2RlO1xuICAgIGxldCB0YXJnZXQgPSB2aWV3LmRvbS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocGxhaW5UZXh0ID8gXCJ0ZXh0YXJlYVwiIDogXCJkaXZcIikpO1xuICAgIGlmICghcGxhaW5UZXh0KVxuICAgICAgICB0YXJnZXQuY29udGVudEVkaXRhYmxlID0gXCJ0cnVlXCI7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC5mb2N1cygpO1xuICAgIGxldCBwbGFpbiA9IHZpZXcuaW5wdXQuc2hpZnRLZXkgJiYgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSAhPSA0NTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICBpZiAodGFyZ2V0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICB0YXJnZXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YXJnZXQpO1xuICAgICAgICBpZiAocGxhaW5UZXh0KVxuICAgICAgICAgICAgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudmFsdWUsIG51bGwsIHBsYWluLCBldmVudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRvUGFzdGUodmlldywgdGFyZ2V0LnRleHRDb250ZW50LCB0YXJnZXQuaW5uZXJIVE1MLCBwbGFpbiwgZXZlbnQpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGRvUGFzdGUodmlldywgdGV4dCwgaHRtbCwgcHJlZmVyUGxhaW4sIGV2ZW50KSB7XG4gICAgbGV0IHNsaWNlID0gcGFyc2VGcm9tQ2xpcGJvYXJkKHZpZXcsIHRleHQsIGh0bWwsIHByZWZlclBsYWluLCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kZnJvbSk7XG4gICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVQYXN0ZVwiLCBmID0+IGYodmlldywgZXZlbnQsIHNsaWNlIHx8IFNsaWNlLmVtcHR5KSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghc2xpY2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2luZ2xlTm9kZSA9IHNsaWNlU2luZ2xlTm9kZShzbGljZSk7XG4gICAgbGV0IHRyID0gc2luZ2xlTm9kZVxuICAgICAgICA/IHZpZXcuc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbldpdGgoc2luZ2xlTm9kZSwgcHJlZmVyUGxhaW4pXG4gICAgICAgIDogdmlldy5zdGF0ZS50ci5yZXBsYWNlU2VsZWN0aW9uKHNsaWNlKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkuc2V0TWV0YShcInBhc3RlXCIsIHRydWUpLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwicGFzdGVcIikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VGV4dChjbGlwYm9hcmREYXRhKSB7XG4gICAgbGV0IHRleHQgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpIHx8IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgaWYgKHRleHQpXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIGxldCB1cmlzID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidGV4dC91cmktbGlzdFwiKTtcbiAgICByZXR1cm4gdXJpcyA/IHVyaXMucmVwbGFjZSgvXFxyP1xcbi9nLCBcIiBcIikgOiBcIlwiO1xufVxuZWRpdEhhbmRsZXJzLnBhc3RlID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICAvLyBIYW5kbGluZyBwYXN0ZSBmcm9tIEphdmFTY3JpcHQgZHVyaW5nIGNvbXBvc2l0aW9uIGlzIHZlcnkgcG9vcmx5XG4gICAgLy8gaGFuZGxlZCBieSBicm93c2Vycywgc28gYXMgYSBkb2RneSBidXQgcHJlZmVyYWJsZSBrbHVkZ2UsIHdlIGp1c3RcbiAgICAvLyBsZXQgdGhlIGJyb3dzZXIgZG8gaXRzIG5hdGl2ZSB0aGluZyB0aGVyZSwgZXhjZXB0IG9uIEFuZHJvaWQsXG4gICAgLy8gd2hlcmUgdGhlIGVkaXRvciBpcyBhbG1vc3QgYWx3YXlzIGNvbXBvc2luZy5cbiAgICBpZiAodmlldy5jb21wb3NpbmcgJiYgIWFuZHJvaWQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGxldCBwbGFpbiA9IHZpZXcuaW5wdXQuc2hpZnRLZXkgJiYgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSAhPSA0NTtcbiAgICBpZiAoZGF0YSAmJiBkb1Bhc3RlKHZpZXcsIGdldFRleHQoZGF0YSksIGRhdGEuZ2V0RGF0YShcInRleHQvaHRtbFwiKSwgcGxhaW4sIGV2ZW50KSlcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBlbHNlXG4gICAgICAgIGNhcHR1cmVQYXN0ZSh2aWV3LCBldmVudCk7XG59O1xuY2xhc3MgRHJhZ2dpbmcge1xuICAgIGNvbnN0cnVjdG9yKHNsaWNlLCBtb3ZlLCBub2RlKSB7XG4gICAgICAgIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgICAgICAgdGhpcy5tb3ZlID0gbW92ZTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG59XG5jb25zdCBkcmFnQ29weU1vZGlmaWVyID0gbWFjID8gXCJhbHRLZXlcIiA6IFwiY3RybEtleVwiO1xuaGFuZGxlcnMuZHJhZ3N0YXJ0ID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBsZXQgbW91c2VEb3duID0gdmlldy5pbnB1dC5tb3VzZURvd247XG4gICAgaWYgKG1vdXNlRG93bilcbiAgICAgICAgbW91c2VEb3duLmRvbmUoKTtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgcG9zID0gc2VsLmVtcHR5ID8gbnVsbCA6IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICBsZXQgbm9kZTtcbiAgICBpZiAocG9zICYmIHBvcy5wb3MgPj0gc2VsLmZyb20gJiYgcG9zLnBvcyA8PSAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiA/IHNlbC50byAtIDEgOiBzZWwudG8pKSA7XG4gICAgZWxzZSBpZiAobW91c2VEb3duICYmIG1vdXNlRG93bi5taWdodERyYWcpIHtcbiAgICAgICAgbm9kZSA9IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBtb3VzZURvd24ubWlnaHREcmFnLnBvcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhldmVudC50YXJnZXQsIHRydWUpO1xuICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSAmJiBkZXNjICE9IHZpZXcuZG9jVmlldylcbiAgICAgICAgICAgIG5vZGUgPSBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgZGVzYy5wb3NCZWZvcmUpO1xuICAgIH1cbiAgICBsZXQgc2xpY2UgPSAobm9kZSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbikuY29udGVudCgpLCB7IGRvbSwgdGV4dCB9ID0gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHZpZXcsIHNsaWNlKTtcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuY2xlYXJEYXRhKCk7XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoYnJva2VuQ2xpcGJvYXJkQVBJID8gXCJUZXh0XCIgOiBcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1Byb3NlTWlycm9yL3Byb3NlbWlycm9yL2lzc3Vlcy8xMTU2XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcImNvcHlNb3ZlXCI7XG4gICAgaWYgKCFicm9rZW5DbGlwYm9hcmRBUEkpXG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB2aWV3LmRyYWdnaW5nID0gbmV3IERyYWdnaW5nKHNsaWNlLCAhZXZlbnRbZHJhZ0NvcHlNb2RpZmllcl0sIG5vZGUpO1xufTtcbmhhbmRsZXJzLmRyYWdlbmQgPSB2aWV3ID0+IHtcbiAgICBsZXQgZHJhZ2dpbmcgPSB2aWV3LmRyYWdnaW5nO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHZpZXcuZHJhZ2dpbmcgPT0gZHJhZ2dpbmcpXG4gICAgICAgICAgICB2aWV3LmRyYWdnaW5nID0gbnVsbDtcbiAgICB9LCA1MCk7XG59O1xuZWRpdEhhbmRsZXJzLmRyYWdvdmVyID0gZWRpdEhhbmRsZXJzLmRyYWdlbnRlciA9IChfLCBlKSA9PiBlLnByZXZlbnREZWZhdWx0KCk7XG5lZGl0SGFuZGxlcnMuZHJvcCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgbGV0IGRyYWdnaW5nID0gdmlldy5kcmFnZ2luZztcbiAgICB2aWV3LmRyYWdnaW5nID0gbnVsbDtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBldmVudFBvcyA9IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICBpZiAoIWV2ZW50UG9zKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0ICRtb3VzZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZXZlbnRQb3MucG9zKTtcbiAgICBsZXQgc2xpY2UgPSBkcmFnZ2luZyAmJiBkcmFnZ2luZy5zbGljZTtcbiAgICBpZiAoc2xpY2UpIHtcbiAgICAgICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFwiLCBmID0+IHsgc2xpY2UgPSBmKHNsaWNlLCB2aWV3KTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCBnZXRUZXh0KGV2ZW50LmRhdGFUcmFuc2ZlciksIGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHQvaHRtbFwiKSwgZmFsc2UsICRtb3VzZSk7XG4gICAgfVxuICAgIGxldCBtb3ZlID0gISEoZHJhZ2dpbmcgJiYgIWV2ZW50W2RyYWdDb3B5TW9kaWZpZXJdKTtcbiAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZURyb3BcIiwgZiA9PiBmKHZpZXcsIGV2ZW50LCBzbGljZSB8fCBTbGljZS5lbXB0eSwgbW92ZSkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzbGljZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgbGV0IGluc2VydFBvcyA9IHNsaWNlID8gZHJvcFBvaW50KHZpZXcuc3RhdGUuZG9jLCAkbW91c2UucG9zLCBzbGljZSkgOiAkbW91c2UucG9zO1xuICAgIGlmIChpbnNlcnRQb3MgPT0gbnVsbClcbiAgICAgICAgaW5zZXJ0UG9zID0gJG1vdXNlLnBvcztcbiAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyO1xuICAgIGlmIChtb3ZlKSB7XG4gICAgICAgIGxldCB7IG5vZGUgfSA9IGRyYWdnaW5nO1xuICAgICAgICBpZiAobm9kZSlcbiAgICAgICAgICAgIG5vZGUucmVwbGFjZSh0cik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRyLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBsZXQgcG9zID0gdHIubWFwcGluZy5tYXAoaW5zZXJ0UG9zKTtcbiAgICBsZXQgaXNOb2RlID0gc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uub3BlbkVuZCA9PSAwICYmIHNsaWNlLmNvbnRlbnQuY2hpbGRDb3VudCA9PSAxO1xuICAgIGxldCBiZWZvcmVJbnNlcnQgPSB0ci5kb2M7XG4gICAgaWYgKGlzTm9kZSlcbiAgICAgICAgdHIucmVwbGFjZVJhbmdlV2l0aChwb3MsIHBvcywgc2xpY2UuY29udGVudC5maXJzdENoaWxkKTtcbiAgICBlbHNlXG4gICAgICAgIHRyLnJlcGxhY2VSYW5nZShwb3MsIHBvcywgc2xpY2UpO1xuICAgIGlmICh0ci5kb2MuZXEoYmVmb3JlSW5zZXJ0KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCAkcG9zID0gdHIuZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoaXNOb2RlICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCkgJiZcbiAgICAgICAgJHBvcy5ub2RlQWZ0ZXIgJiYgJHBvcy5ub2RlQWZ0ZXIuc2FtZU1hcmt1cChzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpKSB7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihuZXcgTm9kZVNlbGVjdGlvbigkcG9zKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgZW5kID0gdHIubWFwcGluZy5tYXAoaW5zZXJ0UG9zKTtcbiAgICAgICAgdHIubWFwcGluZy5tYXBzW3RyLm1hcHBpbmcubWFwcy5sZW5ndGggLSAxXS5mb3JFYWNoKChfZnJvbSwgX3RvLCBfbmV3RnJvbSwgbmV3VG8pID0+IGVuZCA9IG5ld1RvKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbkJldHdlZW4odmlldywgJHBvcywgdHIuZG9jLnJlc29sdmUoZW5kKSkpO1xuICAgIH1cbiAgICB2aWV3LmZvY3VzKCk7XG4gICAgdmlldy5kaXNwYXRjaCh0ci5zZXRNZXRhKFwidWlFdmVudFwiLCBcImRyb3BcIikpO1xufTtcbmhhbmRsZXJzLmZvY3VzID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dC5sYXN0Rm9jdXMgPSBEYXRlLm5vdygpO1xuICAgIGlmICghdmlldy5mb2N1c2VkKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3ItZm9jdXNlZFwiKTtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB2aWV3LmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmRvY1ZpZXcgJiYgdmlldy5oYXNGb2N1cygpICYmICF2aWV3LmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb24uZXEodmlldy5kb21TZWxlY3Rpb25SYW5nZSgpKSlcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgfSwgMjApO1xuICAgIH1cbn07XG5oYW5kbGVycy5ibHVyID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBpZiAodmlldy5mb2N1c2VkKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3ItZm9jdXNlZFwiKTtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICBpZiAoZXZlbnQucmVsYXRlZFRhcmdldCAmJiB2aWV3LmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgICB2aWV3LmZvY3VzZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuaGFuZGxlcnMuYmVmb3JlaW5wdXQgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIC8vIFdlIHNob3VsZCBwcm9iYWJseSBkbyBtb3JlIHdpdGggYmVmb3JlaW5wdXQgZXZlbnRzLCBidXQgc3VwcG9ydFxuICAgIC8vIGlzIHNvIHNwb3R0eSB0aGF0IEknbSBzdGlsbCB3YWl0aW5nIHRvIHNlZSB3aGVyZSB0aGV5IGFyZSBnb2luZy5cbiAgICAvLyBWZXJ5IHNwZWNpZmljIGhhY2sgdG8gZGVhbCB3aXRoIGJhY2tzcGFjZSBzb21ldGltZXMgZmFpbGluZyBvblxuICAgIC8vIENocm9tZSBBbmRyb2lkIHdoZW4gYWZ0ZXIgYW4gdW5lZGl0YWJsZSBub2RlLlxuICAgIGlmIChjaHJvbWUgJiYgYW5kcm9pZCAmJiBldmVudC5pbnB1dFR5cGUgPT0gXCJkZWxldGVDb250ZW50QmFja3dhcmRcIikge1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmZsdXNoU29vbigpO1xuICAgICAgICBsZXQgeyBkb21DaGFuZ2VDb3VudCB9ID0gdmlldy5pbnB1dDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dC5kb21DaGFuZ2VDb3VudCAhPSBkb21DaGFuZ2VDb3VudClcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEV2ZW50IGFscmVhZHkgaGFkIHNvbWUgZWZmZWN0XG4gICAgICAgICAgICAvLyBUaGlzIGJ1ZyB0ZW5kcyB0byBjbG9zZSB0aGUgdmlydHVhbCBrZXlib2FyZCwgc28gd2UgcmVmb2N1c1xuICAgICAgICAgICAgdmlldy5kb20uYmx1cigpO1xuICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICAgICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCg4LCBcIkJhY2tzcGFjZVwiKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB7ICRjdXJzb3IgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgLy8gQ3J1ZGUgYXBwcm94aW1hdGlvbiBvZiBiYWNrc3BhY2UgYmVoYXZpb3Igd2hlbiBubyBjb21tYW5kIGhhbmRsZWQgaXRcbiAgICAgICAgICAgIGlmICgkY3Vyc29yICYmICRjdXJzb3IucG9zID4gMClcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuZGVsZXRlKCRjdXJzb3IucG9zIC0gMSwgJGN1cnNvci5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9LCA1MCk7XG4gICAgfVxufTtcbi8vIE1ha2Ugc3VyZSBhbGwgaGFuZGxlcnMgZ2V0IHJlZ2lzdGVyZWRcbmZvciAobGV0IHByb3AgaW4gZWRpdEhhbmRsZXJzKVxuICAgIGhhbmRsZXJzW3Byb3BdID0gZWRpdEhhbmRsZXJzW3Byb3BdO1xuXG5mdW5jdGlvbiBjb21wYXJlT2JqcyhhLCBiKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZm9yIChsZXQgcCBpbiBhKVxuICAgICAgICBpZiAoYVtwXSAhPT0gYltwXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBwIGluIGIpXG4gICAgICAgIGlmICghKHAgaW4gYSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jbGFzcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih0b0RPTSwgc3BlYykge1xuICAgICAgICB0aGlzLnRvRE9NID0gdG9ET007XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWMgfHwgbm9TcGVjO1xuICAgICAgICB0aGlzLnNpZGUgPSB0aGlzLnNwZWMuc2lkZSB8fCAwO1xuICAgIH1cbiAgICBtYXAobWFwcGluZywgc3Bhbiwgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgbGV0IHsgcG9zLCBkZWxldGVkIH0gPSBtYXBwaW5nLm1hcFJlc3VsdChzcGFuLmZyb20gKyBvbGRPZmZzZXQsIHRoaXMuc2lkZSA8IDAgPyAtMSA6IDEpO1xuICAgICAgICByZXR1cm4gZGVsZXRlZCA/IG51bGwgOiBuZXcgRGVjb3JhdGlvbihwb3MgLSBvZmZzZXQsIHBvcyAtIG9mZnNldCwgdGhpcyk7XG4gICAgfVxuICAgIHZhbGlkKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBXaWRnZXRUeXBlICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuc3BlYy5rZXkgJiYgdGhpcy5zcGVjLmtleSA9PSBvdGhlci5zcGVjLmtleSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvRE9NID09IG90aGVyLnRvRE9NICYmIGNvbXBhcmVPYmpzKHRoaXMuc3BlYywgb3RoZXIuc3BlYykpKTtcbiAgICB9XG4gICAgZGVzdHJveShub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLnNwZWMuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMuc3BlYy5kZXN0cm95KG5vZGUpO1xuICAgIH1cbn1cbmNsYXNzIElubGluZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwKHNwYW4uZnJvbSArIG9sZE9mZnNldCwgdGhpcy5zcGVjLmluY2x1c2l2ZVN0YXJ0ID8gLTEgOiAxKSAtIG9mZnNldDtcbiAgICAgICAgbGV0IHRvID0gbWFwcGluZy5tYXAoc3Bhbi50byArIG9sZE9mZnNldCwgdGhpcy5zcGVjLmluY2x1c2l2ZUVuZCA/IDEgOiAtMSkgLSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiBmcm9tID49IHRvID8gbnVsbCA6IG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCB0aGlzKTtcbiAgICB9XG4gICAgdmFsaWQoXywgc3BhbikgeyByZXR1cm4gc3Bhbi5mcm9tIDwgc3Bhbi50bzsgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBJbmxpbmVUeXBlICYmIGNvbXBhcmVPYmpzKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVPYmpzKHRoaXMuc3BlYywgb3RoZXIuc3BlYykpO1xuICAgIH1cbiAgICBzdGF0aWMgaXMoc3BhbikgeyByZXR1cm4gc3Bhbi50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZTsgfVxuICAgIGRlc3Ryb3koKSB7IH1cbn1cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihhdHRycywgc3BlYykge1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWMgfHwgbm9TcGVjO1xuICAgIH1cbiAgICBtYXAobWFwcGluZywgc3Bhbiwgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdChzcGFuLmZyb20gKyBvbGRPZmZzZXQsIDEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4udG8gKyBvbGRPZmZzZXQsIC0xKTtcbiAgICAgICAgaWYgKHRvLmRlbGV0ZWQgfHwgdG8ucG9zIDw9IGZyb20ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLnBvcyAtIG9mZnNldCwgdG8ucG9zIC0gb2Zmc2V0LCB0aGlzKTtcbiAgICB9XG4gICAgdmFsaWQobm9kZSwgc3Bhbikge1xuICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KHNwYW4uZnJvbSksIGNoaWxkO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID09IHNwYW4uZnJvbSAmJiAhKGNoaWxkID0gbm9kZS5jaGlsZChpbmRleCkpLmlzVGV4dCAmJiBvZmZzZXQgKyBjaGlsZC5ub2RlU2l6ZSA9PSBzcGFuLnRvO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgKG90aGVyIGluc3RhbmNlb2YgTm9kZVR5cGUgJiYgY29tcGFyZU9ianModGhpcy5hdHRycywgb3RoZXIuYXR0cnMpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7IH1cbn1cbi8qKlxuRGVjb3JhdGlvbiBvYmplY3RzIGNhbiBiZSBwcm92aWRlZCB0byB0aGUgdmlldyB0aHJvdWdoIHRoZVxuW2BkZWNvcmF0aW9uc2AgcHJvcF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMuZGVjb3JhdGlvbnMpLiBUaGV5IGNvbWUgaW5cbnNldmVyYWwgdmFyaWFudHNcdTIwMTRzZWUgdGhlIHN0YXRpYyBtZW1iZXJzIG9mIHRoaXMgY2xhc3MgZm9yIGRldGFpbHMuXG4qL1xuY2xhc3MgRGVjb3JhdGlvbiB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIGRlY29yYXRpb24uXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uLiBXaWxsIGJlIHRoZSBzYW1lIGFzIGBmcm9tYCBmb3IgW3dpZGdldFxuICAgIGRlY29yYXRpb25zXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uXndpZGdldCkuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0eXBlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb3B5KGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgdGhpcy50eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlcShvdGhlciwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlLmVxKG90aGVyLnR5cGUpICYmIHRoaXMuZnJvbSArIG9mZnNldCA9PSBvdGhlci5mcm9tICYmIHRoaXMudG8gKyBvZmZzZXQgPT0gb3RoZXIudG87XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUubWFwKG1hcHBpbmcsIHRoaXMsIG9mZnNldCwgb2xkT2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlcyBhIHdpZGdldCBkZWNvcmF0aW9uLCB3aGljaCBpcyBhIERPTSBub2RlIHRoYXQncyBzaG93biBpblxuICAgIHRoZSBkb2N1bWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91XG4gICAgZGVsYXkgcmVuZGVyaW5nIHRoZSB3aWRnZXQgYnkgcGFzc2luZyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICAgIGNhbGxlZCB3aGVuIHRoZSB3aWRnZXQgaXMgYWN0dWFsbHkgZHJhd24gaW4gYSB2aWV3LCBidXQgeW91IGNhblxuICAgIGFsc28gZGlyZWN0bHkgcGFzcyBhIERPTSBub2RlLiBgZ2V0UG9zYCBjYW4gYmUgdXNlZCB0byBmaW5kIHRoZVxuICAgIHdpZGdldCdzIGN1cnJlbnQgZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgd2lkZ2V0KHBvcywgdG9ET00sIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKHBvcywgcG9zLCBuZXcgV2lkZ2V0VHlwZSh0b0RPTSwgc3BlYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGFuIGlubGluZSBkZWNvcmF0aW9uLCB3aGljaCBhZGRzIHRoZSBnaXZlbiBhdHRyaWJ1dGVzIHRvXG4gICAgZWFjaCBpbmxpbmUgbm9kZSBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC5cbiAgICAqL1xuICAgIHN0YXRpYyBpbmxpbmUoZnJvbSwgdG8sIGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgbmV3IElubGluZVR5cGUoYXR0cnMsIHNwZWMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlcyBhIG5vZGUgZGVjb3JhdGlvbi4gYGZyb21gIGFuZCBgdG9gIHNob3VsZCBwb2ludCBwcmVjaXNlbHlcbiAgICBiZWZvcmUgYW5kIGFmdGVyIGEgbm9kZSBpbiB0aGUgZG9jdW1lbnQuIFRoYXQgbm9kZSwgYW5kIG9ubHkgdGhhdFxuICAgIG5vZGUsIHdpbGwgcmVjZWl2ZSB0aGUgZ2l2ZW4gYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBub2RlKGZyb20sIHRvLCBhdHRycywgc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIG5ldyBOb2RlVHlwZShhdHRycywgc3BlYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc3BlYyBwcm92aWRlZCB3aGVuIGNyZWF0aW5nIHRoaXMgZGVjb3JhdGlvbi4gQ2FuIGJlIHVzZWZ1bFxuICAgIGlmIHlvdSd2ZSBzdG9yZWQgZXh0cmEgaW5mb3JtYXRpb24gaW4gdGhhdCBvYmplY3QuXG4gICAgKi9cbiAgICBnZXQgc3BlYygpIHsgcmV0dXJuIHRoaXMudHlwZS5zcGVjOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaW5saW5lKCkgeyByZXR1cm4gdGhpcy50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHdpZGdldCgpIHsgcmV0dXJuIHRoaXMudHlwZSBpbnN0YW5jZW9mIFdpZGdldFR5cGU7IH1cbn1cbmNvbnN0IG5vbmUgPSBbXSwgbm9TcGVjID0ge307XG4vKipcbkEgY29sbGVjdGlvbiBvZiBbZGVjb3JhdGlvbnNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb24pLCBvcmdhbml6ZWQgaW4gc3VjaFxuYSB3YXkgdGhhdCB0aGUgZHJhd2luZyBhbGdvcml0aG0gY2FuIGVmZmljaWVudGx5IHVzZSBhbmQgY29tcGFyZVxudGhlbS4gVGhpcyBpcyBhIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVcdTIwMTRpdCBpcyBub3QgbW9kaWZpZWQsXG51cGRhdGVzIGNyZWF0ZSBhIG5ldyB2YWx1ZS5cbiovXG5jbGFzcyBEZWNvcmF0aW9uU2V0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsLCBjaGlsZHJlbikge1xuICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWwubGVuZ3RoID8gbG9jYWwgOiBub25lO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoID8gY2hpbGRyZW4gOiBub25lO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXQgb2YgZGVjb3JhdGlvbnMsIHVzaW5nIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGdpdmVuXG4gICAgZG9jdW1lbnQuIFRoaXMgd2lsbCBjb25zdW1lIChtb2RpZnkpIHRoZSBgZGVjb3JhdGlvbnNgIGFycmF5LCBzb1xuICAgIHlvdSBtdXN0IG1ha2UgYSBjb3B5IGlmIHlvdSB3YW50IG5lZWQgdG8gcHJlc2VydmUgdGhhdC5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZG9jLCBkZWNvcmF0aW9ucykge1xuICAgICAgICByZXR1cm4gZGVjb3JhdGlvbnMubGVuZ3RoID8gYnVpbGRUcmVlKGRlY29yYXRpb25zLCBkb2MsIDAsIG5vU3BlYykgOiBlbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBhbGwgZGVjb3JhdGlvbnMgaW4gdGhpcyBzZXQgd2hpY2ggdG91Y2ggdGhlIGdpdmVuIHJhbmdlXG4gICAgKGluY2x1ZGluZyBkZWNvcmF0aW9ucyB0aGF0IHN0YXJ0IG9yIGVuZCBkaXJlY3RseSBhdCB0aGVcbiAgICBib3VuZGFyaWVzKSBhbmQgbWF0Y2ggdGhlIGdpdmVuIHByZWRpY2F0ZSBvbiB0aGVpciBzcGVjLiBXaGVuXG4gICAgYHN0YXJ0YCBhbmQgYGVuZGAgYXJlIG9taXR0ZWQsIGFsbCBkZWNvcmF0aW9ucyBpbiB0aGUgc2V0IGFyZVxuICAgIGNvbnNpZGVyZWQuIFdoZW4gYHByZWRpY2F0ZWAgaXNuJ3QgZ2l2ZW4sIGFsbCBkZWNvcmF0aW9ucyBhcmVcbiAgICBhc3N1bWVkIHRvIG1hdGNoLlxuICAgICovXG4gICAgZmluZChzdGFydCwgZW5kLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmZpbmRJbm5lcihzdGFydCA9PSBudWxsID8gMCA6IHN0YXJ0LCBlbmQgPT0gbnVsbCA/IDFlOSA6IGVuZCwgcmVzdWx0LCAwLCBwcmVkaWNhdGUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmaW5kSW5uZXIoc3RhcnQsIGVuZCwgcmVzdWx0LCBvZmZzZXQsIHByZWRpY2F0ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzcGFuID0gdGhpcy5sb2NhbFtpXTtcbiAgICAgICAgICAgIGlmIChzcGFuLmZyb20gPD0gZW5kICYmIHNwYW4udG8gPj0gc3RhcnQgJiYgKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlKHNwYW4uc3BlYykpKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYW4uY29weShzcGFuLmZyb20gKyBvZmZzZXQsIHNwYW4udG8gKyBvZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldIDwgZW5kICYmIHRoaXMuY2hpbGRyZW5baSArIDFdID4gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRPZmYgPSB0aGlzLmNoaWxkcmVuW2ldICsgMTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2kgKyAyXS5maW5kSW5uZXIoc3RhcnQgLSBjaGlsZE9mZiwgZW5kIC0gY2hpbGRPZmYsIHJlc3VsdCwgb2Zmc2V0ICsgY2hpbGRPZmYsIHByZWRpY2F0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIHRoZSBzZXQgb2YgZGVjb3JhdGlvbnMgaW4gcmVzcG9uc2UgdG8gYSBjaGFuZ2UgaW4gdGhlXG4gICAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBtYXAobWFwcGluZywgZG9jLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzID09IGVtcHR5IHx8IG1hcHBpbmcubWFwcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBJbm5lcihtYXBwaW5nLCBkb2MsIDAsIDAsIG9wdGlvbnMgfHwgbm9TcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXBJbm5lcihtYXBwaW5nLCBub2RlLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucykge1xuICAgICAgICBsZXQgbmV3TG9jYWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHRoaXMubG9jYWxbaV0ubWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChtYXBwZWQgJiYgbWFwcGVkLnR5cGUudmFsaWQobm9kZSwgbWFwcGVkKSlcbiAgICAgICAgICAgICAgICAobmV3TG9jYWwgfHwgKG5ld0xvY2FsID0gW10pKS5wdXNoKG1hcHBlZCk7XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uUmVtb3ZlKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZW1vdmUodGhpcy5sb2NhbFtpXS5zcGVjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbWFwQ2hpbGRyZW4odGhpcy5jaGlsZHJlbiwgbmV3TG9jYWwgfHwgW10sIG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG5ld0xvY2FsID8gbmV3IERlY29yYXRpb25TZXQobmV3TG9jYWwuc29ydChieVBvcyksIG5vbmUpIDogZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVjb3JhdGlvbnMgdG8gdGhlIG9uZXMgaW4gdGhlIHNldCxcbiAgICBwcm9kdWNpbmcgYSBuZXcgc2V0LiBDb25zdW1lcyB0aGUgYGRlY29yYXRpb25zYCBhcnJheS4gTmVlZHNcbiAgICBhY2Nlc3MgdG8gdGhlIGN1cnJlbnQgZG9jdW1lbnQgdG8gY3JlYXRlIHRoZSBhcHByb3ByaWF0ZSB0cmVlXG4gICAgc3RydWN0dXJlLlxuICAgICovXG4gICAgYWRkKGRvYywgZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgaWYgKCFkZWNvcmF0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoZG9jLCBkZWNvcmF0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZElubmVyKGRvYywgZGVjb3JhdGlvbnMsIDApO1xuICAgIH1cbiAgICBhZGRJbm5lcihkb2MsIGRlY29yYXRpb25zLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuLCBjaGlsZEluZGV4ID0gMDtcbiAgICAgICAgZG9jLmZvckVhY2goKGNoaWxkTm9kZSwgY2hpbGRPZmZzZXQpID0+IHtcbiAgICAgICAgICAgIGxldCBiYXNlT2Zmc2V0ID0gY2hpbGRPZmZzZXQgKyBvZmZzZXQsIGZvdW5kO1xuICAgICAgICAgICAgaWYgKCEoZm91bmQgPSB0YWtlU3BhbnNGb3JOb2RlKGRlY29yYXRpb25zLCBjaGlsZE5vZGUsIGJhc2VPZmZzZXQpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICAgICAgd2hpbGUgKGNoaWxkSW5kZXggPCBjaGlsZHJlbi5sZW5ndGggJiYgY2hpbGRyZW5bY2hpbGRJbmRleF0gPCBjaGlsZE9mZnNldClcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4ICs9IDM7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5bY2hpbGRJbmRleF0gPT0gY2hpbGRPZmZzZXQpXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5bY2hpbGRJbmRleCArIDJdID0gY2hpbGRyZW5bY2hpbGRJbmRleCArIDJdLmFkZElubmVyKGNoaWxkTm9kZSwgZm91bmQsIGJhc2VPZmZzZXQgKyAxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoY2hpbGRJbmRleCwgMCwgY2hpbGRPZmZzZXQsIGNoaWxkT2Zmc2V0ICsgY2hpbGROb2RlLm5vZGVTaXplLCBidWlsZFRyZWUoZm91bmQsIGNoaWxkTm9kZSwgYmFzZU9mZnNldCArIDEsIG5vU3BlYykpO1xuICAgICAgICAgICAgY2hpbGRJbmRleCArPSAzO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGxvY2FsID0gbW92ZVNwYW5zKGNoaWxkSW5kZXggPyB3aXRob3V0TnVsbHMoZGVjb3JhdGlvbnMpIDogZGVjb3JhdGlvbnMsIC1vZmZzZXQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFsb2NhbFtpXS50eXBlLnZhbGlkKGRvYywgbG9jYWxbaV0pKVxuICAgICAgICAgICAgICAgIGxvY2FsLnNwbGljZShpLS0sIDEpO1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb25TZXQobG9jYWwubGVuZ3RoID8gdGhpcy5sb2NhbC5jb25jYXQobG9jYWwpLnNvcnQoYnlQb3MpIDogdGhpcy5sb2NhbCwgY2hpbGRyZW4gfHwgdGhpcy5jaGlsZHJlbik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzZXQgdGhhdCBjb250YWlucyB0aGUgZGVjb3JhdGlvbnMgaW4gdGhpcyBzZXQsIG1pbnVzXG4gICAgdGhlIG9uZXMgaW4gdGhlIGdpdmVuIGFycmF5LlxuICAgICovXG4gICAgcmVtb3ZlKGRlY29yYXRpb25zKSB7XG4gICAgICAgIGlmIChkZWNvcmF0aW9ucy5sZW5ndGggPT0gMCB8fCB0aGlzID09IGVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUlubmVyKGRlY29yYXRpb25zLCAwKTtcbiAgICB9XG4gICAgcmVtb3ZlSW5uZXIoZGVjb3JhdGlvbnMsIG9mZnNldCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLCBsb2NhbCA9IHRoaXMubG9jYWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZDtcbiAgICAgICAgICAgIGxldCBmcm9tID0gY2hpbGRyZW5baV0gKyBvZmZzZXQsIHRvID0gY2hpbGRyZW5baSArIDFdICsgb2Zmc2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIHNwYW47IGogPCBkZWNvcmF0aW9ucy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAoc3BhbiA9IGRlY29yYXRpb25zW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGFuLmZyb20gPiBmcm9tICYmIHNwYW4udG8gPCB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb3JhdGlvbnNbal0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZvdW5kIHx8IChmb3VuZCA9IFtdKSkucHVzaChzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4gPT0gdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgICAgIGxldCByZW1vdmVkID0gY2hpbGRyZW5baSArIDJdLnJlbW92ZUlubmVyKGZvdW5kLCBmcm9tICsgMSk7XG4gICAgICAgICAgICBpZiAocmVtb3ZlZCAhPSBlbXB0eSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAyXSA9IHJlbW92ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMyk7XG4gICAgICAgICAgICAgICAgaSAtPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbC5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgc3BhbjsgaSA8IGRlY29yYXRpb25zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChzcGFuID0gZGVjb3JhdGlvbnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsb2NhbC5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFtqXS5lcShzcGFuLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsID09IHRoaXMubG9jYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsID0gdGhpcy5sb2NhbC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsLnNwbGljZShqLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkcmVuID09IHRoaXMuY2hpbGRyZW4gJiYgbG9jYWwgPT0gdGhpcy5sb2NhbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbG9jYWwubGVuZ3RoIHx8IGNoaWxkcmVuLmxlbmd0aCA/IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FsLCBjaGlsZHJlbikgOiBlbXB0eTtcbiAgICB9XG4gICAgZm9yQ2hpbGQob2Zmc2V0LCBub2RlKSB7XG4gICAgICAgIGlmICh0aGlzID09IGVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChub2RlLmlzTGVhZilcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmVtcHR5O1xuICAgICAgICBsZXQgY2hpbGQsIGxvY2FsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSA+PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSA9PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpICsgMl07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IG9mZnNldCArIDEsIGVuZCA9IHN0YXJ0ICsgbm9kZS5jb250ZW50LnNpemU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGRlYyA9IHRoaXMubG9jYWxbaV07XG4gICAgICAgICAgICBpZiAoZGVjLmZyb20gPCBlbmQgJiYgZGVjLnRvID4gc3RhcnQgJiYgKGRlYy50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KHN0YXJ0LCBkZWMuZnJvbSkgLSBzdGFydCwgdG8gPSBNYXRoLm1pbihlbmQsIGRlYy50bykgLSBzdGFydDtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHRvKVxuICAgICAgICAgICAgICAgICAgICAobG9jYWwgfHwgKGxvY2FsID0gW10pKS5wdXNoKGRlYy5jb3B5KGZyb20sIHRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgICAgICBsZXQgbG9jYWxTZXQgPSBuZXcgRGVjb3JhdGlvblNldChsb2NhbC5zb3J0KGJ5UG9zKSwgbm9uZSk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQgPyBuZXcgRGVjb3JhdGlvbkdyb3VwKFtsb2NhbFNldCwgY2hpbGRdKSA6IGxvY2FsU2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBlbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAodGhpcyA9PSBvdGhlcilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIERlY29yYXRpb25TZXQpIHx8XG4gICAgICAgICAgICB0aGlzLmxvY2FsLmxlbmd0aCAhPSBvdGhlci5sb2NhbC5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9IG90aGVyLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmxvY2FsW2ldLmVxKG90aGVyLmxvY2FsW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldICE9IG90aGVyLmNoaWxkcmVuW2ldIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpICsgMV0gIT0gb3RoZXIuY2hpbGRyZW5baSArIDFdIHx8XG4gICAgICAgICAgICAgICAgIXRoaXMuY2hpbGRyZW5baSArIDJdLmVxKG90aGVyLmNoaWxkcmVuW2kgKyAyXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBsb2NhbHMobm9kZSkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlT3ZlcmxhcCh0aGlzLmxvY2Fsc0lubmVyKG5vZGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBsb2NhbHNJbm5lcihub2RlKSB7XG4gICAgICAgIGlmICh0aGlzID09IGVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIG5vbmU7XG4gICAgICAgIGlmIChub2RlLmlubGluZUNvbnRlbnQgfHwgIXRoaXMubG9jYWwuc29tZShJbmxpbmVUeXBlLmlzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5sb2NhbFtpXS50eXBlIGluc3RhbmNlb2YgSW5saW5lVHlwZSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5sb2NhbFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcblRoZSBlbXB0eSBzZXQgb2YgZGVjb3JhdGlvbnMuXG4qL1xuRGVjb3JhdGlvblNldC5lbXB0eSA9IG5ldyBEZWNvcmF0aW9uU2V0KFtdLCBbXSk7XG4vKipcbkBpbnRlcm5hbFxuKi9cbkRlY29yYXRpb25TZXQucmVtb3ZlT3ZlcmxhcCA9IHJlbW92ZU92ZXJsYXA7XG5jb25zdCBlbXB0eSA9IERlY29yYXRpb25TZXQuZW1wdHk7XG4vLyBBbiBhYnN0cmFjdGlvbiB0aGF0IGFsbG93cyB0aGUgY29kZSBkZWFsaW5nIHdpdGggZGVjb3JhdGlvbnMgdG9cbi8vIHRyZWF0IG11bHRpcGxlIERlY29yYXRpb25TZXQgb2JqZWN0cyBhcyBpZiBpdCB3ZXJlIGEgc2luZ2xlIG9iamVjdFxuLy8gd2l0aCAoYSBzdWJzZXQgb2YpIHRoZSBzYW1lIGludGVyZmFjZS5cbmNsYXNzIERlY29yYXRpb25Hcm91cCB7XG4gICAgY29uc3RydWN0b3IobWVtYmVycykge1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSBtZW1iZXJzO1xuICAgIH1cbiAgICBtYXAobWFwcGluZywgZG9jKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlZERlY29zID0gdGhpcy5tZW1iZXJzLm1hcChtZW1iZXIgPT4gbWVtYmVyLm1hcChtYXBwaW5nLCBkb2MsIG5vU3BlYykpO1xuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbkdyb3VwLmZyb20obWFwcGVkRGVjb3MpO1xuICAgIH1cbiAgICBmb3JDaGlsZChvZmZzZXQsIGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZC5pc0xlYWYpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5lbXB0eTtcbiAgICAgICAgbGV0IGZvdW5kID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5tZW1iZXJzW2ldLmZvckNoaWxkKG9mZnNldCwgY2hpbGQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBlbXB0eSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBEZWNvcmF0aW9uR3JvdXApXG4gICAgICAgICAgICAgICAgZm91bmQgPSBmb3VuZC5jb25jYXQocmVzdWx0Lm1lbWJlcnMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGZvdW5kLnB1c2gocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbkdyb3VwLmZyb20oZm91bmQpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIERlY29yYXRpb25Hcm91cCkgfHxcbiAgICAgICAgICAgIG90aGVyLm1lbWJlcnMubGVuZ3RoICE9IHRoaXMubWVtYmVycy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLm1lbWJlcnNbaV0uZXEob3RoZXIubWVtYmVyc1tpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbG9jYWxzKG5vZGUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCwgc29ydGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsb2NhbHMgPSB0aGlzLm1lbWJlcnNbaV0ubG9jYWxzSW5uZXIobm9kZSk7XG4gICAgICAgICAgICBpZiAoIWxvY2Fscy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxvY2FscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvY2Fscy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobG9jYWxzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ID8gcmVtb3ZlT3ZlcmxhcChzb3J0ZWQgPyByZXN1bHQgOiByZXN1bHQuc29ydChieVBvcykpIDogbm9uZTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgZ3JvdXAgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiBkZWNvcmF0aW9uIHNldHMsIG9yIHJldHVyblxuICAgIC8vIGEgc2luZ2xlIHNldCB3aGVuIHBvc3NpYmxlLlxuICAgIHN0YXRpYyBmcm9tKG1lbWJlcnMpIHtcbiAgICAgICAgc3dpdGNoIChtZW1iZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gZW1wdHk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBtZW1iZXJzWzBdO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIG5ldyBEZWNvcmF0aW9uR3JvdXAobWVtYmVycy5ldmVyeShtID0+IG0gaW5zdGFuY2VvZiBEZWNvcmF0aW9uU2V0KSA/IG1lbWJlcnMgOlxuICAgICAgICAgICAgICAgIG1lbWJlcnMucmVkdWNlKChyLCBtKSA9PiByLmNvbmNhdChtIGluc3RhbmNlb2YgRGVjb3JhdGlvblNldCA/IG0gOiBtLm1lbWJlcnMpLCBbXSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwQ2hpbGRyZW4ob2xkQ2hpbGRyZW4sIG5ld0xvY2FsLCBtYXBwaW5nLCBub2RlLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucykge1xuICAgIGxldCBjaGlsZHJlbiA9IG9sZENoaWxkcmVuLnNsaWNlKCk7XG4gICAgLy8gTWFyayB0aGUgY2hpbGRyZW4gdGhhdCBhcmUgZGlyZWN0bHkgdG91Y2hlZCBieSBjaGFuZ2VzLCBhbmRcbiAgICAvLyBtb3ZlIHRob3NlIHRoYXQgYXJlIGFmdGVyIHRoZSBjaGFuZ2VzLlxuICAgIGZvciAobGV0IGkgPSAwLCBiYXNlT2Zmc2V0ID0gb2xkT2Zmc2V0OyBpIDwgbWFwcGluZy5tYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBtb3ZlZCA9IDA7XG4gICAgICAgIG1hcHBpbmcubWFwc1tpXS5mb3JFYWNoKChvbGRTdGFydCwgb2xkRW5kLCBuZXdTdGFydCwgbmV3RW5kKSA9PiB7XG4gICAgICAgICAgICBsZXQgZFNpemUgPSAobmV3RW5kIC0gbmV3U3RhcnQpIC0gKG9sZEVuZCAtIG9sZFN0YXJ0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gY2hpbGRyZW5baSArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPCAwIHx8IG9sZFN0YXJ0ID4gZW5kICsgYmFzZU9mZnNldCAtIG1vdmVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBjaGlsZHJlbltpXSArIGJhc2VPZmZzZXQgLSBtb3ZlZDtcbiAgICAgICAgICAgICAgICBpZiAob2xkRW5kID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAxXSA9IG9sZFN0YXJ0IDw9IHN0YXJ0ID8gLTIgOiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkU3RhcnQgPj0gYmFzZU9mZnNldCAmJiBkU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSArPSBkU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdICs9IGRTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vdmVkICs9IGRTaXplO1xuICAgICAgICB9KTtcbiAgICAgICAgYmFzZU9mZnNldCA9IG1hcHBpbmcubWFwc1tpXS5tYXAoYmFzZU9mZnNldCwgLTEpO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBjaGlsZCBub2RlcyB0aGF0IHN0aWxsIGNvcnJlc3BvbmQgdG8gYSBzaW5nbGUgbm9kZSxcbiAgICAvLyByZWN1cnNpdmVseSBjYWxsIG1hcElubmVyIG9uIHRoZW0gYW5kIHVwZGF0ZSB0aGVpciBwb3NpdGlvbnMuXG4gICAgbGV0IG11c3RSZWJ1aWxkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA8IDApIHsgLy8gVG91Y2hlZCBub2Rlc1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA9PSAtMikge1xuICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSAtMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAob2xkQ2hpbGRyZW5baV0gKyBvbGRPZmZzZXQpLCBmcm9tTG9jYWwgPSBmcm9tIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGZyb21Mb2NhbCA8IDAgfHwgZnJvbUxvY2FsID49IG5vZGUuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTXVzdCByZWFkIG9sZENoaWxkcmVuIGJlY2F1c2UgY2hpbGRyZW4gd2FzIHRhZ2dlZCB3aXRoIC0xXG4gICAgICAgICAgICBsZXQgdG8gPSBtYXBwaW5nLm1hcChvbGRDaGlsZHJlbltpICsgMV0gKyBvbGRPZmZzZXQsIC0xKSwgdG9Mb2NhbCA9IHRvIC0gb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldDogY2hpbGRPZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoZnJvbUxvY2FsKTtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSBub2RlLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE9mZnNldCA9PSBmcm9tTG9jYWwgJiYgY2hpbGRPZmZzZXQgKyBjaGlsZE5vZGUubm9kZVNpemUgPT0gdG9Mb2NhbCkge1xuICAgICAgICAgICAgICAgIGxldCBtYXBwZWQgPSBjaGlsZHJlbltpICsgMl1cbiAgICAgICAgICAgICAgICAgICAgLm1hcElubmVyKG1hcHBpbmcsIGNoaWxkTm9kZSwgZnJvbSArIDEsIG9sZENoaWxkcmVuW2ldICsgb2xkT2Zmc2V0ICsgMSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCAhPSBlbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSA9IGZyb21Mb2NhbDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gdG9Mb2NhbDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDJdID0gbWFwcGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gLTI7XG4gICAgICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAvLyBSZW1haW5pbmcgY2hpbGRyZW4gbXVzdCBiZSBjb2xsZWN0ZWQgYW5kIHJlYnVpbHQgaW50byB0aGUgYXBwcm9wcmlhdGUgc3RydWN0dXJlXG4gICAgaWYgKG11c3RSZWJ1aWxkKSB7XG4gICAgICAgIGxldCBkZWNvcmF0aW9ucyA9IG1hcEFuZEdhdGhlclJlbWFpbmluZ0RlY29yYXRpb25zKGNoaWxkcmVuLCBvbGRDaGlsZHJlbiwgbmV3TG9jYWwsIG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKTtcbiAgICAgICAgbGV0IGJ1aWx0ID0gYnVpbGRUcmVlKGRlY29yYXRpb25zLCBub2RlLCAwLCBvcHRpb25zKTtcbiAgICAgICAgbmV3TG9jYWwgPSBidWlsdC5sb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltpICsgMV0gPCAwKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDMpO1xuICAgICAgICAgICAgICAgIGkgLT0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgYnVpbHQuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gYnVpbHQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICB3aGlsZSAoaiA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlbltqXSA8IGZyb20pXG4gICAgICAgICAgICAgICAgaiArPSAzO1xuICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGosIDAsIGJ1aWx0LmNoaWxkcmVuW2ldLCBidWlsdC5jaGlsZHJlbltpICsgMV0sIGJ1aWx0LmNoaWxkcmVuW2kgKyAyXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uU2V0KG5ld0xvY2FsLnNvcnQoYnlQb3MpLCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBtb3ZlU3BhbnMoc3BhbnMsIG9mZnNldCkge1xuICAgIGlmICghb2Zmc2V0IHx8ICFzcGFucy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBzcGFucztcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgICByZXN1bHQucHVzaChuZXcgRGVjb3JhdGlvbihzcGFuLmZyb20gKyBvZmZzZXQsIHNwYW4udG8gKyBvZmZzZXQsIHNwYW4udHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWFwQW5kR2F0aGVyUmVtYWluaW5nRGVjb3JhdGlvbnMoY2hpbGRyZW4sIG9sZENoaWxkcmVuLCBkZWNvcmF0aW9ucywgbWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIHtcbiAgICAvLyBHYXRoZXIgYWxsIGRlY29yYXRpb25zIGZyb20gdGhlIHJlbWFpbmluZyBtYXJrZWQgY2hpbGRyZW5cbiAgICBmdW5jdGlvbiBnYXRoZXIoc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSBzZXQubG9jYWxbaV0ubWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChtYXBwZWQpXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vblJlbW92ZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVtb3ZlKHNldC5sb2NhbFtpXS5zcGVjKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGdhdGhlcihzZXQuY2hpbGRyZW5baSArIDJdLCBzZXQuY2hpbGRyZW5baV0gKyBvbGRPZmZzZXQgKyAxKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA9PSAtMSlcbiAgICAgICAgICAgIGdhdGhlcihjaGlsZHJlbltpICsgMl0sIG9sZENoaWxkcmVuW2ldICsgb2xkT2Zmc2V0ICsgMSk7XG4gICAgcmV0dXJuIGRlY29yYXRpb25zO1xufVxuZnVuY3Rpb24gdGFrZVNwYW5zRm9yTm9kZShzcGFucywgbm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZW5kID0gb2Zmc2V0ICsgbm9kZS5ub2RlU2l6ZSwgZm91bmQgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwLCBzcGFuOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKChzcGFuID0gc3BhbnNbaV0pICYmIHNwYW4uZnJvbSA+IG9mZnNldCAmJiBzcGFuLnRvIDwgZW5kKSB7XG4gICAgICAgICAgICAoZm91bmQgfHwgKGZvdW5kID0gW10pKS5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgc3BhbnNbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIHdpdGhvdXROdWxscyhhcnJheSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYXJyYXlbaV0gIT0gbnVsbClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQnVpbGQgdXAgYSB0cmVlIHRoYXQgY29ycmVzcG9uZHMgdG8gYSBzZXQgb2YgZGVjb3JhdGlvbnMuIGBvZmZzZXRgXG4vLyBpcyBhIGJhc2Ugb2Zmc2V0IHRoYXQgc2hvdWxkIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgYGZyb21gIGFuZCBgdG9gXG4vLyBwb3NpdGlvbnMgaW4gdGhlIHNwYW5zIChzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gYWxsb2NhdGUgbmV3IHNwYW5zXG4vLyBmb3IgcmVjdXJzaXZlIGNhbGxzKS5cbmZ1bmN0aW9uIGJ1aWxkVHJlZShzcGFucywgbm9kZSwgb2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIGhhc051bGxzID0gZmFsc2U7XG4gICAgbm9kZS5mb3JFYWNoKChjaGlsZE5vZGUsIGxvY2FsU3RhcnQpID0+IHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGFrZVNwYW5zRm9yTm9kZShzcGFucywgY2hpbGROb2RlLCBsb2NhbFN0YXJ0ICsgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICBoYXNOdWxscyA9IHRydWU7XG4gICAgICAgICAgICBsZXQgc3VidHJlZSA9IGJ1aWxkVHJlZShmb3VuZCwgY2hpbGROb2RlLCBvZmZzZXQgKyBsb2NhbFN0YXJ0ICsgMSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc3VidHJlZSAhPSBlbXB0eSlcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGxvY2FsU3RhcnQsIGxvY2FsU3RhcnQgKyBjaGlsZE5vZGUubm9kZVNpemUsIHN1YnRyZWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGxvY2FscyA9IG1vdmVTcGFucyhoYXNOdWxscyA/IHdpdGhvdXROdWxscyhzcGFucykgOiBzcGFucywgLW9mZnNldCkuc29ydChieVBvcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbHMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghbG9jYWxzW2ldLnR5cGUudmFsaWQobm9kZSwgbG9jYWxzW2ldKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25SZW1vdmUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlbW92ZShsb2NhbHNbaV0uc3BlYyk7XG4gICAgICAgICAgICBsb2NhbHMuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbG9jYWxzLmxlbmd0aCB8fCBjaGlsZHJlbi5sZW5ndGggPyBuZXcgRGVjb3JhdGlvblNldChsb2NhbHMsIGNoaWxkcmVuKSA6IGVtcHR5O1xufVxuLy8gVXNlZCB0byBzb3J0IGRlY29yYXRpb25zIHNvIHRoYXQgb25lcyB3aXRoIGEgbG93IHN0YXJ0IHBvc2l0aW9uXG4vLyBjb21lIGZpcnN0LCBhbmQgd2l0aGluIGEgc2V0IHdpdGggdGhlIHNhbWUgc3RhcnQgcG9zaXRpb24sIHRob3NlXG4vLyB3aXRoIGFuIHNtYWxsZXIgZW5kIHBvc2l0aW9uIGNvbWUgZmlyc3QuXG5mdW5jdGlvbiBieVBvcyhhLCBiKSB7XG4gICAgcmV0dXJuIGEuZnJvbSAtIGIuZnJvbSB8fCBhLnRvIC0gYi50bztcbn1cbi8vIFNjYW4gYSBzb3J0ZWQgYXJyYXkgb2YgZGVjb3JhdGlvbnMgZm9yIHBhcnRpYWxseSBvdmVybGFwcGluZyBzcGFucyxcbi8vIGFuZCBzcGxpdCB0aG9zZSBzbyB0aGF0IG9ubHkgZnVsbHkgb3ZlcmxhcHBpbmcgc3BhbnMgYXJlIGxlZnQgKHRvXG4vLyBtYWtlIHN1YnNlcXVlbnQgcmVuZGVyaW5nIGVhc2llcikuIFdpbGwgcmV0dXJuIHRoZSBpbnB1dCBhcnJheSBpZlxuLy8gbm8gcGFydGlhbGx5IG92ZXJsYXBwaW5nIHNwYW5zIGFyZSBmb3VuZCAodGhlIGNvbW1vbiBjYXNlKS5cbmZ1bmN0aW9uIHJlbW92ZU92ZXJsYXAoc3BhbnMpIHtcbiAgICBsZXQgd29ya2luZyA9IHNwYW5zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29ya2luZy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbGV0IHNwYW4gPSB3b3JraW5nW2ldO1xuICAgICAgICBpZiAoc3Bhbi5mcm9tICE9IHNwYW4udG8pXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCB3b3JraW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB3b3JraW5nW2pdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LmZyb20gPT0gc3Bhbi5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LnRvICE9IHNwYW4udG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JraW5nID09IHNwYW5zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmcgPSBzcGFucy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9sbG93ZWQgYnkgYSBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgbGFyZ2VyIHNwYW4uIFNwbGl0IHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwYW4uXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nW2pdID0gbmV4dC5jb3B5KG5leHQuZnJvbSwgc3Bhbi50byk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqICsgMSwgbmV4dC5jb3B5KHNwYW4udG8sIG5leHQudG8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmZyb20gPCBzcGFuLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya2luZyA9PSBzcGFucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nID0gc3BhbnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBlbmQgb2YgdGhpcyBvbmUgb3ZlcmxhcHMgd2l0aCBhIHN1YnNlcXVlbnQgc3Bhbi4gU3BsaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1tpXSA9IHNwYW4uY29weShzcGFuLmZyb20sIG5leHQuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqLCBzcGFuLmNvcHkobmV4dC5mcm9tLCBzcGFuLnRvKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd29ya2luZztcbn1cbmZ1bmN0aW9uIGluc2VydEFoZWFkKGFycmF5LCBpLCBkZWNvKSB7XG4gICAgd2hpbGUgKGkgPCBhcnJheS5sZW5ndGggJiYgYnlQb3MoZGVjbywgYXJyYXlbaV0pID4gMClcbiAgICAgICAgaSsrO1xuICAgIGFycmF5LnNwbGljZShpLCAwLCBkZWNvKTtcbn1cbi8vIEdldCB0aGUgZGVjb3JhdGlvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IHByb3BzIG9mIGEgdmlldy5cbmZ1bmN0aW9uIHZpZXdEZWNvcmF0aW9ucyh2aWV3KSB7XG4gICAgbGV0IGZvdW5kID0gW107XG4gICAgdmlldy5zb21lUHJvcChcImRlY29yYXRpb25zXCIsIGYgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZih2aWV3LnN0YXRlKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgIT0gZW1wdHkpXG4gICAgICAgICAgICBmb3VuZC5wdXNoKHJlc3VsdCk7XG4gICAgfSk7XG4gICAgaWYgKHZpZXcuY3Vyc29yV3JhcHBlcilcbiAgICAgICAgZm91bmQucHVzaChEZWNvcmF0aW9uU2V0LmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgW3ZpZXcuY3Vyc29yV3JhcHBlci5kZWNvXSkpO1xuICAgIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShmb3VuZCk7XG59XG5cbmNvbnN0IG9ic2VydmVPcHRpb25zID0ge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWVcbn07XG4vLyBJRTExIGhhcyB2ZXJ5IGJyb2tlbiBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHdlIGFsc28gbGlzdGVuIHRvIERPTUNoYXJhY3RlckRhdGFNb2RpZmllZFxuY29uc3QgdXNlQ2hhckRhdGEgPSBpZSAmJiBpZV92ZXJzaW9uIDw9IDExO1xuY2xhc3MgU2VsZWN0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IDA7XG4gICAgfVxuICAgIHNldChzZWwpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gc2VsLmFuY2hvck5vZGU7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gc2VsLmFuY2hvck9mZnNldDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBzZWwuZm9jdXNOb2RlO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICAgIH1cbiAgICBlcShzZWwpIHtcbiAgICAgICAgcmV0dXJuIHNlbC5hbmNob3JOb2RlID09IHRoaXMuYW5jaG9yTm9kZSAmJiBzZWwuYW5jaG9yT2Zmc2V0ID09IHRoaXMuYW5jaG9yT2Zmc2V0ICYmXG4gICAgICAgICAgICBzZWwuZm9jdXNOb2RlID09IHRoaXMuZm9jdXNOb2RlICYmIHNlbC5mb2N1c09mZnNldCA9PSB0aGlzLmZvY3VzT2Zmc2V0O1xuICAgIH1cbn1cbmNsYXNzIERPTU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBoYW5kbGVET01DaGFuZ2UpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5oYW5kbGVET01DaGFuZ2UgPSBoYW5kbGVET01DaGFuZ2U7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb25TdGF0ZTtcbiAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyICYmXG4gICAgICAgICAgICBuZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dGF0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgLy8gSUUxMSB3aWxsIHNvbWV0aW1lcyAob24gYmFja3NwYWNpbmcgb3V0IGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIC8vIHRleHQgbm9kZSBhZnRlciBhIEJSIG5vZGUpIGNhbGwgdGhlIG9ic2VydmVyIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlIGFjdHVhbGx5IHVwZGF0aW5nIHRoZSBET00sIHdoaWNoIHdpbGwgY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBQcm9zZU1pcnJvciB0byBtaXNzIHRoZSBjaGFuZ2UgKHNlZSAjOTMwKVxuICAgICAgICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmIG11dGF0aW9ucy5zb21lKG0gPT4gbS50eXBlID09IFwiY2hpbGRMaXN0XCIgJiYgbS5yZW1vdmVkTm9kZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIG0udHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIiAmJiBtLm9sZFZhbHVlLmxlbmd0aCA+IG0udGFyZ2V0Lm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgdGFyZ2V0OiBlLnRhcmdldCwgdHlwZTogXCJjaGFyYWN0ZXJEYXRhXCIsIG9sZFZhbHVlOiBlLnByZXZWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlID0gdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBmbHVzaFNvb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmZsdXNoaW5nU29vbiA8IDApXG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nU29vbiA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTsgdGhpcy5mbHVzaCgpOyB9LCAyMCk7XG4gICAgfVxuICAgIGZvcmNlRmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZsdXNoaW5nU29vbiA+IC0xKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuZmx1c2hpbmdTb29uKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hpbmdTb29uID0gLTE7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcy52aWV3LmRvbSwgb2JzZXJ2ZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9uQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICAgICAgdGhpcy5jb25uZWN0U2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICBsZXQgdGFrZSA9IHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgICAgICAgIGlmICh0YWtlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRha2VbaV0pO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuZmx1c2goKSwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub25DaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgY29ubmVjdFNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5vd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlldy5kb20ub3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICBzdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKSB7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyA9IGZhbHNlLCA1MCk7XG4gICAgfVxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKCkge1xuICAgICAgICBpZiAoIWhhc0ZvY3VzQW5kU2VsZWN0aW9uKHRoaXMudmlldykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcylcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25Ub0RPTSh0aGlzLnZpZXcpO1xuICAgICAgICAvLyBEZWxldGlvbnMgb24gSUUxMSBmaXJlIHRoZWlyIGV2ZW50cyBpbiB0aGUgd3Jvbmcgb3JkZXIsIGdpdmluZ1xuICAgICAgICAvLyB1cyBhIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQgYmVmb3JlIHRoZSBET00gY2hhbmdlcyBhcmVcbiAgICAgICAgLy8gcmVwb3J0ZWQuXG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmICF0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgc2VsID0gdGhpcy52aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICAvLyBTZWxlY3Rpb24uaXNDb2xsYXBzZWQgaXNuJ3QgcmVsaWFibGUgb24gSUVcbiAgICAgICAgICAgIGlmIChzZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgc2V0Q3VyU2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uc2V0KHRoaXMudmlldy5kb21TZWxlY3Rpb25SYW5nZSgpKTtcbiAgICB9XG4gICAgaWdub3JlU2VsZWN0aW9uQ2hhbmdlKHNlbCkge1xuICAgICAgICBpZiAoIXNlbC5mb2N1c05vZGUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IGFuY2VzdG9ycyA9IG5ldyBTZXQsIGNvbnRhaW5lcjtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IHNlbC5mb2N1c05vZGU7IHNjYW47IHNjYW4gPSBwYXJlbnROb2RlKHNjYW4pKVxuICAgICAgICAgICAgYW5jZXN0b3JzLmFkZChzY2FuKTtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IHNlbC5hbmNob3JOb2RlOyBzY2FuOyBzY2FuID0gcGFyZW50Tm9kZShzY2FuKSlcbiAgICAgICAgICAgIGlmIChhbmNlc3RvcnMuaGFzKHNjYW4pKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gc2NhbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IGRlc2MgPSBjb250YWluZXIgJiYgdGhpcy52aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoY29udGFpbmVyKTtcbiAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5pZ25vcmVNdXRhdGlvbih7XG4gICAgICAgICAgICB0eXBlOiBcInNlbGVjdGlvblwiLFxuICAgICAgICAgICAgdGFyZ2V0OiBjb250YWluZXIubm9kZVR5cGUgPT0gMyA/IGNvbnRhaW5lci5wYXJlbnROb2RlIDogY29udGFpbmVyXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgICB0aGlzLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGVuZGluZ1JlY29yZHMoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKVxuICAgICAgICAgICAgZm9yIChsZXQgbXV0IG9mIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSlcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWU7XG4gICAgfVxuICAgIGZsdXNoKCkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXZpZXcuZG9jVmlldyB8fCB0aGlzLmZsdXNoaW5nU29vbiA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbXV0YXRpb25zID0gdGhpcy5wZW5kaW5nUmVjb3JkcygpO1xuICAgICAgICBpZiAobXV0YXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IG5ld1NlbCA9ICF0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyAmJiAhdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkgJiYgaGFzRm9jdXNBbmRTZWxlY3Rpb24odmlldykgJiYgIXRoaXMuaWdub3JlU2VsZWN0aW9uQ2hhbmdlKHNlbCk7XG4gICAgICAgIGxldCBmcm9tID0gLTEsIHRvID0gLTEsIHR5cGVPdmVyID0gZmFsc2UsIGFkZGVkID0gW107XG4gICAgICAgIGlmICh2aWV3LmVkaXRhYmxlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnJlZ2lzdGVyTXV0YXRpb24obXV0YXRpb25zW2ldLCBhZGRlZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gZnJvbSA8IDAgPyByZXN1bHQuZnJvbSA6IE1hdGgubWluKHJlc3VsdC5mcm9tLCBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSB0byA8IDAgPyByZXN1bHQudG8gOiBNYXRoLm1heChyZXN1bHQudG8sIHRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlT3ZlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVPdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlY2tvICYmIGFkZGVkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCBicnMgPSBhZGRlZC5maWx0ZXIobiA9PiBuLm5vZGVOYW1lID09IFwiQlJcIik7XG4gICAgICAgICAgICBpZiAoYnJzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGEgPSBicnNbMF0sIGIgPSBicnNbMV07XG4gICAgICAgICAgICAgICAgaWYgKGEucGFyZW50Tm9kZSAmJiBhLnBhcmVudE5vZGUucGFyZW50Tm9kZSA9PSBiLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBhLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZWFkU2VsID0gbnVsbDtcbiAgICAgICAgLy8gSWYgaXQgbG9va3MgbGlrZSB0aGUgYnJvd3NlciBoYXMgcmVzZXQgdGhlIHNlbGVjdGlvbiB0byB0aGVcbiAgICAgICAgLy8gc3RhcnQgb2YgdGhlIGRvY3VtZW50IGFmdGVyIGZvY3VzLCByZXN0b3JlIHRoZSBzZWxlY3Rpb24gZnJvbVxuICAgICAgICAvLyB0aGUgc3RhdGVcbiAgICAgICAgaWYgKGZyb20gPCAwICYmIG5ld1NlbCAmJiB2aWV3LmlucHV0Lmxhc3RGb2N1cyA+IERhdGUubm93KCkgLSAyMDAgJiZcbiAgICAgICAgICAgIE1hdGgubWF4KHZpZXcuaW5wdXQubGFzdFRvdWNoLCB2aWV3LmlucHV0Lmxhc3RDbGljay50aW1lKSA8IERhdGUubm93KCkgLSAzMDAgJiZcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbGxhcHNlZChzZWwpICYmIChyZWFkU2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3KSkgJiZcbiAgICAgICAgICAgIHJlYWRTZWwuZXEoU2VsZWN0aW9uLm5lYXIodmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgwKSwgMSkpKSB7XG4gICAgICAgICAgICB2aWV3LmlucHV0Lmxhc3RGb2N1cyA9IDA7XG4gICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQoc2VsKTtcbiAgICAgICAgICAgIHZpZXcuc2Nyb2xsVG9TZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcm9tID4gLTEgfHwgbmV3U2VsKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdmlldy5kb2NWaWV3Lm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgY2hlY2tDU1Modmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURPTUNoYW5nZShmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKTtcbiAgICAgICAgICAgIGlmICh2aWV3LmRvY1ZpZXcgJiYgdmlldy5kb2NWaWV3LmRpcnR5KVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlU3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkpXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uc2V0KHNlbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJNdXRhdGlvbihtdXQsIGFkZGVkKSB7XG4gICAgICAgIC8vIElnbm9yZSBtdXRhdGlvbnMgaW5zaWRlIG5vZGVzIHRoYXQgd2VyZSBhbHJlYWR5IG5vdGVkIGFzIGluc2VydGVkXG4gICAgICAgIGlmIChhZGRlZC5pbmRleE9mKG11dC50YXJnZXQpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGRlc2MgPSB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhtdXQudGFyZ2V0KTtcbiAgICAgICAgaWYgKG11dC50eXBlID09IFwiYXR0cmlidXRlc1wiICYmXG4gICAgICAgICAgICAoZGVzYyA9PSB0aGlzLnZpZXcuZG9jVmlldyB8fCBtdXQuYXR0cmlidXRlTmFtZSA9PSBcImNvbnRlbnRlZGl0YWJsZVwiIHx8XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzb21ldGltZXMgZmlyZXMgc3B1cmlvdXMgZXZlbnRzIGZvciBudWxsL2VtcHR5IHN0eWxlc1xuICAgICAgICAgICAgICAgIChtdXQuYXR0cmlidXRlTmFtZSA9PSBcInN0eWxlXCIgJiYgIW11dC5vbGRWYWx1ZSAmJiAhbXV0LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSkpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghZGVzYyB8fCBkZXNjLmlnbm9yZU11dGF0aW9uKG11dCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG11dC50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0LmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgYWRkZWQucHVzaChtdXQuYWRkZWROb2Rlc1tpXSk7XG4gICAgICAgICAgICBpZiAoZGVzYy5jb250ZW50RE9NICYmIGRlc2MuY29udGVudERPTSAhPSBkZXNjLmRvbSAmJiAhZGVzYy5jb250ZW50RE9NLmNvbnRhaW5zKG11dC50YXJnZXQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGZyb206IGRlc2MucG9zQmVmb3JlLCB0bzogZGVzYy5wb3NBZnRlciB9O1xuICAgICAgICAgICAgbGV0IHByZXYgPSBtdXQucHJldmlvdXNTaWJsaW5nLCBuZXh0ID0gbXV0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgbXV0LmFkZGVkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gSUUxMSBnaXZlcyB1cyBpbmNvcnJlY3QgbmV4dC9wcmV2IHNpYmxpbmdzIGZvciBzb21lXG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0aW9ucywgc28gaWYgdGhlcmUgYXJlIGFkZGVkIG5vZGVzLCByZWNvbXB1dGUgdGhvc2VcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dC5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHByZXZpb3VzU2libGluZywgbmV4dFNpYmxpbmcgfSA9IG11dC5hZGRlZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZpb3VzU2libGluZyB8fCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKG11dC5hZGRlZE5vZGVzLCBwcmV2aW91c1NpYmxpbmcpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBwcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dFNpYmxpbmcgfHwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChtdXQuYWRkZWROb2RlcywgbmV4dFNpYmxpbmcpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZnJvbU9mZnNldCA9IHByZXYgJiYgcHJldi5wYXJlbnROb2RlID09IG11dC50YXJnZXRcbiAgICAgICAgICAgICAgICA/IGRvbUluZGV4KHByZXYpICsgMSA6IDA7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGRlc2MubG9jYWxQb3NGcm9tRE9NKG11dC50YXJnZXQsIGZyb21PZmZzZXQsIC0xKTtcbiAgICAgICAgICAgIGxldCB0b09mZnNldCA9IG5leHQgJiYgbmV4dC5wYXJlbnROb2RlID09IG11dC50YXJnZXRcbiAgICAgICAgICAgICAgICA/IGRvbUluZGV4KG5leHQpIDogbXV0LnRhcmdldC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCB0byA9IGRlc2MubG9jYWxQb3NGcm9tRE9NKG11dC50YXJnZXQsIHRvT2Zmc2V0LCAxKTtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb20sIHRvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXV0LnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb206IGRlc2MucG9zQXRTdGFydCAtIGRlc2MuYm9yZGVyLCB0bzogZGVzYy5wb3NBdEVuZCArIGRlc2MuYm9yZGVyIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIFwiY2hhcmFjdGVyRGF0YVwiXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IGRlc2MucG9zQXRTdGFydCxcbiAgICAgICAgICAgICAgICB0bzogZGVzYy5wb3NBdEVuZCxcbiAgICAgICAgICAgICAgICAvLyBBbiBldmVudCB3YXMgZ2VuZXJhdGVkIGZvciBhIHRleHQgY2hhbmdlIHRoYXQgZGlkbid0IGNoYW5nZVxuICAgICAgICAgICAgICAgIC8vIGFueSB0ZXh0LiBNYXJrIHRoZSBkb20gY2hhbmdlIHRvIGZhbGwgYmFjayB0byBhc3N1bWluZyB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3Rpb24gd2FzIHR5cGVkIG92ZXIgd2l0aCBhbiBpZGVudGljYWwgdmFsdWUgaWYgaXQgY2FuJ3RcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGFub3RoZXIgY2hhbmdlLlxuICAgICAgICAgICAgICAgIHR5cGVPdmVyOiBtdXQudGFyZ2V0Lm5vZGVWYWx1ZSA9PSBtdXQub2xkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5sZXQgY3NzQ2hlY2tlZCA9IG5ldyBXZWFrTWFwKCk7XG5sZXQgY3NzQ2hlY2tXYXJuZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGNoZWNrQ1NTKHZpZXcpIHtcbiAgICBpZiAoY3NzQ2hlY2tlZC5oYXModmlldykpXG4gICAgICAgIHJldHVybjtcbiAgICBjc3NDaGVja2VkLnNldCh2aWV3LCBudWxsKTtcbiAgICBpZiAoWydub3JtYWwnLCAnbm93cmFwJywgJ3ByZS1saW5lJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKHZpZXcuZG9tKS53aGl0ZVNwYWNlKSAhPT0gLTEpIHtcbiAgICAgICAgdmlldy5yZXF1aXJlc0dlY2tvSGFja05vZGUgPSBnZWNrbztcbiAgICAgICAgaWYgKGNzc0NoZWNrV2FybmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlW1wid2FyblwiXShcIlByb3NlTWlycm9yIGV4cGVjdHMgdGhlIENTUyB3aGl0ZS1zcGFjZSBwcm9wZXJ0eSB0byBiZSBzZXQsIHByZWZlcmFibHkgdG8gJ3ByZS13cmFwJy4gSXQgaXMgcmVjb21tZW5kZWQgdG8gbG9hZCBzdHlsZS9wcm9zZW1pcnJvci5jc3MgZnJvbSB0aGUgcHJvc2VtaXJyb3ItdmlldyBwYWNrYWdlLlwiKTtcbiAgICAgICAgY3NzQ2hlY2tXYXJuZWQgPSB0cnVlO1xuICAgIH1cbn1cbi8vIFVzZWQgdG8gd29yayBhcm91bmQgYSBTYWZhcmkgU2VsZWN0aW9uL3NoYWRvdyBET00gYnVnXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzQxNCBmaXhcbmZ1bmN0aW9uIHNhZmFyaVNoYWRvd1NlbGVjdGlvblJhbmdlKHZpZXcpIHtcbiAgICBsZXQgZm91bmQ7XG4gICAgZnVuY3Rpb24gcmVhZChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZm91bmQgPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKVswXTtcbiAgICB9XG4gICAgLy8gQmVjYXVzZSBTYWZhcmkgKGF0IGxlYXN0IGluIDIwMTgtMjAyMikgZG9lc24ndCBwcm92aWRlIHJlZ3VsYXJcbiAgICAvLyBhY2Nlc3MgdG8gdGhlIHNlbGVjdGlvbiBpbnNpZGUgYSBzaGFkb3dSb290LCB3ZSBoYXZlIHRvIHBlcmZvcm0gYVxuICAgIC8vIHJpZGljdWxvdXMgaGFjayB0byBnZXQgYXQgaXRcdTIwMTR1c2luZyBgZXhlY0NvbW1hbmRgIHRvIHRyaWdnZXIgYVxuICAgIC8vIGBiZWZvcmVJbnB1dGAgZXZlbnQgc28gdGhhdCB3ZSBjYW4gcmVhZCB0aGUgdGFyZ2V0IHJhbmdlIGZyb20gdGhlXG4gICAgLy8gZXZlbnQuXG4gICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiaW5kZW50XCIpO1xuICAgIHZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcbiAgICBsZXQgYW5jaG9yTm9kZSA9IGZvdW5kLnN0YXJ0Q29udGFpbmVyLCBhbmNob3JPZmZzZXQgPSBmb3VuZC5zdGFydE9mZnNldDtcbiAgICBsZXQgZm9jdXNOb2RlID0gZm91bmQuZW5kQ29udGFpbmVyLCBmb2N1c09mZnNldCA9IGZvdW5kLmVuZE9mZnNldDtcbiAgICBsZXQgY3VycmVudEFuY2hvciA9IHZpZXcuZG9tQXRQb3Modmlldy5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yKTtcbiAgICAvLyBTaW5jZSBzdWNoIGEgcmFuZ2UgZG9lc24ndCBkaXN0aW5ndWlzaCBiZXR3ZWVuIGFuY2hvciBhbmQgaGVhZCxcbiAgICAvLyB1c2UgYSBoZXVyaXN0aWMgdGhhdCBmbGlwcyBpdCBhcm91bmQgaWYgaXRzIGVuZCBtYXRjaGVzIHRoZVxuICAgIC8vIGN1cnJlbnQgYW5jaG9yLlxuICAgIGlmIChpc0VxdWl2YWxlbnRQb3NpdGlvbihjdXJyZW50QW5jaG9yLm5vZGUsIGN1cnJlbnRBbmNob3Iub2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSlcbiAgICAgICAgW2FuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldF0gPSBbZm9jdXNOb2RlLCBmb2N1c09mZnNldCwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0XTtcbiAgICByZXR1cm4geyBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfTtcbn1cblxuLy8gTm90ZSB0aGF0IGFsbCByZWZlcmVuY2luZyBhbmQgcGFyc2luZyBpcyBkb25lIHdpdGggdGhlXG4vLyBzdGFydC1vZi1vcGVyYXRpb24gc2VsZWN0aW9uIGFuZCBkb2N1bWVudCwgc2luY2UgdGhhdCdzIHRoZSBvbmVcbi8vIHRoYXQgdGhlIERPTSByZXByZXNlbnRzLiBJZiBhbnkgY2hhbmdlcyBjYW1lIGluIGluIHRoZSBtZWFudGltZSxcbi8vIHRoZSBtb2RpZmljYXRpb24gaXMgbWFwcGVkIG92ZXIgdGhvc2UgYmVmb3JlIGl0IGlzIGFwcGxpZWQsIGluXG4vLyByZWFkRE9NQ2hhbmdlLlxuZnVuY3Rpb24gcGFyc2VCZXR3ZWVuKHZpZXcsIGZyb21fLCB0b18pIHtcbiAgICBsZXQgeyBub2RlOiBwYXJlbnQsIGZyb21PZmZzZXQsIHRvT2Zmc2V0LCBmcm9tLCB0byB9ID0gdmlldy5kb2NWaWV3LnBhcnNlUmFuZ2UoZnJvbV8sIHRvXyk7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgZmluZDtcbiAgICBsZXQgYW5jaG9yID0gZG9tU2VsLmFuY2hvck5vZGU7XG4gICAgaWYgKGFuY2hvciAmJiB2aWV3LmRvbS5jb250YWlucyhhbmNob3Iubm9kZVR5cGUgPT0gMSA/IGFuY2hvciA6IGFuY2hvci5wYXJlbnROb2RlKSkge1xuICAgICAgICBmaW5kID0gW3sgbm9kZTogYW5jaG9yLCBvZmZzZXQ6IGRvbVNlbC5hbmNob3JPZmZzZXQgfV07XG4gICAgICAgIGlmICghc2VsZWN0aW9uQ29sbGFwc2VkKGRvbVNlbCkpXG4gICAgICAgICAgICBmaW5kLnB1c2goeyBub2RlOiBkb21TZWwuZm9jdXNOb2RlLCBvZmZzZXQ6IGRvbVNlbC5mb2N1c09mZnNldCB9KTtcbiAgICB9XG4gICAgLy8gV29yayBhcm91bmQgaXNzdWUgaW4gQ2hyb21lIHdoZXJlIGJhY2tzcGFjaW5nIHNvbWV0aW1lcyByZXBsYWNlc1xuICAgIC8vIHRoZSBkZWxldGVkIGNvbnRlbnQgd2l0aCBhIHJhbmRvbSBCUiBub2RlIChpc3N1ZXMgIzc5OSwgIzgzMSlcbiAgICBpZiAoY2hyb21lICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDgpIHtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gdG9PZmZzZXQ7IG9mZiA+IGZyb21PZmZzZXQ7IG9mZi0tKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHBhcmVudC5jaGlsZE5vZGVzW29mZiAtIDFdLCBkZXNjID0gbm9kZS5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJCUlwiICYmICFkZXNjKSB7XG4gICAgICAgICAgICAgICAgdG9PZmZzZXQgPSBvZmY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgZGVzYy5zaXplKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdGFydERvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgIGxldCBwYXJzZXIgPSB2aWV3LnNvbWVQcm9wKFwiZG9tUGFyc2VyXCIpIHx8IERPTVBhcnNlci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgICBsZXQgJGZyb20gPSBzdGFydERvYy5yZXNvbHZlKGZyb20pO1xuICAgIGxldCBzZWwgPSBudWxsLCBkb2MgPSBwYXJzZXIucGFyc2UocGFyZW50LCB7XG4gICAgICAgIHRvcE5vZGU6ICRmcm9tLnBhcmVudCxcbiAgICAgICAgdG9wTWF0Y2g6ICRmcm9tLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleCgpKSxcbiAgICAgICAgdG9wT3BlbjogdHJ1ZSxcbiAgICAgICAgZnJvbTogZnJvbU9mZnNldCxcbiAgICAgICAgdG86IHRvT2Zmc2V0LFxuICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICRmcm9tLnBhcmVudC50eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIiA/IFwiZnVsbFwiIDogdHJ1ZSxcbiAgICAgICAgZmluZFBvc2l0aW9uczogZmluZCxcbiAgICAgICAgcnVsZUZyb21Ob2RlLFxuICAgICAgICBjb250ZXh0OiAkZnJvbVxuICAgIH0pO1xuICAgIGlmIChmaW5kICYmIGZpbmRbMF0ucG9zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGFuY2hvciA9IGZpbmRbMF0ucG9zLCBoZWFkID0gZmluZFsxXSAmJiBmaW5kWzFdLnBvcztcbiAgICAgICAgaWYgKGhlYWQgPT0gbnVsbClcbiAgICAgICAgICAgIGhlYWQgPSBhbmNob3I7XG4gICAgICAgIHNlbCA9IHsgYW5jaG9yOiBhbmNob3IgKyBmcm9tLCBoZWFkOiBoZWFkICsgZnJvbSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBkb2MsIHNlbCwgZnJvbSwgdG8gfTtcbn1cbmZ1bmN0aW9uIHJ1bGVGcm9tTm9kZShkb20pIHtcbiAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgIGlmIChkZXNjKSB7XG4gICAgICAgIHJldHVybiBkZXNjLnBhcnNlUnVsZSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmIGRvbS5wYXJlbnROb2RlKSB7XG4gICAgICAgIC8vIFNhZmFyaSByZXBsYWNlcyB0aGUgbGlzdCBpdGVtIG9yIHRhYmxlIGNlbGwgd2l0aCBhIEJSXG4gICAgICAgIC8vIGRpcmVjdGx5IGluIHRoZSBsaXN0IG5vZGUgKD8hKSBpZiB5b3UgZGVsZXRlIHRoZSBsYXN0XG4gICAgICAgIC8vIGNoYXJhY3RlciBpbiBhIGxpc3QgaXRlbSBvciB0YWJsZSBjZWxsICgjNzA4LCAjODYyKVxuICAgICAgICBpZiAoc2FmYXJpICYmIC9eKHVsfG9sKSQvaS50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgbGV0IHNraXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgc2tpcC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc2tpcCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvbS5wYXJlbnROb2RlLmxhc3RDaGlsZCA9PSBkb20gfHwgc2FmYXJpICYmIC9eKHRyfHRhYmxlKSQvaS50ZXN0KGRvbS5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZG9tLm5vZGVOYW1lID09IFwiSU1HXCIgJiYgZG9tLmdldEF0dHJpYnV0ZShcIm1hcmstcGxhY2Vob2xkZXJcIikpIHtcbiAgICAgICAgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgaXNJbmxpbmUgPSAvXihhfGFiYnJ8YWNyb255bXxifGJkW2lvXXxiaWd8YnJ8YnV0dG9ufGNpdGV8Y29kZXxkYXRhKGxpc3QpP3xkZWx8ZGZufGVtfGl8aW5zfGtiZHxsYWJlbHxtYXB8bWFya3xtZXRlcnxvdXRwdXR8cXxydWJ5fHN8c2FtcHxzbWFsbHxzcGFufHN0cm9uZ3xzdVticF18dGltZXx1fHR0fHZhcikkL2k7XG5mdW5jdGlvbiByZWFkRE9NQ2hhbmdlKHZpZXcsIGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWROb2Rlcykge1xuICAgIGxldCBjb21wb3NpdGlvbklEID0gdmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzIHx8ICh2aWV3LmNvbXBvc2luZyA/IHZpZXcuaW5wdXQuY29tcG9zaXRpb25JRCA6IDApO1xuICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcyA9IDA7XG4gICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgIGxldCBvcmlnaW4gPSB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwID8gdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uT3JpZ2luIDogbnVsbDtcbiAgICAgICAgbGV0IG5ld1NlbCA9IHNlbGVjdGlvbkZyb21ET00odmlldywgb3JpZ2luKTtcbiAgICAgICAgaWYgKG5ld1NlbCAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24uZXEobmV3U2VsKSkge1xuICAgICAgICAgICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkICYmXG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9PT0gMTMgJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lICYmXG4gICAgICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3U2VsKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW4gPT0gXCJwb2ludGVyXCIpXG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcInBvaW50ZXJcIiwgdHJ1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChvcmlnaW4gPT0gXCJrZXlcIilcbiAgICAgICAgICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uSUQpXG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcImNvbXBvc2l0aW9uXCIsIGNvbXBvc2l0aW9uSUQpO1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgJGJlZm9yZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgbGV0IHNoYXJlZCA9ICRiZWZvcmUuc2hhcmVkRGVwdGgodG8pO1xuICAgIGZyb20gPSAkYmVmb3JlLmJlZm9yZShzaGFyZWQgKyAxKTtcbiAgICB0byA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUodG8pLmFmdGVyKHNoYXJlZCArIDEpO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgcGFyc2UgPSBwYXJzZUJldHdlZW4odmlldywgZnJvbSwgdG8pO1xuICAgIGxldCBkb2MgPSB2aWV3LnN0YXRlLmRvYywgY29tcGFyZSA9IGRvYy5zbGljZShwYXJzZS5mcm9tLCBwYXJzZS50byk7XG4gICAgbGV0IHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZTtcbiAgICAvLyBQcmVmZXIgYW5jaG9yaW5nIHRvIGVuZCB3aGVuIEJhY2tzcGFjZSBpcyBwcmVzc2VkXG4gICAgaWYgKHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDggJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lKSB7XG4gICAgICAgIHByZWZlcnJlZFBvcyA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvO1xuICAgICAgICBwcmVmZXJyZWRTaWRlID0gXCJlbmRcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHByZWZlcnJlZFBvcyA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb207XG4gICAgICAgIHByZWZlcnJlZFNpZGUgPSBcInN0YXJ0XCI7XG4gICAgfVxuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPSBudWxsO1xuICAgIGxldCBjaGFuZ2UgPSBmaW5kRGlmZihjb21wYXJlLmNvbnRlbnQsIHBhcnNlLmRvYy5jb250ZW50LCBwYXJzZS5mcm9tLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpO1xuICAgIGlmICgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSB8fCBhbmRyb2lkKSAmJlxuICAgICAgICBhZGRlZE5vZGVzLnNvbWUobiA9PiBuLm5vZGVUeXBlID09IDEgJiYgIWlzSW5saW5lLnRlc3Qobi5ub2RlTmFtZSkpICYmXG4gICAgICAgICghY2hhbmdlIHx8IGNoYW5nZS5lbmRBID49IGNoYW5nZS5lbmRCKSAmJlxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKSkge1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVPdmVyICYmIHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgIXNlbC5lbXB0eSAmJiBzZWwuJGhlYWQuc2FtZVBhcmVudChzZWwuJGFuY2hvcikgJiZcbiAgICAgICAgICAgICF2aWV3LmNvbXBvc2luZyAmJiAhKHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yICE9IHBhcnNlLnNlbC5oZWFkKSkge1xuICAgICAgICAgICAgY2hhbmdlID0geyBzdGFydDogc2VsLmZyb20sIGVuZEE6IHNlbC50bywgZW5kQjogc2VsLnRvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IHJlc29sdmVTZWxlY3Rpb24odmlldywgdmlldy5zdGF0ZS5kb2MsIHBhcnNlLnNlbCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbCAmJiAhc2VsLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoXCJjb21wb3NpdGlvblwiLCBjb21wb3NpdGlvbklEKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENocm9tZSBzb21ldGltZXMgbGVhdmVzIHRoZSBjdXJzb3IgYmVmb3JlIHRoZSBpbnNlcnRlZCB0ZXh0IHdoZW5cbiAgICAvLyBjb21wb3NpbmcgYWZ0ZXIgYSBjdXJzb3Igd3JhcHBlci4gVGhpcyBtb3ZlcyBpdCBmb3J3YXJkLlxuICAgIGlmIChjaHJvbWUgJiYgdmlldy5jdXJzb3JXcmFwcGVyICYmIHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yID09IHZpZXcuY3Vyc29yV3JhcHBlci5kZWNvLmZyb20gJiZcbiAgICAgICAgcGFyc2Uuc2VsLmhlYWQgPT0gcGFyc2Uuc2VsLmFuY2hvcikge1xuICAgICAgICBsZXQgc2l6ZSA9IGNoYW5nZS5lbmRCIC0gY2hhbmdlLnN0YXJ0O1xuICAgICAgICBwYXJzZS5zZWwgPSB7IGFuY2hvcjogcGFyc2Uuc2VsLmFuY2hvciArIHNpemUsIGhlYWQ6IHBhcnNlLnNlbC5hbmNob3IgKyBzaXplIH07XG4gICAgfVxuICAgIHZpZXcuaW5wdXQuZG9tQ2hhbmdlQ291bnQrKztcbiAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgb3ZlcndyaXRpbmcgYSBzZWxlY3Rpb24gYnkgdHlwaW5nIG1hdGNoZXNcbiAgICAvLyB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBzZWxlY3RlZCBjb250ZW50LCBjcmVhdGluZyBhIGNoYW5nZVxuICAgIC8vIHRoYXQncyBzbWFsbGVyIHRoYW4gd2hhdCB3YXMgYWN0dWFsbHkgb3ZlcndyaXR0ZW4uXG4gICAgaWYgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gPCB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAmJlxuICAgICAgICBjaGFuZ2Uuc3RhcnQgPT0gY2hhbmdlLmVuZEIgJiZcbiAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChjaGFuZ2Uuc3RhcnQgPiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tICYmIGNoYW5nZS5zdGFydCA8PSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tICsgMiAmJlxuICAgICAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+PSBwYXJzZS5mcm9tKSB7XG4gICAgICAgICAgICBjaGFuZ2Uuc3RhcnQgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS5lbmRBIDwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gJiYgY2hhbmdlLmVuZEEgPj0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gLSAyICYmXG4gICAgICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byA8PSBwYXJzZS50bykge1xuICAgICAgICAgICAgY2hhbmdlLmVuZEIgKz0gKHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIC0gY2hhbmdlLmVuZEEpO1xuICAgICAgICAgICAgY2hhbmdlLmVuZEEgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50bztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJRTExIHdpbGwgaW5zZXJ0IGEgbm9uLWJyZWFraW5nIHNwYWNlIF9haGVhZF8gb2YgdGhlIHNwYWNlIGFmdGVyXG4gICAgLy8gdGhlIGN1cnNvciBzcGFjZSB3aGVuIGFkZGluZyBhIHNwYWNlIGJlZm9yZSBhbm90aGVyIHNwYWNlLiBXaGVuXG4gICAgLy8gdGhhdCBoYXBwZW5lZCwgYWRqdXN0IHRoZSBjaGFuZ2UgdG8gY292ZXIgdGhlIHNwYWNlIGluc3RlYWQuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgY2hhbmdlLmVuZEIgPT0gY2hhbmdlLnN0YXJ0ICsgMSAmJlxuICAgICAgICBjaGFuZ2UuZW5kQSA9PSBjaGFuZ2Uuc3RhcnQgJiYgY2hhbmdlLnN0YXJ0ID4gcGFyc2UuZnJvbSAmJlxuICAgICAgICBwYXJzZS5kb2MudGV4dEJldHdlZW4oY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSAtIDEsIGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20gKyAxKSA9PSBcIiBcXHUwMGEwXCIpIHtcbiAgICAgICAgY2hhbmdlLnN0YXJ0LS07XG4gICAgICAgIGNoYW5nZS5lbmRBLS07XG4gICAgICAgIGNoYW5nZS5lbmRCLS07XG4gICAgfVxuICAgIGxldCAkZnJvbSA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tKTtcbiAgICBsZXQgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgbGV0ICRmcm9tQSA9IGRvYy5yZXNvbHZlKGNoYW5nZS5zdGFydCk7XG4gICAgbGV0IGlubGluZUNoYW5nZSA9ICRmcm9tLnNhbWVQYXJlbnQoJHRvKSAmJiAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCAmJiAkZnJvbUEuZW5kKCkgPj0gY2hhbmdlLmVuZEE7XG4gICAgbGV0IG5leHRTZWw7XG4gICAgLy8gSWYgdGhpcyBsb29rcyBsaWtlIHRoZSBlZmZlY3Qgb2YgcHJlc3NpbmcgRW50ZXIgKG9yIHdhcyByZWNvcmRlZFxuICAgIC8vIGFzIGJlaW5nIGFuIGlPUyBlbnRlciBwcmVzcyksIGp1c3QgZGlzcGF0Y2ggYW4gRW50ZXIga2V5IGluc3RlYWQuXG4gICAgaWYgKCgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSAmJlxuICAgICAgICAoIWlubGluZUNoYW5nZSB8fCBhZGRlZE5vZGVzLnNvbWUobiA9PiBuLm5vZGVOYW1lID09IFwiRElWXCIgfHwgbi5ub2RlTmFtZSA9PSBcIlBcIikpKSB8fFxuICAgICAgICAoIWlubGluZUNoYW5nZSAmJiAkZnJvbS5wb3MgPCBwYXJzZS5kb2MuY29udGVudC5zaXplICYmICEkZnJvbS5zYW1lUGFyZW50KCR0bykgJiZcbiAgICAgICAgICAgIChuZXh0U2VsID0gU2VsZWN0aW9uLmZpbmRGcm9tKHBhcnNlLmRvYy5yZXNvbHZlKCRmcm9tLnBvcyArIDEpLCAxLCB0cnVlKSkgJiZcbiAgICAgICAgICAgIG5leHRTZWwuaGVhZCA9PSAkdG8ucG9zKSkgJiZcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpIHtcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFNhbWUgZm9yIGJhY2tzcGFjZVxuICAgIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IgPiBjaGFuZ2Uuc3RhcnQgJiZcbiAgICAgICAgbG9va3NMaWtlSm9pbihkb2MsIGNoYW5nZS5zdGFydCwgY2hhbmdlLmVuZEEsICRmcm9tLCAkdG8pICYmXG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCg4LCBcIkJhY2tzcGFjZVwiKSkpKSB7XG4gICAgICAgIGlmIChhbmRyb2lkICYmIGNocm9tZSlcbiAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCk7IC8vICM4MjBcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDaHJvbWUgQW5kcm9pZCB3aWxsIG9jY2FzaW9uYWxseSwgZHVyaW5nIGNvbXBvc2l0aW9uLCBkZWxldGUgdGhlXG4gICAgLy8gZW50aXJlIGNvbXBvc2l0aW9uIGFuZCB0aGVuIGltbWVkaWF0ZWx5IGluc2VydCBpdCBhZ2Fpbi4gVGhpcyBpc1xuICAgIC8vIHVzZWQgdG8gZGV0ZWN0IHRoYXQgc2l0dWF0aW9uLlxuICAgIGlmIChjaHJvbWUgJiYgYW5kcm9pZCAmJiBjaGFuZ2UuZW5kQiA9PSBjaGFuZ2Uuc3RhcnQpXG4gICAgICAgIHZpZXcuaW5wdXQubGFzdEFuZHJvaWREZWxldGUgPSBEYXRlLm5vdygpO1xuICAgIC8vIFRoaXMgdHJpZXMgdG8gZGV0ZWN0IEFuZHJvaWQgdmlydHVhbCBrZXlib2FyZFxuICAgIC8vIGVudGVyLWFuZC1waWNrLXN1Z2dlc3Rpb24gYWN0aW9uLiBUaGF0IHNvbWV0aW1lcyAoc2VlIGlzc3VlXG4gICAgLy8gIzEwNTkpIGZpcnN0IGZpcmVzIGEgRE9NIG11dGF0aW9uLCBiZWZvcmUgbW92aW5nIHRoZSBzZWxlY3Rpb24gdG9cbiAgICAvLyB0aGUgbmV3bHkgY3JlYXRlZCBibG9jay4gQW5kIHRoZW4sIGJlY2F1c2UgUHJvc2VNaXJyb3IgY2xlYW5zIHVwXG4gICAgLy8gdGhlIERPTSBzZWxlY3Rpb24sIGl0IGdpdmVzIHVwIG1vdmluZyB0aGUgc2VsZWN0aW9uIGVudGlyZWx5LFxuICAgIC8vIGxlYXZpbmcgdGhlIGN1cnNvciBpbiB0aGUgd3JvbmcgcGxhY2UuIFdoZW4gdGhhdCBoYXBwZW5zLCB3ZSBkcm9wXG4gICAgLy8gdGhlIG5ldyBwYXJhZ3JhcGggZnJvbSB0aGUgaW5pdGlhbCBjaGFuZ2UsIGFuZCBmaXJlIGEgc2ltdWxhdGVkXG4gICAgLy8gZW50ZXIga2V5IGFmdGVyd2FyZHMuXG4gICAgaWYgKGFuZHJvaWQgJiYgIWlubGluZUNoYW5nZSAmJiAkZnJvbS5zdGFydCgpICE9ICR0by5zdGFydCgpICYmICR0by5wYXJlbnRPZmZzZXQgPT0gMCAmJiAkZnJvbS5kZXB0aCA9PSAkdG8uZGVwdGggJiZcbiAgICAgICAgcGFyc2Uuc2VsICYmIHBhcnNlLnNlbC5hbmNob3IgPT0gcGFyc2Uuc2VsLmhlYWQgJiYgcGFyc2Uuc2VsLmhlYWQgPT0gY2hhbmdlLmVuZEEpIHtcbiAgICAgICAgY2hhbmdlLmVuZEIgLT0gMjtcbiAgICAgICAgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpOyB9KTtcbiAgICAgICAgfSwgMjApO1xuICAgIH1cbiAgICBsZXQgY2hGcm9tID0gY2hhbmdlLnN0YXJ0LCBjaFRvID0gY2hhbmdlLmVuZEE7XG4gICAgbGV0IHRyLCBzdG9yZWRNYXJrcywgbWFya0NoYW5nZTtcbiAgICBpZiAoaW5saW5lQ2hhbmdlKSB7XG4gICAgICAgIGlmICgkZnJvbS5wb3MgPT0gJHRvLnBvcykgeyAvLyBEZWxldGlvblxuICAgICAgICAgICAgLy8gSUUxMSBzb21ldGltZXMgd2VpcmRseSBtb3ZlcyB0aGUgRE9NIHNlbGVjdGlvbiBhcm91bmQgYWZ0ZXJcbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIG91dCB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIHRleHRibG9ja1xuICAgICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgJGZyb20ucGFyZW50T2Zmc2V0ID09IDApIHtcbiAgICAgICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcygpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2VsZWN0aW9uVG9ET00odmlldyksIDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyID0gdmlldy5zdGF0ZS50ci5kZWxldGUoY2hGcm9tLCBjaFRvKTtcbiAgICAgICAgICAgIHN0b3JlZE1hcmtzID0gZG9jLnJlc29sdmUoY2hhbmdlLnN0YXJ0KS5tYXJrc0Fjcm9zcyhkb2MucmVzb2x2ZShjaGFuZ2UuZW5kQSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCAvLyBBZGRpbmcgb3IgcmVtb3ZpbmcgYSBtYXJrXG4gICAgICAgIGNoYW5nZS5lbmRBID09IGNoYW5nZS5lbmRCICYmXG4gICAgICAgICAgICAobWFya0NoYW5nZSA9IGlzTWFya0NoYW5nZSgkZnJvbS5wYXJlbnQuY29udGVudC5jdXQoJGZyb20ucGFyZW50T2Zmc2V0LCAkdG8ucGFyZW50T2Zmc2V0KSwgJGZyb21BLnBhcmVudC5jb250ZW50LmN1dCgkZnJvbUEucGFyZW50T2Zmc2V0LCBjaGFuZ2UuZW5kQSAtICRmcm9tQS5zdGFydCgpKSkpKSB7XG4gICAgICAgICAgICB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgICAgICAgICBpZiAobWFya0NoYW5nZS50eXBlID09IFwiYWRkXCIpXG4gICAgICAgICAgICAgICAgdHIuYWRkTWFyayhjaEZyb20sIGNoVG8sIG1hcmtDaGFuZ2UubWFyayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdHIucmVtb3ZlTWFyayhjaEZyb20sIGNoVG8sIG1hcmtDaGFuZ2UubWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJGZyb20ucGFyZW50LmNoaWxkKCRmcm9tLmluZGV4KCkpLmlzVGV4dCAmJiAkZnJvbS5pbmRleCgpID09ICR0by5pbmRleCgpIC0gKCR0by50ZXh0T2Zmc2V0ID8gMCA6IDEpKSB7XG4gICAgICAgICAgICAvLyBCb3RoIHBvc2l0aW9ucyBpbiB0aGUgc2FtZSB0ZXh0IG5vZGUgLS0gc2ltcGx5IGluc2VydCB0ZXh0XG4gICAgICAgICAgICBsZXQgdGV4dCA9ICRmcm9tLnBhcmVudC50ZXh0QmV0d2VlbigkZnJvbS5wYXJlbnRPZmZzZXQsICR0by5wYXJlbnRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVUZXh0SW5wdXRcIiwgZiA9PiBmKHZpZXcsIGNoRnJvbSwgY2hUbywgdGV4dCkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRyID0gdmlldy5zdGF0ZS50ci5pbnNlcnRUZXh0KHRleHQsIGNoRnJvbSwgY2hUbyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0cilcbiAgICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyLnJlcGxhY2UoY2hGcm9tLCBjaFRvLCBwYXJzZS5kb2Muc2xpY2UoY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSwgY2hhbmdlLmVuZEIgLSBwYXJzZS5mcm9tKSk7XG4gICAgaWYgKHBhcnNlLnNlbCkge1xuICAgICAgICBsZXQgc2VsID0gcmVzb2x2ZVNlbGVjdGlvbih2aWV3LCB0ci5kb2MsIHBhcnNlLnNlbCk7XG4gICAgICAgIC8vIENocm9tZSBBbmRyb2lkIHdpbGwgc29tZXRpbWVzLCBkdXJpbmcgY29tcG9zaXRpb24sIHJlcG9ydCB0aGVcbiAgICAgICAgLy8gc2VsZWN0aW9uIGluIHRoZSB3cm9uZyBwbGFjZS4gSWYgaXQgbG9va3MgbGlrZSB0aGF0IGlzXG4gICAgICAgIC8vIGhhcHBlbmluZywgZG9uJ3QgdXBkYXRlIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgIC8vIEVkZ2UganVzdCBkb2Vzbid0IG1vdmUgdGhlIGN1cnNvciBmb3J3YXJkIHdoZW4geW91IHN0YXJ0IHR5cGluZ1xuICAgICAgICAvLyBpbiBhbiBlbXB0eSBibG9jayBvciBiZXR3ZWVuIGJyIG5vZGVzLlxuICAgICAgICBpZiAoc2VsICYmICEoY2hyb21lICYmIGFuZHJvaWQgJiYgdmlldy5jb21wb3NpbmcgJiYgc2VsLmVtcHR5ICYmXG4gICAgICAgICAgICAoY2hhbmdlLnN0YXJ0ICE9IGNoYW5nZS5lbmRCIHx8IHZpZXcuaW5wdXQubGFzdEFuZHJvaWREZWxldGUgPCBEYXRlLm5vdygpIC0gMTAwKSAmJlxuICAgICAgICAgICAgKHNlbC5oZWFkID09IGNoRnJvbSB8fCBzZWwuaGVhZCA9PSB0ci5tYXBwaW5nLm1hcChjaFRvKSAtIDEpIHx8XG4gICAgICAgICAgICBpZSAmJiBzZWwuZW1wdHkgJiYgc2VsLmhlYWQgPT0gY2hGcm9tKSlcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgIH1cbiAgICBpZiAoc3RvcmVkTWFya3MpXG4gICAgICAgIHRyLmVuc3VyZU1hcmtzKHN0b3JlZE1hcmtzKTtcbiAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgdHIuc2V0TWV0YShcImNvbXBvc2l0aW9uXCIsIGNvbXBvc2l0aW9uSUQpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG59XG5mdW5jdGlvbiByZXNvbHZlU2VsZWN0aW9uKHZpZXcsIGRvYywgcGFyc2VkU2VsKSB7XG4gICAgaWYgKE1hdGgubWF4KHBhcnNlZFNlbC5hbmNob3IsIHBhcnNlZFNlbC5oZWFkKSA+IGRvYy5jb250ZW50LnNpemUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsIGRvYy5yZXNvbHZlKHBhcnNlZFNlbC5hbmNob3IpLCBkb2MucmVzb2x2ZShwYXJzZWRTZWwuaGVhZCkpO1xufVxuLy8gR2l2ZW4gdHdvIHNhbWUtbGVuZ3RoLCBub24tZW1wdHkgZnJhZ21lbnRzIG9mIGlubGluZSBjb250ZW50LFxuLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGZpcnN0IGNvdWxkIGJlIGNyZWF0ZWQgZnJvbSB0aGUgc2Vjb25kIGJ5XG4vLyByZW1vdmluZyBvciBhZGRpbmcgYSBzaW5nbGUgbWFyayB0eXBlLlxuZnVuY3Rpb24gaXNNYXJrQ2hhbmdlKGN1ciwgcHJldikge1xuICAgIGxldCBjdXJNYXJrcyA9IGN1ci5maXJzdENoaWxkLm1hcmtzLCBwcmV2TWFya3MgPSBwcmV2LmZpcnN0Q2hpbGQubWFya3M7XG4gICAgbGV0IGFkZGVkID0gY3VyTWFya3MsIHJlbW92ZWQgPSBwcmV2TWFya3MsIHR5cGUsIG1hcmssIHVwZGF0ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgYWRkZWQgPSBwcmV2TWFya3NbaV0ucmVtb3ZlRnJvbVNldChhZGRlZCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVtb3ZlZCA9IGN1ck1hcmtzW2ldLnJlbW92ZUZyb21TZXQocmVtb3ZlZCk7XG4gICAgaWYgKGFkZGVkLmxlbmd0aCA9PSAxICYmIHJlbW92ZWQubGVuZ3RoID09IDApIHtcbiAgICAgICAgbWFyayA9IGFkZGVkWzBdO1xuICAgICAgICB0eXBlID0gXCJhZGRcIjtcbiAgICAgICAgdXBkYXRlID0gKG5vZGUpID0+IG5vZGUubWFyayhtYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWRkZWQubGVuZ3RoID09IDAgJiYgcmVtb3ZlZC5sZW5ndGggPT0gMSkge1xuICAgICAgICBtYXJrID0gcmVtb3ZlZFswXTtcbiAgICAgICAgdHlwZSA9IFwicmVtb3ZlXCI7XG4gICAgICAgIHVwZGF0ZSA9IChub2RlKSA9PiBub2RlLm1hcmsobWFyay5yZW1vdmVGcm9tU2V0KG5vZGUubWFya3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgdXBkYXRlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldi5jaGlsZENvdW50OyBpKyspXG4gICAgICAgIHVwZGF0ZWQucHVzaCh1cGRhdGUocHJldi5jaGlsZChpKSkpO1xuICAgIGlmIChGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLmVxKGN1cikpXG4gICAgICAgIHJldHVybiB7IG1hcmssIHR5cGUgfTtcbn1cbmZ1bmN0aW9uIGxvb2tzTGlrZUpvaW4ob2xkLCBzdGFydCwgZW5kLCAkbmV3U3RhcnQsICRuZXdFbmQpIHtcbiAgICBpZiAoISRuZXdTdGFydC5wYXJlbnQuaXNUZXh0YmxvY2sgfHxcbiAgICAgICAgLy8gVGhlIGNvbnRlbnQgbXVzdCBoYXZlIHNocnVua1xuICAgICAgICBlbmQgLSBzdGFydCA8PSAkbmV3RW5kLnBvcyAtICRuZXdTdGFydC5wb3MgfHxcbiAgICAgICAgLy8gbmV3RW5kIG11c3QgcG9pbnQgZGlyZWN0bHkgYXQgb3IgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgYmxvY2sgdGhhdCBuZXdTdGFydCBwb2ludHMgaW50b1xuICAgICAgICBza2lwQ2xvc2luZ0FuZE9wZW5pbmcoJG5ld1N0YXJ0LCB0cnVlLCBmYWxzZSkgPCAkbmV3RW5kLnBvcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkc3RhcnQgPSBvbGQucmVzb2x2ZShzdGFydCk7XG4gICAgLy8gU3RhcnQgbXVzdCBiZSBhdCB0aGUgZW5kIG9mIGEgYmxvY2tcbiAgICBpZiAoJHN0YXJ0LnBhcmVudE9mZnNldCA8ICRzdGFydC5wYXJlbnQuY29udGVudC5zaXplIHx8ICEkc3RhcnQucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRuZXh0ID0gb2xkLnJlc29sdmUoc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRzdGFydCwgdHJ1ZSwgdHJ1ZSkpO1xuICAgIC8vIFRoZSBuZXh0IHRleHRibG9jayBtdXN0IHN0YXJ0IGJlZm9yZSBlbmQgYW5kIGVuZCBuZWFyIGl0XG4gICAgaWYgKCEkbmV4dC5wYXJlbnQuaXNUZXh0YmxvY2sgfHwgJG5leHQucG9zID4gZW5kIHx8XG4gICAgICAgIHNraXBDbG9zaW5nQW5kT3BlbmluZygkbmV4dCwgdHJ1ZSwgZmFsc2UpIDwgZW5kKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gVGhlIGZyYWdtZW50cyBhZnRlciB0aGUgam9pbiBwb2ludCBtdXN0IG1hdGNoXG4gICAgcmV0dXJuICRuZXdTdGFydC5wYXJlbnQuY29udGVudC5jdXQoJG5ld1N0YXJ0LnBhcmVudE9mZnNldCkuZXEoJG5leHQucGFyZW50LmNvbnRlbnQpO1xufVxuZnVuY3Rpb24gc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRwb3MsIGZyb21FbmQsIG1heU9wZW4pIHtcbiAgICBsZXQgZGVwdGggPSAkcG9zLmRlcHRoLCBlbmQgPSBmcm9tRW5kID8gJHBvcy5lbmQoKSA6ICRwb3MucG9zO1xuICAgIHdoaWxlIChkZXB0aCA+IDAgJiYgKGZyb21FbmQgfHwgJHBvcy5pbmRleEFmdGVyKGRlcHRoKSA9PSAkcG9zLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpKSB7XG4gICAgICAgIGRlcHRoLS07XG4gICAgICAgIGVuZCsrO1xuICAgICAgICBmcm9tRW5kID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChtYXlPcGVuKSB7XG4gICAgICAgIGxldCBuZXh0ID0gJHBvcy5ub2RlKGRlcHRoKS5tYXliZUNoaWxkKCRwb3MuaW5kZXhBZnRlcihkZXB0aCkpO1xuICAgICAgICB3aGlsZSAobmV4dCAmJiAhbmV4dC5pc0xlYWYpIHtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5kO1xufVxuZnVuY3Rpb24gZmluZERpZmYoYSwgYiwgcG9zLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpIHtcbiAgICBsZXQgc3RhcnQgPSBhLmZpbmREaWZmU3RhcnQoYiwgcG9zKTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHsgYTogZW5kQSwgYjogZW5kQiB9ID0gYS5maW5kRGlmZkVuZChiLCBwb3MgKyBhLnNpemUsIHBvcyArIGIuc2l6ZSk7XG4gICAgaWYgKHByZWZlcnJlZFNpZGUgPT0gXCJlbmRcIikge1xuICAgICAgICBsZXQgYWRqdXN0ID0gTWF0aC5tYXgoMCwgc3RhcnQgLSBNYXRoLm1pbihlbmRBLCBlbmRCKSk7XG4gICAgICAgIHByZWZlcnJlZFBvcyAtPSBlbmRBICsgYWRqdXN0IC0gc3RhcnQ7XG4gICAgfVxuICAgIGlmIChlbmRBIDwgc3RhcnQgJiYgYS5zaXplIDwgYi5zaXplKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IHN0YXJ0ICYmIHByZWZlcnJlZFBvcyA+PSBlbmRBID8gc3RhcnQgLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBzdGFydCAtPSBtb3ZlO1xuICAgICAgICBpZiAoc3RhcnQgJiYgc3RhcnQgPCBiLnNpemUgJiYgaXNTdXJyb2dhdGVQYWlyKGIudGV4dEJldHdlZW4oc3RhcnQgLSAxLCBzdGFydCArIDEpKSlcbiAgICAgICAgICAgIHN0YXJ0ICs9IG1vdmUgPyAxIDogLTE7XG4gICAgICAgIGVuZEIgPSBzdGFydCArIChlbmRCIC0gZW5kQSk7XG4gICAgICAgIGVuZEEgPSBzdGFydDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZW5kQiA8IHN0YXJ0KSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IHN0YXJ0ICYmIHByZWZlcnJlZFBvcyA+PSBlbmRCID8gc3RhcnQgLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBzdGFydCAtPSBtb3ZlO1xuICAgICAgICBpZiAoc3RhcnQgJiYgc3RhcnQgPCBhLnNpemUgJiYgaXNTdXJyb2dhdGVQYWlyKGEudGV4dEJldHdlZW4oc3RhcnQgLSAxLCBzdGFydCArIDEpKSlcbiAgICAgICAgICAgIHN0YXJ0ICs9IG1vdmUgPyAxIDogLTE7XG4gICAgICAgIGVuZEEgPSBzdGFydCArIChlbmRBIC0gZW5kQik7XG4gICAgICAgIGVuZEIgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZEEsIGVuZEIgfTtcbn1cbmZ1bmN0aW9uIGlzU3Vycm9nYXRlUGFpcihzdHIpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCAhPSAyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGEgPSBzdHIuY2hhckNvZGVBdCgwKSwgYiA9IHN0ci5jaGFyQ29kZUF0KDEpO1xuICAgIHJldHVybiBhID49IDB4REMwMCAmJiBhIDw9IDB4REZGRiAmJiBiID49IDB4RDgwMCAmJiBiIDw9IDB4REJGRjtcbn1cblxuLyoqXG5AaW50ZXJuYWxcbiovXG5jb25zdCBfX3NlcmlhbGl6ZUZvckNsaXBib2FyZCA9IHNlcmlhbGl6ZUZvckNsaXBib2FyZDtcbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX19wYXJzZUZyb21DbGlwYm9hcmQgPSBwYXJzZUZyb21DbGlwYm9hcmQ7XG4vKipcbkBpbnRlcm5hbFxuKi9cbmNvbnN0IF9fZW5kQ29tcG9zaXRpb24gPSBlbmRDb21wb3NpdGlvbjtcbi8qKlxuQW4gZWRpdG9yIHZpZXcgbWFuYWdlcyB0aGUgRE9NIHN0cnVjdHVyZSB0aGF0IHJlcHJlc2VudHMgYW5cbmVkaXRhYmxlIGRvY3VtZW50LiBJdHMgc3RhdGUgYW5kIGJlaGF2aW9yIGFyZSBkZXRlcm1pbmVkIGJ5IGl0c1xuW3Byb3BzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EaXJlY3RFZGl0b3JQcm9wcykuXG4qL1xuY2xhc3MgRWRpdG9yVmlldyB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdmlldy4gYHBsYWNlYCBtYXkgYmUgYSBET00gbm9kZSB0aGF0IHRoZSBlZGl0b3Igc2hvdWxkXG4gICAgYmUgYXBwZW5kZWQgdG8sIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHBsYWNlIGl0IGludG8gdGhlIGRvY3VtZW50LFxuICAgIG9yIGFuIG9iamVjdCB3aG9zZSBgbW91bnRgIHByb3BlcnR5IGhvbGRzIHRoZSBub2RlIHRvIHVzZSBhcyB0aGVcbiAgICBkb2N1bWVudCBjb250YWluZXIuIElmIGl0IGlzIGBudWxsYCwgdGhlIGVkaXRvciB3aWxsIG5vdCBiZVxuICAgIGFkZGVkIHRvIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlLCBwcm9wcykge1xuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIEtsdWRnZSB1c2VkIHRvIHdvcmsgYXJvdW5kIGEgQ2hyb21lIGJ1ZyBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFja1dyaXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFya0N1cnNvciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJzb3JXcmFwcGVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW5wdXQgPSBuZXcgSW5wdXRTdGF0ZTtcbiAgICAgICAgdGhpcy5wcmV2RGlyZWN0UGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLnBsdWdpblZpZXdzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBIb2xkcyBgdHJ1ZWAgd2hlbiBhIGhhY2sgbm9kZSBpcyBuZWVkZWQgaW4gRmlyZWZveCB0byBwcmV2ZW50IHRoZVxuICAgICAgICBbc3BhY2UgaXMgZWF0ZW4gaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9zZU1pcnJvci9wcm9zZW1pcnJvci9pc3N1ZXMvNjUxKVxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXF1aXJlc0dlY2tvSGFja05vZGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZW4gZWRpdG9yIGNvbnRlbnQgaXMgYmVpbmcgZHJhZ2dlZCwgdGhpcyBvYmplY3QgY29udGFpbnNcbiAgICAgICAgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGRyYWdnZWQgc2xpY2UgYW5kIHdoZXRoZXIgaXQgaXMgYmVpbmdcbiAgICAgICAgY29waWVkIG9yIG1vdmVkLiBBdCBhbnkgb3RoZXIgdGltZSwgaXQgaXMgbnVsbC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Byb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBwcm9wcy5zdGF0ZTtcbiAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zID0gcHJvcHMucGx1Z2lucyB8fCBbXTtcbiAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zLmZvckVhY2goY2hlY2tTdGF0ZUNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSB0aGlzLmRpc3BhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZG9tID0gKHBsYWNlICYmIHBsYWNlLm1vdW50KSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBpZiAocGxhY2UpIHtcbiAgICAgICAgICAgIGlmIChwbGFjZS5hcHBlbmRDaGlsZClcbiAgICAgICAgICAgICAgICBwbGFjZS5hcHBlbmRDaGlsZCh0aGlzLmRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGxhY2UgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIHBsYWNlKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYWNlLm1vdW50KVxuICAgICAgICAgICAgICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGdldEVkaXRhYmxlKHRoaXMpO1xuICAgICAgICB1cGRhdGVDdXJzb3JXcmFwcGVyKHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGVWaWV3cyA9IGJ1aWxkTm9kZVZpZXdzKHRoaXMpO1xuICAgICAgICB0aGlzLmRvY1ZpZXcgPSBkb2NWaWV3RGVzYyh0aGlzLnN0YXRlLmRvYywgY29tcHV0ZURvY0RlY28odGhpcyksIHZpZXdEZWNvcmF0aW9ucyh0aGlzKSwgdGhpcy5kb20sIHRoaXMpO1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyID0gbmV3IERPTU9ic2VydmVyKHRoaXMsIChmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKSA9PiByZWFkRE9NQ2hhbmdlKHRoaXMsIGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpKTtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICBpbml0SW5wdXQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlUGx1Z2luVmlld3MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSG9sZHMgYHRydWVgIHdoZW4gYVxuICAgIFtjb21wb3NpdGlvbl0oaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3VpZXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHMpXG4gICAgaXMgYWN0aXZlLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2luZygpIHsgcmV0dXJuIHRoaXMuaW5wdXQuY29tcG9zaW5nOyB9XG4gICAgLyoqXG4gICAgVGhlIHZpZXcncyBjdXJyZW50IFtwcm9wc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMpLlxuICAgICovXG4gICAgZ2V0IHByb3BzKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvcHMuc3RhdGUgIT0gdGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgbGV0IHByZXYgPSB0aGlzLl9wcm9wcztcbiAgICAgICAgICAgIHRoaXMuX3Byb3BzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvcHNbbmFtZV0gPSBwcmV2W25hbWVdO1xuICAgICAgICAgICAgdGhpcy5fcHJvcHMuc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wcztcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB2aWV3J3MgcHJvcHMuIFdpbGwgaW1tZWRpYXRlbHkgY2F1c2UgYW4gdXBkYXRlIHRvXG4gICAgdGhlIERPTS5cbiAgICAqL1xuICAgIHVwZGF0ZShwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMuaGFuZGxlRE9NRXZlbnRzICE9IHRoaXMuX3Byb3BzLmhhbmRsZURPTUV2ZW50cylcbiAgICAgICAgICAgIGVuc3VyZUxpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgbGV0IHByZXZQcm9wcyA9IHRoaXMuX3Byb3BzO1xuICAgICAgICB0aGlzLl9wcm9wcyA9IHByb3BzO1xuICAgICAgICBpZiAocHJvcHMucGx1Z2lucykge1xuICAgICAgICAgICAgcHJvcHMucGx1Z2lucy5mb3JFYWNoKGNoZWNrU3RhdGVDb21wb25lbnQpO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zID0gcHJvcHMucGx1Z2lucztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlSW5uZXIocHJvcHMuc3RhdGUsIHByZXZQcm9wcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdmlldyBieSB1cGRhdGluZyBleGlzdGluZyBwcm9wcyBvYmplY3Qgd2l0aCB0aGUgb2JqZWN0XG4gICAgZ2l2ZW4gYXMgYXJndW1lbnQuIEVxdWl2YWxlbnQgdG8gYHZpZXcudXBkYXRlKE9iamVjdC5hc3NpZ24oe30sXG4gICAgdmlldy5wcm9wcywgcHJvcHMpKWAuXG4gICAgKi9cbiAgICBzZXRQcm9wcyhwcm9wcykge1xuICAgICAgICBsZXQgdXBkYXRlZCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuX3Byb3BzKVxuICAgICAgICAgICAgdXBkYXRlZFtuYW1lXSA9IHRoaXMuX3Byb3BzW25hbWVdO1xuICAgICAgICB1cGRhdGVkLnN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcm9wcylcbiAgICAgICAgICAgIHVwZGF0ZWRbbmFtZV0gPSBwcm9wc1tuYW1lXTtcbiAgICAgICAgdGhpcy51cGRhdGUodXBkYXRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgZWRpdG9yJ3MgYHN0YXRlYCBwcm9wLCB3aXRob3V0IHRvdWNoaW5nIGFueSBvZiB0aGVcbiAgICBvdGhlciBwcm9wcy5cbiAgICAqL1xuICAgIHVwZGF0ZVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGVJbm5lcihzdGF0ZSwgdGhpcy5fcHJvcHMpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZUlubmVyKHN0YXRlLCBwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgcHJldiA9IHRoaXMuc3RhdGUsIHJlZHJhdyA9IGZhbHNlLCB1cGRhdGVTZWwgPSBmYWxzZTtcbiAgICAgICAgLy8gV2hlbiBzdG9yZWQgbWFya3MgYXJlIGFkZGVkLCBzdG9wIGNvbXBvc2l0aW9uLCBzbyB0aGF0IHRoZXkgY2FuXG4gICAgICAgIC8vIGJlIGRpc3BsYXllZC5cbiAgICAgICAgaWYgKHN0YXRlLnN0b3JlZE1hcmtzICYmIHRoaXMuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICBjbGVhckNvbXBvc2l0aW9uKHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlU2VsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIGxldCBwbHVnaW5zQ2hhbmdlZCA9IHByZXYucGx1Z2lucyAhPSBzdGF0ZS5wbHVnaW5zIHx8IHRoaXMuX3Byb3BzLnBsdWdpbnMgIT0gcHJldlByb3BzLnBsdWdpbnM7XG4gICAgICAgIGlmIChwbHVnaW5zQ2hhbmdlZCB8fCB0aGlzLl9wcm9wcy5wbHVnaW5zICE9IHByZXZQcm9wcy5wbHVnaW5zIHx8IHRoaXMuX3Byb3BzLm5vZGVWaWV3cyAhPSBwcmV2UHJvcHMubm9kZVZpZXdzKSB7XG4gICAgICAgICAgICBsZXQgbm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZE5vZGVWaWV3cyhub2RlVmlld3MsIHRoaXMubm9kZVZpZXdzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZVZpZXdzID0gbm9kZVZpZXdzO1xuICAgICAgICAgICAgICAgIHJlZHJhdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsdWdpbnNDaGFuZ2VkIHx8IHByZXZQcm9wcy5oYW5kbGVET01FdmVudHMgIT0gdGhpcy5fcHJvcHMuaGFuZGxlRE9NRXZlbnRzKSB7XG4gICAgICAgICAgICBlbnN1cmVMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGdldEVkaXRhYmxlKHRoaXMpO1xuICAgICAgICB1cGRhdGVDdXJzb3JXcmFwcGVyKHRoaXMpO1xuICAgICAgICBsZXQgaW5uZXJEZWNvID0gdmlld0RlY29yYXRpb25zKHRoaXMpLCBvdXRlckRlY28gPSBjb21wdXRlRG9jRGVjbyh0aGlzKTtcbiAgICAgICAgbGV0IHNjcm9sbCA9IHByZXYucGx1Z2lucyAhPSBzdGF0ZS5wbHVnaW5zICYmICFwcmV2LmRvYy5lcShzdGF0ZS5kb2MpID8gXCJyZXNldFwiXG4gICAgICAgICAgICA6IHN0YXRlLnNjcm9sbFRvU2VsZWN0aW9uID4gcHJldi5zY3JvbGxUb1NlbGVjdGlvbiA/IFwidG8gc2VsZWN0aW9uXCIgOiBcInByZXNlcnZlXCI7XG4gICAgICAgIGxldCB1cGRhdGVEb2MgPSByZWRyYXcgfHwgIXRoaXMuZG9jVmlldy5tYXRjaGVzTm9kZShzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgICAgaWYgKHVwZGF0ZURvYyB8fCAhc3RhdGUuc2VsZWN0aW9uLmVxKHByZXYuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHVwZGF0ZVNlbCA9IHRydWU7XG4gICAgICAgIGxldCBvbGRTY3JvbGxQb3MgPSBzY3JvbGwgPT0gXCJwcmVzZXJ2ZVwiICYmIHVwZGF0ZVNlbCAmJiB0aGlzLmRvbS5zdHlsZS5vdmVyZmxvd0FuY2hvciA9PSBudWxsICYmIHN0b3JlU2Nyb2xsUG9zKHRoaXMpO1xuICAgICAgICBpZiAodXBkYXRlU2VsKSB7XG4gICAgICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGFuIGlzc3VlIGluIENocm9tZSwgSUUsIGFuZCBFZGdlIHdoZXJlIGNoYW5naW5nXG4gICAgICAgICAgICAvLyB0aGUgRE9NIGFyb3VuZCBhbiBhY3RpdmUgc2VsZWN0aW9uIHB1dHMgaXQgaW50byBhIGJyb2tlblxuICAgICAgICAgICAgLy8gc3RhdGUgd2hlcmUgdGhlIHRoaW5nIHRoZSB1c2VyIHNlZXMgZGlmZmVycyBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gc2VsZWN0aW9uIHJlcG9ydGVkIGJ5IHRoZSBTZWxlY3Rpb24gb2JqZWN0ICgjNzEwLCAjOTczLFxuICAgICAgICAgICAgLy8gIzEwMTEsICMxMDEzLCAjMTAzNSkuXG4gICAgICAgICAgICBsZXQgZm9yY2VTZWxVcGRhdGUgPSB1cGRhdGVEb2MgJiYgKGllIHx8IGNocm9tZSkgJiYgIXRoaXMuY29tcG9zaW5nICYmXG4gICAgICAgICAgICAgICAgIXByZXYuc2VsZWN0aW9uLmVtcHR5ICYmICFzdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiYgc2VsZWN0aW9uQ29udGV4dENoYW5nZWQocHJldi5zZWxlY3Rpb24sIHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICBpZiAodXBkYXRlRG9jKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgdGhhdCB0aGUgc2VsZWN0aW9uIHBvaW50cyBpbnRvIGlzIHdyaXR0ZW4gdG8sXG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIHNvbWV0aW1lcyBzdGFydHMgbWlzcmVwb3J0aW5nIHRoZSBzZWxlY3Rpb24sIHNvIHRoaXNcbiAgICAgICAgICAgICAgICAvLyB0cmFja3MgdGhhdCBhbmQgZm9yY2VzIGEgc2VsZWN0aW9uIHJlc2V0IHdoZW4gb3VyIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIGRpZCB3cml0ZSB0byB0aGUgbm9kZS5cbiAgICAgICAgICAgICAgICBsZXQgY2hyb21lS2x1ZGdlID0gY2hyb21lID8gKHRoaXMudHJhY2tXcml0ZXMgPSB0aGlzLmRvbVNlbGVjdGlvblJhbmdlKCkuZm9jdXNOb2RlKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHJhdyB8fCAhdGhpcy5kb2NWaWV3LnVwZGF0ZShzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlT3V0ZXJEZWNvKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3ID0gZG9jVmlld0Rlc2Moc3RhdGUuZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgdGhpcy5kb20sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hyb21lS2x1ZGdlICYmICF0aGlzLnRyYWNrV3JpdGVzKVxuICAgICAgICAgICAgICAgICAgICBmb3JjZVNlbFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBmb3IgYW4gaXNzdWUgd2hlcmUgYW4gdXBkYXRlIGFycml2aW5nIHJpZ2h0IGJldHdlZW5cbiAgICAgICAgICAgIC8vIGEgRE9NIHNlbGVjdGlvbiBjaGFuZ2UgYW5kIHRoZSBcInNlbGVjdGlvbmNoYW5nZVwiIGV2ZW50IGZvciBpdFxuICAgICAgICAgICAgLy8gY2FuIGNhdXNlIGEgc3B1cmlvdXMgRE9NIHNlbGVjdGlvbiB1cGRhdGUsIGRpc3J1cHRpbmcgbW91c2VcbiAgICAgICAgICAgIC8vIGRyYWcgc2VsZWN0aW9uLlxuICAgICAgICAgICAgaWYgKGZvcmNlU2VsVXBkYXRlIHx8XG4gICAgICAgICAgICAgICAgISh0aGlzLmlucHV0Lm1vdXNlRG93biAmJiB0aGlzLmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb24uZXEodGhpcy5kb21TZWxlY3Rpb25SYW5nZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICBhbmNob3JJblJpZ2h0UGxhY2UodGhpcykpKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odGhpcywgZm9yY2VTZWxVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3luY05vZGVTZWxlY3Rpb24odGhpcywgc3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUGx1Z2luVmlld3MocHJldik7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5kcmFnZ2luZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGUpICYmICFwcmV2LmRvYy5lcShzdGF0ZS5kb2MpKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVEcmFnZ2VkTm9kZSh0aGlzLmRyYWdnaW5nLCBwcmV2KTtcbiAgICAgICAgaWYgKHNjcm9sbCA9PSBcInJlc2V0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2Nyb2xsID09IFwidG8gc2VsZWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9TZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvbGRTY3JvbGxQb3MpIHtcbiAgICAgICAgICAgIHJlc2V0U2Nyb2xsUG9zKG9sZFNjcm9sbFBvcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzY3JvbGxUb1NlbGVjdGlvbigpIHtcbiAgICAgICAgbGV0IHN0YXJ0RE9NID0gdGhpcy5kb21TZWxlY3Rpb25SYW5nZSgpLmZvY3VzTm9kZTtcbiAgICAgICAgaWYgKHRoaXMuc29tZVByb3AoXCJoYW5kbGVTY3JvbGxUb1NlbGVjdGlvblwiLCBmID0+IGYodGhpcykpKSA7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuZG9jVmlldy5kb21BZnRlclBvcyh0aGlzLnN0YXRlLnNlbGVjdGlvbi5mcm9tKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICBzY3JvbGxSZWN0SW50b1ZpZXcodGhpcywgdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzdGFydERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY3JvbGxSZWN0SW50b1ZpZXcodGhpcywgdGhpcy5jb29yZHNBdFBvcyh0aGlzLnN0YXRlLnNlbGVjdGlvbi5oZWFkLCAxKSwgc3RhcnRET00pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3lQbHVnaW5WaWV3cygpIHtcbiAgICAgICAgbGV0IHZpZXc7XG4gICAgICAgIHdoaWxlICh2aWV3ID0gdGhpcy5wbHVnaW5WaWV3cy5wb3AoKSlcbiAgICAgICAgICAgIGlmICh2aWV3LmRlc3Ryb3kpXG4gICAgICAgICAgICAgICAgdmlldy5kZXN0cm95KCk7XG4gICAgfVxuICAgIHVwZGF0ZVBsdWdpblZpZXdzKHByZXZTdGF0ZSkge1xuICAgICAgICBpZiAoIXByZXZTdGF0ZSB8fCBwcmV2U3RhdGUucGx1Z2lucyAhPSB0aGlzLnN0YXRlLnBsdWdpbnMgfHwgdGhpcy5kaXJlY3RQbHVnaW5zICE9IHRoaXMucHJldkRpcmVjdFBsdWdpbnMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldkRpcmVjdFBsdWdpbnMgPSB0aGlzLmRpcmVjdFBsdWdpbnM7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lQbHVnaW5WaWV3cygpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRpcmVjdFBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5kaXJlY3RQbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy52aWV3KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpblZpZXdzLnB1c2gocGx1Z2luLnNwZWMudmlldyh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhdGUucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLnN0YXRlLnBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLnZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luVmlld3MucHVzaChwbHVnaW4uc3BlYy52aWV3KHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5WaWV3cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW5WaWV3ID0gdGhpcy5wbHVnaW5WaWV3c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luVmlldy51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpblZpZXcudXBkYXRlKHRoaXMsIHByZXZTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlRHJhZ2dlZE5vZGUoZHJhZ2dpbmcsIHByZXYpIHtcbiAgICAgICAgbGV0IHNlbCA9IGRyYWdnaW5nLm5vZGUsIGZvdW5kID0gLTE7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRvYy5ub2RlQXQoc2VsLmZyb20pID09IHNlbC5ub2RlKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHNlbC5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1vdmVkUG9zID0gc2VsLmZyb20gKyAodGhpcy5zdGF0ZS5kb2MuY29udGVudC5zaXplIC0gcHJldi5kb2MuY29udGVudC5zaXplKTtcbiAgICAgICAgICAgIGxldCBtb3ZlZCA9IG1vdmVkUG9zID4gMCAmJiB0aGlzLnN0YXRlLmRvYy5ub2RlQXQobW92ZWRQb3MpO1xuICAgICAgICAgICAgaWYgKG1vdmVkID09IHNlbC5ub2RlKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gbW92ZWRQb3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IG5ldyBEcmFnZ2luZyhkcmFnZ2luZy5zbGljZSwgZHJhZ2dpbmcubW92ZSwgZm91bmQgPCAwID8gdW5kZWZpbmVkIDogTm9kZVNlbGVjdGlvbi5jcmVhdGUodGhpcy5zdGF0ZS5kb2MsIGZvdW5kKSk7XG4gICAgfVxuICAgIHNvbWVQcm9wKHByb3BOYW1lLCBmKSB7XG4gICAgICAgIGxldCBwcm9wID0gdGhpcy5fcHJvcHMgJiYgdGhpcy5fcHJvcHNbcHJvcE5hbWVdLCB2YWx1ZTtcbiAgICAgICAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGlyZWN0UGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHByb3AgPSB0aGlzLmRpcmVjdFBsdWdpbnNbaV0ucHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGx1Z2lucyA9IHRoaXMuc3RhdGUucGx1Z2lucztcbiAgICAgICAgaWYgKHBsdWdpbnMpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcCA9IHBsdWdpbnNbaV0ucHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wICE9IG51bGwgJiYgKHZhbHVlID0gZiA/IGYocHJvcCkgOiBwcm9wKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBRdWVyeSB3aGV0aGVyIHRoZSB2aWV3IGhhcyBmb2N1cy5cbiAgICAqL1xuICAgIGhhc0ZvY3VzKCkge1xuICAgICAgICAvLyBXb3JrIGFyb3VuZCBJRSBub3QgaGFuZGxpbmcgZm9jdXMgY29ycmVjdGx5IGlmIHJlc2l6ZSBoYW5kbGVzIGFyZSBzaG93bi5cbiAgICAgICAgLy8gSWYgdGhlIGN1cnNvciBpcyBpbnNpZGUgYW4gZWxlbWVudCB3aXRoIHJlc2l6ZSBoYW5kbGVzLCBhY3RpdmVFbGVtZW50XG4gICAgICAgIC8vIHdpbGwgYmUgdGhhdCBlbGVtZW50IGluc3RlYWQgb2YgdGhpcy5kb20uXG4gICAgICAgIGlmIChpZSkge1xuICAgICAgICAgICAgLy8gSWYgYWN0aXZlRWxlbWVudCBpcyB3aXRoaW4gdGhpcy5kb20sIGFuZCB0aGVyZSBhcmUgbm8gb3RoZXIgZWxlbWVudHNcbiAgICAgICAgICAgIC8vIHNldHRpbmcgYGNvbnRlbnRlZGl0YWJsZWAgdG8gZmFsc2UgaW4gYmV0d2VlbiwgdHJlYXQgaXQgYXMgZm9jdXNlZC5cbiAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAobm9kZSA9PSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCAhdGhpcy5kb20uY29udGFpbnMobm9kZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUgJiYgdGhpcy5kb20gIT0gbm9kZSAmJiB0aGlzLmRvbS5jb250YWlucyhub2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSAnZmFsc2UnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmRvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgRm9jdXMgdGhlIGVkaXRvci5cbiAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdGFibGUpXG4gICAgICAgICAgICBmb2N1c1ByZXZlbnRTY3JvbGwodGhpcy5kb20pO1xuICAgICAgICBzZWxlY3Rpb25Ub0RPTSh0aGlzKTtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGRvY3VtZW50IHJvb3QgaW4gd2hpY2ggdGhlIGVkaXRvciBleGlzdHMuIFRoaXMgd2lsbFxuICAgIHVzdWFsbHkgYmUgdGhlIHRvcC1sZXZlbCBgZG9jdW1lbnRgLCBidXQgbWlnaHQgYmUgYSBbc2hhZG93XG4gICAgRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9XZWJfQ29tcG9uZW50cy9TaGFkb3dfRE9NKVxuICAgIHJvb3QgaWYgdGhlIGVkaXRvciBpcyBpbnNpZGUgb25lLlxuICAgICovXG4gICAgZ2V0IHJvb3QoKSB7XG4gICAgICAgIGxldCBjYWNoZWQgPSB0aGlzLl9yb290O1xuICAgICAgICBpZiAoY2FjaGVkID09IG51bGwpXG4gICAgICAgICAgICBmb3IgKGxldCBzZWFyY2ggPSB0aGlzLmRvbS5wYXJlbnROb2RlOyBzZWFyY2g7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5ub2RlVHlwZSA9PSA5IHx8IChzZWFyY2gubm9kZVR5cGUgPT0gMTEgJiYgc2VhcmNoLmhvc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VhcmNoLmdldFNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihzZWFyY2gpLmdldFNlbGVjdGlvbiA9ICgpID0+IHNlYXJjaC5vd25lckRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdCA9IHNlYXJjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZWQgfHwgZG9jdW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZW4gYW4gZXhpc3RpbmcgZWRpdG9yIHZpZXcgaXMgbW92ZWQgdG8gYSBuZXcgZG9jdW1lbnQgb3JcbiAgICBzaGFkb3cgdHJlZSwgY2FsbCB0aGlzIHRvIG1ha2UgaXQgcmVjb21wdXRlIGl0cyByb290LlxuICAgICovXG4gICAgdXBkYXRlUm9vdCgpIHtcbiAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEdpdmVuIGEgcGFpciBvZiB2aWV3cG9ydCBjb29yZGluYXRlcywgcmV0dXJuIHRoZSBkb2N1bWVudFxuICAgIHBvc2l0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlbS4gTWF5IHJldHVybiBudWxsIGlmIHRoZSBnaXZlblxuICAgIGNvb3JkaW5hdGVzIGFyZW4ndCBpbnNpZGUgb2YgdGhlIGVkaXRvci4gV2hlbiBhbiBvYmplY3QgaXNcbiAgICByZXR1cm5lZCwgaXRzIGBwb3NgIHByb3BlcnR5IGlzIHRoZSBwb3NpdGlvbiBuZWFyZXN0IHRvIHRoZVxuICAgIGNvb3JkaW5hdGVzLCBhbmQgaXRzIGBpbnNpZGVgIHByb3BlcnR5IGhvbGRzIHRoZSBwb3NpdGlvbiBvZiB0aGVcbiAgICBpbm5lciBub2RlIHRoYXQgdGhlIHBvc2l0aW9uIGZhbGxzIGluc2lkZSBvZiwgb3IgLTEgaWYgaXQgaXMgYXRcbiAgICB0aGUgdG9wIGxldmVsLCBub3QgaW4gYW55IG5vZGUuXG4gICAgKi9cbiAgICBwb3NBdENvb3Jkcyhjb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHBvc0F0Q29vcmRzKHRoaXMsIGNvb3Jkcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIHZpZXdwb3J0IHJlY3RhbmdsZSBhdCBhIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLlxuICAgIGBsZWZ0YCBhbmQgYHJpZ2h0YCB3aWxsIGJlIHRoZSBzYW1lIG51bWJlciwgYXMgdGhpcyByZXR1cm5zIGFcbiAgICBmbGF0IGN1cnNvci1pc2ggcmVjdGFuZ2xlLiBJZiB0aGUgcG9zaXRpb24gaXMgYmV0d2VlbiB0d28gdGhpbmdzXG4gICAgdGhhdCBhcmVuJ3QgZGlyZWN0bHkgYWRqYWNlbnQsIGBzaWRlYCBkZXRlcm1pbmVzIHdoaWNoIGVsZW1lbnRcbiAgICBpcyB1c2VkLiBXaGVuIDwgMCwgdGhlIGVsZW1lbnQgYmVmb3JlIHRoZSBwb3NpdGlvbiBpcyB1c2VkLFxuICAgIG90aGVyd2lzZSB0aGUgZWxlbWVudCBhZnRlci5cbiAgICAqL1xuICAgIGNvb3Jkc0F0UG9zKHBvcywgc2lkZSA9IDEpIHtcbiAgICAgICAgcmV0dXJuIGNvb3Jkc0F0UG9zKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIERPTSBwb3NpdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBkb2N1bWVudFxuICAgIHBvc2l0aW9uLiBXaGVuIGBzaWRlYCBpcyBuZWdhdGl2ZSwgZmluZCB0aGUgcG9zaXRpb24gYXMgY2xvc2UgYXNcbiAgICBwb3NzaWJsZSB0byB0aGUgY29udGVudCBiZWZvcmUgdGhlIHBvc2l0aW9uLiBXaGVuIHBvc2l0aXZlLFxuICAgIHByZWZlciBwb3NpdGlvbnMgY2xvc2UgdG8gdGhlIGNvbnRlbnQgYWZ0ZXIgdGhlIHBvc2l0aW9uLiBXaGVuXG4gICAgemVybywgcHJlZmVyIGFzIHNoYWxsb3cgYSBwb3NpdGlvbiBhcyBwb3NzaWJsZS5cbiAgICBcbiAgICBOb3RlIHRoYXQgeW91IHNob3VsZCAqKm5vdCoqIG11dGF0ZSB0aGUgZWRpdG9yJ3MgaW50ZXJuYWwgRE9NLFxuICAgIG9ubHkgaW5zcGVjdCBpdCAoYW5kIGV2ZW4gdGhhdCBpcyB1c3VhbGx5IG5vdCBuZWNlc3NhcnkpLlxuICAgICovXG4gICAgZG9tQXRQb3MocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgRE9NIG5vZGUgdGhhdCByZXByZXNlbnRzIHRoZSBkb2N1bWVudCBub2RlIGFmdGVyIHRoZVxuICAgIGdpdmVuIHBvc2l0aW9uLiBNYXkgcmV0dXJuIGBudWxsYCB3aGVuIHRoZSBwb3NpdGlvbiBkb2Vzbid0IHBvaW50XG4gICAgaW4gZnJvbnQgb2YgYSBub2RlIG9yIGlmIHRoZSBub2RlIGlzIGluc2lkZSBhbiBvcGFxdWUgbm9kZSB2aWV3LlxuICAgIFxuICAgIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgYWJsZSB0byBjYWxsIHRoaW5ncyBsaWtlXG4gICAgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgb24gdGhhdCBET00gbm9kZS4gRG8gKipub3QqKiBtdXRhdGUgdGhlXG4gICAgZWRpdG9yIERPTSBkaXJlY3RseSwgb3IgYWRkIHN0eWxpbmcgdGhpcyB3YXksIHNpbmNlIHRoYXQgd2lsbCBiZVxuICAgIGltbWVkaWF0ZWx5IG92ZXJyaWRlbiBieSB0aGUgZWRpdG9yIGFzIGl0IHJlZHJhd3MgdGhlIG5vZGUuXG4gICAgKi9cbiAgICBub2RlRE9NKHBvcykge1xuICAgICAgICBsZXQgZGVzYyA9IHRoaXMuZG9jVmlldy5kZXNjQXQocG9zKTtcbiAgICAgICAgcmV0dXJuIGRlc2MgPyBkZXNjLm5vZGVET00gOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBkb2N1bWVudCBwb3NpdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgZ2l2ZW4gRE9NXG4gICAgcG9zaXRpb24uIChXaGVuZXZlciBwb3NzaWJsZSwgaXQgaXMgcHJlZmVyYWJsZSB0byBpbnNwZWN0IHRoZVxuICAgIGRvY3VtZW50IHN0cnVjdHVyZSBkaXJlY3RseSwgcmF0aGVyIHRoYW4gcG9raW5nIGFyb3VuZCBpbiB0aGVcbiAgICBET00sIGJ1dCBzb21ldGltZXNcdTIwMTRmb3IgZXhhbXBsZSB3aGVuIGludGVycHJldGluZyBhbiBldmVudFxuICAgIHRhcmdldFx1MjAxNHlvdSBkb24ndCBoYXZlIGEgY2hvaWNlLilcbiAgICBcbiAgICBUaGUgYGJpYXNgIHBhcmFtZXRlciBjYW4gYmUgdXNlZCB0byBpbmZsdWVuY2Ugd2hpY2ggc2lkZSBvZiBhIERPTVxuICAgIG5vZGUgdG8gdXNlIHdoZW4gdGhlIHBvc2l0aW9uIGlzIGluc2lkZSBhIGxlYWYgbm9kZS5cbiAgICAqL1xuICAgIHBvc0F0RE9NKG5vZGUsIG9mZnNldCwgYmlhcyA9IC0xKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQsIGJpYXMpO1xuICAgICAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRPTSBwb3NpdGlvbiBub3QgaW5zaWRlIHRoZSBlZGl0b3JcIik7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgb3V0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrIHdoZW5cbiAgICBtb3ZpbmcgaW4gYSBnaXZlbiBkaXJlY3Rpb24uIFdoZW4sIGZvciBleGFtcGxlLCBnaXZlbiBgXCJsZWZ0XCJgLFxuICAgIGl0IHdpbGwgcmV0dXJuIHRydWUgaWYgbW92aW5nIGxlZnQgZnJvbSB0aGUgY3VycmVudCBjdXJzb3JcbiAgICBwb3NpdGlvbiB3b3VsZCBsZWF2ZSB0aGF0IHBvc2l0aW9uJ3MgcGFyZW50IHRleHRibG9jay4gV2lsbCBhcHBseVxuICAgIHRvIHRoZSB2aWV3J3MgY3VycmVudCBzdGF0ZSBieSBkZWZhdWx0LCBidXQgaXQgaXMgcG9zc2libGUgdG9cbiAgICBwYXNzIGEgZGlmZmVyZW50IHN0YXRlLlxuICAgICovXG4gICAgZW5kT2ZUZXh0YmxvY2soZGlyLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gZW5kT2ZUZXh0YmxvY2sodGhpcywgc3RhdGUgfHwgdGhpcy5zdGF0ZSwgZGlyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUnVuIHRoZSBlZGl0b3IncyBwYXN0ZSBsb2dpYyB3aXRoIHRoZSBnaXZlbiBIVE1MIHN0cmluZy4gVGhlXG4gICAgYGV2ZW50YCwgaWYgZ2l2ZW4sIHdpbGwgYmUgcGFzc2VkIHRvIHRoZVxuICAgIFtgaGFuZGxlUGFzdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy5oYW5kbGVQYXN0ZSkgaG9vay5cbiAgICAqL1xuICAgIHBhc3RlSFRNTChodG1sLCBldmVudCkge1xuICAgICAgICByZXR1cm4gZG9QYXN0ZSh0aGlzLCBcIlwiLCBodG1sLCBmYWxzZSwgZXZlbnQgfHwgbmV3IENsaXBib2FyZEV2ZW50KFwicGFzdGVcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gdGhlIGVkaXRvcidzIHBhc3RlIGxvZ2ljIHdpdGggdGhlIGdpdmVuIHBsYWluLXRleHQgaW5wdXQuXG4gICAgKi9cbiAgICBwYXN0ZVRleHQodGV4dCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvUGFzdGUodGhpcywgdGV4dCwgbnVsbCwgdHJ1ZSwgZXZlbnQgfHwgbmV3IENsaXBib2FyZEV2ZW50KFwicGFzdGVcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmVzIHRoZSBlZGl0b3IgZnJvbSB0aGUgRE9NIGFuZCBkZXN0cm95cyBhbGwgW25vZGVcbiAgICB2aWV3c10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuTm9kZVZpZXcpLlxuICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvY1ZpZXcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlc3Ryb3lJbnB1dCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXN0cm95UGx1Z2luVmlld3MoKTtcbiAgICAgICAgaWYgKHRoaXMubW91bnRlZCkge1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZSh0aGlzLnN0YXRlLmRvYywgW10sIHZpZXdEZWNvcmF0aW9ucyh0aGlzKSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRvbS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb20ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5kb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb2NWaWV3ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhpcyBpcyB0cnVlIHdoZW4gdGhlIHZpZXcgaGFzIGJlZW5cbiAgICBbZGVzdHJveWVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRlc3Ryb3kpIChhbmQgdGh1cyBzaG91bGQgbm90IGJlXG4gICAgdXNlZCBhbnltb3JlKS5cbiAgICAqL1xuICAgIGdldCBpc0Rlc3Ryb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldyA9PSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2VkIGZvciB0ZXN0aW5nLlxuICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCBldmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIERpc3BhdGNoIGEgdHJhbnNhY3Rpb24uIFdpbGwgY2FsbFxuICAgIFtgZGlzcGF0Y2hUcmFuc2FjdGlvbmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRpcmVjdEVkaXRvclByb3BzLmRpc3BhdGNoVHJhbnNhY3Rpb24pXG4gICAgd2hlbiBnaXZlbiwgYW5kIG90aGVyd2lzZSBkZWZhdWx0cyB0byBhcHBseWluZyB0aGUgdHJhbnNhY3Rpb24gdG9cbiAgICB0aGUgY3VycmVudCBzdGF0ZSBhbmQgY2FsbGluZ1xuICAgIFtgdXBkYXRlU3RhdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnVwZGF0ZVN0YXRlKSB3aXRoIHRoZSByZXN1bHQuXG4gICAgVGhpcyBtZXRob2QgaXMgYm91bmQgdG8gdGhlIHZpZXcgaW5zdGFuY2UsIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgZWFzaWx5IHBhc3NlZCBhcm91bmQuXG4gICAgKi9cbiAgICBkaXNwYXRjaCh0cikge1xuICAgICAgICBsZXQgZGlzcGF0Y2hUcmFuc2FjdGlvbiA9IHRoaXMuX3Byb3BzLmRpc3BhdGNoVHJhbnNhY3Rpb247XG4gICAgICAgIGlmIChkaXNwYXRjaFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgZGlzcGF0Y2hUcmFuc2FjdGlvbi5jYWxsKHRoaXMsIHRyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh0aGlzLnN0YXRlLmFwcGx5KHRyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiBzYWZhcmkgJiYgdGhpcy5yb290Lm5vZGVUeXBlID09PSAxMSAmJiBkZWVwQWN0aXZlRWxlbWVudCh0aGlzLmRvbS5vd25lckRvY3VtZW50KSA9PSB0aGlzLmRvbVxuICAgICAgICAgICAgPyBzYWZhcmlTaGFkb3dTZWxlY3Rpb25SYW5nZSh0aGlzKSA6IHRoaXMuZG9tU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tU2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LmdldFNlbGVjdGlvbigpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVEb2NEZWNvKHZpZXcpIHtcbiAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGF0dHJzLmNsYXNzID0gXCJQcm9zZU1pcnJvclwiO1xuICAgIGF0dHJzLmNvbnRlbnRlZGl0YWJsZSA9IFN0cmluZyh2aWV3LmVkaXRhYmxlKTtcbiAgICB2aWV3LnNvbWVQcm9wKFwiYXR0cmlidXRlc1wiLCB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgZm9yIChsZXQgYXR0ciBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyID09IFwiY2xhc3NcIilcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuY2xhc3MgKz0gXCIgXCIgKyB2YWx1ZVthdHRyXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRyID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuc3R5bGUgPSAoYXR0cnMuc3R5bGUgPyBhdHRycy5zdHlsZSArIFwiO1wiIDogXCJcIikgKyB2YWx1ZVthdHRyXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYXR0cnNbYXR0cl0gJiYgYXR0ciAhPSBcImNvbnRlbnRlZGl0YWJsZVwiICYmIGF0dHIgIT0gXCJub2RlTmFtZVwiKVxuICAgICAgICAgICAgICAgICAgICBhdHRyc1thdHRyXSA9IFN0cmluZyh2YWx1ZVthdHRyXSk7XG4gICAgICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFhdHRycy50cmFuc2xhdGUpXG4gICAgICAgIGF0dHJzLnRyYW5zbGF0ZSA9IFwibm9cIjtcbiAgICByZXR1cm4gW0RlY29yYXRpb24ubm9kZSgwLCB2aWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUsIGF0dHJzKV07XG59XG5mdW5jdGlvbiB1cGRhdGVDdXJzb3JXcmFwcGVyKHZpZXcpIHtcbiAgICBpZiAodmlldy5tYXJrQ3Vyc29yKSB7XG4gICAgICAgIGxldCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIjtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcIm1hcmstcGxhY2Vob2xkZXJcIiwgXCJ0cnVlXCIpO1xuICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwiYWx0XCIsIFwiXCIpO1xuICAgICAgICB2aWV3LmN1cnNvcldyYXBwZXIgPSB7IGRvbSwgZGVjbzogRGVjb3JhdGlvbi53aWRnZXQodmlldy5zdGF0ZS5zZWxlY3Rpb24uaGVhZCwgZG9tLCB7IHJhdzogdHJ1ZSwgbWFya3M6IHZpZXcubWFya0N1cnNvciB9KSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5jdXJzb3JXcmFwcGVyID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFZGl0YWJsZSh2aWV3KSB7XG4gICAgcmV0dXJuICF2aWV3LnNvbWVQcm9wKFwiZWRpdGFibGVcIiwgdmFsdWUgPT4gdmFsdWUodmlldy5zdGF0ZSkgPT09IGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkNvbnRleHRDaGFuZ2VkKHNlbDEsIHNlbDIpIHtcbiAgICBsZXQgZGVwdGggPSBNYXRoLm1pbihzZWwxLiRhbmNob3Iuc2hhcmVkRGVwdGgoc2VsMS5oZWFkKSwgc2VsMi4kYW5jaG9yLnNoYXJlZERlcHRoKHNlbDIuaGVhZCkpO1xuICAgIHJldHVybiBzZWwxLiRhbmNob3Iuc3RhcnQoZGVwdGgpICE9IHNlbDIuJGFuY2hvci5zdGFydChkZXB0aCk7XG59XG5mdW5jdGlvbiBidWlsZE5vZGVWaWV3cyh2aWV3KSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZnVuY3Rpb24gYWRkKG9iaikge1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG9iailcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgcHJvcCkpXG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIH1cbiAgICB2aWV3LnNvbWVQcm9wKFwibm9kZVZpZXdzXCIsIGFkZCk7XG4gICAgdmlldy5zb21lUHJvcChcIm1hcmtWaWV3c1wiLCBhZGQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjaGFuZ2VkTm9kZVZpZXdzKGEsIGIpIHtcbiAgICBsZXQgbkEgPSAwLCBuQiA9IDA7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBhKSB7XG4gICAgICAgIGlmIChhW3Byb3BdICE9IGJbcHJvcF0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbkErKztcbiAgICB9XG4gICAgZm9yIChsZXQgXyBpbiBiKVxuICAgICAgICBuQisrO1xuICAgIHJldHVybiBuQSAhPSBuQjtcbn1cbmZ1bmN0aW9uIGNoZWNrU3RhdGVDb21wb25lbnQocGx1Z2luKSB7XG4gICAgaWYgKHBsdWdpbi5zcGVjLnN0YXRlIHx8IHBsdWdpbi5zcGVjLmZpbHRlclRyYW5zYWN0aW9uIHx8IHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBsdWdpbnMgcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSB2aWV3IG11c3Qgbm90IGhhdmUgYSBzdGF0ZSBjb21wb25lbnRcIik7XG59XG5cbmV4cG9ydCB7IERlY29yYXRpb24sIERlY29yYXRpb25TZXQsIEVkaXRvclZpZXcsIF9fZW5kQ29tcG9zaXRpb24sIF9fcGFyc2VGcm9tQ2xpcGJvYXJkLCBfX3NlcmlhbGl6ZUZvckNsaXBib2FyZCB9O1xuIiwgImV4cG9ydCB2YXIgYmFzZSA9IHtcbiAgODogXCJCYWNrc3BhY2VcIixcbiAgOTogXCJUYWJcIixcbiAgMTA6IFwiRW50ZXJcIixcbiAgMTI6IFwiTnVtTG9ja1wiLFxuICAxMzogXCJFbnRlclwiLFxuICAxNjogXCJTaGlmdFwiLFxuICAxNzogXCJDb250cm9sXCIsXG4gIDE4OiBcIkFsdFwiLFxuICAyMDogXCJDYXBzTG9ja1wiLFxuICAyNzogXCJFc2NhcGVcIixcbiAgMzI6IFwiIFwiLFxuICAzMzogXCJQYWdlVXBcIixcbiAgMzQ6IFwiUGFnZURvd25cIixcbiAgMzU6IFwiRW5kXCIsXG4gIDM2OiBcIkhvbWVcIixcbiAgMzc6IFwiQXJyb3dMZWZ0XCIsXG4gIDM4OiBcIkFycm93VXBcIixcbiAgMzk6IFwiQXJyb3dSaWdodFwiLFxuICA0MDogXCJBcnJvd0Rvd25cIixcbiAgNDQ6IFwiUHJpbnRTY3JlZW5cIixcbiAgNDU6IFwiSW5zZXJ0XCIsXG4gIDQ2OiBcIkRlbGV0ZVwiLFxuICA1OTogXCI7XCIsXG4gIDYxOiBcIj1cIixcbiAgOTE6IFwiTWV0YVwiLFxuICA5MjogXCJNZXRhXCIsXG4gIDEwNjogXCIqXCIsXG4gIDEwNzogXCIrXCIsXG4gIDEwODogXCIsXCIsXG4gIDEwOTogXCItXCIsXG4gIDExMDogXCIuXCIsXG4gIDExMTogXCIvXCIsXG4gIDE0NDogXCJOdW1Mb2NrXCIsXG4gIDE0NTogXCJTY3JvbGxMb2NrXCIsXG4gIDE2MDogXCJTaGlmdFwiLFxuICAxNjE6IFwiU2hpZnRcIixcbiAgMTYyOiBcIkNvbnRyb2xcIixcbiAgMTYzOiBcIkNvbnRyb2xcIixcbiAgMTY0OiBcIkFsdFwiLFxuICAxNjU6IFwiQWx0XCIsXG4gIDE3MzogXCItXCIsXG4gIDE4NjogXCI7XCIsXG4gIDE4NzogXCI9XCIsXG4gIDE4ODogXCIsXCIsXG4gIDE4OTogXCItXCIsXG4gIDE5MDogXCIuXCIsXG4gIDE5MTogXCIvXCIsXG4gIDE5MjogXCJgXCIsXG4gIDIxOTogXCJbXCIsXG4gIDIyMDogXCJcXFxcXCIsXG4gIDIyMTogXCJdXCIsXG4gIDIyMjogXCInXCJcbn1cblxuZXhwb3J0IHZhciBzaGlmdCA9IHtcbiAgNDg6IFwiKVwiLFxuICA0OTogXCIhXCIsXG4gIDUwOiBcIkBcIixcbiAgNTE6IFwiI1wiLFxuICA1MjogXCIkXCIsXG4gIDUzOiBcIiVcIixcbiAgNTQ6IFwiXlwiLFxuICA1NTogXCImXCIsXG4gIDU2OiBcIipcIixcbiAgNTc6IFwiKFwiLFxuICA1OTogXCI6XCIsXG4gIDYxOiBcIitcIixcbiAgMTczOiBcIl9cIixcbiAgMTg2OiBcIjpcIixcbiAgMTg3OiBcIitcIixcbiAgMTg4OiBcIjxcIixcbiAgMTg5OiBcIl9cIixcbiAgMTkwOiBcIj5cIixcbiAgMTkxOiBcIj9cIixcbiAgMTkyOiBcIn5cIixcbiAgMjE5OiBcIntcIixcbiAgMjIwOiBcInxcIixcbiAgMjIxOiBcIn1cIixcbiAgMjIyOiBcIlxcXCJcIlxufVxuXG52YXIgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKVxudmFyIGllID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9NU0lFIFxcZHxUcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVxuXG4vLyBGaWxsIGluIHRoZSBkaWdpdCBrZXlzXG5mb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIGJhc2VbNDggKyBpXSA9IGJhc2VbOTYgKyBpXSA9IFN0cmluZyhpKVxuXG4vLyBUaGUgZnVuY3Rpb24ga2V5c1xuZm9yICh2YXIgaSA9IDE7IGkgPD0gMjQ7IGkrKykgYmFzZVtpICsgMTExXSA9IFwiRlwiICsgaVxuXG4vLyBBbmQgdGhlIGFscGhhYmV0aWMga2V5c1xuZm9yICh2YXIgaSA9IDY1OyBpIDw9IDkwOyBpKyspIHtcbiAgYmFzZVtpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSArIDMyKVxuICBzaGlmdFtpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSlcbn1cblxuLy8gRm9yIGVhY2ggY29kZSB0aGF0IGRvZXNuJ3QgaGF2ZSBhIHNoaWZ0LWVxdWl2YWxlbnQsIGNvcHkgdGhlIGJhc2UgbmFtZVxuZm9yICh2YXIgY29kZSBpbiBiYXNlKSBpZiAoIXNoaWZ0Lmhhc093blByb3BlcnR5KGNvZGUpKSBzaGlmdFtjb2RlXSA9IGJhc2VbY29kZV1cblxuZXhwb3J0IGZ1bmN0aW9uIGtleU5hbWUoZXZlbnQpIHtcbiAgLy8gT24gbWFjT1MsIGtleXMgaGVsZCB3aXRoIFNoaWZ0IGFuZCBDbWQgZG9uJ3QgcmVmbGVjdCB0aGUgZWZmZWN0IG9mIFNoaWZ0IGluIGAua2V5YC5cbiAgLy8gT24gSUUsIHNoaWZ0IGVmZmVjdCBpcyBuZXZlciBpbmNsdWRlZCBpbiBgLmtleWAuXG4gIHZhciBpZ25vcmVLZXkgPSBtYWMgJiYgZXZlbnQubWV0YUtleSAmJiBldmVudC5zaGlmdEtleSAmJiAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuYWx0S2V5IHx8XG4gICAgICBpZSAmJiBldmVudC5zaGlmdEtleSAmJiBldmVudC5rZXkgJiYgZXZlbnQua2V5Lmxlbmd0aCA9PSAxIHx8XG4gICAgICBldmVudC5rZXkgPT0gXCJVbmlkZW50aWZpZWRcIlxuICB2YXIgbmFtZSA9ICghaWdub3JlS2V5ICYmIGV2ZW50LmtleSkgfHxcbiAgICAoZXZlbnQuc2hpZnRLZXkgPyBzaGlmdCA6IGJhc2UpW2V2ZW50LmtleUNvZGVdIHx8XG4gICAgZXZlbnQua2V5IHx8IFwiVW5pZGVudGlmaWVkXCJcbiAgLy8gRWRnZSBzb21ldGltZXMgcHJvZHVjZXMgd3JvbmcgbmFtZXMgKElzc3VlICMzKVxuICBpZiAobmFtZSA9PSBcIkVzY1wiKSBuYW1lID0gXCJFc2NhcGVcIlxuICBpZiAobmFtZSA9PSBcIkRlbFwiKSBuYW1lID0gXCJEZWxldGVcIlxuICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy84ODYwNTcxL1xuICBpZiAobmFtZSA9PSBcIkxlZnRcIikgbmFtZSA9IFwiQXJyb3dMZWZ0XCJcbiAgaWYgKG5hbWUgPT0gXCJVcFwiKSBuYW1lID0gXCJBcnJvd1VwXCJcbiAgaWYgKG5hbWUgPT0gXCJSaWdodFwiKSBuYW1lID0gXCJBcnJvd1JpZ2h0XCJcbiAgaWYgKG5hbWUgPT0gXCJEb3duXCIpIG5hbWUgPSBcIkFycm93RG93blwiXG4gIHJldHVybiBuYW1lXG59XG4iLCAiaW1wb3J0IHsga2V5TmFtZSwgYmFzZSB9IGZyb20gJ3czYy1rZXluYW1lJztcbmltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxuY29uc3QgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gL01hY3xpUChob25lfFtvYV1kKS8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pIDogZmFsc2U7XG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUpIHtcbiAgICBsZXQgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKSwgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHJlc3VsdCA9PSBcIlNwYWNlXCIpXG4gICAgICAgIHJlc3VsdCA9IFwiIFwiO1xuICAgIGxldCBhbHQsIGN0cmwsIHNoaWZ0LCBtZXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGxldCBtb2QgPSBwYXJ0c1tpXTtcbiAgICAgICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBhbHQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgc2hpZnQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIGlmIChtYWMpXG4gICAgICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiICsgbW9kKTtcbiAgICB9XG4gICAgaWYgKGFsdClcbiAgICAgICAgcmVzdWx0ID0gXCJBbHQtXCIgKyByZXN1bHQ7XG4gICAgaWYgKGN0cmwpXG4gICAgICAgIHJlc3VsdCA9IFwiQ3RybC1cIiArIHJlc3VsdDtcbiAgICBpZiAobWV0YSlcbiAgICAgICAgcmVzdWx0ID0gXCJNZXRhLVwiICsgcmVzdWx0O1xuICAgIGlmIChzaGlmdClcbiAgICAgICAgcmVzdWx0ID0gXCJTaGlmdC1cIiArIHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplKG1hcCkge1xuICAgIGxldCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBwcm9wIGluIG1hcClcbiAgICAgICAgY29weVtub3JtYWxpemVLZXlOYW1lKHByb3ApXSA9IG1hcFtwcm9wXTtcbiAgICByZXR1cm4gY29weTtcbn1cbmZ1bmN0aW9uIG1vZGlmaWVycyhuYW1lLCBldmVudCwgc2hpZnQgPSB0cnVlKSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSlcbiAgICAgICAgbmFtZSA9IFwiQWx0LVwiICsgbmFtZTtcbiAgICBpZiAoZXZlbnQuY3RybEtleSlcbiAgICAgICAgbmFtZSA9IFwiQ3RybC1cIiArIG5hbWU7XG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkpXG4gICAgICAgIG5hbWUgPSBcIk1ldGEtXCIgKyBuYW1lO1xuICAgIGlmIChzaGlmdCAmJiBldmVudC5zaGlmdEtleSlcbiAgICAgICAgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lO1xuICAgIHJldHVybiBuYW1lO1xufVxuLyoqXG5DcmVhdGUgYSBrZXltYXAgcGx1Z2luIGZvciB0aGUgZ2l2ZW4gc2V0IG9mIGJpbmRpbmdzLlxuXG5CaW5kaW5ncyBzaG91bGQgbWFwIGtleSBuYW1lcyB0byBbY29tbWFuZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzKS1zdHlsZVxuZnVuY3Rpb25zLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aXRoIGAoRWRpdG9yU3RhdGUsIGRpc3BhdGNoLFxuRWRpdG9yVmlldylgIGFyZ3VtZW50cywgYW5kIHNob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHRoZXkndmUgaGFuZGxlZFxudGhlIGtleS4gTm90ZSB0aGF0IHRoZSB2aWV3IGFyZ3VtZW50IGlzbid0IHBhcnQgb2YgdGhlIGNvbW1hbmRcbnByb3RvY29sLCBidXQgY2FuIGJlIHVzZWQgYXMgYW4gZXNjYXBlIGhhdGNoIGlmIGEgYmluZGluZyBuZWVkcyB0b1xuZGlyZWN0bHkgaW50ZXJhY3Qgd2l0aCB0aGUgVUkuXG5cbktleSBuYW1lcyBtYXkgYmUgc3RyaW5ncyBsaWtlIGBcIlNoaWZ0LUN0cmwtRW50ZXJcImBcdTIwMTRhIGtleVxuaWRlbnRpZmllciBwcmVmaXhlZCB3aXRoIHplcm8gb3IgbW9yZSBtb2RpZmllcnMuIEtleSBpZGVudGlmaWVyc1xuYXJlIGJhc2VkIG9uIHRoZSBzdHJpbmdzIHRoYXQgY2FuIGFwcGVhciBpblxuW2BLZXlFdmVudC5rZXlgXShodHRwczpkZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5KS5cblVzZSBsb3dlcmNhc2UgbGV0dGVycyB0byByZWZlciB0byBsZXR0ZXIga2V5cyAob3IgdXBwZXJjYXNlIGxldHRlcnNcbmlmIHlvdSB3YW50IHNoaWZ0IHRvIGJlIGhlbGQpLiBZb3UgbWF5IHVzZSBgXCJTcGFjZVwiYCBhcyBhbiBhbGlhc1xuZm9yIHRoZSBgXCIgXCJgIG5hbWUuXG5cbk1vZGlmaWVycyBjYW4gYmUgZ2l2ZW4gaW4gYW55IG9yZGVyLiBgU2hpZnQtYCAob3IgYHMtYCksIGBBbHQtYCAob3JcbmBhLWApLCBgQ3RybC1gIChvciBgYy1gIG9yIGBDb250cm9sLWApIGFuZCBgQ21kLWAgKG9yIGBtLWAgb3JcbmBNZXRhLWApIGFyZSByZWNvZ25pemVkLiBGb3IgY2hhcmFjdGVycyB0aGF0IGFyZSBjcmVhdGVkIGJ5IGhvbGRpbmdcbnNoaWZ0LCB0aGUgYFNoaWZ0LWAgcHJlZml4IGlzIGltcGxpZWQsIGFuZCBzaG91bGQgbm90IGJlIGFkZGVkXG5leHBsaWNpdGx5LlxuXG5Zb3UgY2FuIHVzZSBgTW9kLWAgYXMgYSBzaG9ydGhhbmQgZm9yIGBDbWQtYCBvbiBNYWMgYW5kIGBDdHJsLWAgb25cbm90aGVyIHBsYXRmb3Jtcy5cblxuWW91IGNhbiBhZGQgbXVsdGlwbGUga2V5bWFwIHBsdWdpbnMgdG8gYW4gZWRpdG9yLiBUaGUgb3JkZXIgaW5cbndoaWNoIHRoZXkgYXBwZWFyIGRldGVybWluZXMgdGhlaXIgcHJlY2VkZW5jZSAodGhlIG9uZXMgZWFybHkgaW5cbnRoZSBhcnJheSBnZXQgdG8gZGlzcGF0Y2ggZmlyc3QpLlxuKi9cbmZ1bmN0aW9uIGtleW1hcChiaW5kaW5ncykge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHsgcHJvcHM6IHsgaGFuZGxlS2V5RG93bjoga2V5ZG93bkhhbmRsZXIoYmluZGluZ3MpIH0gfSk7XG59XG4vKipcbkdpdmVuIGEgc2V0IG9mIGJpbmRpbmdzICh1c2luZyB0aGUgc2FtZSBmb3JtYXQgYXNcbltga2V5bWFwYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2tleW1hcC5rZXltYXApKSwgcmV0dXJuIGEgW2tleWRvd25cbmhhbmRsZXJdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzLmhhbmRsZUtleURvd24pIHRoYXQgaGFuZGxlcyB0aGVtLlxuKi9cbmZ1bmN0aW9uIGtleWRvd25IYW5kbGVyKGJpbmRpbmdzKSB7XG4gICAgbGV0IG1hcCA9IG5vcm1hbGl6ZShiaW5kaW5ncyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2aWV3LCBldmVudCkge1xuICAgICAgICBsZXQgbmFtZSA9IGtleU5hbWUoZXZlbnQpLCBiYXNlTmFtZSwgZGlyZWN0ID0gbWFwW21vZGlmaWVycyhuYW1lLCBldmVudCldO1xuICAgICAgICBpZiAoZGlyZWN0ICYmIGRpcmVjdCh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoLCB2aWV3KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBBIGNoYXJhY3RlciBrZXlcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09IDEgJiYgbmFtZSAhPSBcIiBcIikge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGUgbmFtZSB3YXMgYWxyZWFkeSBtb2RpZmllZCBieSBzaGlmdCwgdHJ5IGxvb2tpbmdcbiAgICAgICAgICAgICAgICAvLyBpdCB1cCB3aXRob3V0IGl0cyBzaGlmdCBtb2RpZmllclxuICAgICAgICAgICAgICAgIGxldCBub1NoaWZ0ID0gbWFwW21vZGlmaWVycyhuYW1lLCBldmVudCwgZmFsc2UpXTtcbiAgICAgICAgICAgICAgICBpZiAobm9TaGlmdCAmJiBub1NoaWZ0KHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgbmFtZS5jaGFyQ29kZUF0KDApID4gMTI3KSAmJlxuICAgICAgICAgICAgICAgIChiYXNlTmFtZSA9IGJhc2VbZXZlbnQua2V5Q29kZV0pICYmIGJhc2VOYW1lICE9IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgZmFsbGluZyBiYWNrIHRvIHRoZSBrZXlDb2RlIHdoZW4gdGhlcmUncyBhIG1vZGlmaWVyXG4gICAgICAgICAgICAgICAgLy8gYWN0aXZlIG9yIHRoZSBjaGFyYWN0ZXIgcHJvZHVjZWQgaXNuJ3QgQVNDSUksIGFuZCBvdXIgdGFibGVcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWNlcyBhIGRpZmZlcmVudCBuYW1lIGZyb20gdGhlIHRoZSBrZXlDb2RlLiBTZWUgIzY2OCxcbiAgICAgICAgICAgICAgICAvLyAjMTA2MFxuICAgICAgICAgICAgICAgIGxldCBmcm9tQ29kZSA9IG1hcFttb2RpZmllcnMoYmFzZU5hbWUsIGV2ZW50KV07XG4gICAgICAgICAgICAgICAgaWYgKGZyb21Db2RlICYmIGZyb21Db2RlKHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxuZXhwb3J0IHsga2V5ZG93bkhhbmRsZXIsIGtleW1hcCB9O1xuIiwgImltcG9ydCB7IGxpZnRUYXJnZXQsIHJlcGxhY2VTdGVwLCBSZXBsYWNlU3RlcCwgY2FuSm9pbiwgam9pblBvaW50LCBjYW5TcGxpdCwgUmVwbGFjZUFyb3VuZFN0ZXAsIGZpbmRXcmFwcGluZyB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBTbGljZSwgRnJhZ21lbnQgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBOb2RlU2VsZWN0aW9uLCBTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24sIEFsbFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgaWYgdGhlcmUgaXMgb25lLlxuKi9cbmNvbnN0IGRlbGV0ZVNlbGVjdGlvbiA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpIHtcbiAgICBsZXQgeyAkY3Vyc29yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJiYWNrd2FyZFwiLCBzdGF0ZSlcbiAgICAgICAgOiAkY3Vyc29yLnBhcmVudE9mZnNldCA+IDApKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gJGN1cnNvcjtcbn1cbi8qKlxuSWYgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLCB0cnkgdG9cbnJlZHVjZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGF0IGJsb2NrIGFuZCB0aGUgb25lIGJlZm9yZSBpdFx1MjAxNGlmXG50aGVyZSdzIGEgYmxvY2sgZGlyZWN0bHkgYmVmb3JlIGl0IHRoYXQgY2FuIGJlIGpvaW5lZCwgam9pbiB0aGVtLlxuSWYgbm90LCB0cnkgdG8gbW92ZSB0aGUgc2VsZWN0ZWQgYmxvY2sgY2xvc2VyIHRvIHRoZSBuZXh0IG9uZSBpblxudGhlIGRvY3VtZW50IHN0cnVjdHVyZSBieSBsaWZ0aW5nIGl0IG91dCBvZiBpdHMgcGFyZW50IG9yIG1vdmluZyBpdFxuaW50byBhIHBhcmVudCBvZiB0aGUgcHJldmlvdXMgYmxvY2suIFdpbGwgdXNlIHRoZSB2aWV3IGZvciBhY2N1cmF0ZVxuKGJpZGktYXdhcmUpIHN0YXJ0LW9mLXRleHRibG9jayBkZXRlY3Rpb24gaWYgZ2l2ZW4uXG4qL1xuY29uc3Qgam9pbkJhY2t3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCAkY3Vyc29yID0gYXRCbG9ja1N0YXJ0KHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGN1cnNvcik7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gbm9kZSBiZWZvcmUgdGhpcywgdHJ5IHRvIGxpZnRcbiAgICBpZiAoISRjdXQpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gJGN1cnNvci5ibG9ja1JhbmdlKCksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlO1xuICAgIC8vIEFwcGx5IHRoZSBqb2luaW5nIGFsZ29yaXRobVxuICAgIGlmICghYmVmb3JlLnR5cGUuc3BlYy5pc29sYXRpbmcgJiYgZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyBJZiB0aGUgbm9kZSBiZWxvdyBoYXMgbm8gY29udGVudCBhbmQgdGhlIG5vZGUgYWJvdmUgaXNcbiAgICAvLyBzZWxlY3RhYmxlLCBkZWxldGUgdGhlIG5vZGUgYmVsb3cgYW5kIHNlbGVjdCB0aGUgb25lIGFib3ZlLlxuICAgIGlmICgkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJlxuICAgICAgICAodGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSB8fCBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShiZWZvcmUpKSkge1xuICAgICAgICBsZXQgZGVsU3RlcCA9IHJlcGxhY2VTdGVwKHN0YXRlLmRvYywgJGN1cnNvci5iZWZvcmUoKSwgJGN1cnNvci5hZnRlcigpLCBTbGljZS5lbXB0eSk7XG4gICAgICAgIGlmIChkZWxTdGVwICYmIGRlbFN0ZXAuc2xpY2Uuc2l6ZSA8IGRlbFN0ZXAudG8gLSBkZWxTdGVwLmZyb20pIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAoZGVsU3RlcCk7XG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikgPyBTZWxlY3Rpb24uZmluZEZyb20odHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoJGN1dC5wb3MsIC0xKSksIC0xKVxuICAgICAgICAgICAgICAgICAgICA6IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJGN1dC5wb3MgLSBiZWZvcmUubm9kZVNpemUpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBub2RlIGJlZm9yZSBpcyBhbiBhdG9tLCBkZWxldGUgaXRcbiAgICBpZiAoYmVmb3JlLmlzQXRvbSAmJiAkY3V0LmRlcHRoID09ICRjdXJzb3IuZGVwdGggLSAxKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZSgkY3V0LnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSwgJGN1dC5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuQSBtb3JlIGxpbWl0ZWQgZm9ybSBvZiBbYGpvaW5CYWNrd2FyZGBdKCRjb21tYW5kcy5qb2luQmFja3dhcmQpXG50aGF0IG9ubHkgdHJpZXMgdG8gam9pbiB0aGUgY3VycmVudCB0ZXh0YmxvY2sgdG8gdGhlIG9uZSBiZWZvcmVcbml0LCBpZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jay5cbiovXG5jb25zdCBqb2luVGV4dGJsb2NrQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEJlZm9yZSgkY3Vyc29yKTtcbiAgICByZXR1cm4gJGN1dCA/IGpvaW5UZXh0YmxvY2tzQXJvdW5kKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkgOiBmYWxzZTtcbn07XG4vKipcbkEgbW9yZSBsaW1pdGVkIGZvcm0gb2YgW2Bqb2luRm9yd2FyZGBdKCRjb21tYW5kcy5qb2luRm9yd2FyZClcbnRoYXQgb25seSB0cmllcyB0byBqb2luIHRoZSBjdXJyZW50IHRleHRibG9jayB0byB0aGUgb25lIGFmdGVyXG5pdCwgaWYgdGhlIGN1cnNvciBpcyBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrLlxuKi9cbmNvbnN0IGpvaW5UZXh0YmxvY2tGb3J3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCAkY3Vyc29yID0gYXRCbG9ja0VuZChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QWZ0ZXIoJGN1cnNvcik7XG4gICAgcmV0dXJuICRjdXQgPyBqb2luVGV4dGJsb2Nrc0Fyb3VuZChzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIDogZmFsc2U7XG59O1xuZnVuY3Rpb24gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSB7XG4gICAgbGV0IGJlZm9yZSA9ICRjdXQubm9kZUJlZm9yZSwgYmVmb3JlVGV4dCA9IGJlZm9yZSwgYmVmb3JlUG9zID0gJGN1dC5wb3MgLSAxO1xuICAgIGZvciAoOyAhYmVmb3JlVGV4dC5pc1RleHRibG9jazsgYmVmb3JlUG9zLS0pIHtcbiAgICAgICAgaWYgKGJlZm9yZVRleHQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gYmVmb3JlVGV4dC5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGJlZm9yZVRleHQgPSBjaGlsZDtcbiAgICB9XG4gICAgbGV0IGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXIsIGFmdGVyVGV4dCA9IGFmdGVyLCBhZnRlclBvcyA9ICRjdXQucG9zICsgMTtcbiAgICBmb3IgKDsgIWFmdGVyVGV4dC5pc1RleHRibG9jazsgYWZ0ZXJQb3MrKykge1xuICAgICAgICBpZiAoYWZ0ZXJUZXh0LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBjaGlsZCA9IGFmdGVyVGV4dC5maXJzdENoaWxkO1xuICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBhZnRlclRleHQgPSBjaGlsZDtcbiAgICB9XG4gICAgbGV0IHN0ZXAgPSByZXBsYWNlU3RlcChzdGF0ZS5kb2MsIGJlZm9yZVBvcywgYWZ0ZXJQb3MsIFNsaWNlLmVtcHR5KTtcbiAgICBpZiAoIXN0ZXAgfHwgc3RlcC5mcm9tICE9IGJlZm9yZVBvcyB8fFxuICAgICAgICBzdGVwIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXAgJiYgc3RlcC5zbGljZS5zaXplID49IGFmdGVyUG9zIC0gYmVmb3JlUG9zKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAoc3RlcCk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIGJlZm9yZVBvcykpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB0ZXh0YmxvY2tBdChub2RlLCBzaWRlLCBvbmx5ID0gZmFsc2UpIHtcbiAgICBmb3IgKGxldCBzY2FuID0gbm9kZTsgc2Nhbjsgc2NhbiA9IChzaWRlID09IFwic3RhcnRcIiA/IHNjYW4uZmlyc3RDaGlsZCA6IHNjYW4ubGFzdENoaWxkKSkge1xuICAgICAgICBpZiAoc2Nhbi5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob25seSAmJiBzY2FuLmNoaWxkQ291bnQgIT0gMSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG5XaGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jaywgc2VsZWN0XG50aGUgbm9kZSBiZWZvcmUgdGhhdCB0ZXh0YmxvY2ssIGlmIHBvc3NpYmxlLiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG5ib3VuZCB0byBrZXlzIGxpa2UgYmFja3NwYWNlLCBhZnRlclxuW2Bqb2luQmFja3dhcmRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuam9pbkJhY2t3YXJkKSBvciBvdGhlciBkZWxldGluZ1xuY29tbWFuZHMsIGFzIGEgZmFsbC1iYWNrIGJlaGF2aW9yIHdoZW4gdGhlIHNjaGVtYSBkb2Vzbid0IGFsbG93XG5kZWxldGlvbiBhdCB0aGUgc2VsZWN0ZWQgcG9pbnQuXG4qL1xuY29uc3Qgc2VsZWN0Tm9kZUJhY2t3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCB7ICRoZWFkLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uLCAkY3V0ID0gJGhlYWQ7XG4gICAgaWYgKCFlbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgaWYgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImJhY2t3YXJkXCIsIHN0YXRlKSA6ICRoZWFkLnBhcmVudE9mZnNldCA+IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRoZWFkKTtcbiAgICB9XG4gICAgbGV0IG5vZGUgPSAkY3V0ICYmICRjdXQubm9kZUJlZm9yZTtcbiAgICBpZiAoIW5vZGUgfHwgIU5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCAkY3V0LnBvcyAtIG5vZGUubm9kZVNpemUpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBmaW5kQ3V0QmVmb3JlKCRwb3MpIHtcbiAgICBpZiAoISRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICgkcG9zLmluZGV4KGkpID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5kb2MucmVzb2x2ZSgkcG9zLmJlZm9yZShpICsgMSkpO1xuICAgICAgICAgICAgaWYgKCRwb3Mubm9kZShpKS50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBhdEJsb2NrRW5kKHN0YXRlLCB2aWV3KSB7XG4gICAgbGV0IHsgJGN1cnNvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGN1cnNvciB8fCAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiZm9yd2FyZFwiLCBzdGF0ZSlcbiAgICAgICAgOiAkY3Vyc29yLnBhcmVudE9mZnNldCA8ICRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiAkY3Vyc29yO1xufVxuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgYVxudGV4dGJsb2NrLCB0cnkgdG8gcmVkdWNlIG9yIHJlbW92ZSB0aGUgYm91bmRhcnkgYmV0d2VlbiB0aGF0IGJsb2NrXG5hbmQgdGhlIG9uZSBhZnRlciBpdCwgZWl0aGVyIGJ5IGpvaW5pbmcgdGhlbSBvciBieSBtb3ZpbmcgdGhlIG90aGVyXG5ibG9jayBjbG9zZXIgdG8gdGhpcyBvbmUgaW4gdGhlIHRyZWUgc3RydWN0dXJlLiBXaWxsIHVzZSB0aGUgdmlld1xuZm9yIGFjY3VyYXRlIHN0YXJ0LW9mLXRleHRibG9jayBkZXRlY3Rpb24gaWYgZ2l2ZW4uXG4qL1xuY29uc3Qgam9pbkZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrRW5kKHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRBZnRlcigkY3Vyc29yKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBub2RlIGFmdGVyIHRoaXMsIHRoZXJlJ3Mgbm90aGluZyB0byBkb1xuICAgIGlmICghJGN1dClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhZnRlciA9ICRjdXQubm9kZUFmdGVyO1xuICAgIC8vIFRyeSB0aGUgam9pbmluZyBhbGdvcml0aG1cbiAgICBpZiAoZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyBJZiB0aGUgbm9kZSBhYm92ZSBoYXMgbm8gY29udGVudCBhbmQgdGhlIG5vZGUgYmVsb3cgaXNcbiAgICAvLyBzZWxlY3RhYmxlLCBkZWxldGUgdGhlIG5vZGUgYWJvdmUgYW5kIHNlbGVjdCB0aGUgb25lIGJlbG93LlxuICAgIGlmICgkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJlxuICAgICAgICAodGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIikgfHwgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoYWZ0ZXIpKSkge1xuICAgICAgICBsZXQgZGVsU3RlcCA9IHJlcGxhY2VTdGVwKHN0YXRlLmRvYywgJGN1cnNvci5iZWZvcmUoKSwgJGN1cnNvci5hZnRlcigpLCBTbGljZS5lbXB0eSk7XG4gICAgICAgIGlmIChkZWxTdGVwICYmIGRlbFN0ZXAuc2xpY2Uuc2l6ZSA8IGRlbFN0ZXAudG8gLSBkZWxTdGVwLmZyb20pIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAoZGVsU3RlcCk7XG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIpID8gU2VsZWN0aW9uLmZpbmRGcm9tKHRyLmRvYy5yZXNvbHZlKHRyLm1hcHBpbmcubWFwKCRjdXQucG9zKSksIDEpXG4gICAgICAgICAgICAgICAgICAgIDogTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcykpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBuZXh0IG5vZGUgaXMgYW4gYXRvbSwgZGVsZXRlIGl0XG4gICAgaWYgKGFmdGVyLmlzQXRvbSAmJiAkY3V0LmRlcHRoID09ICRjdXJzb3IuZGVwdGggLSAxKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZSgkY3V0LnBvcywgJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG5XaGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2ssIHNlbGVjdFxudGhlIG5vZGUgY29taW5nIGFmdGVyIHRoYXQgdGV4dGJsb2NrLCBpZiBwb3NzaWJsZS4gVGhpcyBpcyBpbnRlbmRlZFxudG8gYmUgYm91bmQgdG8ga2V5cyBsaWtlIGRlbGV0ZSwgYWZ0ZXJcbltgam9pbkZvcndhcmRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuam9pbkZvcndhcmQpIGFuZCBzaW1pbGFyIGRlbGV0aW5nXG5jb21tYW5kcywgdG8gcHJvdmlkZSBhIGZhbGwtYmFjayBiZWhhdmlvciB3aGVuIHRoZSBzY2hlbWEgZG9lc24ndFxuYWxsb3cgZGVsZXRpb24gYXQgdGhlIHNlbGVjdGVkIHBvaW50LlxuKi9cbmNvbnN0IHNlbGVjdE5vZGVGb3J3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCB7ICRoZWFkLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uLCAkY3V0ID0gJGhlYWQ7XG4gICAgaWYgKCFlbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgaWYgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImZvcndhcmRcIiwgc3RhdGUpIDogJGhlYWQucGFyZW50T2Zmc2V0IDwgJGhlYWQucGFyZW50LmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgJGN1dCA9IGZpbmRDdXRBZnRlcigkaGVhZCk7XG4gICAgfVxuICAgIGxldCBub2RlID0gJGN1dCAmJiAkY3V0Lm5vZGVBZnRlcjtcbiAgICBpZiAoIW5vZGUgfHwgIU5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCAkY3V0LnBvcykpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGZpbmRDdXRBZnRlcigkcG9zKSB7XG4gICAgaWYgKCEkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gJHBvcy5ub2RlKGkpO1xuICAgICAgICAgICAgaWYgKCRwb3MuaW5kZXgoaSkgKyAxIDwgcGFyZW50LmNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3MuZG9jLnJlc29sdmUoJHBvcy5hZnRlcihpICsgMSkpO1xuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbkpvaW4gdGhlIHNlbGVjdGVkIGJsb2NrIG9yLCBpZiB0aGVyZSBpcyBhIHRleHQgc2VsZWN0aW9uLCB0aGVcbmNsb3Nlc3QgYW5jZXN0b3IgYmxvY2sgb2YgdGhlIHNlbGVjdGlvbiB0aGF0IGNhbiBiZSBqb2luZWQsIHdpdGhcbnRoZSBzaWJsaW5nIGFib3ZlIGl0LlxuKi9cbmNvbnN0IGpvaW5VcCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCBub2RlU2VsID0gc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiwgcG9pbnQ7XG4gICAgaWYgKG5vZGVTZWwpIHtcbiAgICAgICAgaWYgKHNlbC5ub2RlLmlzVGV4dGJsb2NrIHx8ICFjYW5Kb2luKHN0YXRlLmRvYywgc2VsLmZyb20pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwb2ludCA9IHNlbC5mcm9tO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzZWwuZnJvbSwgLTEpO1xuICAgICAgICBpZiAocG9pbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLmpvaW4ocG9pbnQpO1xuICAgICAgICBpZiAobm9kZVNlbClcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHBvaW50IC0gc3RhdGUuZG9jLnJlc29sdmUocG9pbnQpLm5vZGVCZWZvcmUubm9kZVNpemUpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSm9pbiB0aGUgc2VsZWN0ZWQgYmxvY2ssIG9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yIG9mIHRoZSBzZWxlY3Rpb25cbnRoYXQgY2FuIGJlIGpvaW5lZCwgd2l0aCB0aGUgc2libGluZyBhZnRlciBpdC5cbiovXG5jb25zdCBqb2luRG93biA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCBwb2ludDtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikge1xuICAgICAgICBpZiAoc2VsLm5vZGUuaXNUZXh0YmxvY2sgfHwgIWNhbkpvaW4oc3RhdGUuZG9jLCBzZWwudG8pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwb2ludCA9IHNlbC50bztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc2VsLnRvLCAxKTtcbiAgICAgICAgaWYgKHBvaW50ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuam9pbihwb2ludCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5MaWZ0IHRoZSBzZWxlY3RlZCBibG9jaywgb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgYmxvY2sgb2YgdGhlXG5zZWxlY3Rpb24gdGhhdCBjYW4gYmUgbGlmdGVkLCBvdXQgb2YgaXRzIHBhcmVudCBub2RlLlxuKi9cbmNvbnN0IGxpZnQgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSWYgdGhlIHNlbGVjdGlvbiBpcyBpbiBhIG5vZGUgd2hvc2UgdHlwZSBoYXMgYSB0cnV0aHlcbltgY29kZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5jb2RlKSBwcm9wZXJ0eSBpbiBpdHMgc3BlYywgcmVwbGFjZSB0aGVcbnNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZSBjaGFyYWN0ZXIuXG4qL1xuY29uc3QgbmV3bGluZUluQ29kZSA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkaGVhZCwgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQucGFyZW50LnR5cGUuc3BlYy5jb2RlIHx8ICEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5pbnNlcnRUZXh0KFwiXFxuXCIpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGRlZmF1bHRCbG9ja0F0KG1hdGNoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkrKykge1xuICAgICAgICBsZXQgeyB0eXBlIH0gPSBtYXRjaC5lZGdlKGkpO1xuICAgICAgICBpZiAodHlwZS5pc1RleHRibG9jayAmJiAhdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpXG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBpbiBhIG5vZGUgd2l0aCBhIHRydXRoeVxuW2Bjb2RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvZGUpIHByb3BlcnR5IGluIGl0cyBzcGVjLCBjcmVhdGUgYVxuZGVmYXVsdCBibG9jayBhZnRlciB0aGUgY29kZSBibG9jaywgYW5kIG1vdmUgdGhlIGN1cnNvciB0aGVyZS5cbiovXG5jb25zdCBleGl0Q29kZSA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkaGVhZCwgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQucGFyZW50LnR5cGUuc3BlYy5jb2RlIHx8ICEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFib3ZlID0gJGhlYWQubm9kZSgtMSksIGFmdGVyID0gJGhlYWQuaW5kZXhBZnRlcigtMSksIHR5cGUgPSBkZWZhdWx0QmxvY2tBdChhYm92ZS5jb250ZW50TWF0Y2hBdChhZnRlcikpO1xuICAgIGlmICghdHlwZSB8fCAhYWJvdmUuY2FuUmVwbGFjZVdpdGgoYWZ0ZXIsIGFmdGVyLCB0eXBlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgcG9zID0gJGhlYWQuYWZ0ZXIoKSwgdHIgPSBzdGF0ZS50ci5yZXBsYWNlV2l0aChwb3MsIHBvcywgdHlwZS5jcmVhdGVBbmRGaWxsKCkpO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUocG9zKSwgMSkpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JZiBhIGJsb2NrIG5vZGUgaXMgc2VsZWN0ZWQsIGNyZWF0ZSBhbiBlbXB0eSBwYXJhZ3JhcGggYmVmb3JlIChpZlxuaXQgaXMgaXRzIHBhcmVudCdzIGZpcnN0IGNoaWxkKSBvciBhZnRlciBpdC5cbiovXG5jb25zdCBjcmVhdGVQYXJhZ3JhcGhOZWFyID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIHsgJGZyb20sICR0byB9ID0gc2VsO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24gfHwgJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgfHwgJHRvLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHR5cGUgPSBkZWZhdWx0QmxvY2tBdCgkdG8ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCR0by5pbmRleEFmdGVyKCkpKTtcbiAgICBpZiAoIXR5cGUgfHwgIXR5cGUuaXNUZXh0YmxvY2spXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHNpZGUgPSAoISRmcm9tLnBhcmVudE9mZnNldCAmJiAkdG8uaW5kZXgoKSA8ICR0by5wYXJlbnQuY2hpbGRDb3VudCA/ICRmcm9tIDogJHRvKS5wb3M7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLmluc2VydChzaWRlLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHNpZGUgKyAxKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbklmIHRoZSBjdXJzb3IgaXMgaW4gYW4gZW1wdHkgdGV4dGJsb2NrIHRoYXQgY2FuIGJlIGxpZnRlZCwgbGlmdCB0aGVcbmJsb2NrLlxuKi9cbmNvbnN0IGxpZnRFbXB0eUJsb2NrID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRjdXJzb3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRjdXJzb3IgfHwgJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRjdXJzb3IuZGVwdGggPiAxICYmICRjdXJzb3IuYWZ0ZXIoKSAhPSAkY3Vyc29yLmVuZCgtMSkpIHtcbiAgICAgICAgbGV0IGJlZm9yZSA9ICRjdXJzb3IuYmVmb3JlKCk7XG4gICAgICAgIGlmIChjYW5TcGxpdChzdGF0ZS5kb2MsIGJlZm9yZSkpIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zcGxpdChiZWZvcmUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJhbmdlID0gJGN1cnNvci5ibG9ja1JhbmdlKCksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNyZWF0ZSBhIHZhcmlhbnQgb2YgW2BzcGxpdEJsb2NrYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLnNwbGl0QmxvY2spIHRoYXQgdXNlc1xuYSBjdXN0b20gZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIHRoZSBuZXdseSBzcGxpdCBvZmYgYmxvY2suXG4qL1xuZnVuY3Rpb24gc3BsaXRCbG9ja0FzKHNwbGl0Tm9kZSkge1xuICAgIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc3RhdGUuc2VsZWN0aW9uLm5vZGUuaXNCbG9jaykge1xuICAgICAgICAgICAgaWYgKCEkZnJvbS5wYXJlbnRPZmZzZXQgfHwgIWNhblNwbGl0KHN0YXRlLmRvYywgJGZyb20ucG9zKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc3BsaXQoJGZyb20ucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJGZyb20ucGFyZW50LmlzQmxvY2spXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IGF0RW5kID0gJHRvLnBhcmVudE9mZnNldCA9PSAkdG8ucGFyZW50LmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gfHwgc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgIHRyLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgbGV0IGRlZmx0ID0gJGZyb20uZGVwdGggPT0gMCA/IG51bGwgOiBkZWZhdWx0QmxvY2tBdCgkZnJvbS5ub2RlKC0xKS5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleEFmdGVyKC0xKSkpO1xuICAgICAgICAgICAgbGV0IHNwbGl0VHlwZSA9IHNwbGl0Tm9kZSAmJiBzcGxpdE5vZGUoJHRvLnBhcmVudCwgYXRFbmQpO1xuICAgICAgICAgICAgbGV0IHR5cGVzID0gc3BsaXRUeXBlID8gW3NwbGl0VHlwZV0gOiBhdEVuZCAmJiBkZWZsdCA/IFt7IHR5cGU6IGRlZmx0IH1dIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGNhbiA9IGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpO1xuICAgICAgICAgICAgaWYgKCF0eXBlcyAmJiAhY2FuICYmIGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgZGVmbHQgPyBbeyB0eXBlOiBkZWZsdCB9XSA6IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmbHQpXG4gICAgICAgICAgICAgICAgICAgIHR5cGVzID0gW3sgdHlwZTogZGVmbHQgfV07XG4gICAgICAgICAgICAgICAgY2FuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW4pIHtcbiAgICAgICAgICAgICAgICB0ci5zcGxpdCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFhdEVuZCAmJiAhJGZyb20ucGFyZW50T2Zmc2V0ICYmICRmcm9tLnBhcmVudC50eXBlICE9IGRlZmx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKSwgJGZpcnN0ID0gdHIuZG9jLnJlc29sdmUoZmlyc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmbHQgJiYgJGZyb20ubm9kZSgtMSkuY2FuUmVwbGFjZVdpdGgoJGZpcnN0LmluZGV4KCksICRmaXJzdC5pbmRleCgpICsgMSwgZGVmbHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSksIGRlZmx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5TcGxpdCB0aGUgcGFyZW50IGJsb2NrIG9mIHRoZSBzZWxlY3Rpb24uIElmIHRoZSBzZWxlY3Rpb24gaXMgYSB0ZXh0XG5zZWxlY3Rpb24sIGFsc28gZGVsZXRlIGl0cyBjb250ZW50LlxuKi9cbmNvbnN0IHNwbGl0QmxvY2sgPSBzcGxpdEJsb2NrQXMoKTtcbi8qKlxuQWN0cyBsaWtlIFtgc3BsaXRCbG9ja2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5zcGxpdEJsb2NrKSwgYnV0IHdpdGhvdXRcbnJlc2V0dGluZyB0aGUgc2V0IG9mIGFjdGl2ZSBtYXJrcyBhdCB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IHNwbGl0QmxvY2tLZWVwTWFya3MgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgcmV0dXJuIHNwbGl0QmxvY2soc3RhdGUsIGRpc3BhdGNoICYmICh0ciA9PiB7XG4gICAgICAgIGxldCBtYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzIHx8IChzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gICAgICAgIGlmIChtYXJrcylcbiAgICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKG1hcmtzKTtcbiAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH0pKTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgbm9kZSB3cmFwcGluZyB0aGUgY3VycmVudCBzZWxlY3Rpb24sIGlmXG5hbnkuIChXaWxsIG5vdCBzZWxlY3QgdGhlIGRvY3VtZW50IG5vZGUuKVxuKi9cbmNvbnN0IHNlbGVjdFBhcmVudE5vZGUgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGZyb20sIHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb24sIHBvcztcbiAgICBsZXQgc2FtZSA9ICRmcm9tLnNoYXJlZERlcHRoKHRvKTtcbiAgICBpZiAoc2FtZSA9PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcG9zID0gJGZyb20uYmVmb3JlKHNhbWUpO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgcG9zKSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2VsZWN0IHRoZSB3aG9sZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3RBbGwgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IEFsbFNlbGVjdGlvbihzdGF0ZS5kb2MpKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gam9pbk1heWJlQ2xlYXIoc3RhdGUsICRwb3MsIGRpc3BhdGNoKSB7XG4gICAgbGV0IGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZSwgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlciwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgaWYgKCFiZWZvcmUgfHwgIWFmdGVyIHx8ICFiZWZvcmUudHlwZS5jb21wYXRpYmxlQ29udGVudChhZnRlci50eXBlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghYmVmb3JlLmNvbnRlbnQuc2l6ZSAmJiAkcG9zLnBhcmVudC5jYW5SZXBsYWNlKGluZGV4IC0gMSwgaW5kZXgpKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZSgkcG9zLnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSwgJHBvcy5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCEkcG9zLnBhcmVudC5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpIHx8ICEoYWZ0ZXIuaXNUZXh0YmxvY2sgfHwgY2FuSm9pbihzdGF0ZS5kb2MsICRwb3MucG9zKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyXG4gICAgICAgICAgICAuY2xlYXJJbmNvbXBhdGlibGUoJHBvcy5wb3MsIGJlZm9yZS50eXBlLCBiZWZvcmUuY29udGVudE1hdGNoQXQoYmVmb3JlLmNoaWxkQ291bnQpKVxuICAgICAgICAgICAgLmpvaW4oJHBvcy5wb3MpXG4gICAgICAgICAgICAuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkge1xuICAgIGxldCBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmUsIGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXIsIGNvbm4sIG1hdGNoO1xuICAgIGlmIChiZWZvcmUudHlwZS5zcGVjLmlzb2xhdGluZyB8fCBhZnRlci50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGpvaW5NYXliZUNsZWFyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBjYW5EZWxBZnRlciA9ICRjdXQucGFyZW50LmNhblJlcGxhY2UoJGN1dC5pbmRleCgpLCAkY3V0LmluZGV4KCkgKyAxKTtcbiAgICBpZiAoY2FuRGVsQWZ0ZXIgJiZcbiAgICAgICAgKGNvbm4gPSAobWF0Y2ggPSBiZWZvcmUuY29udGVudE1hdGNoQXQoYmVmb3JlLmNoaWxkQ291bnQpKS5maW5kV3JhcHBpbmcoYWZ0ZXIudHlwZSkpICYmXG4gICAgICAgIG1hdGNoLm1hdGNoVHlwZShjb25uWzBdIHx8IGFmdGVyLnR5cGUpLnZhbGlkRW5kKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IGVuZCA9ICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUsIHdyYXAgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBjb25uLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgIHdyYXAgPSBGcmFnbWVudC5mcm9tKGNvbm5baV0uY3JlYXRlKG51bGwsIHdyYXApKTtcbiAgICAgICAgICAgIHdyYXAgPSBGcmFnbWVudC5mcm9tKGJlZm9yZS5jb3B5KHdyYXApKTtcbiAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKCRjdXQucG9zIC0gMSwgZW5kLCAkY3V0LnBvcywgZW5kLCBuZXcgU2xpY2Uod3JhcCwgMSwgMCksIGNvbm4ubGVuZ3RoLCB0cnVlKSk7XG4gICAgICAgICAgICBsZXQgam9pbkF0ID0gZW5kICsgMiAqIGNvbm4ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGNhbkpvaW4odHIuZG9jLCBqb2luQXQpKVxuICAgICAgICAgICAgICAgIHRyLmpvaW4oam9pbkF0KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgc2VsQWZ0ZXIgPSBTZWxlY3Rpb24uZmluZEZyb20oJGN1dCwgMSk7XG4gICAgbGV0IHJhbmdlID0gc2VsQWZ0ZXIgJiYgc2VsQWZ0ZXIuJGZyb20uYmxvY2tSYW5nZShzZWxBZnRlci4kdG8pLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ICE9IG51bGwgJiYgdGFyZ2V0ID49ICRjdXQuZGVwdGgpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjYW5EZWxBZnRlciAmJiB0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiLCB0cnVlKSAmJiB0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpKSB7XG4gICAgICAgIGxldCBhdCA9IGJlZm9yZSwgd3JhcCA9IFtdO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICB3cmFwLnB1c2goYXQpO1xuICAgICAgICAgICAgaWYgKGF0LmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgYXQgPSBhdC5sYXN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFmdGVyVGV4dCA9IGFmdGVyLCBhZnRlckRlcHRoID0gMTtcbiAgICAgICAgZm9yICg7ICFhZnRlclRleHQuaXNUZXh0YmxvY2s7IGFmdGVyVGV4dCA9IGFmdGVyVGV4dC5maXJzdENoaWxkKVxuICAgICAgICAgICAgYWZ0ZXJEZXB0aCsrO1xuICAgICAgICBpZiAoYXQuY2FuUmVwbGFjZShhdC5jaGlsZENvdW50LCBhdC5jaGlsZENvdW50LCBhZnRlclRleHQuY29udGVudCkpIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gd3JhcC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gRnJhZ21lbnQuZnJvbSh3cmFwW2ldLmNvcHkoZW5kKSk7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSB3cmFwLmxlbmd0aCwgJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSwgJGN1dC5wb3MgKyBhZnRlckRlcHRoLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplIC0gYWZ0ZXJEZXB0aCwgbmV3IFNsaWNlKGVuZCwgd3JhcC5sZW5ndGgsIDApLCAwLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RUZXh0YmxvY2tTaWRlKHNpZGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCAkcG9zID0gc2lkZSA8IDAgPyBzZWwuJGZyb20gOiBzZWwuJHRvO1xuICAgICAgICBsZXQgZGVwdGggPSAkcG9zLmRlcHRoO1xuICAgICAgICB3aGlsZSAoJHBvcy5ub2RlKGRlcHRoKS5pc0lubGluZSkge1xuICAgICAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJHBvcy5ub2RlKGRlcHRoKS5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgc2lkZSA8IDAgPyAkcG9zLnN0YXJ0KGRlcHRoKSA6ICRwb3MuZW5kKGRlcHRoKSkpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuTW92ZXMgdGhlIGN1cnNvciB0byB0aGUgc3RhcnQgb2YgY3VycmVudCB0ZXh0IGJsb2NrLlxuKi9cbmNvbnN0IHNlbGVjdFRleHRibG9ja1N0YXJ0ID0gc2VsZWN0VGV4dGJsb2NrU2lkZSgtMSk7XG4vKipcbk1vdmVzIHRoZSBjdXJzb3IgdG8gdGhlIGVuZCBvZiBjdXJyZW50IHRleHQgYmxvY2suXG4qL1xuY29uc3Qgc2VsZWN0VGV4dGJsb2NrRW5kID0gc2VsZWN0VGV4dGJsb2NrU2lkZSgxKTtcbi8vIFBhcmFtZXRlcml6ZWQgY29tbWFuZHNcbi8qKlxuV3JhcCB0aGUgc2VsZWN0aW9uIGluIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSB3aXRoIHRoZSBnaXZlblxuYXR0cmlidXRlcy5cbiovXG5mdW5jdGlvbiB3cmFwSW4obm9kZVR5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLCB3cmFwcGluZyA9IHJhbmdlICYmIGZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUsIGF0dHJzKTtcbiAgICAgICAgaWYgKCF3cmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIud3JhcChyYW5nZSwgd3JhcHBpbmcpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5SZXR1cm5zIGEgY29tbWFuZCB0aGF0IHRyaWVzIHRvIHNldCB0aGUgc2VsZWN0ZWQgdGV4dGJsb2NrcyB0byB0aGVcbmdpdmVuIG5vZGUgdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuKi9cbmZ1bmN0aW9uIHNldEJsb2NrVHlwZShub2RlVHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IGFwcGxpY2FibGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aCAmJiAhYXBwbGljYWJsZTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyAkZnJvbTogeyBwb3M6IGZyb20gfSwgJHRvOiB7IHBvczogdG8gfSB9ID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlc1tpXTtcbiAgICAgICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwbGljYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5pc1RleHRibG9jayB8fCBub2RlLmhhc01hcmt1cChub2RlVHlwZSwgYXR0cnMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWNhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCAkcG9zID0gc3RhdGUuZG9jLnJlc29sdmUocG9zKSwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2FibGUgPSAkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXggKyAxLCBub2RlVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcHBsaWNhYmxlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgJGZyb206IHsgcG9zOiBmcm9tIH0sICR0bzogeyBwb3M6IHRvIH0gfSA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgdHIuc2V0QmxvY2tUeXBlKGZyb20sIHRvLCBub2RlVHlwZSwgYXR0cnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1hcmtBcHBsaWVzKGRvYywgcmFuZ2VzLCB0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICBsZXQgY2FuID0gJGZyb20uZGVwdGggPT0gMCA/IGRvYy5pbmxpbmVDb250ZW50ICYmIGRvYy50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpIDogZmFsc2U7XG4gICAgICAgIGRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCBub2RlID0+IHtcbiAgICAgICAgICAgIGlmIChjYW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FuID0gbm9kZS5pbmxpbmVDb250ZW50ICYmIG5vZGUudHlwZS5hbGxvd3NNYXJrVHlwZSh0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjYW4pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG5DcmVhdGUgYSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgdG9nZ2xlcyB0aGUgZ2l2ZW4gbWFyayB3aXRoIHRoZVxuZ2l2ZW4gYXR0cmlidXRlcy4gV2lsbCByZXR1cm4gYGZhbHNlYCB3aGVuIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuZG9lc24ndCBzdXBwb3J0IHRoYXQgbWFyay4gVGhpcyB3aWxsIHJlbW92ZSB0aGUgbWFyayBpZiBhbnkgbWFya3Ncbm9mIHRoYXQgdHlwZSBleGlzdCBpbiB0aGUgc2VsZWN0aW9uLCBvciBhZGQgaXQgb3RoZXJ3aXNlLiBJZiB0aGVcbnNlbGVjdGlvbiBpcyBlbXB0eSwgdGhpcyBhcHBsaWVzIHRvIHRoZSBbc3RvcmVkXG5tYXJrc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnN0b3JlZE1hcmtzKSBpbnN0ZWFkIG9mIGEgcmFuZ2Ugb2YgdGhlXG5kb2N1bWVudC5cbiovXG5mdW5jdGlvbiB0b2dnbGVNYXJrKG1hcmtUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyBlbXB0eSwgJGN1cnNvciwgcmFuZ2VzIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmICgoZW1wdHkgJiYgISRjdXJzb3IpIHx8ICFtYXJrQXBwbGllcyhzdGF0ZS5kb2MsIHJhbmdlcywgbWFya1R5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGlmICgkY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlLmlzSW5TZXQoc3RhdGUuc3RvcmVkTWFya3MgfHwgJGN1cnNvci5tYXJrcygpKSlcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIucmVtb3ZlU3RvcmVkTWFyayhtYXJrVHlwZSkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuYWRkU3RvcmVkTWFyayhtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaGFzID0gZmFsc2UsIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7ICFoYXMgJiYgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGhhcyA9IHN0YXRlLmRvYy5yYW5nZUhhc01hcmsoJGZyb20ucG9zLCAkdG8ucG9zLCBtYXJrVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIucmVtb3ZlTWFyaygkZnJvbS5wb3MsICR0by5wb3MsIG1hcmtUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gJGZyb20ucG9zLCB0byA9ICR0by5wb3MsIHN0YXJ0ID0gJGZyb20ubm9kZUFmdGVyLCBlbmQgPSAkdG8ubm9kZUJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZVN0YXJ0ID0gc3RhcnQgJiYgc3RhcnQuaXNUZXh0ID8gL15cXHMqLy5leGVjKHN0YXJ0LnRleHQpWzBdLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VFbmQgPSBlbmQgJiYgZW5kLmlzVGV4dCA/IC9cXHMqJC8uZXhlYyhlbmQudGV4dClbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tICsgc3BhY2VTdGFydCA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSArPSBzcGFjZVN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIC09IHNwYWNlRW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkTWFyayhmcm9tLCB0bywgbWFya1R5cGUuY3JlYXRlKGF0dHJzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHdyYXBEaXNwYXRjaEZvckpvaW4oZGlzcGF0Y2gsIGlzSm9pbmFibGUpIHtcbiAgICByZXR1cm4gKHRyKSA9PiB7XG4gICAgICAgIGlmICghdHIuaXNHZW5lcmljKVxuICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyLm1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcCA9IHRyLm1hcHBpbmcubWFwc1tpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmFuZ2VzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIHJhbmdlc1tqXSA9IG1hcC5tYXAocmFuZ2VzW2pdKTtcbiAgICAgICAgICAgIG1hcC5mb3JFYWNoKChfcywgX2UsIGZyb20sIHRvKSA9PiByYW5nZXMucHVzaChmcm9tLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggam9pbmFibGUgcG9pbnRzIGV4aXN0IGluc2lkZSB0aG9zZSByYW5nZXMsXG4gICAgICAgIC8vIGJ5IGNoZWNraW5nIGFsbCBub2RlIGJvdW5kYXJpZXMgaW4gdGhlaXIgcGFyZW50IG5vZGVzLlxuICAgICAgICBsZXQgam9pbmFibGUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gcmFuZ2VzW2ldLCB0byA9IHJhbmdlc1tpICsgMV07XG4gICAgICAgICAgICBsZXQgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSwgZGVwdGggPSAkZnJvbS5zaGFyZWREZXB0aCh0byksIHBhcmVudCA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSwgcG9zID0gJGZyb20uYWZ0ZXIoZGVwdGggKyAxKTsgcG9zIDw9IHRvOyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFmdGVyID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICghYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAmJiBqb2luYWJsZS5pbmRleE9mKHBvcykgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlLnR5cGUgPT0gYWZ0ZXIudHlwZSAmJiBpc0pvaW5hYmxlKGJlZm9yZSwgYWZ0ZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmFibGUucHVzaChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgKz0gYWZ0ZXIubm9kZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSm9pbiB0aGUgam9pbmFibGUgcG9pbnRzXG4gICAgICAgIGpvaW5hYmxlLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGpvaW5hYmxlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoY2FuSm9pbih0ci5kb2MsIGpvaW5hYmxlW2ldKSlcbiAgICAgICAgICAgICAgICB0ci5qb2luKGpvaW5hYmxlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgfTtcbn1cbi8qKlxuV3JhcCBhIGNvbW1hbmQgc28gdGhhdCwgd2hlbiBpdCBwcm9kdWNlcyBhIHRyYW5zZm9ybSB0aGF0IGNhdXNlc1xudHdvIGpvaW5hYmxlIG5vZGVzIHRvIGVuZCB1cCBuZXh0IHRvIGVhY2ggb3RoZXIsIHRob3NlIGFyZSBqb2luZWQuXG5Ob2RlcyBhcmUgY29uc2lkZXJlZCBqb2luYWJsZSB3aGVuIHRoZXkgYXJlIG9mIHRoZSBzYW1lIHR5cGUgYW5kXG53aGVuIHRoZSBgaXNKb2luYWJsZWAgcHJlZGljYXRlIHJldHVybnMgdHJ1ZSBmb3IgdGhlbSBvciwgaWYgYW5cbmFycmF5IG9mIHN0cmluZ3Mgd2FzIHBhc3NlZCwgaWYgdGhlaXIgbm9kZSB0eXBlIG5hbWUgaXMgaW4gdGhhdFxuYXJyYXkuXG4qL1xuZnVuY3Rpb24gYXV0b0pvaW4oY29tbWFuZCwgaXNKb2luYWJsZSkge1xuICAgIGxldCBjYW5Kb2luID0gQXJyYXkuaXNBcnJheShpc0pvaW5hYmxlKSA/IChub2RlKSA9PiBpc0pvaW5hYmxlLmluZGV4T2Yobm9kZS50eXBlLm5hbWUpID4gLTFcbiAgICAgICAgOiBpc0pvaW5hYmxlO1xuICAgIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiBjb21tYW5kKHN0YXRlLCBkaXNwYXRjaCAmJiB3cmFwRGlzcGF0Y2hGb3JKb2luKGRpc3BhdGNoLCBjYW5Kb2luKSwgdmlldyk7XG59XG4vKipcbkNvbWJpbmUgYSBudW1iZXIgb2YgY29tbWFuZCBmdW5jdGlvbnMgaW50byBhIHNpbmdsZSBmdW5jdGlvbiAod2hpY2hcbmNhbGxzIHRoZW0gb25lIGJ5IG9uZSB1bnRpbCBvbmUgcmV0dXJucyB0cnVlKS5cbiovXG5mdW5jdGlvbiBjaGFpbkNvbW1hbmRzKC4uLmNvbW1hbmRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjb21tYW5kc1tpXShzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cbmxldCBiYWNrc3BhY2UgPSBjaGFpbkNvbW1hbmRzKGRlbGV0ZVNlbGVjdGlvbiwgam9pbkJhY2t3YXJkLCBzZWxlY3ROb2RlQmFja3dhcmQpO1xubGV0IGRlbCA9IGNoYWluQ29tbWFuZHMoZGVsZXRlU2VsZWN0aW9uLCBqb2luRm9yd2FyZCwgc2VsZWN0Tm9kZUZvcndhcmQpO1xuLyoqXG5BIGJhc2ljIGtleW1hcCBjb250YWluaW5nIGJpbmRpbmdzIG5vdCBzcGVjaWZpYyB0byBhbnkgc2NoZW1hLlxuQmluZHMgdGhlIGZvbGxvd2luZyBrZXlzICh3aGVuIG11bHRpcGxlIGNvbW1hbmRzIGFyZSBsaXN0ZWQsIHRoZXlcbmFyZSBjaGFpbmVkIHdpdGggW2BjaGFpbkNvbW1hbmRzYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLmNoYWluQ29tbWFuZHMpKTpcblxuKiAqKkVudGVyKiogdG8gYG5ld2xpbmVJbkNvZGVgLCBgY3JlYXRlUGFyYWdyYXBoTmVhcmAsIGBsaWZ0RW1wdHlCbG9ja2AsIGBzcGxpdEJsb2NrYFxuKiAqKk1vZC1FbnRlcioqIHRvIGBleGl0Q29kZWBcbiogKipCYWNrc3BhY2UqKiBhbmQgKipNb2QtQmFja3NwYWNlKiogdG8gYGRlbGV0ZVNlbGVjdGlvbmAsIGBqb2luQmFja3dhcmRgLCBgc2VsZWN0Tm9kZUJhY2t3YXJkYFxuKiAqKkRlbGV0ZSoqIGFuZCAqKk1vZC1EZWxldGUqKiB0byBgZGVsZXRlU2VsZWN0aW9uYCwgYGpvaW5Gb3J3YXJkYCwgYHNlbGVjdE5vZGVGb3J3YXJkYFxuKiAqKk1vZC1EZWxldGUqKiB0byBgZGVsZXRlU2VsZWN0aW9uYCwgYGpvaW5Gb3J3YXJkYCwgYHNlbGVjdE5vZGVGb3J3YXJkYFxuKiAqKk1vZC1hKiogdG8gYHNlbGVjdEFsbGBcbiovXG5jb25zdCBwY0Jhc2VLZXltYXAgPSB7XG4gICAgXCJFbnRlclwiOiBjaGFpbkNvbW1hbmRzKG5ld2xpbmVJbkNvZGUsIGNyZWF0ZVBhcmFncmFwaE5lYXIsIGxpZnRFbXB0eUJsb2NrLCBzcGxpdEJsb2NrKSxcbiAgICBcIk1vZC1FbnRlclwiOiBleGl0Q29kZSxcbiAgICBcIkJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gICAgXCJNb2QtQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIlNoaWZ0LUJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gICAgXCJEZWxldGVcIjogZGVsLFxuICAgIFwiTW9kLURlbGV0ZVwiOiBkZWwsXG4gICAgXCJNb2QtYVwiOiBzZWxlY3RBbGxcbn07XG4vKipcbkEgY29weSBvZiBgcGNCYXNlS2V5bWFwYCB0aGF0IGFsc28gYmluZHMgKipDdHJsLWgqKiBsaWtlIEJhY2tzcGFjZSxcbioqQ3RybC1kKiogbGlrZSBEZWxldGUsICoqQWx0LUJhY2tzcGFjZSoqIGxpa2UgQ3RybC1CYWNrc3BhY2UsIGFuZFxuKipDdHJsLUFsdC1CYWNrc3BhY2UqKiwgKipBbHQtRGVsZXRlKiosIGFuZCAqKkFsdC1kKiogbGlrZVxuQ3RybC1EZWxldGUuXG4qL1xuY29uc3QgbWFjQmFzZUtleW1hcCA9IHtcbiAgICBcIkN0cmwtaFwiOiBwY0Jhc2VLZXltYXBbXCJCYWNrc3BhY2VcIl0sXG4gICAgXCJBbHQtQmFja3NwYWNlXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1CYWNrc3BhY2VcIl0sXG4gICAgXCJDdHJsLWRcIjogcGNCYXNlS2V5bWFwW1wiRGVsZXRlXCJdLFxuICAgIFwiQ3RybC1BbHQtQmFja3NwYWNlXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gICAgXCJBbHQtRGVsZXRlXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gICAgXCJBbHQtZFwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICAgIFwiQ3RybC1hXCI6IHNlbGVjdFRleHRibG9ja1N0YXJ0LFxuICAgIFwiQ3RybC1lXCI6IHNlbGVjdFRleHRibG9ja0VuZFxufTtcbmZvciAobGV0IGtleSBpbiBwY0Jhc2VLZXltYXApXG4gICAgbWFjQmFzZUtleW1hcFtrZXldID0gcGNCYXNlS2V5bWFwW2tleV07XG5jb25zdCBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyAvTWFjfGlQKGhvbmV8W29hXWQpLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgOiB0eXBlb2Ygb3MgIT0gXCJ1bmRlZmluZWRcIiAmJiBvcy5wbGF0Zm9ybSA/IG9zLnBsYXRmb3JtKCkgPT0gXCJkYXJ3aW5cIiA6IGZhbHNlO1xuLyoqXG5EZXBlbmRpbmcgb24gdGhlIGRldGVjdGVkIHBsYXRmb3JtLCB0aGlzIHdpbGwgaG9sZFxuW2BwY0Jhc2VrZXltYXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMucGNCYXNlS2V5bWFwKSBvclxuW2BtYWNCYXNlS2V5bWFwYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLm1hY0Jhc2VLZXltYXApLlxuKi9cbmNvbnN0IGJhc2VLZXltYXAgPSBtYWMgPyBtYWNCYXNlS2V5bWFwIDogcGNCYXNlS2V5bWFwO1xuXG5leHBvcnQgeyBhdXRvSm9pbiwgYmFzZUtleW1hcCwgY2hhaW5Db21tYW5kcywgY3JlYXRlUGFyYWdyYXBoTmVhciwgZGVsZXRlU2VsZWN0aW9uLCBleGl0Q29kZSwgam9pbkJhY2t3YXJkLCBqb2luRG93biwgam9pbkZvcndhcmQsIGpvaW5UZXh0YmxvY2tCYWNrd2FyZCwgam9pblRleHRibG9ja0ZvcndhcmQsIGpvaW5VcCwgbGlmdCwgbGlmdEVtcHR5QmxvY2ssIG1hY0Jhc2VLZXltYXAsIG5ld2xpbmVJbkNvZGUsIHBjQmFzZUtleW1hcCwgc2VsZWN0QWxsLCBzZWxlY3ROb2RlQmFja3dhcmQsIHNlbGVjdE5vZGVGb3J3YXJkLCBzZWxlY3RQYXJlbnROb2RlLCBzZWxlY3RUZXh0YmxvY2tFbmQsIHNlbGVjdFRleHRibG9ja1N0YXJ0LCBzZXRCbG9ja1R5cGUsIHNwbGl0QmxvY2ssIHNwbGl0QmxvY2tBcywgc3BsaXRCbG9ja0tlZXBNYXJrcywgdG9nZ2xlTWFyaywgd3JhcEluIH07XG4iLCAiaW1wb3J0IHsgZmluZFdyYXBwaW5nLCBSZXBsYWNlQXJvdW5kU3RlcCwgY2FuU3BsaXQsIGxpZnRUYXJnZXQsIGNhbkpvaW4gfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgTm9kZVJhbmdlLCBGcmFnbWVudCwgU2xpY2UgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBTZWxlY3Rpb24gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbmNvbnN0IG9sRE9NID0gW1wib2xcIiwgMF0sIHVsRE9NID0gW1widWxcIiwgMF0sIGxpRE9NID0gW1wibGlcIiwgMF07XG4vKipcbkFuIG9yZGVyZWQgbGlzdCBbbm9kZSBzcGVjXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMpLiBIYXMgYSBzaW5nbGVcbmF0dHJpYnV0ZSwgYG9yZGVyYCwgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIGF0IHdoaWNoIHRoZSBsaXN0XG5zdGFydHMgY291bnRpbmcsIGFuZCBkZWZhdWx0cyB0byAxLiBSZXByZXNlbnRlZCBhcyBhbiBgPG9sPmBcbmVsZW1lbnQuXG4qL1xuY29uc3Qgb3JkZXJlZExpc3QgPSB7XG4gICAgYXR0cnM6IHsgb3JkZXI6IHsgZGVmYXVsdDogMSB9IH0sXG4gICAgcGFyc2VET006IFt7IHRhZzogXCJvbFwiLCBnZXRBdHRycyhkb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBvcmRlcjogZG9tLmhhc0F0dHJpYnV0ZShcInN0YXJ0XCIpID8gK2RvbS5nZXRBdHRyaWJ1dGUoXCJzdGFydFwiKSA6IDEgfTtcbiAgICAgICAgICAgIH0gfV0sXG4gICAgdG9ET00obm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5hdHRycy5vcmRlciA9PSAxID8gb2xET00gOiBbXCJvbFwiLCB7IHN0YXJ0OiBub2RlLmF0dHJzLm9yZGVyIH0sIDBdO1xuICAgIH1cbn07XG4vKipcbkEgYnVsbGV0IGxpc3Qgbm9kZSBzcGVjLCByZXByZXNlbnRlZCBpbiB0aGUgRE9NIGFzIGA8dWw+YC5cbiovXG5jb25zdCBidWxsZXRMaXN0ID0ge1xuICAgIHBhcnNlRE9NOiBbeyB0YWc6IFwidWxcIiB9XSxcbiAgICB0b0RPTSgpIHsgcmV0dXJuIHVsRE9NOyB9XG59O1xuLyoqXG5BIGxpc3QgaXRlbSAoYDxsaT5gKSBzcGVjLlxuKi9cbmNvbnN0IGxpc3RJdGVtID0ge1xuICAgIHBhcnNlRE9NOiBbeyB0YWc6IFwibGlcIiB9XSxcbiAgICB0b0RPTSgpIHsgcmV0dXJuIGxpRE9NOyB9LFxuICAgIGRlZmluaW5nOiB0cnVlXG59O1xuZnVuY3Rpb24gYWRkKG9iaiwgcHJvcHMpIHtcbiAgICBsZXQgY29weSA9IHt9O1xuICAgIGZvciAobGV0IHByb3AgaW4gb2JqKVxuICAgICAgICBjb3B5W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpXG4gICAgICAgIGNvcHlbcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgICByZXR1cm4gY29weTtcbn1cbi8qKlxuQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGFkZGluZyBsaXN0LXJlbGF0ZWQgbm9kZSB0eXBlcyB0byBhIG1hcFxuc3BlY2lmeWluZyB0aGUgbm9kZXMgZm9yIGEgc2NoZW1hLiBBZGRzXG5bYG9yZGVyZWRMaXN0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3NjaGVtYS1saXN0Lm9yZGVyZWRMaXN0KSBhcyBgXCJvcmRlcmVkX2xpc3RcImAsXG5bYGJ1bGxldExpc3RgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc2NoZW1hLWxpc3QuYnVsbGV0TGlzdCkgYXMgYFwiYnVsbGV0X2xpc3RcImAsIGFuZFxuW2BsaXN0SXRlbWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzY2hlbWEtbGlzdC5saXN0SXRlbSkgYXMgYFwibGlzdF9pdGVtXCJgLlxuXG5gaXRlbUNvbnRlbnRgIGRldGVybWluZXMgdGhlIGNvbnRlbnQgZXhwcmVzc2lvbiBmb3IgdGhlIGxpc3QgaXRlbXMuXG5JZiB5b3Ugd2FudCB0aGUgY29tbWFuZHMgZGVmaW5lZCBpbiB0aGlzIG1vZHVsZSB0byBhcHBseSB0byB5b3VyXG5saXN0IHN0cnVjdHVyZSwgaXQgc2hvdWxkIGhhdmUgYSBzaGFwZSBsaWtlIGBcInBhcmFncmFwaCBibG9jaypcImAgb3JcbmBcInBhcmFncmFwaCAob3JkZXJlZF9saXN0IHwgYnVsbGV0X2xpc3QpKlwiYC4gYGxpc3RHcm91cGAgY2FuIGJlXG5naXZlbiB0byBhc3NpZ24gYSBncm91cCBuYW1lIHRvIHRoZSBsaXN0IG5vZGUgdHlwZXMsIGZvciBleGFtcGxlXG5gXCJibG9ja1wiYC5cbiovXG5mdW5jdGlvbiBhZGRMaXN0Tm9kZXMobm9kZXMsIGl0ZW1Db250ZW50LCBsaXN0R3JvdXApIHtcbiAgICByZXR1cm4gbm9kZXMuYXBwZW5kKHtcbiAgICAgICAgb3JkZXJlZF9saXN0OiBhZGQob3JkZXJlZExpc3QsIHsgY29udGVudDogXCJsaXN0X2l0ZW0rXCIsIGdyb3VwOiBsaXN0R3JvdXAgfSksXG4gICAgICAgIGJ1bGxldF9saXN0OiBhZGQoYnVsbGV0TGlzdCwgeyBjb250ZW50OiBcImxpc3RfaXRlbStcIiwgZ3JvdXA6IGxpc3RHcm91cCB9KSxcbiAgICAgICAgbGlzdF9pdGVtOiBhZGQobGlzdEl0ZW0sIHsgY29udGVudDogaXRlbUNvbnRlbnQgfSlcbiAgICB9KTtcbn1cbi8qKlxuUmV0dXJucyBhIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB3cmFwcyB0aGUgc2VsZWN0aW9uIGluIGEgbGlzdCB3aXRoXG50aGUgZ2l2ZW4gdHlwZSBhbiBhdHRyaWJ1dGVzLiBJZiBgZGlzcGF0Y2hgIGlzIG51bGwsIG9ubHkgcmV0dXJuIGFcbnZhbHVlIHRvIGluZGljYXRlIHdoZXRoZXIgdGhpcyBpcyBwb3NzaWJsZSwgYnV0IGRvbid0IGFjdHVhbGx5XG5wZXJmb3JtIHRoZSBjaGFuZ2UuXG4qL1xuZnVuY3Rpb24gd3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksIGRvSm9pbiA9IGZhbHNlLCBvdXRlclJhbmdlID0gcmFuZ2U7XG4gICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFRoaXMgaXMgYXQgdGhlIHRvcCBvZiBhbiBleGlzdGluZyBsaXN0IGl0ZW1cbiAgICAgICAgaWYgKHJhbmdlLmRlcHRoID49IDIgJiYgJGZyb20ubm9kZShyYW5nZS5kZXB0aCAtIDEpLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQobGlzdFR5cGUpICYmIHJhbmdlLnN0YXJ0SW5kZXggPT0gMCkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhpcyBpcyB0aGUgdG9wIG9mIHRoZSBsaXN0XG4gICAgICAgICAgICBpZiAoJGZyb20uaW5kZXgocmFuZ2UuZGVwdGggLSAxKSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCAkaW5zZXJ0ID0gc3RhdGUuZG9jLnJlc29sdmUocmFuZ2Uuc3RhcnQgLSAyKTtcbiAgICAgICAgICAgIG91dGVyUmFuZ2UgPSBuZXcgTm9kZVJhbmdlKCRpbnNlcnQsICRpbnNlcnQsIHJhbmdlLmRlcHRoKTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbmRJbmRleCA8IHJhbmdlLnBhcmVudC5jaGlsZENvdW50KVxuICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IE5vZGVSYW5nZSgkZnJvbSwgc3RhdGUuZG9jLnJlc29sdmUoJHRvLmVuZChyYW5nZS5kZXB0aCkpLCByYW5nZS5kZXB0aCk7XG4gICAgICAgICAgICBkb0pvaW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3cmFwID0gZmluZFdyYXBwaW5nKG91dGVyUmFuZ2UsIGxpc3RUeXBlLCBhdHRycywgcmFuZ2UpO1xuICAgICAgICBpZiAoIXdyYXApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKGRvV3JhcEluTGlzdChzdGF0ZS50ciwgcmFuZ2UsIHdyYXAsIGRvSm9pbiwgbGlzdFR5cGUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZG9XcmFwSW5MaXN0KHRyLCByYW5nZSwgd3JhcHBlcnMsIGpvaW5CZWZvcmUsIGxpc3RUeXBlKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBpID0gd3JhcHBlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHdyYXBwZXJzW2ldLnR5cGUuY3JlYXRlKHdyYXBwZXJzW2ldLmF0dHJzLCBjb250ZW50KSk7XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAocmFuZ2Uuc3RhcnQgLSAoam9pbkJlZm9yZSA/IDIgOiAwKSwgcmFuZ2UuZW5kLCByYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBuZXcgU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xuICAgIGxldCBmb3VuZCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cmFwcGVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKHdyYXBwZXJzW2ldLnR5cGUgPT0gbGlzdFR5cGUpXG4gICAgICAgICAgICBmb3VuZCA9IGkgKyAxO1xuICAgIGxldCBzcGxpdERlcHRoID0gd3JhcHBlcnMubGVuZ3RoIC0gZm91bmQ7XG4gICAgbGV0IHNwbGl0UG9zID0gcmFuZ2Uuc3RhcnQgKyB3cmFwcGVycy5sZW5ndGggLSAoam9pbkJlZm9yZSA/IDIgOiAwKSwgcGFyZW50ID0gcmFuZ2UucGFyZW50O1xuICAgIGZvciAobGV0IGkgPSByYW5nZS5zdGFydEluZGV4LCBlID0gcmFuZ2UuZW5kSW5kZXgsIGZpcnN0ID0gdHJ1ZTsgaSA8IGU7IGkrKywgZmlyc3QgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIWZpcnN0ICYmIGNhblNwbGl0KHRyLmRvYywgc3BsaXRQb3MsIHNwbGl0RGVwdGgpKSB7XG4gICAgICAgICAgICB0ci5zcGxpdChzcGxpdFBvcywgc3BsaXREZXB0aCk7XG4gICAgICAgICAgICBzcGxpdFBvcyArPSAyICogc3BsaXREZXB0aDtcbiAgICAgICAgfVxuICAgICAgICBzcGxpdFBvcyArPSBwYXJlbnQuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbi8qKlxuQnVpbGQgYSBjb21tYW5kIHRoYXQgc3BsaXRzIGEgbm9uLWVtcHR5IHRleHRibG9jayBhdCB0aGUgdG9wIGxldmVsXG5vZiBhIGxpc3QgaXRlbSBieSBhbHNvIHNwbGl0dGluZyB0aGF0IGxpc3QgaXRlbS5cbiovXG5mdW5jdGlvbiBzcGxpdExpc3RJdGVtKGl0ZW1UeXBlLCBpdGVtQXR0cnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvLCBub2RlIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmICgobm9kZSAmJiBub2RlLmlzQmxvY2spIHx8ICRmcm9tLmRlcHRoIDwgMiB8fCAhJGZyb20uc2FtZVBhcmVudCgkdG8pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgZ3JhbmRQYXJlbnQgPSAkZnJvbS5ub2RlKC0xKTtcbiAgICAgICAgaWYgKGdyYW5kUGFyZW50LnR5cGUgIT0gaXRlbVR5cGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICgkZnJvbS5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiYgJGZyb20ubm9kZSgtMSkuY2hpbGRDb3VudCA9PSAkZnJvbS5pbmRleEFmdGVyKC0xKSkge1xuICAgICAgICAgICAgLy8gSW4gYW4gZW1wdHkgYmxvY2suIElmIHRoaXMgaXMgYSBuZXN0ZWQgbGlzdCwgdGhlIHdyYXBwaW5nXG4gICAgICAgICAgICAvLyBsaXN0IGl0ZW0gc2hvdWxkIGJlIHNwbGl0LiBPdGhlcndpc2UsIGJhaWwgb3V0IGFuZCBsZXQgbmV4dFxuICAgICAgICAgICAgLy8gY29tbWFuZCBoYW5kbGUgbGlmdGluZy5cbiAgICAgICAgICAgIGlmICgkZnJvbS5kZXB0aCA9PSAzIHx8ICRmcm9tLm5vZGUoLTMpLnR5cGUgIT0gaXRlbVR5cGUgfHxcbiAgICAgICAgICAgICAgICAkZnJvbS5pbmRleCgtMikgIT0gJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXAgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgICAgICAgICBsZXQgZGVwdGhCZWZvcmUgPSAkZnJvbS5pbmRleCgtMSkgPyAxIDogJGZyb20uaW5kZXgoLTIpID8gMiA6IDM7XG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgYSBmcmFnbWVudCBjb250YWluaW5nIGVtcHR5IHZlcnNpb25zIG9mIHRoZSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBvdXRlciBsaXN0IGl0ZW0gdG8gdGhlIHBhcmVudCBub2RlIG9mIHRoZSBjdXJzb3JcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGggLSBkZXB0aEJlZm9yZTsgZCA+PSAkZnJvbS5kZXB0aCAtIDM7IGQtLSlcbiAgICAgICAgICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KHdyYXApKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVwdGhBZnRlciA9ICRmcm9tLmluZGV4QWZ0ZXIoLTEpIDwgJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCA/IDFcbiAgICAgICAgICAgICAgICAgICAgOiAkZnJvbS5pbmRleEFmdGVyKC0yKSA8ICRmcm9tLm5vZGUoLTMpLmNoaWxkQ291bnQgPyAyIDogMztcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBzZWNvbmQgbGlzdCBpdGVtIHdpdGggYW4gZW1wdHkgZGVmYXVsdCBzdGFydCBub2RlXG4gICAgICAgICAgICAgICAgd3JhcCA9IHdyYXAuYXBwZW5kKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlQW5kRmlsbCgpKSk7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gJGZyb20uYmVmb3JlKCRmcm9tLmRlcHRoIC0gKGRlcHRoQmVmb3JlIC0gMSkpO1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnJlcGxhY2Uoc3RhcnQsICRmcm9tLmFmdGVyKC1kZXB0aEFmdGVyKSwgbmV3IFNsaWNlKHdyYXAsIDQgLSBkZXB0aEJlZm9yZSwgMCkpO1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSAtMTtcbiAgICAgICAgICAgICAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKHN0YXJ0LCB0ci5kb2MuY29udGVudC5zaXplLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWwgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0YmxvY2sgJiYgbm9kZS5jb250ZW50LnNpemUgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoc2VsKSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRUeXBlID0gJHRvLnBvcyA9PSAkZnJvbS5lbmQoKSA/IGdyYW5kUGFyZW50LmNvbnRlbnRNYXRjaEF0KDApLmRlZmF1bHRUeXBlIDogbnVsbDtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuZGVsZXRlKCRmcm9tLnBvcywgJHRvLnBvcyk7XG4gICAgICAgIGxldCB0eXBlcyA9IG5leHRUeXBlID8gW2l0ZW1BdHRycyA/IHsgdHlwZTogaXRlbVR5cGUsIGF0dHJzOiBpdGVtQXR0cnMgfSA6IG51bGwsIHsgdHlwZTogbmV4dFR5cGUgfV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghY2FuU3BsaXQodHIuZG9jLCAkZnJvbS5wb3MsIDIsIHR5cGVzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc3BsaXQoJGZyb20ucG9zLCAyLCB0eXBlcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkNyZWF0ZSBhIGNvbW1hbmQgdG8gbGlmdCB0aGUgbGlzdCBpdGVtIGFyb3VuZCB0aGUgc2VsZWN0aW9uIHVwIGludG9cbmEgd3JhcHBpbmcgbGlzdC5cbiovXG5mdW5jdGlvbiBsaWZ0TGlzdEl0ZW0oaXRlbVR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBub2RlID0+IG5vZGUuY2hpbGRDb3VudCA+IDAgJiYgbm9kZS5maXJzdENoaWxkLnR5cGUgPT0gaXRlbVR5cGUpO1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWRpc3BhdGNoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICgkZnJvbS5ub2RlKHJhbmdlLmRlcHRoIC0gMSkudHlwZSA9PSBpdGVtVHlwZSkgLy8gSW5zaWRlIGEgcGFyZW50IGxpc3RcbiAgICAgICAgICAgIHJldHVybiBsaWZ0VG9PdXRlckxpc3Qoc3RhdGUsIGRpc3BhdGNoLCBpdGVtVHlwZSwgcmFuZ2UpO1xuICAgICAgICBlbHNlIC8vIE91dGVyIGxpc3Qgbm9kZVxuICAgICAgICAgICAgcmV0dXJuIGxpZnRPdXRPZkxpc3Qoc3RhdGUsIGRpc3BhdGNoLCByYW5nZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpZnRUb091dGVyTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIGl0ZW1UeXBlLCByYW5nZSkge1xuICAgIGxldCB0ciA9IHN0YXRlLnRyLCBlbmQgPSByYW5nZS5lbmQsIGVuZE9mTGlzdCA9IHJhbmdlLiR0by5lbmQocmFuZ2UuZGVwdGgpO1xuICAgIGlmIChlbmQgPCBlbmRPZkxpc3QpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHNpYmxpbmdzIGFmdGVyIHRoZSBsaWZ0ZWQgaXRlbXMsIHdoaWNoIG11c3QgYmVjb21lXG4gICAgICAgIC8vIGNoaWxkcmVuIG9mIHRoZSBsYXN0IGl0ZW1cbiAgICAgICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoZW5kIC0gMSwgZW5kT2ZMaXN0LCBlbmQsIGVuZE9mTGlzdCwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlKG51bGwsIHJhbmdlLnBhcmVudC5jb3B5KCkpKSwgMSwgMCksIDEsIHRydWUpKTtcbiAgICAgICAgcmFuZ2UgPSBuZXcgTm9kZVJhbmdlKHRyLmRvYy5yZXNvbHZlKHJhbmdlLiRmcm9tLnBvcyksIHRyLmRvYy5yZXNvbHZlKGVuZE9mTGlzdCksIHJhbmdlLmRlcHRoKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHIubGlmdChyYW5nZSwgdGFyZ2V0KTtcbiAgICBsZXQgYWZ0ZXIgPSB0ci5tYXBwaW5nLm1hcChlbmQsIC0xKSAtIDE7XG4gICAgaWYgKGNhbkpvaW4odHIuZG9jLCBhZnRlcikpXG4gICAgICAgIHRyLmpvaW4oYWZ0ZXIpO1xuICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbGlmdE91dE9mTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIHJhbmdlKSB7XG4gICAgbGV0IHRyID0gc3RhdGUudHIsIGxpc3QgPSByYW5nZS5wYXJlbnQ7XG4gICAgLy8gTWVyZ2UgdGhlIGxpc3QgaXRlbXMgaW50byBhIHNpbmdsZSBiaWcgaXRlbVxuICAgIGZvciAobGV0IHBvcyA9IHJhbmdlLmVuZCwgaSA9IHJhbmdlLmVuZEluZGV4IC0gMSwgZSA9IHJhbmdlLnN0YXJ0SW5kZXg7IGkgPiBlOyBpLS0pIHtcbiAgICAgICAgcG9zIC09IGxpc3QuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgICAgIHRyLmRlbGV0ZShwb3MgLSAxLCBwb3MgKyAxKTtcbiAgICB9XG4gICAgbGV0ICRzdGFydCA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLnN0YXJ0KSwgaXRlbSA9ICRzdGFydC5ub2RlQWZ0ZXI7XG4gICAgaWYgKHRyLm1hcHBpbmcubWFwKHJhbmdlLmVuZCkgIT0gcmFuZ2Uuc3RhcnQgKyAkc3RhcnQubm9kZUFmdGVyLm5vZGVTaXplKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGF0U3RhcnQgPSByYW5nZS5zdGFydEluZGV4ID09IDAsIGF0RW5kID0gcmFuZ2UuZW5kSW5kZXggPT0gbGlzdC5jaGlsZENvdW50O1xuICAgIGxldCBwYXJlbnQgPSAkc3RhcnQubm9kZSgtMSksIGluZGV4QmVmb3JlID0gJHN0YXJ0LmluZGV4KC0xKTtcbiAgICBpZiAoIXBhcmVudC5jYW5SZXBsYWNlKGluZGV4QmVmb3JlICsgKGF0U3RhcnQgPyAwIDogMSksIGluZGV4QmVmb3JlICsgMSwgaXRlbS5jb250ZW50LmFwcGVuZChhdEVuZCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0KSkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHN0YXJ0ID0gJHN0YXJ0LnBvcywgZW5kID0gc3RhcnQgKyBpdGVtLm5vZGVTaXplO1xuICAgIC8vIFN0cmlwIG9mZiB0aGUgc3Vycm91bmRpbmcgbGlzdC4gQXQgdGhlIHNpZGVzIHdoZXJlIHdlJ3JlIG5vdCBhdFxuICAgIC8vIHRoZSBlbmQgb2YgdGhlIGxpc3QsIHRoZSBleGlzdGluZyBsaXN0IGlzIGNsb3NlZC4gQXQgc2lkZXMgd2hlcmVcbiAgICAvLyB0aGlzIGlzIHRoZSBlbmQsIGl0IGlzIG92ZXJ3cml0dGVuIHRvIGl0cyBlbmQuXG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQgLSAoYXRTdGFydCA/IDEgOiAwKSwgZW5kICsgKGF0RW5kID8gMSA6IDApLCBzdGFydCArIDEsIGVuZCAtIDEsIG5ldyBTbGljZSgoYXRTdGFydCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0LmNvcHkoRnJhZ21lbnQuZW1wdHkpKSlcbiAgICAgICAgLmFwcGVuZChhdEVuZCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0LmNvcHkoRnJhZ21lbnQuZW1wdHkpKSksIGF0U3RhcnQgPyAwIDogMSwgYXRFbmQgPyAwIDogMSksIGF0U3RhcnQgPyAwIDogMSkpO1xuICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5DcmVhdGUgYSBjb21tYW5kIHRvIHNpbmsgdGhlIGxpc3QgaXRlbSBhcm91bmQgdGhlIHNlbGVjdGlvbiBkb3duXG5pbnRvIGFuIGlubmVyIGxpc3QuXG4qL1xuZnVuY3Rpb24gc2lua0xpc3RJdGVtKGl0ZW1UeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bywgbm9kZSA9PiBub2RlLmNoaWxkQ291bnQgPiAwICYmIG5vZGUuZmlyc3RDaGlsZC50eXBlID09IGl0ZW1UeXBlKTtcbiAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSByYW5nZS5zdGFydEluZGV4O1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgcGFyZW50ID0gcmFuZ2UucGFyZW50LCBub2RlQmVmb3JlID0gcGFyZW50LmNoaWxkKHN0YXJ0SW5kZXggLSAxKTtcbiAgICAgICAgaWYgKG5vZGVCZWZvcmUudHlwZSAhPSBpdGVtVHlwZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgbmVzdGVkQmVmb3JlID0gbm9kZUJlZm9yZS5sYXN0Q2hpbGQgJiYgbm9kZUJlZm9yZS5sYXN0Q2hpbGQudHlwZSA9PSBwYXJlbnQudHlwZTtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IEZyYWdtZW50LmZyb20obmVzdGVkQmVmb3JlID8gaXRlbVR5cGUuY3JlYXRlKCkgOiBudWxsKTtcbiAgICAgICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGl0ZW1UeXBlLmNyZWF0ZShudWxsLCBGcmFnbWVudC5mcm9tKHBhcmVudC50eXBlLmNyZWF0ZShudWxsLCBpbm5lcikpKSksIG5lc3RlZEJlZm9yZSA/IDMgOiAxLCAwKTtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSByYW5nZS5zdGFydCwgYWZ0ZXIgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChiZWZvcmUgLSAobmVzdGVkQmVmb3JlID8gMyA6IDEpLCBhZnRlciwgYmVmb3JlLCBhZnRlciwgc2xpY2UsIDEsIHRydWUpKVxuICAgICAgICAgICAgICAgIC5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBhZGRMaXN0Tm9kZXMsIGJ1bGxldExpc3QsIGxpZnRMaXN0SXRlbSwgbGlzdEl0ZW0sIG9yZGVyZWRMaXN0LCBzaW5rTGlzdEl0ZW0sIHNwbGl0TGlzdEl0ZW0sIHdyYXBJbkxpc3QgfTtcbiIsICJpbXBvcnQgeyBFZGl0b3JTdGF0ZSwgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoY29uZmlnOiB7XG4gIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblxuICBzdGF0ZTogRWRpdG9yU3RhdGVcbn0pOiBFZGl0b3JTdGF0ZSB7XG4gIGNvbnN0IHsgc3RhdGUsIHRyYW5zYWN0aW9uIH0gPSBjb25maWdcbiAgbGV0IHsgc2VsZWN0aW9uIH0gPSB0cmFuc2FjdGlvblxuICBsZXQgeyBkb2MgfSA9IHRyYW5zYWN0aW9uXG4gIGxldCB7IHN0b3JlZE1hcmtzIH0gPSB0cmFuc2FjdGlvblxuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgYXBwbHk6IHN0YXRlLmFwcGx5LmJpbmQoc3RhdGUpLFxuICAgIGFwcGx5VHJhbnNhY3Rpb246IHN0YXRlLmFwcGx5VHJhbnNhY3Rpb24uYmluZChzdGF0ZSksXG4gICAgcGx1Z2luczogc3RhdGUucGx1Z2lucyxcbiAgICBzY2hlbWE6IHN0YXRlLnNjaGVtYSxcbiAgICByZWNvbmZpZ3VyZTogc3RhdGUucmVjb25maWd1cmUuYmluZChzdGF0ZSksXG4gICAgdG9KU09OOiBzdGF0ZS50b0pTT04uYmluZChzdGF0ZSksXG4gICAgZ2V0IHN0b3JlZE1hcmtzKCkge1xuICAgICAgcmV0dXJuIHN0b3JlZE1hcmtzXG4gICAgfSxcbiAgICBnZXQgc2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNlbGVjdGlvblxuICAgIH0sXG4gICAgZ2V0IGRvYygpIHtcbiAgICAgIHJldHVybiBkb2NcbiAgICB9LFxuICAgIGdldCB0cigpIHtcbiAgICAgIHNlbGVjdGlvbiA9IHRyYW5zYWN0aW9uLnNlbGVjdGlvblxuICAgICAgZG9jID0gdHJhbnNhY3Rpb24uZG9jXG4gICAgICBzdG9yZWRNYXJrcyA9IHRyYW5zYWN0aW9uLnN0b3JlZE1hcmtzXG5cbiAgICAgIHJldHVybiB0cmFuc2FjdGlvblxuICAgIH0sXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBFZGl0b3JTdGF0ZSwgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IGNyZWF0ZUNoYWluYWJsZVN0YXRlIH0gZnJvbSAnLi9oZWxwZXJzL2NyZWF0ZUNoYWluYWJsZVN0YXRlLmpzJ1xuaW1wb3J0IHtcbiAgQW55Q29tbWFuZHMsIENhbkNvbW1hbmRzLCBDaGFpbmVkQ29tbWFuZHMsIENvbW1hbmRQcm9wcywgU2luZ2xlQ29tbWFuZHMsXG59IGZyb20gJy4vdHlwZXMuanMnXG5cbmV4cG9ydCBjbGFzcyBDb21tYW5kTWFuYWdlciB7XG4gIGVkaXRvcjogRWRpdG9yXG5cbiAgcmF3Q29tbWFuZHM6IEFueUNvbW1hbmRzXG5cbiAgY3VzdG9tU3RhdGU/OiBFZGl0b3JTdGF0ZVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiB7IGVkaXRvcjogRWRpdG9yOyBzdGF0ZT86IEVkaXRvclN0YXRlIH0pIHtcbiAgICB0aGlzLmVkaXRvciA9IHByb3BzLmVkaXRvclxuICAgIHRoaXMucmF3Q29tbWFuZHMgPSB0aGlzLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmNvbW1hbmRzXG4gICAgdGhpcy5jdXN0b21TdGF0ZSA9IHByb3BzLnN0YXRlXG4gIH1cblxuICBnZXQgaGFzQ3VzdG9tU3RhdGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5jdXN0b21TdGF0ZVxuICB9XG5cbiAgZ2V0IHN0YXRlKCk6IEVkaXRvclN0YXRlIHtcbiAgICByZXR1cm4gdGhpcy5jdXN0b21TdGF0ZSB8fCB0aGlzLmVkaXRvci5zdGF0ZVxuICB9XG5cbiAgZ2V0IGNvbW1hbmRzKCk6IFNpbmdsZUNvbW1hbmRzIHtcbiAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzXG4gICAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3JcbiAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyKVxuXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xuICAgICAgICBjb25zdCBtZXRob2QgPSAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGNvbW1hbmQoLi4uYXJncykocHJvcHMpXG5cbiAgICAgICAgICBpZiAoIXRyLmdldE1ldGEoJ3ByZXZlbnREaXNwYXRjaCcpICYmICF0aGlzLmhhc0N1c3RvbVN0YXRlKSB7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjYWxsYmFja1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtuYW1lLCBtZXRob2RdXG4gICAgICB9KSxcbiAgICApIGFzIHVua25vd24gYXMgU2luZ2xlQ29tbWFuZHNcbiAgfVxuXG4gIGdldCBjaGFpbigpOiAoKSA9PiBDaGFpbmVkQ29tbWFuZHMge1xuICAgIHJldHVybiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKClcbiAgfVxuXG4gIGdldCBjYW4oKTogKCkgPT4gQ2FuQ29tbWFuZHMge1xuICAgIHJldHVybiAoKSA9PiB0aGlzLmNyZWF0ZUNhbigpXG4gIH1cblxuICBwdWJsaWMgY3JlYXRlQ2hhaW4oc3RhcnRUcj86IFRyYW5zYWN0aW9uLCBzaG91bGREaXNwYXRjaCA9IHRydWUpOiBDaGFpbmVkQ29tbWFuZHMge1xuICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXNcbiAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvclxuICAgIGNvbnN0IGNhbGxiYWNrczogYm9vbGVhbltdID0gW11cbiAgICBjb25zdCBoYXNTdGFydFRyYW5zYWN0aW9uID0gISFzdGFydFRyXG4gICAgY29uc3QgdHIgPSBzdGFydFRyIHx8IHN0YXRlLnRyXG5cbiAgICBjb25zdCBydW4gPSAoKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgICFoYXNTdGFydFRyYW5zYWN0aW9uXG4gICAgICAgICYmIHNob3VsZERpc3BhdGNoXG4gICAgICAgICYmICF0ci5nZXRNZXRhKCdwcmV2ZW50RGlzcGF0Y2gnKVxuICAgICAgICAmJiAhdGhpcy5oYXNDdXN0b21TdGF0ZVxuICAgICAgKSB7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godHIpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsYmFja3MuZXZlcnkoY2FsbGJhY2sgPT4gY2FsbGJhY2sgPT09IHRydWUpXG4gICAgfVxuXG4gICAgY29uc3QgY2hhaW4gPSB7XG4gICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNoYWluZWRDb21tYW5kID0gKC4uLmFyZ3M6IG5ldmVyW10pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyLCBzaG91bGREaXNwYXRjaClcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gY29tbWFuZCguLi5hcmdzKShwcm9wcylcblxuICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spXG5cbiAgICAgICAgICAgIHJldHVybiBjaGFpblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbbmFtZSwgY2hhaW5lZENvbW1hbmRdXG4gICAgICAgIH0pLFxuICAgICAgKSxcbiAgICAgIHJ1bixcbiAgICB9IGFzIHVua25vd24gYXMgQ2hhaW5lZENvbW1hbmRzXG5cbiAgICByZXR1cm4gY2hhaW5cbiAgfVxuXG4gIHB1YmxpYyBjcmVhdGVDYW4oc3RhcnRUcj86IFRyYW5zYWN0aW9uKTogQ2FuQ29tbWFuZHMge1xuICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIHN0YXRlIH0gPSB0aGlzXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBmYWxzZVxuICAgIGNvbnN0IHRyID0gc3RhcnRUciB8fCBzdGF0ZS50clxuICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyLCBkaXNwYXRjaClcbiAgICBjb25zdCBmb3JtYXR0ZWRDb21tYW5kcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xuICAgICAgICByZXR1cm4gW25hbWUsICguLi5hcmdzOiBuZXZlcltdKSA9PiBjb21tYW5kKC4uLmFyZ3MpKHsgLi4ucHJvcHMsIGRpc3BhdGNoOiB1bmRlZmluZWQgfSldXG4gICAgICB9KSxcbiAgICApIGFzIHVua25vd24gYXMgU2luZ2xlQ29tbWFuZHNcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5mb3JtYXR0ZWRDb21tYW5kcyxcbiAgICAgIGNoYWluOiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKHRyLCBkaXNwYXRjaCksXG4gICAgfSBhcyBDYW5Db21tYW5kc1xuICB9XG5cbiAgcHVibGljIGJ1aWxkUHJvcHModHI6IFRyYW5zYWN0aW9uLCBzaG91bGREaXNwYXRjaCA9IHRydWUpOiBDb21tYW5kUHJvcHMge1xuICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXNcbiAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvclxuXG4gICAgY29uc3QgcHJvcHM6IENvbW1hbmRQcm9wcyA9IHtcbiAgICAgIHRyLFxuICAgICAgZWRpdG9yLFxuICAgICAgdmlldyxcbiAgICAgIHN0YXRlOiBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgICB9KSxcbiAgICAgIGRpc3BhdGNoOiBzaG91bGREaXNwYXRjaCA/ICgpID0+IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCxcbiAgICAgIGNoYWluOiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKHRyLCBzaG91bGREaXNwYXRjaCksXG4gICAgICBjYW46ICgpID0+IHRoaXMuY3JlYXRlQ2FuKHRyKSxcbiAgICAgIGdldCBjb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbbmFtZSwgKC4uLmFyZ3M6IG5ldmVyW10pID0+IGNvbW1hbmQoLi4uYXJncykocHJvcHMpXVxuICAgICAgICAgIH0pLFxuICAgICAgICApIGFzIHVua25vd24gYXMgU2luZ2xlQ29tbWFuZHNcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzXG4gIH1cbn1cbiIsICJ0eXBlIFN0cmluZ0tleU9mPFQ+ID0gRXh0cmFjdDxrZXlvZiBULCBzdHJpbmc+XG50eXBlIENhbGxiYWNrVHlwZTxcbiAgVCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIEV2ZW50TmFtZSBleHRlbmRzIFN0cmluZ0tleU9mPFQ+LFxuPiA9IFRbRXZlbnROYW1lXSBleHRlbmRzIGFueVtdID8gVFtFdmVudE5hbWVdIDogW1RbRXZlbnROYW1lXV1cbnR5cGUgQ2FsbGJhY2tGdW5jdGlvbjxcbiAgVCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIEV2ZW50TmFtZSBleHRlbmRzIFN0cmluZ0tleU9mPFQ+LFxuPiA9ICguLi5wcm9wczogQ2FsbGJhY2tUeXBlPFQsIEV2ZW50TmFtZT4pID0+IGFueVxuXG5leHBvcnQgY2xhc3MgRXZlbnRFbWl0dGVyPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PiB7XG5cbiAgcHJpdmF0ZSBjYWxsYmFja3M6IHsgW2tleTogc3RyaW5nXTogRnVuY3Rpb25bXSB9ID0ge31cblxuICBwdWJsaWMgb248RXZlbnROYW1lIGV4dGVuZHMgU3RyaW5nS2V5T2Y8VD4+KGV2ZW50OiBFdmVudE5hbWUsIGZuOiBDYWxsYmFja0Z1bmN0aW9uPFQsIEV2ZW50TmFtZT4pOiB0aGlzIHtcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW2V2ZW50XSkge1xuICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdID0gW11cbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0ucHVzaChmbilcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcm90ZWN0ZWQgZW1pdDxFdmVudE5hbWUgZXh0ZW5kcyBTdHJpbmdLZXlPZjxUPj4oZXZlbnQ6IEV2ZW50TmFtZSwgLi4uYXJnczogQ2FsbGJhY2tUeXBlPFQsIEV2ZW50TmFtZT4pOiB0aGlzIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF1cblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgb2ZmPEV2ZW50TmFtZSBleHRlbmRzIFN0cmluZ0tleU9mPFQ+PihldmVudDogRXZlbnROYW1lLCBmbj86IENhbGxiYWNrRnVuY3Rpb248VCwgRXZlbnROYW1lPik6IHRoaXMge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XVxuXG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IGNhbGxiYWNrcy5maWx0ZXIoY2FsbGJhY2sgPT4gY2FsbGJhY2sgIT09IGZuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tzW2V2ZW50XVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcm90ZWN0ZWQgcmVtb3ZlQWxsTGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIHRoaXMuY2FsbGJhY2tzID0ge31cbiAgfVxufVxuIiwgImltcG9ydCB7IEFueUV4dGVuc2lvbiwgTWF5YmVUaGlzUGFyYW1ldGVyVHlwZSwgUmVtb3ZlVGhpcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uRmllbGQ8VCA9IGFueT4oXG4gIGV4dGVuc2lvbjogQW55RXh0ZW5zaW9uLFxuICBmaWVsZDogc3RyaW5nLFxuICBjb250ZXh0PzogT21pdDxNYXliZVRoaXNQYXJhbWV0ZXJUeXBlPFQ+LCAncGFyZW50Jz4sXG4pOiBSZW1vdmVUaGlzPFQ+IHtcblxuICBpZiAoZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF0gPT09IHVuZGVmaW5lZCAmJiBleHRlbnNpb24ucGFyZW50KSB7XG4gICAgcmV0dXJuIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbi5wYXJlbnQsIGZpZWxkLCBjb250ZXh0KVxuICB9XG5cbiAgaWYgKHR5cGVvZiBleHRlbnNpb24uY29uZmlnW2ZpZWxkXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IHZhbHVlID0gZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF0uYmluZCh7XG4gICAgICAuLi5jb250ZXh0LFxuICAgICAgcGFyZW50OiBleHRlbnNpb24ucGFyZW50XG4gICAgICAgID8gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLnBhcmVudCwgZmllbGQsIGNvbnRleHQpXG4gICAgICAgIDogbnVsbCxcbiAgICB9KVxuXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICByZXR1cm4gZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF1cbn1cbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5pbXBvcnQgeyBNYXJrIH0gZnJvbSAnLi4vTWFyay5qcydcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuLi9Ob2RlLmpzJ1xuaW1wb3J0IHsgRXh0ZW5zaW9ucyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpIHtcbiAgY29uc3QgYmFzZUV4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcihleHRlbnNpb24gPT4gZXh0ZW5zaW9uLnR5cGUgPT09ICdleHRlbnNpb24nKSBhcyBFeHRlbnNpb25bXVxuICBjb25zdCBub2RlRXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMuZmlsdGVyKGV4dGVuc2lvbiA9PiBleHRlbnNpb24udHlwZSA9PT0gJ25vZGUnKSBhcyBOb2RlW11cbiAgY29uc3QgbWFya0V4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcihleHRlbnNpb24gPT4gZXh0ZW5zaW9uLnR5cGUgPT09ICdtYXJrJykgYXMgTWFya1tdXG5cbiAgcmV0dXJuIHtcbiAgICBiYXNlRXh0ZW5zaW9ucyxcbiAgICBub2RlRXh0ZW5zaW9ucyxcbiAgICBtYXJrRXh0ZW5zaW9ucyxcbiAgfVxufVxuIiwgImltcG9ydCB7IE1hcmtDb25maWcsIE5vZGVDb25maWcgfSBmcm9tICcuLi9pbmRleC5qcydcbmltcG9ydCB7XG4gIEFueUNvbmZpZyxcbiAgQXR0cmlidXRlLFxuICBBdHRyaWJ1dGVzLFxuICBFeHRlbnNpb25BdHRyaWJ1dGUsXG4gIEV4dGVuc2lvbnMsXG4gIEdsb2JhbEF0dHJpYnV0ZXMsXG59IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZ2V0RXh0ZW5zaW9uRmllbGQgfSBmcm9tICcuL2dldEV4dGVuc2lvbkZpZWxkLmpzJ1xuaW1wb3J0IHsgc3BsaXRFeHRlbnNpb25zIH0gZnJvbSAnLi9zcGxpdEV4dGVuc2lvbnMuanMnXG5cbi8qKlxuICogR2V0IGEgbGlzdCBvZiBhbGwgZXh0ZW5zaW9uIGF0dHJpYnV0ZXMgZGVmaW5lZCBpbiBgYWRkQXR0cmlidXRlYCBhbmQgYGFkZEdsb2JhbEF0dHJpYnV0ZWAuXG4gKiBAcGFyYW0gZXh0ZW5zaW9ucyBMaXN0IG9mIGV4dGVuc2lvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyhleHRlbnNpb25zOiBFeHRlbnNpb25zKTogRXh0ZW5zaW9uQXR0cmlidXRlW10ge1xuICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzOiBFeHRlbnNpb25BdHRyaWJ1dGVbXSA9IFtdXG4gIGNvbnN0IHsgbm9kZUV4dGVuc2lvbnMsIG1hcmtFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnMoZXh0ZW5zaW9ucylcbiAgY29uc3Qgbm9kZUFuZE1hcmtFeHRlbnNpb25zID0gWy4uLm5vZGVFeHRlbnNpb25zLCAuLi5tYXJrRXh0ZW5zaW9uc11cbiAgY29uc3QgZGVmYXVsdEF0dHJpYnV0ZTogUmVxdWlyZWQ8QXR0cmlidXRlPiA9IHtcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIHJlbmRlcmVkOiB0cnVlLFxuICAgIHJlbmRlckhUTUw6IG51bGwsXG4gICAgcGFyc2VIVE1MOiBudWxsLFxuICAgIGtlZXBPblNwbGl0OiB0cnVlLFxuICAgIGlzUmVxdWlyZWQ6IGZhbHNlLFxuICB9XG5cbiAgZXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICB9XG5cbiAgICBjb25zdCBhZGRHbG9iYWxBdHRyaWJ1dGVzID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRHbG9iYWxBdHRyaWJ1dGVzJ10+KFxuICAgICAgZXh0ZW5zaW9uLFxuICAgICAgJ2FkZEdsb2JhbEF0dHJpYnV0ZXMnLFxuICAgICAgY29udGV4dCxcbiAgICApXG5cbiAgICBpZiAoIWFkZEdsb2JhbEF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSBgYXMgR2xvYmFsQXR0cmlidXRlc2BcbiAgICBjb25zdCBnbG9iYWxBdHRyaWJ1dGVzID0gYWRkR2xvYmFsQXR0cmlidXRlcygpIGFzIEdsb2JhbEF0dHJpYnV0ZXNcblxuICAgIGdsb2JhbEF0dHJpYnV0ZXMuZm9yRWFjaChnbG9iYWxBdHRyaWJ1dGUgPT4ge1xuICAgICAgZ2xvYmFsQXR0cmlidXRlLnR5cGVzLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgIE9iamVjdFxuICAgICAgICAgIC5lbnRyaWVzKGdsb2JhbEF0dHJpYnV0ZS5hdHRyaWJ1dGVzKVxuICAgICAgICAgIC5mb3JFYWNoKChbbmFtZSwgYXR0cmlidXRlXSkgPT4ge1xuICAgICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlOiB7XG4gICAgICAgICAgICAgICAgLi4uZGVmYXVsdEF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGUsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG5cbiAgbm9kZUFuZE1hcmtFeHRlbnNpb25zLmZvckVhY2goZXh0ZW5zaW9uID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgIH1cblxuICAgIGNvbnN0IGFkZEF0dHJpYnV0ZXMgPSBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydhZGRBdHRyaWJ1dGVzJ10gfCBNYXJrQ29uZmlnWydhZGRBdHRyaWJ1dGVzJ10+KFxuICAgICAgZXh0ZW5zaW9uLFxuICAgICAgJ2FkZEF0dHJpYnV0ZXMnLFxuICAgICAgY29udGV4dCxcbiAgICApXG5cbiAgICBpZiAoIWFkZEF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSBgYXMgQXR0cmlidXRlc2BcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gYWRkQXR0cmlidXRlcygpIGFzIEF0dHJpYnV0ZXNcblxuICAgIE9iamVjdFxuICAgICAgLmVudHJpZXMoYXR0cmlidXRlcylcbiAgICAgIC5mb3JFYWNoKChbbmFtZSwgYXR0cmlidXRlXSkgPT4ge1xuICAgICAgICBjb25zdCBtZXJnZWRBdHRyID0ge1xuICAgICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGUsXG4gICAgICAgICAgLi4uYXR0cmlidXRlLFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXJnZWRBdHRyPy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbWVyZ2VkQXR0ci5kZWZhdWx0ID0gbWVyZ2VkQXR0ci5kZWZhdWx0KClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXJnZWRBdHRyPy5pc1JlcXVpcmVkICYmIG1lcmdlZEF0dHI/LmRlZmF1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZSBtZXJnZWRBdHRyLmRlZmF1bHRcbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBhdHRyaWJ1dGU6IG1lcmdlZEF0dHIsXG4gICAgICAgIH0pXG4gICAgICB9KVxuICB9KVxuXG4gIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGVzXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlVHlwZShuYW1lT3JUeXBlOiBzdHJpbmcgfCBOb2RlVHlwZSwgc2NoZW1hOiBTY2hlbWEpOiBOb2RlVHlwZSB7XG4gIGlmICh0eXBlb2YgbmFtZU9yVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIXNjaGVtYS5ub2Rlc1tuYW1lT3JUeXBlXSkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBUaGVyZSBpcyBubyBub2RlIHR5cGUgbmFtZWQgJyR7bmFtZU9yVHlwZX0nLiBNYXliZSB5b3UgZm9yZ290IHRvIGFkZCB0aGUgZXh0ZW5zaW9uP2AsXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYS5ub2Rlc1tuYW1lT3JUeXBlXVxuICB9XG5cbiAgcmV0dXJuIG5hbWVPclR5cGVcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gbWVyZ2VBdHRyaWJ1dGVzKC4uLm9iamVjdHM6IFJlY29yZDxzdHJpbmcsIGFueT5bXSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICByZXR1cm4gb2JqZWN0c1xuICAgIC5maWx0ZXIoaXRlbSA9PiAhIWl0ZW0pXG4gICAgLnJlZHVjZSgoaXRlbXMsIGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IG1lcmdlZEF0dHJpYnV0ZXMgPSB7IC4uLml0ZW1zIH1cblxuICAgICAgT2JqZWN0LmVudHJpZXMoaXRlbSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IG1lcmdlZEF0dHJpYnV0ZXNba2V5XVxuXG4gICAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gdmFsdWVcblxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlQ2xhc3Nlczogc3RyaW5nW10gPSB2YWx1ZSA/IHZhbHVlLnNwbGl0KCcgJykgOiBbXVxuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQ2xhc3Nlczogc3RyaW5nW10gPSBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPyBtZXJnZWRBdHRyaWJ1dGVzW2tleV0uc3BsaXQoJyAnKSA6IFtdXG5cbiAgICAgICAgICBjb25zdCBpbnNlcnRDbGFzc2VzID0gdmFsdWVDbGFzc2VzLmZpbHRlcihcbiAgICAgICAgICAgIHZhbHVlQ2xhc3MgPT4gIWV4aXN0aW5nQ2xhc3Nlcy5pbmNsdWRlcyh2YWx1ZUNsYXNzKSxcbiAgICAgICAgICApXG5cbiAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSBbLi4uZXhpc3RpbmdDbGFzc2VzLCAuLi5pbnNlcnRDbGFzc2VzXS5qb2luKCcgJylcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSBbbWVyZ2VkQXR0cmlidXRlc1trZXldLCB2YWx1ZV0uam9pbignOyAnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiBtZXJnZWRBdHRyaWJ1dGVzXG4gICAgfSwge30pXG59XG4iLCAiaW1wb3J0IHsgTWFyaywgTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEV4dGVuc2lvbkF0dHJpYnV0ZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vdXRpbGl0aWVzL21lcmdlQXR0cmlidXRlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbmRlcmVkQXR0cmlidXRlcyhcbiAgbm9kZU9yTWFyazogTm9kZSB8IE1hcmssXG4gIGV4dGVuc2lvbkF0dHJpYnV0ZXM6IEV4dGVuc2lvbkF0dHJpYnV0ZVtdLFxuKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGVzXG4gICAgLmZpbHRlcihpdGVtID0+IGl0ZW0uYXR0cmlidXRlLnJlbmRlcmVkKVxuICAgIC5tYXAoaXRlbSA9PiB7XG4gICAgICBpZiAoIWl0ZW0uYXR0cmlidXRlLnJlbmRlckhUTUwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBbaXRlbS5uYW1lXTogbm9kZU9yTWFyay5hdHRyc1tpdGVtLm5hbWVdLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtLmF0dHJpYnV0ZS5yZW5kZXJIVE1MKG5vZGVPck1hcmsuYXR0cnMpIHx8IHt9XG4gICAgfSlcbiAgICAucmVkdWNlKChhdHRyaWJ1dGVzLCBhdHRyaWJ1dGUpID0+IG1lcmdlQXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBhdHRyaWJ1dGUpLCB7fSlcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZTogYW55KTogdmFsdWUgaXMgRnVuY3Rpb24ge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nXG59XG4iLCAiaW1wb3J0IHsgTWF5YmVSZXR1cm5UeXBlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJ1xuXG4vKipcbiAqIE9wdGlvbmFsbHkgY2FsbHMgYHZhbHVlYCBhcyBhIGZ1bmN0aW9uLlxuICogT3RoZXJ3aXNlIGl0IGlzIHJldHVybmVkIGRpcmVjdGx5LlxuICogQHBhcmFtIHZhbHVlIEZ1bmN0aW9uIG9yIGFueSB2YWx1ZS5cbiAqIEBwYXJhbSBjb250ZXh0IE9wdGlvbmFsIGNvbnRleHQgdG8gYmluZCB0byBmdW5jdGlvbi5cbiAqIEBwYXJhbSBwcm9wcyBPcHRpb25hbCBwcm9wcyB0byBwYXNzIHRvIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsbE9yUmV0dXJuPFQ+KHZhbHVlOiBULCBjb250ZXh0OiBhbnkgPSB1bmRlZmluZWQsIC4uLnByb3BzOiBhbnlbXSk6IE1heWJlUmV0dXJuVHlwZTxUPiB7XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdmFsdWUuYmluZChjb250ZXh0KSguLi5wcm9wcylcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUoLi4ucHJvcHMpXG4gIH1cblxuICByZXR1cm4gdmFsdWUgYXMgTWF5YmVSZXR1cm5UeXBlPFQ+XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHlPYmplY3QodmFsdWUgPSB7fSk6IGJvb2xlYW4ge1xuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMCAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWU6IGFueSk6IGFueSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBpZiAodmFsdWUubWF0Y2goL15bKy1dPyg/OlxcZCpcXC4pP1xcZCskLykpIHtcbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdmFsdWVcbn1cbiIsICJpbXBvcnQgeyBQYXJzZVJ1bGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb25BdHRyaWJ1dGUgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGZyb21TdHJpbmcgfSBmcm9tICcuLi91dGlsaXRpZXMvZnJvbVN0cmluZy5qcydcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIG1lcmdlcyBleHRlbnNpb24gYXR0cmlidXRlcyBpbnRvIHBhcnNlcnVsZSBhdHRyaWJ1dGVzIChgYXR0cnNgIG9yIGBnZXRBdHRyc2ApLlxuICogQ2FuY2VscyB3aGVuIGBnZXRBdHRyc2AgcmV0dXJuZWQgYGZhbHNlYC5cbiAqIEBwYXJhbSBwYXJzZVJ1bGUgUHJvc2VNaXJyb3IgUGFyc2VSdWxlXG4gKiBAcGFyYW0gZXh0ZW5zaW9uQXR0cmlidXRlcyBMaXN0IG9mIGF0dHJpYnV0ZXMgdG8gaW5qZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUoXG4gIHBhcnNlUnVsZTogUGFyc2VSdWxlLFxuICBleHRlbnNpb25BdHRyaWJ1dGVzOiBFeHRlbnNpb25BdHRyaWJ1dGVbXSxcbik6IFBhcnNlUnVsZSB7XG4gIGlmIChwYXJzZVJ1bGUuc3R5bGUpIHtcbiAgICByZXR1cm4gcGFyc2VSdWxlXG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnBhcnNlUnVsZSxcbiAgICBnZXRBdHRyczogbm9kZSA9PiB7XG4gICAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0gcGFyc2VSdWxlLmdldEF0dHJzID8gcGFyc2VSdWxlLmdldEF0dHJzKG5vZGUpIDogcGFyc2VSdWxlLmF0dHJzXG5cbiAgICAgIGlmIChvbGRBdHRyaWJ1dGVzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IGV4dGVuc2lvbkF0dHJpYnV0ZXMucmVkdWNlKChpdGVtcywgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGl0ZW0uYXR0cmlidXRlLnBhcnNlSFRNTFxuICAgICAgICAgID8gaXRlbS5hdHRyaWJ1dGUucGFyc2VIVE1MKG5vZGUgYXMgSFRNTEVsZW1lbnQpXG4gICAgICAgICAgOiBmcm9tU3RyaW5nKChub2RlIGFzIEhUTUxFbGVtZW50KS5nZXRBdHRyaWJ1dGUoaXRlbS5uYW1lKSlcblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBpdGVtc1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5pdGVtcyxcbiAgICAgICAgICBbaXRlbS5uYW1lXTogdmFsdWUsXG4gICAgICAgIH1cbiAgICAgIH0sIHt9KVxuXG4gICAgICByZXR1cm4geyAuLi5vbGRBdHRyaWJ1dGVzLCAuLi5uZXdBdHRyaWJ1dGVzIH1cbiAgICB9LFxuICB9XG59XG4iLCAiaW1wb3J0IHsgTWFya1NwZWMsIE5vZGVTcGVjLCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBFZGl0b3IsIE1hcmtDb25maWcsIE5vZGVDb25maWcgfSBmcm9tICcuLi9pbmRleC5qcydcbmltcG9ydCB7IEFueUNvbmZpZywgRXh0ZW5zaW9ucyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcbmltcG9ydCB7IGlzRW1wdHlPYmplY3QgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNFbXB0eU9iamVjdC5qcydcbmltcG9ydCB7IGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyB9IGZyb20gJy4vZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zLmpzJ1xuaW1wb3J0IHsgZ2V0RXh0ZW5zaW9uRmllbGQgfSBmcm9tICcuL2dldEV4dGVuc2lvbkZpZWxkLmpzJ1xuaW1wb3J0IHsgZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzIH0gZnJvbSAnLi9nZXRSZW5kZXJlZEF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUgfSBmcm9tICcuL2luamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZS5qcydcbmltcG9ydCB7IHNwbGl0RXh0ZW5zaW9ucyB9IGZyb20gJy4vc3BsaXRFeHRlbnNpb25zLmpzJ1xuXG5mdW5jdGlvbiBjbGVhblVwU2NoZW1hSXRlbTxUPihkYXRhOiBUKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIE9iamVjdC5lbnRyaWVzKGRhdGEpLmZpbHRlcigoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAoa2V5ID09PSAnYXR0cnMnICYmIGlzRW1wdHlPYmplY3QodmFsdWUgYXMge30gfCB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZFxuICAgIH0pLFxuICApIGFzIFRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMsIGVkaXRvcj86IEVkaXRvcik6IFNjaGVtYSB7XG4gIGNvbnN0IGFsbEF0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMoZXh0ZW5zaW9ucylcbiAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucywgbWFya0V4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKVxuICBjb25zdCB0b3BOb2RlID0gbm9kZUV4dGVuc2lvbnMuZmluZChleHRlbnNpb24gPT4gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAndG9wTm9kZScpKT8ubmFtZVxuXG4gIGNvbnN0IG5vZGVzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIG5vZGVFeHRlbnNpb25zLm1hcChleHRlbnNpb24gPT4ge1xuICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGFsbEF0dHJpYnV0ZXMuZmlsdGVyKFxuICAgICAgICBhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLnR5cGUgPT09IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgKVxuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgZWRpdG9yLFxuICAgICAgfVxuXG4gICAgICBjb25zdCBleHRyYU5vZGVGaWVsZHMgPSBleHRlbnNpb25zLnJlZHVjZSgoZmllbGRzLCBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4dGVuZE5vZGVTY2hlbWEgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2V4dGVuZE5vZGVTY2hlbWEnXT4oXG4gICAgICAgICAgZSxcbiAgICAgICAgICAnZXh0ZW5kTm9kZVNjaGVtYScsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgIC4uLihleHRlbmROb2RlU2NoZW1hID8gZXh0ZW5kTm9kZVNjaGVtYShleHRlbnNpb24pIDoge30pLFxuICAgICAgICB9XG4gICAgICB9LCB7fSlcblxuICAgICAgY29uc3Qgc2NoZW1hOiBOb2RlU3BlYyA9IGNsZWFuVXBTY2hlbWFJdGVtKHtcbiAgICAgICAgLi4uZXh0cmFOb2RlRmllbGRzLFxuICAgICAgICBjb250ZW50OiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snY29udGVudCddPihleHRlbnNpb24sICdjb250ZW50JywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIG1hcmtzOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snbWFya3MnXT4oZXh0ZW5zaW9uLCAnbWFya3MnLCBjb250ZXh0KSksXG4gICAgICAgIGdyb3VwOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snZ3JvdXAnXT4oZXh0ZW5zaW9uLCAnZ3JvdXAnLCBjb250ZXh0KSksXG4gICAgICAgIGlubGluZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2lubGluZSddPihleHRlbnNpb24sICdpbmxpbmUnLCBjb250ZXh0KSksXG4gICAgICAgIGF0b206IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydhdG9tJ10+KGV4dGVuc2lvbiwgJ2F0b20nLCBjb250ZXh0KSksXG4gICAgICAgIHNlbGVjdGFibGU6IGNhbGxPclJldHVybihcbiAgICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydzZWxlY3RhYmxlJ10+KGV4dGVuc2lvbiwgJ3NlbGVjdGFibGUnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgZHJhZ2dhYmxlOiBjYWxsT3JSZXR1cm4oXG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snZHJhZ2dhYmxlJ10+KGV4dGVuc2lvbiwgJ2RyYWdnYWJsZScsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBjb2RlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snY29kZSddPihleHRlbnNpb24sICdjb2RlJywgY29udGV4dCkpLFxuICAgICAgICBkZWZpbmluZzogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2RlZmluaW5nJ10+KGV4dGVuc2lvbiwgJ2RlZmluaW5nJywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIGlzb2xhdGluZzogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2lzb2xhdGluZyddPihleHRlbnNpb24sICdpc29sYXRpbmcnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgYXR0cnM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLm1hcChleHRlbnNpb25BdHRyaWJ1dGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25BdHRyaWJ1dGUubmFtZSwgeyBkZWZhdWx0OiBleHRlbnNpb25BdHRyaWJ1dGU/LmF0dHJpYnV0ZT8uZGVmYXVsdCB9XVxuICAgICAgICAgIH0pLFxuICAgICAgICApLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgcGFyc2VIVE1MID0gY2FsbE9yUmV0dXJuKFxuICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydwYXJzZUhUTUwnXT4oZXh0ZW5zaW9uLCAncGFyc2VIVE1MJywgY29udGV4dCksXG4gICAgICApXG5cbiAgICAgIGlmIChwYXJzZUhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnBhcnNlRE9NID0gcGFyc2VIVE1MLm1hcChwYXJzZVJ1bGUgPT4gaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKHBhcnNlUnVsZSwgZXh0ZW5zaW9uQXR0cmlidXRlcykpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlbmRlckhUTUwgPSBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydyZW5kZXJIVE1MJ10+KFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICdyZW5kZXJIVE1MJyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcblxuICAgICAgaWYgKHJlbmRlckhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnRvRE9NID0gbm9kZSA9PiByZW5kZXJIVE1MKHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobm9kZSwgZXh0ZW5zaW9uQXR0cmlidXRlcyksXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlbmRlclRleHQgPSBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydyZW5kZXJUZXh0J10+KFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICdyZW5kZXJUZXh0JyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcblxuICAgICAgaWYgKHJlbmRlclRleHQpIHtcbiAgICAgICAgc2NoZW1hLnRvVGV4dCA9IHJlbmRlclRleHRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtleHRlbnNpb24ubmFtZSwgc2NoZW1hXVxuICAgIH0pLFxuICApXG5cbiAgY29uc3QgbWFya3MgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgbWFya0V4dGVuc2lvbnMubWFwKGV4dGVuc2lvbiA9PiB7XG4gICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gYWxsQXR0cmlidXRlcy5maWx0ZXIoXG4gICAgICAgIGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUsXG4gICAgICApXG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICBlZGl0b3IsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4dHJhTWFya0ZpZWxkcyA9IGV4dGVuc2lvbnMucmVkdWNlKChmaWVsZHMsIGUpID0+IHtcbiAgICAgICAgY29uc3QgZXh0ZW5kTWFya1NjaGVtYSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snZXh0ZW5kTWFya1NjaGVtYSddPihcbiAgICAgICAgICBlLFxuICAgICAgICAgICdleHRlbmRNYXJrU2NoZW1hJyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICApXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgLi4uKGV4dGVuZE1hcmtTY2hlbWEgPyBleHRlbmRNYXJrU2NoZW1hKGV4dGVuc2lvbikgOiB7fSksXG4gICAgICAgIH1cbiAgICAgIH0sIHt9KVxuXG4gICAgICBjb25zdCBzY2hlbWE6IE1hcmtTcGVjID0gY2xlYW5VcFNjaGVtYUl0ZW0oe1xuICAgICAgICAuLi5leHRyYU1hcmtGaWVsZHMsXG4gICAgICAgIGluY2x1c2l2ZTogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE1hcmtDb25maWdbJ2luY2x1c2l2ZSddPihleHRlbnNpb24sICdpbmNsdXNpdmUnLCBjb250ZXh0KSxcbiAgICAgICAgKSxcbiAgICAgICAgZXhjbHVkZXM6IGNhbGxPclJldHVybihcbiAgICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydleGNsdWRlcyddPihleHRlbnNpb24sICdleGNsdWRlcycsIGNvbnRleHQpLFxuICAgICAgICApLFxuICAgICAgICBncm91cDogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE1hcmtDb25maWdbJ2dyb3VwJ10+KGV4dGVuc2lvbiwgJ2dyb3VwJywgY29udGV4dCkpLFxuICAgICAgICBzcGFubmluZzogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE1hcmtDb25maWdbJ3NwYW5uaW5nJ10+KGV4dGVuc2lvbiwgJ3NwYW5uaW5nJywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIGNvZGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydjb2RlJ10+KGV4dGVuc2lvbiwgJ2NvZGUnLCBjb250ZXh0KSksXG4gICAgICAgIGF0dHJzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcy5tYXAoZXh0ZW5zaW9uQXR0cmlidXRlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uQXR0cmlidXRlLm5hbWUsIHsgZGVmYXVsdDogZXh0ZW5zaW9uQXR0cmlidXRlPy5hdHRyaWJ1dGU/LmRlZmF1bHQgfV1cbiAgICAgICAgICB9KSxcbiAgICAgICAgKSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHBhcnNlSFRNTCA9IGNhbGxPclJldHVybihcbiAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1sncGFyc2VIVE1MJ10+KGV4dGVuc2lvbiwgJ3BhcnNlSFRNTCcsIGNvbnRleHQpLFxuICAgICAgKVxuXG4gICAgICBpZiAocGFyc2VIVE1MKSB7XG4gICAgICAgIHNjaGVtYS5wYXJzZURPTSA9IHBhcnNlSFRNTC5tYXAocGFyc2VSdWxlID0+IGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZShwYXJzZVJ1bGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZW5kZXJIVE1MID0gZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1sncmVuZGVySFRNTCddPihcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAncmVuZGVySFRNTCcsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApXG5cbiAgICAgIGlmIChyZW5kZXJIVE1MKSB7XG4gICAgICAgIHNjaGVtYS50b0RPTSA9IG1hcmsgPT4gcmVuZGVySFRNTCh7XG4gICAgICAgICAgbWFyayxcbiAgICAgICAgICBIVE1MQXR0cmlidXRlczogZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG1hcmssIGV4dGVuc2lvbkF0dHJpYnV0ZXMpLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2V4dGVuc2lvbi5uYW1lLCBzY2hlbWFdXG4gICAgfSksXG4gIClcblxuICByZXR1cm4gbmV3IFNjaGVtYSh7XG4gICAgdG9wTm9kZSxcbiAgICBub2RlcyxcbiAgICBtYXJrcyxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSwgTm9kZVR5cGUsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2hlbWFUeXBlQnlOYW1lKG5hbWU6IHN0cmluZywgc2NoZW1hOiBTY2hlbWEpOiBOb2RlVHlwZSB8IE1hcmtUeXBlIHwgbnVsbCB7XG4gIHJldHVybiBzY2hlbWEubm9kZXNbbmFtZV0gfHwgc2NoZW1hLm1hcmtzW25hbWVdIHx8IG51bGxcbn1cbiIsICJpbXBvcnQgeyBBbnlFeHRlbnNpb24sIEVuYWJsZVJ1bGVzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZChleHRlbnNpb246IEFueUV4dGVuc2lvbiwgZW5hYmxlZDogRW5hYmxlUnVsZXMpOiBib29sZWFuIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZW5hYmxlZCkpIHtcbiAgICByZXR1cm4gZW5hYmxlZC5zb21lKGVuYWJsZWRFeHRlbnNpb24gPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IHR5cGVvZiBlbmFibGVkRXh0ZW5zaW9uID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGVuYWJsZWRFeHRlbnNpb25cbiAgICAgICAgOiBlbmFibGVkRXh0ZW5zaW9uLm5hbWVcblxuICAgICAgcmV0dXJuIG5hbWUgPT09IGV4dGVuc2lvbi5uYW1lXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBlbmFibGVkXG59XG4iLCAiaW1wb3J0IHsgUmVzb2x2ZWRQb3MgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgY29uc3QgZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMgPSAoJGZyb206IFJlc29sdmVkUG9zLCBtYXhNYXRjaCA9IDUwMCkgPT4ge1xuICBsZXQgdGV4dEJlZm9yZSA9ICcnXG5cbiAgY29uc3Qgc2xpY2VFbmRQb3MgPSAkZnJvbS5wYXJlbnRPZmZzZXRcblxuICAkZnJvbS5wYXJlbnQubm9kZXNCZXR3ZWVuKFxuICAgIE1hdGgubWF4KDAsIHNsaWNlRW5kUG9zIC0gbWF4TWF0Y2gpLFxuICAgIHNsaWNlRW5kUG9zLFxuICAgIChub2RlLCBwb3MsIHBhcmVudCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNodW5rID0gbm9kZS50eXBlLnNwZWMudG9UZXh0Py4oe1xuICAgICAgICBub2RlLFxuICAgICAgICBwb3MsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9KVxuICAgICAgICB8fCBub2RlLnRleHRDb250ZW50XG4gICAgICAgIHx8ICclbGVhZiUnXG5cbiAgICAgIHRleHRCZWZvcmUgKz0gY2h1bmsuc2xpY2UoMCwgTWF0aC5tYXgoMCwgc2xpY2VFbmRQb3MgLSBwb3MpKVxuICAgIH0sXG4gIClcblxuICByZXR1cm4gdGV4dEJlZm9yZVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZTogYW55KTogdmFsdWUgaXMgUmVnRXhwIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUsIFBsdWdpbiwgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IENvbW1hbmRNYW5hZ2VyIH0gZnJvbSAnLi9Db21tYW5kTWFuYWdlci5qcydcbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgY3JlYXRlQ2hhaW5hYmxlU3RhdGUgfSBmcm9tICcuL2hlbHBlcnMvY3JlYXRlQ2hhaW5hYmxlU3RhdGUuanMnXG5pbXBvcnQgeyBnZXRUZXh0Q29udGVudEZyb21Ob2RlcyB9IGZyb20gJy4vaGVscGVycy9nZXRUZXh0Q29udGVudEZyb21Ob2Rlcy5qcydcbmltcG9ydCB7XG4gIENhbkNvbW1hbmRzLFxuICBDaGFpbmVkQ29tbWFuZHMsXG4gIEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSxcbiAgUmFuZ2UsXG4gIFNpbmdsZUNvbW1hbmRzLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgaXNSZWdFeHAgfSBmcm9tICcuL3V0aWxpdGllcy9pc1JlZ0V4cC5qcydcblxuZXhwb3J0IHR5cGUgSW5wdXRSdWxlTWF0Y2ggPSB7XG4gIGluZGV4OiBudW1iZXJcbiAgdGV4dDogc3RyaW5nXG4gIHJlcGxhY2VXaXRoPzogc3RyaW5nXG4gIG1hdGNoPzogUmVnRXhwTWF0Y2hBcnJheVxuICBkYXRhPzogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG5leHBvcnQgdHlwZSBJbnB1dFJ1bGVGaW5kZXIgPSBSZWdFeHAgfCAoKHRleHQ6IHN0cmluZykgPT4gSW5wdXRSdWxlTWF0Y2ggfCBudWxsKVxuXG5leHBvcnQgY2xhc3MgSW5wdXRSdWxlIHtcbiAgZmluZDogSW5wdXRSdWxlRmluZGVyXG5cbiAgaGFuZGxlcjogKHByb3BzOiB7XG4gICAgc3RhdGU6IEVkaXRvclN0YXRlXG4gICAgcmFuZ2U6IFJhbmdlXG4gICAgbWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheVxuICAgIGNvbW1hbmRzOiBTaW5nbGVDb21tYW5kc1xuICAgIGNoYWluOiAoKSA9PiBDaGFpbmVkQ29tbWFuZHNcbiAgICBjYW46ICgpID0+IENhbkNvbW1hbmRzXG4gIH0pID0+IHZvaWQgfCBudWxsXG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiB7XG4gICAgZmluZDogSW5wdXRSdWxlRmluZGVyXG4gICAgaGFuZGxlcjogKHByb3BzOiB7XG4gICAgICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgICAgIHJhbmdlOiBSYW5nZVxuICAgICAgbWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheVxuICAgICAgY29tbWFuZHM6IFNpbmdsZUNvbW1hbmRzXG4gICAgICBjaGFpbjogKCkgPT4gQ2hhaW5lZENvbW1hbmRzXG4gICAgICBjYW46ICgpID0+IENhbkNvbW1hbmRzXG4gICAgfSkgPT4gdm9pZCB8IG51bGxcbiAgfSkge1xuICAgIHRoaXMuZmluZCA9IGNvbmZpZy5maW5kXG4gICAgdGhpcy5oYW5kbGVyID0gY29uZmlnLmhhbmRsZXJcbiAgfVxufVxuXG5jb25zdCBpbnB1dFJ1bGVNYXRjaGVySGFuZGxlciA9IChcbiAgdGV4dDogc3RyaW5nLFxuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXIsXG4pOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkgfCBudWxsID0+IHtcbiAgaWYgKGlzUmVnRXhwKGZpbmQpKSB7XG4gICAgcmV0dXJuIGZpbmQuZXhlYyh0ZXh0KVxuICB9XG5cbiAgY29uc3QgaW5wdXRSdWxlTWF0Y2ggPSBmaW5kKHRleHQpXG5cbiAgaWYgKCFpbnB1dFJ1bGVNYXRjaCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCByZXN1bHQ6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSA9IFtpbnB1dFJ1bGVNYXRjaC50ZXh0XVxuXG4gIHJlc3VsdC5pbmRleCA9IGlucHV0UnVsZU1hdGNoLmluZGV4XG4gIHJlc3VsdC5pbnB1dCA9IHRleHRcbiAgcmVzdWx0LmRhdGEgPSBpbnB1dFJ1bGVNYXRjaC5kYXRhXG5cbiAgaWYgKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKSB7XG4gICAgaWYgKCFpbnB1dFJ1bGVNYXRjaC50ZXh0LmluY2x1ZGVzKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnW3RpcHRhcCB3YXJuXTogXCJpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aFwiIG11c3QgYmUgcGFydCBvZiBcImlucHV0UnVsZU1hdGNoLnRleHRcIi4nLFxuICAgICAgKVxuICAgIH1cblxuICAgIHJlc3VsdC5wdXNoKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBydW4oY29uZmlnOiB7XG4gIGVkaXRvcjogRWRpdG9yXG4gIGZyb206IG51bWJlclxuICB0bzogbnVtYmVyXG4gIHRleHQ6IHN0cmluZ1xuICBydWxlczogSW5wdXRSdWxlW11cbiAgcGx1Z2luOiBQbHVnaW5cbn0pOiBib29sZWFuIHtcbiAgY29uc3Qge1xuICAgIGVkaXRvciwgZnJvbSwgdG8sIHRleHQsIHJ1bGVzLCBwbHVnaW4sXG4gIH0gPSBjb25maWdcbiAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3JcblxuICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0ICRmcm9tID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShmcm9tKVxuXG4gIGlmIChcbiAgICAvLyBjaGVjayBmb3IgY29kZSBub2RlXG4gICAgJGZyb20ucGFyZW50LnR5cGUuc3BlYy5jb2RlXG4gICAgLy8gY2hlY2sgZm9yIGNvZGUgbWFya1xuICAgIHx8ICEhKCRmcm9tLm5vZGVCZWZvcmUgfHwgJGZyb20ubm9kZUFmdGVyKT8ubWFya3MuZmluZChtYXJrID0+IG1hcmsudHlwZS5zcGVjLmNvZGUpXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgbGV0IG1hdGNoZWQgPSBmYWxzZVxuXG4gIGNvbnN0IHRleHRCZWZvcmUgPSBnZXRUZXh0Q29udGVudEZyb21Ob2RlcygkZnJvbSkgKyB0ZXh0XG5cbiAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgbWF0Y2ggPSBpbnB1dFJ1bGVNYXRjaGVySGFuZGxlcih0ZXh0QmVmb3JlLCBydWxlLmZpbmQpXG5cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB0ciA9IHZpZXcuc3RhdGUudHJcbiAgICBjb25zdCBzdGF0ZSA9IGNyZWF0ZUNoYWluYWJsZVN0YXRlKHtcbiAgICAgIHN0YXRlOiB2aWV3LnN0YXRlLFxuICAgICAgdHJhbnNhY3Rpb246IHRyLFxuICAgIH0pXG4gICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICBmcm9tOiBmcm9tIC0gKG1hdGNoWzBdLmxlbmd0aCAtIHRleHQubGVuZ3RoKSxcbiAgICAgIHRvLFxuICAgIH1cblxuICAgIGNvbnN0IHsgY29tbWFuZHMsIGNoYWluLCBjYW4gfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgICBlZGl0b3IsXG4gICAgICBzdGF0ZSxcbiAgICB9KVxuXG4gICAgY29uc3QgaGFuZGxlciA9IHJ1bGUuaGFuZGxlcih7XG4gICAgICBzdGF0ZSxcbiAgICAgIHJhbmdlLFxuICAgICAgbWF0Y2gsXG4gICAgICBjb21tYW5kcyxcbiAgICAgIGNoYWluLFxuICAgICAgY2FuLFxuICAgIH0pXG5cbiAgICAvLyBzdG9wIGlmIHRoZXJlIGFyZSBubyBjaGFuZ2VzXG4gICAgaWYgKGhhbmRsZXIgPT09IG51bGwgfHwgIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gc3RvcmUgdHJhbnNmb3JtIGFzIG1ldGEgZGF0YVxuICAgIC8vIHNvIHdlIGNhbiB1bmRvIGlucHV0IHJ1bGVzIHdpdGhpbiB0aGUgYHVuZG9JbnB1dFJ1bGVzYCBjb21tYW5kXG4gICAgdHIuc2V0TWV0YShwbHVnaW4sIHtcbiAgICAgIHRyYW5zZm9ybTogdHIsXG4gICAgICBmcm9tLFxuICAgICAgdG8sXG4gICAgICB0ZXh0LFxuICAgIH0pXG5cbiAgICB2aWV3LmRpc3BhdGNoKHRyKVxuICAgIG1hdGNoZWQgPSB0cnVlXG4gIH0pXG5cbiAgcmV0dXJuIG1hdGNoZWRcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5wdXQgcnVsZXMgcGx1Z2luLiBXaGVuIGVuYWJsZWQsIGl0IHdpbGwgY2F1c2UgdGV4dFxuICogaW5wdXQgdGhhdCBtYXRjaGVzIGFueSBvZiB0aGUgZ2l2ZW4gcnVsZXMgdG8gdHJpZ2dlciB0aGUgcnVsZeKAmXNcbiAqIGFjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlucHV0UnVsZXNQbHVnaW4ocHJvcHM6IHsgZWRpdG9yOiBFZGl0b3I7IHJ1bGVzOiBJbnB1dFJ1bGVbXSB9KTogUGx1Z2luIHtcbiAgY29uc3QgeyBlZGl0b3IsIHJ1bGVzIH0gPSBwcm9wc1xuICBjb25zdCBwbHVnaW4gPSBuZXcgUGx1Z2luKHtcbiAgICBzdGF0ZToge1xuICAgICAgaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH0sXG4gICAgICBhcHBseSh0ciwgcHJldikge1xuICAgICAgICBjb25zdCBzdG9yZWQgPSB0ci5nZXRNZXRhKHBsdWdpbilcblxuICAgICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHN0b3JlZFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyLnNlbGVjdGlvblNldCB8fCB0ci5kb2NDaGFuZ2VkID8gbnVsbCA6IHByZXZcbiAgICAgIH0sXG4gICAgfSxcblxuICAgIHByb3BzOiB7XG4gICAgICBoYW5kbGVUZXh0SW5wdXQodmlldywgZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJ1bih7XG4gICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgIGZyb20sXG4gICAgICAgICAgdG8sXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgICBydWxlcyxcbiAgICAgICAgICBwbHVnaW4sXG4gICAgICAgIH0pXG4gICAgICB9LFxuXG4gICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgY29tcG9zaXRpb25lbmQ6IHZpZXcgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyAkY3Vyc29yIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiBhcyBUZXh0U2VsZWN0aW9uXG5cbiAgICAgICAgICAgIGlmICgkY3Vyc29yKSB7XG4gICAgICAgICAgICAgIHJ1bih7XG4gICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgIGZyb206ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgICAgIHRvOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICBydWxlcyxcbiAgICAgICAgICAgICAgICBwbHVnaW4sXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgfSxcblxuICAgICAgLy8gYWRkIHN1cHBvcnQgZm9yIGlucHV0IHJ1bGVzIHRvIHRyaWdnZXIgb24gZW50ZXJcbiAgICAgIC8vIHRoaXMgaXMgdXNlZnVsIGZvciBleGFtcGxlIGZvciBjb2RlIGJsb2Nrc1xuICAgICAgaGFuZGxlS2V5RG93bih2aWV3LCBldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5ICE9PSAnRW50ZXInKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7ICRjdXJzb3IgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uIGFzIFRleHRTZWxlY3Rpb25cblxuICAgICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICAgIHJldHVybiBydW4oe1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgZnJvbTogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICB0bzogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICB0ZXh0OiAnXFxuJyxcbiAgICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgICAgcGx1Z2luLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0sXG4gICAgfSxcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpc0lucHV0UnVsZXM6IHRydWUsXG4gIH0pIGFzIFBsdWdpblxuXG4gIHJldHVybiBwbHVnaW5cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWU6IGFueSk6IHZhbHVlIGlzIG51bWJlciB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUsIFBsdWdpbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IENvbW1hbmRNYW5hZ2VyIH0gZnJvbSAnLi9Db21tYW5kTWFuYWdlci5qcydcbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgY3JlYXRlQ2hhaW5hYmxlU3RhdGUgfSBmcm9tICcuL2hlbHBlcnMvY3JlYXRlQ2hhaW5hYmxlU3RhdGUuanMnXG5pbXBvcnQge1xuICBDYW5Db21tYW5kcyxcbiAgQ2hhaW5lZENvbW1hbmRzLFxuICBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXksXG4gIFJhbmdlLFxuICBTaW5nbGVDb21tYW5kcyxcbn0gZnJvbSAnLi90eXBlcy5qcydcbmltcG9ydCB7IGlzTnVtYmVyIH0gZnJvbSAnLi91dGlsaXRpZXMvaXNOdW1iZXIuanMnXG5pbXBvcnQgeyBpc1JlZ0V4cCB9IGZyb20gJy4vdXRpbGl0aWVzL2lzUmVnRXhwLmpzJ1xuXG5leHBvcnQgdHlwZSBQYXN0ZVJ1bGVNYXRjaCA9IHtcbiAgaW5kZXg6IG51bWJlclxuICB0ZXh0OiBzdHJpbmdcbiAgcmVwbGFjZVdpdGg/OiBzdHJpbmdcbiAgbWF0Y2g/OiBSZWdFeHBNYXRjaEFycmF5XG4gIGRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG59XG5cbmV4cG9ydCB0eXBlIFBhc3RlUnVsZUZpbmRlciA9IFJlZ0V4cCB8ICgodGV4dDogc3RyaW5nLCBldmVudD86IENsaXBib2FyZEV2ZW50IHwgbnVsbCkgPT4gUGFzdGVSdWxlTWF0Y2hbXSB8IG51bGwgfCB1bmRlZmluZWQpXG5cbmV4cG9ydCBjbGFzcyBQYXN0ZVJ1bGUge1xuICBmaW5kOiBQYXN0ZVJ1bGVGaW5kZXJcblxuICBoYW5kbGVyOiAocHJvcHM6IHtcbiAgICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgICByYW5nZTogUmFuZ2VcbiAgICBtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5XG4gICAgY29tbWFuZHM6IFNpbmdsZUNvbW1hbmRzXG4gICAgY2hhaW46ICgpID0+IENoYWluZWRDb21tYW5kc1xuICAgIGNhbjogKCkgPT4gQ2FuQ29tbWFuZHNcbiAgICBwYXN0ZUV2ZW50OiBDbGlwYm9hcmRFdmVudCB8IG51bGxcbiAgICBkcm9wRXZlbnQ6IERyYWdFdmVudCB8IG51bGxcbiAgfSkgPT4gdm9pZCB8IG51bGxcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IHtcbiAgICBmaW5kOiBQYXN0ZVJ1bGVGaW5kZXJcbiAgICBoYW5kbGVyOiAocHJvcHM6IHtcbiAgICAgIGNhbjogKCkgPT4gQ2FuQ29tbWFuZHNcbiAgICAgIGNoYWluOiAoKSA9PiBDaGFpbmVkQ29tbWFuZHNcbiAgICAgIGNvbW1hbmRzOiBTaW5nbGVDb21tYW5kc1xuICAgICAgZHJvcEV2ZW50OiBEcmFnRXZlbnQgfCBudWxsXG4gICAgICBtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5XG4gICAgICBwYXN0ZUV2ZW50OiBDbGlwYm9hcmRFdmVudCB8IG51bGxcbiAgICAgIHJhbmdlOiBSYW5nZVxuICAgICAgc3RhdGU6IEVkaXRvclN0YXRlXG4gICAgfSkgPT4gdm9pZCB8IG51bGxcbiAgfSkge1xuICAgIHRoaXMuZmluZCA9IGNvbmZpZy5maW5kXG4gICAgdGhpcy5oYW5kbGVyID0gY29uZmlnLmhhbmRsZXJcbiAgfVxufVxuXG5jb25zdCBwYXN0ZVJ1bGVNYXRjaGVySGFuZGxlciA9IChcbiAgdGV4dDogc3RyaW5nLFxuICBmaW5kOiBQYXN0ZVJ1bGVGaW5kZXIsXG4gIGV2ZW50PzogQ2xpcGJvYXJkRXZlbnQgfCBudWxsLFxuKTogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5W10gPT4ge1xuICBpZiAoaXNSZWdFeHAoZmluZCkpIHtcbiAgICByZXR1cm4gWy4uLnRleHQubWF0Y2hBbGwoZmluZCldXG4gIH1cblxuICBjb25zdCBtYXRjaGVzID0gZmluZCh0ZXh0LCBldmVudClcblxuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzLm1hcChwYXN0ZVJ1bGVNYXRjaCA9PiB7XG4gICAgY29uc3QgcmVzdWx0OiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkgPSBbcGFzdGVSdWxlTWF0Y2gudGV4dF1cblxuICAgIHJlc3VsdC5pbmRleCA9IHBhc3RlUnVsZU1hdGNoLmluZGV4XG4gICAgcmVzdWx0LmlucHV0ID0gdGV4dFxuICAgIHJlc3VsdC5kYXRhID0gcGFzdGVSdWxlTWF0Y2guZGF0YVxuXG4gICAgaWYgKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKSB7XG4gICAgICBpZiAoIXBhc3RlUnVsZU1hdGNoLnRleHQuaW5jbHVkZXMocGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnW3RpcHRhcCB3YXJuXTogXCJwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aFwiIG11c3QgYmUgcGFydCBvZiBcInBhc3RlUnVsZU1hdGNoLnRleHRcIi4nLFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5wdXNoKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfSlcbn1cblxuZnVuY3Rpb24gcnVuKGNvbmZpZzoge1xuICBlZGl0b3I6IEVkaXRvclxuICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgZnJvbTogbnVtYmVyXG4gIHRvOiBudW1iZXJcbiAgcnVsZTogUGFzdGVSdWxlXG4gIHBhc3RlRXZlbnQ6IENsaXBib2FyZEV2ZW50IHwgbnVsbFxuICBkcm9wRXZlbnQ6IERyYWdFdmVudCB8IG51bGxcbn0pOiBib29sZWFuIHtcbiAgY29uc3Qge1xuICAgIGVkaXRvciwgc3RhdGUsIGZyb20sIHRvLCBydWxlLCBwYXN0ZUV2ZW50LCBkcm9wRXZlbnQsXG4gIH0gPSBjb25maWdcblxuICBjb25zdCB7IGNvbW1hbmRzLCBjaGFpbiwgY2FuIH0gPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgIGVkaXRvcixcbiAgICBzdGF0ZSxcbiAgfSlcblxuICBjb25zdCBoYW5kbGVyczogKHZvaWQgfCBudWxsKVtdID0gW11cblxuICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgaWYgKCFub2RlLmlzVGV4dGJsb2NrIHx8IG5vZGUudHlwZS5zcGVjLmNvZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlc29sdmVkRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcylcbiAgICBjb25zdCByZXNvbHZlZFRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUuY29udGVudC5zaXplKVxuICAgIGNvbnN0IHRleHRUb01hdGNoID0gbm9kZS50ZXh0QmV0d2VlbihyZXNvbHZlZEZyb20gLSBwb3MsIHJlc29sdmVkVG8gLSBwb3MsIHVuZGVmaW5lZCwgJ1xcdWZmZmMnKVxuXG4gICAgY29uc3QgbWF0Y2hlcyA9IHBhc3RlUnVsZU1hdGNoZXJIYW5kbGVyKHRleHRUb01hdGNoLCBydWxlLmZpbmQsIHBhc3RlRXZlbnQpXG5cbiAgICBtYXRjaGVzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXJ0ID0gcmVzb2x2ZWRGcm9tICsgbWF0Y2guaW5kZXggKyAxXG4gICAgICBjb25zdCBlbmQgPSBzdGFydCArIG1hdGNoWzBdLmxlbmd0aFxuICAgICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICAgIGZyb206IHN0YXRlLnRyLm1hcHBpbmcubWFwKHN0YXJ0KSxcbiAgICAgICAgdG86IHN0YXRlLnRyLm1hcHBpbmcubWFwKGVuZCksXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcmFuZ2UsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgY2hhaW4sXG4gICAgICAgIGNhbixcbiAgICAgICAgcGFzdGVFdmVudCxcbiAgICAgICAgZHJvcEV2ZW50LFxuICAgICAgfSlcblxuICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKVxuICAgIH0pXG4gIH0pXG5cbiAgY29uc3Qgc3VjY2VzcyA9IGhhbmRsZXJzLmV2ZXJ5KGhhbmRsZXIgPT4gaGFuZGxlciAhPT0gbnVsbClcblxuICByZXR1cm4gc3VjY2Vzc1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBwYXN0ZSBydWxlcyBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgaXQgd2lsbCBjYXVzZSBwYXN0ZWRcbiAqIHRleHQgdGhhdCBtYXRjaGVzIGFueSBvZiB0aGUgZ2l2ZW4gcnVsZXMgdG8gdHJpZ2dlciB0aGUgcnVsZeKAmXNcbiAqIGFjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhc3RlUnVsZXNQbHVnaW4ocHJvcHM6IHsgZWRpdG9yOiBFZGl0b3I7IHJ1bGVzOiBQYXN0ZVJ1bGVbXSB9KTogUGx1Z2luW10ge1xuICBjb25zdCB7IGVkaXRvciwgcnVsZXMgfSA9IHByb3BzXG4gIGxldCBkcmFnU291cmNlRWxlbWVudDogRWxlbWVudCB8IG51bGwgPSBudWxsXG4gIGxldCBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9IGZhbHNlXG4gIGxldCBpc0Ryb3BwZWRGcm9tUHJvc2VNaXJyb3IgPSBmYWxzZVxuICBsZXQgcGFzdGVFdmVudCA9IHR5cGVvZiBDbGlwYm9hcmRFdmVudCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJykgOiBudWxsXG4gIGxldCBkcm9wRXZlbnQgPSB0eXBlb2YgRHJhZ0V2ZW50ICE9PSAndW5kZWZpbmVkJyA/IG5ldyBEcmFnRXZlbnQoJ2Ryb3AnKSA6IG51bGxcblxuICBjb25zdCBwbHVnaW5zID0gcnVsZXMubWFwKHJ1bGUgPT4ge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgIC8vIHdlIHJlZ2lzdGVyIGEgZ2xvYmFsIGRyYWcgaGFuZGxlciB0byB0cmFjayB0aGUgY3VycmVudCBkcmFnIHNvdXJjZSBlbGVtZW50XG4gICAgICB2aWV3KHZpZXcpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlRHJhZ3N0YXJ0ID0gKGV2ZW50OiBEcmFnRXZlbnQpID0+IHtcbiAgICAgICAgICBkcmFnU291cmNlRWxlbWVudCA9IHZpZXcuZG9tLnBhcmVudEVsZW1lbnQ/LmNvbnRhaW5zKGV2ZW50LnRhcmdldCBhcyBFbGVtZW50KVxuICAgICAgICAgICAgPyB2aWV3LmRvbS5wYXJlbnRFbGVtZW50XG4gICAgICAgICAgICA6IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBoYW5kbGVEcmFnc3RhcnQpXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkZXN0cm95KCkge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIGhhbmRsZURyYWdzdGFydClcbiAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICBkcm9wOiAodmlldywgZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpc0Ryb3BwZWRGcm9tUHJvc2VNaXJyb3IgPSBkcmFnU291cmNlRWxlbWVudCA9PT0gdmlldy5kb20ucGFyZW50RWxlbWVudFxuICAgICAgICAgICAgZHJvcEV2ZW50ID0gZXZlbnQgYXMgRHJhZ0V2ZW50XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBwYXN0ZTogKF92aWV3LCBldmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSAoZXZlbnQgYXMgQ2xpcGJvYXJkRXZlbnQpLmNsaXBib2FyZERhdGE/LmdldERhdGEoJ3RleHQvaHRtbCcpXG5cbiAgICAgICAgICAgIHBhc3RlRXZlbnQgPSBldmVudCBhcyBDbGlwYm9hcmRFdmVudFxuXG4gICAgICAgICAgICBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9ICEhaHRtbD8uaW5jbHVkZXMoJ2RhdGEtcG0tc2xpY2UnKVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcblxuICAgICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uc1swXVxuICAgICAgICBjb25zdCBpc1Bhc3RlID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgndWlFdmVudCcpID09PSAncGFzdGUnICYmICFpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvclxuICAgICAgICBjb25zdCBpc0Ryb3AgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCd1aUV2ZW50JykgPT09ICdkcm9wJyAmJiAhaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yXG5cbiAgICAgICAgaWYgKCFpc1Bhc3RlICYmICFpc0Ryb3ApIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0b3AgaWYgdGhlcmUgaXMgbm8gY2hhbmdlZCByYW5nZVxuICAgICAgICBjb25zdCBmcm9tID0gb2xkU3RhdGUuZG9jLmNvbnRlbnQuZmluZERpZmZTdGFydChzdGF0ZS5kb2MuY29udGVudClcbiAgICAgICAgY29uc3QgdG8gPSBvbGRTdGF0ZS5kb2MuY29udGVudC5maW5kRGlmZkVuZChzdGF0ZS5kb2MuY29udGVudClcblxuICAgICAgICBpZiAoIWlzTnVtYmVyKGZyb20pIHx8ICF0byB8fCBmcm9tID09PSB0by5iKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBidWlsZCBhIGNoYWluYWJsZSBzdGF0ZVxuICAgICAgICAvLyBzbyB3ZSBjYW4gdXNlIGEgc2luZ2xlIHRyYW5zYWN0aW9uIGZvciBhbGwgcGFzdGUgcnVsZXNcbiAgICAgICAgY29uc3QgdHIgPSBzdGF0ZS50clxuICAgICAgICBjb25zdCBjaGFpbmFibGVTdGF0ZSA9IGNyZWF0ZUNoYWluYWJsZVN0YXRlKHtcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHJ1bih7XG4gICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgIHN0YXRlOiBjaGFpbmFibGVTdGF0ZSxcbiAgICAgICAgICBmcm9tOiBNYXRoLm1heChmcm9tIC0gMSwgMCksXG4gICAgICAgICAgdG86IHRvLmIgLSAxLFxuICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgcGFzdGVFdmVudCxcbiAgICAgICAgICBkcm9wRXZlbnQsXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gc3RvcCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlc1xuICAgICAgICBpZiAoIWhhbmRsZXIgfHwgIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgZHJvcEV2ZW50ID0gdHlwZW9mIERyYWdFdmVudCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgRHJhZ0V2ZW50KCdkcm9wJykgOiBudWxsXG4gICAgICAgIHBhc3RlRXZlbnQgPSB0eXBlb2YgQ2xpcGJvYXJkRXZlbnQgIT09ICd1bmRlZmluZWQnID8gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScpIDogbnVsbFxuXG4gICAgICAgIHJldHVybiB0clxuICAgICAgfSxcbiAgICB9KVxuICB9KVxuXG4gIHJldHVybiBwbHVnaW5zXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGZpbmREdXBsaWNhdGVzKGl0ZW1zOiBhbnlbXSk6IGFueVtdIHtcbiAgY29uc3QgZmlsdGVyZWQgPSBpdGVtcy5maWx0ZXIoKGVsLCBpbmRleCkgPT4gaXRlbXMuaW5kZXhPZihlbCkgIT09IGluZGV4KVxuXG4gIHJldHVybiBbLi4ubmV3IFNldChmaWx0ZXJlZCldXG59XG4iLCAiaW1wb3J0IHsga2V5bWFwIH0gZnJvbSAnQHRpcHRhcC9wbS9rZXltYXAnXG5pbXBvcnQgeyBOb2RlIGFzIFByb3NlbWlycm9yTm9kZSwgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBEZWNvcmF0aW9uLCBFZGl0b3JWaWV3IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3J1xuXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyB9IGZyb20gJy4vaGVscGVycy9nZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vaGVscGVycy9nZXRFeHRlbnNpb25GaWVsZC5qcydcbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzIH0gZnJvbSAnLi9oZWxwZXJzL2dldFJlbmRlcmVkQXR0cmlidXRlcy5qcydcbmltcG9ydCB7IGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zIH0gZnJvbSAnLi9oZWxwZXJzL2dldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zLmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hVHlwZUJ5TmFtZSB9IGZyb20gJy4vaGVscGVycy9nZXRTY2hlbWFUeXBlQnlOYW1lLmpzJ1xuaW1wb3J0IHsgaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQgfSBmcm9tICcuL2hlbHBlcnMvaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQuanMnXG5pbXBvcnQgeyBzcGxpdEV4dGVuc2lvbnMgfSBmcm9tICcuL2hlbHBlcnMvc3BsaXRFeHRlbnNpb25zLmpzJ1xuaW1wb3J0IHsgTWFyaywgTm9kZUNvbmZpZyB9IGZyb20gJy4vaW5kZXguanMnXG5pbXBvcnQgeyBpbnB1dFJ1bGVzUGx1Z2luIH0gZnJvbSAnLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBwYXN0ZVJ1bGVzUGx1Z2luIH0gZnJvbSAnLi9QYXN0ZVJ1bGUuanMnXG5pbXBvcnQgeyBBbnlDb25maWcsIEV4dGVuc2lvbnMsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcbmltcG9ydCB7IGZpbmREdXBsaWNhdGVzIH0gZnJvbSAnLi91dGlsaXRpZXMvZmluZER1cGxpY2F0ZXMuanMnXG5cbmV4cG9ydCBjbGFzcyBFeHRlbnNpb25NYW5hZ2VyIHtcbiAgZWRpdG9yOiBFZGl0b3JcblxuICBzY2hlbWE6IFNjaGVtYVxuXG4gIGV4dGVuc2lvbnM6IEV4dGVuc2lvbnNcblxuICBzcGxpdHRhYmxlTWFya3M6IHN0cmluZ1tdID0gW11cblxuICBjb25zdHJ1Y3RvcihleHRlbnNpb25zOiBFeHRlbnNpb25zLCBlZGl0b3I6IEVkaXRvcikge1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yXG4gICAgdGhpcy5leHRlbnNpb25zID0gRXh0ZW5zaW9uTWFuYWdlci5yZXNvbHZlKGV4dGVuc2lvbnMpXG4gICAgdGhpcy5zY2hlbWEgPSBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyh0aGlzLmV4dGVuc2lvbnMsIGVkaXRvcilcblxuICAgIHRoaXMuZXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiB7XG4gICAgICAvLyBzdG9yZSBleHRlbnNpb24gc3RvcmFnZSBpbiBlZGl0b3JcbiAgICAgIHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2VbZXh0ZW5zaW9uLm5hbWVdID0gZXh0ZW5zaW9uLnN0b3JhZ2VcblxuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgdHlwZTogZ2V0U2NoZW1hVHlwZUJ5TmFtZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxuICAgICAgfVxuXG4gICAgICBpZiAoZXh0ZW5zaW9uLnR5cGUgPT09ICdtYXJrJykge1xuICAgICAgICBjb25zdCBrZWVwT25TcGxpdCA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdrZWVwT25TcGxpdCcsIGNvbnRleHQpKSA/PyB0cnVlXG5cbiAgICAgICAgaWYgKGtlZXBPblNwbGl0KSB7XG4gICAgICAgICAgdGhpcy5zcGxpdHRhYmxlTWFya3MucHVzaChleHRlbnNpb24ubmFtZSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvbkJlZm9yZUNyZWF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25CZWZvcmVDcmVhdGUnXT4oXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgJ29uQmVmb3JlQ3JlYXRlJyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcblxuICAgICAgaWYgKG9uQmVmb3JlQ3JlYXRlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdiZWZvcmVDcmVhdGUnLCBvbkJlZm9yZUNyZWF0ZSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25DcmVhdGUgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ29uQ3JlYXRlJ10+KGV4dGVuc2lvbiwgJ29uQ3JlYXRlJywgY29udGV4dClcblxuICAgICAgaWYgKG9uQ3JlYXRlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdjcmVhdGUnLCBvbkNyZWF0ZSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25VcGRhdGUgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ29uVXBkYXRlJ10+KGV4dGVuc2lvbiwgJ29uVXBkYXRlJywgY29udGV4dClcblxuICAgICAgaWYgKG9uVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCd1cGRhdGUnLCBvblVwZGF0ZSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25TZWxlY3Rpb25VcGRhdGUgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ29uU2VsZWN0aW9uVXBkYXRlJ10+KFxuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICdvblNlbGVjdGlvblVwZGF0ZScsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApXG5cbiAgICAgIGlmIChvblNlbGVjdGlvblVwZGF0ZSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignc2VsZWN0aW9uVXBkYXRlJywgb25TZWxlY3Rpb25VcGRhdGUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uVHJhbnNhY3Rpb24gPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ29uVHJhbnNhY3Rpb24nXT4oXG4gICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgJ29uVHJhbnNhY3Rpb24nLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuXG4gICAgICBpZiAob25UcmFuc2FjdGlvbikge1xuICAgICAgICB0aGlzLmVkaXRvci5vbigndHJhbnNhY3Rpb24nLCBvblRyYW5zYWN0aW9uKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvbkZvY3VzID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvbkZvY3VzJ10+KGV4dGVuc2lvbiwgJ29uRm9jdXMnLCBjb250ZXh0KVxuXG4gICAgICBpZiAob25Gb2N1cykge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignZm9jdXMnLCBvbkZvY3VzKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvbkJsdXIgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ29uQmx1ciddPihleHRlbnNpb24sICdvbkJsdXInLCBjb250ZXh0KVxuXG4gICAgICBpZiAob25CbHVyKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdibHVyJywgb25CbHVyKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvbkRlc3Ryb3kgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ29uRGVzdHJveSddPihleHRlbnNpb24sICdvbkRlc3Ryb3knLCBjb250ZXh0KVxuXG4gICAgICBpZiAob25EZXN0cm95KSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdkZXN0cm95Jywgb25EZXN0cm95KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBzdGF0aWMgcmVzb2x2ZShleHRlbnNpb25zOiBFeHRlbnNpb25zKTogRXh0ZW5zaW9ucyB7XG4gICAgY29uc3QgcmVzb2x2ZWRFeHRlbnNpb25zID0gRXh0ZW5zaW9uTWFuYWdlci5zb3J0KEV4dGVuc2lvbk1hbmFnZXIuZmxhdHRlbihleHRlbnNpb25zKSlcbiAgICBjb25zdCBkdXBsaWNhdGVkTmFtZXMgPSBmaW5kRHVwbGljYXRlcyhyZXNvbHZlZEV4dGVuc2lvbnMubWFwKGV4dGVuc2lvbiA9PiBleHRlbnNpb24ubmFtZSkpXG5cbiAgICBpZiAoZHVwbGljYXRlZE5hbWVzLmxlbmd0aCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogRHVwbGljYXRlIGV4dGVuc2lvbiBuYW1lcyBmb3VuZDogWyR7ZHVwbGljYXRlZE5hbWVzXG4gICAgICAgICAgLm1hcChpdGVtID0+IGAnJHtpdGVtfSdgKVxuICAgICAgICAgIC5qb2luKCcsICcpfV0uIFRoaXMgY2FuIGxlYWQgdG8gaXNzdWVzLmAsXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc29sdmVkRXh0ZW5zaW9uc1xuICB9XG5cbiAgc3RhdGljIGZsYXR0ZW4oZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyk6IEV4dGVuc2lvbnMge1xuICAgIHJldHVybiAoXG4gICAgICBleHRlbnNpb25zXG4gICAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGFkZEV4dGVuc2lvbnMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZEV4dGVuc2lvbnMnXT4oXG4gICAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgICAnYWRkRXh0ZW5zaW9ucycsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIClcblxuICAgICAgICAgIGlmIChhZGRFeHRlbnNpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbiwgLi4udGhpcy5mbGF0dGVuKGFkZEV4dGVuc2lvbnMoKSldXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGV4dGVuc2lvblxuICAgICAgICB9KVxuICAgICAgICAvLyBgSW5maW5pdHlgIHdpbGwgYnJlYWsgVHlwZVNjcmlwdCBzbyB3ZSBzZXQgYSBudW1iZXIgdGhhdCBpcyBwcm9iYWJseSBoaWdoIGVub3VnaFxuICAgICAgICAuZmxhdCgxMClcbiAgICApXG4gIH1cblxuICBzdGF0aWMgc29ydChleHRlbnNpb25zOiBFeHRlbnNpb25zKTogRXh0ZW5zaW9ucyB7XG4gICAgY29uc3QgZGVmYXVsdFByaW9yaXR5ID0gMTAwXG5cbiAgICByZXR1cm4gZXh0ZW5zaW9ucy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBwcmlvcml0eUEgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ3ByaW9yaXR5J10+KGEsICdwcmlvcml0eScpIHx8IGRlZmF1bHRQcmlvcml0eVxuICAgICAgY29uc3QgcHJpb3JpdHlCID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydwcmlvcml0eSddPihiLCAncHJpb3JpdHknKSB8fCBkZWZhdWx0UHJpb3JpdHlcblxuICAgICAgaWYgKHByaW9yaXR5QSA+IHByaW9yaXR5Qikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cblxuICAgICAgaWYgKHByaW9yaXR5QSA8IHByaW9yaXR5Qikge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gMFxuICAgIH0pXG4gIH1cblxuICBnZXQgY29tbWFuZHMoKTogUmF3Q29tbWFuZHMge1xuICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnMucmVkdWNlKChjb21tYW5kcywgZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFkZENvbW1hbmRzID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRDb21tYW5kcyddPihcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAnYWRkQ29tbWFuZHMnLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuXG4gICAgICBpZiAoIWFkZENvbW1hbmRzKSB7XG4gICAgICAgIHJldHVybiBjb21tYW5kc1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5jb21tYW5kcyxcbiAgICAgICAgLi4uYWRkQ29tbWFuZHMoKSxcbiAgICAgIH1cbiAgICB9LCB7fSBhcyBSYXdDb21tYW5kcylcbiAgfVxuXG4gIGdldCBwbHVnaW5zKCk6IFBsdWdpbltdIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpc1xuXG4gICAgLy8gV2l0aCBQcm9zZU1pcnJvciwgZmlyc3QgcGx1Z2lucyB3aXRoaW4gYW4gYXJyYXkgYXJlIGV4ZWN1dGVkIGZpcnN0LlxuICAgIC8vIEluIFRpcHRhcCwgd2UgcHJvdmlkZSB0aGUgYWJpbGl0eSB0byBvdmVycmlkZSBwbHVnaW5zLFxuICAgIC8vIHNvIGl0IGZlZWxzIG1vcmUgbmF0dXJhbCB0byBydW4gcGx1Z2lucyBhdCB0aGUgZW5kIG9mIGFuIGFycmF5IGZpcnN0LlxuICAgIC8vIFRoYXTigJlzIHdoeSB3ZSBoYXZlIHRvIHJldmVyc2UgdGhlIGBleHRlbnNpb25zYCBhcnJheSBhbmQgc29ydCBhZ2FpblxuICAgIC8vIGJhc2VkIG9uIHRoZSBgcHJpb3JpdHlgIG9wdGlvbi5cbiAgICBjb25zdCBleHRlbnNpb25zID0gRXh0ZW5zaW9uTWFuYWdlci5zb3J0KFsuLi50aGlzLmV4dGVuc2lvbnNdLnJldmVyc2UoKSlcblxuICAgIGNvbnN0IGlucHV0UnVsZXM6IGFueVtdID0gW11cbiAgICBjb25zdCBwYXN0ZVJ1bGVzOiBhbnlbXSA9IFtdXG5cbiAgICBjb25zdCBhbGxQbHVnaW5zID0gZXh0ZW5zaW9uc1xuICAgICAgLm1hcChleHRlbnNpb24gPT4ge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwbHVnaW5zOiBQbHVnaW5bXSA9IFtdXG5cbiAgICAgICAgY29uc3QgYWRkS2V5Ym9hcmRTaG9ydGN1dHMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZEtleWJvYXJkU2hvcnRjdXRzJ10+KFxuICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAnYWRkS2V5Ym9hcmRTaG9ydGN1dHMnLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIClcblxuICAgICAgICBsZXQgZGVmYXVsdEJpbmRpbmdzOiBSZWNvcmQ8c3RyaW5nLCAoKSA9PiBib29sZWFuPiA9IHt9XG5cbiAgICAgICAgLy8gYmluZCBleGl0IGhhbmRsaW5nXG4gICAgICAgIGlmIChleHRlbnNpb24udHlwZSA9PT0gJ21hcmsnICYmIGV4dGVuc2lvbi5jb25maWcuZXhpdGFibGUpIHtcbiAgICAgICAgICBkZWZhdWx0QmluZGluZ3MuQXJyb3dSaWdodCA9ICgpID0+IE1hcmsuaGFuZGxlRXhpdCh7IGVkaXRvciwgbWFyazogZXh0ZW5zaW9uIGFzIE1hcmsgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhZGRLZXlib2FyZFNob3J0Y3V0cykge1xuICAgICAgICAgIGNvbnN0IGJpbmRpbmdzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSkubWFwKChbc2hvcnRjdXQsIG1ldGhvZF0pID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtzaG9ydGN1dCwgKCkgPT4gbWV0aG9kKHsgZWRpdG9yIH0pXVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgZGVmYXVsdEJpbmRpbmdzID0geyAuLi5kZWZhdWx0QmluZGluZ3MsIC4uLmJpbmRpbmdzIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGtleU1hcFBsdWdpbiA9IGtleW1hcChkZWZhdWx0QmluZGluZ3MpXG5cbiAgICAgICAgcGx1Z2lucy5wdXNoKGtleU1hcFBsdWdpbilcblxuICAgICAgICBjb25zdCBhZGRJbnB1dFJ1bGVzID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRJbnB1dFJ1bGVzJ10+KFxuICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAnYWRkSW5wdXRSdWxlcycsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZChleHRlbnNpb24sIGVkaXRvci5vcHRpb25zLmVuYWJsZUlucHV0UnVsZXMpICYmIGFkZElucHV0UnVsZXMpIHtcbiAgICAgICAgICBpbnB1dFJ1bGVzLnB1c2goLi4uYWRkSW5wdXRSdWxlcygpKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWRkUGFzdGVSdWxlcyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkUGFzdGVSdWxlcyddPihcbiAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgJ2FkZFBhc3RlUnVsZXMnLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIClcblxuICAgICAgICBpZiAoaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uLCBlZGl0b3Iub3B0aW9ucy5lbmFibGVQYXN0ZVJ1bGVzKSAmJiBhZGRQYXN0ZVJ1bGVzKSB7XG4gICAgICAgICAgcGFzdGVSdWxlcy5wdXNoKC4uLmFkZFBhc3RlUnVsZXMoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFkZFByb3NlTWlycm9yUGx1Z2lucyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkUHJvc2VNaXJyb3JQbHVnaW5zJ10+KFxuICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAnYWRkUHJvc2VNaXJyb3JQbHVnaW5zJyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGFkZFByb3NlTWlycm9yUGx1Z2lucykge1xuICAgICAgICAgIGNvbnN0IHByb3NlTWlycm9yUGx1Z2lucyA9IGFkZFByb3NlTWlycm9yUGx1Z2lucygpXG5cbiAgICAgICAgICBwbHVnaW5zLnB1c2goLi4ucHJvc2VNaXJyb3JQbHVnaW5zKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBsdWdpbnNcbiAgICAgIH0pXG4gICAgICAuZmxhdCgpXG5cbiAgICByZXR1cm4gW1xuICAgICAgaW5wdXRSdWxlc1BsdWdpbih7XG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgcnVsZXM6IGlucHV0UnVsZXMsXG4gICAgICB9KSxcbiAgICAgIC4uLnBhc3RlUnVsZXNQbHVnaW4oe1xuICAgICAgICBlZGl0b3IsXG4gICAgICAgIHJ1bGVzOiBwYXN0ZVJ1bGVzLFxuICAgICAgfSksXG4gICAgICAuLi5hbGxQbHVnaW5zLFxuICAgIF1cbiAgfVxuXG4gIGdldCBhdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKVxuICB9XG5cbiAgZ2V0IG5vZGVWaWV3cygpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpc1xuICAgIGNvbnN0IHsgbm9kZUV4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyh0aGlzLmV4dGVuc2lvbnMpXG5cbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgbm9kZUV4dGVuc2lvbnNcbiAgICAgICAgLmZpbHRlcihleHRlbnNpb24gPT4gISFnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGROb2RlVmlldycpKVxuICAgICAgICAubWFwKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcy5maWx0ZXIoXG4gICAgICAgICAgICBhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLnR5cGUgPT09IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgIClcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgdHlwZTogZ2V0Tm9kZVR5cGUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKSxcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYWRkTm9kZVZpZXcgPSBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydhZGROb2RlVmlldyddPihcbiAgICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAgICdhZGROb2RlVmlldycsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIClcblxuICAgICAgICAgIGlmICghYWRkTm9kZVZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG5vZGV2aWV3ID0gKFxuICAgICAgICAgICAgbm9kZTogUHJvc2VtaXJyb3JOb2RlLFxuICAgICAgICAgICAgdmlldzogRWRpdG9yVmlldyxcbiAgICAgICAgICAgIGdldFBvczogKCgpID0+IG51bWJlcikgfCBib29sZWFuLFxuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IERlY29yYXRpb25bXSxcbiAgICAgICAgICApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IEhUTUxBdHRyaWJ1dGVzID0gZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG5vZGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpXG5cbiAgICAgICAgICAgIHJldHVybiBhZGROb2RlVmlldygpKHtcbiAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICBnZXRQb3MsXG4gICAgICAgICAgICAgIGRlY29yYXRpb25zLFxuICAgICAgICAgICAgICBIVE1MQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbi5uYW1lLCBub2Rldmlld11cbiAgICAgICAgfSksXG4gICAgKVxuICB9XG59XG4iLCAiLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWVzcXVlZWIvaXMtd2hhdC9ibG9iLzg4ZDZlNGNhOTJmYjJiYWFiNjAwM2M1NGUwMmVlZGY0ZTcyOWU1YWIvc3JjL2luZGV4LnRzXG5cbmZ1bmN0aW9uIGdldFR5cGUodmFsdWU6IGFueSk6IHN0cmluZyB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZTogYW55KTogdmFsdWUgaXMgUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gJ09iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IE9iamVjdC5wcm90b3R5cGVcbn1cbiIsICJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi9pc1BsYWluT2JqZWN0LmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VEZWVwKHRhcmdldDogUmVjb3JkPHN0cmluZywgYW55Piwgc291cmNlOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGNvbnN0IG91dHB1dCA9IHsgLi4udGFyZ2V0IH1cblxuICBpZiAoaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIGlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pKSB7XG4gICAgICAgIGlmICghKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihvdXRwdXQsIHsgW2tleV06IHNvdXJjZVtrZXldIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0W2tleV0gPSBtZXJnZURlZXAodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3QuYXNzaWduKG91dHB1dCwgeyBba2V5XTogc291cmNlW2tleV0gfSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuIiwgImltcG9ydCB7IFBsdWdpbiwgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSAnLi9oZWxwZXJzL2dldEV4dGVuc2lvbkZpZWxkLmpzJ1xuaW1wb3J0IHsgRXh0ZW5zaW9uQ29uZmlnIH0gZnJvbSAnLi9pbmRleC5qcydcbmltcG9ydCB7IElucHV0UnVsZSB9IGZyb20gJy4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgTWFyayB9IGZyb20gJy4vTWFyay5qcydcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuL05vZGUuanMnXG5pbXBvcnQgeyBQYXN0ZVJ1bGUgfSBmcm9tICcuL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB7XG4gIEFueUNvbmZpZyxcbiAgRXh0ZW5zaW9ucyxcbiAgR2xvYmFsQXR0cmlidXRlcyxcbiAgS2V5Ym9hcmRTaG9ydGN1dENvbW1hbmQsXG4gIFBhcmVudENvbmZpZyxcbiAgUmF3Q29tbWFuZHMsXG59IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5pbXBvcnQgeyBtZXJnZURlZXAgfSBmcm9tICcuL3V0aWxpdGllcy9tZXJnZURlZXAuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zID0gYW55LCBTdG9yYWdlID0gYW55PiB7XG4gICAgW2tleTogc3RyaW5nXTogYW55XG5cbiAgICAvKipcbiAgICAgKiBOYW1lXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nXG5cbiAgICAvKipcbiAgICAgKiBQcmlvcml0eVxuICAgICAqL1xuICAgIHByaW9yaXR5PzogbnVtYmVyXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IG9wdGlvbnNcbiAgICAgKi9cbiAgICBkZWZhdWx0T3B0aW9ucz86IE9wdGlvbnNcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgT3B0aW9uc1xuICAgICAqL1xuICAgIGFkZE9wdGlvbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBwYXJlbnQ6IEV4Y2x1ZGU8UGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZE9wdGlvbnMnXSwgdW5kZWZpbmVkPlxuICAgIH0pID0+IE9wdGlvbnNcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgU3RvcmFnZVxuICAgICAqL1xuICAgIGFkZFN0b3JhZ2U/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBwYXJlbnQ6IEV4Y2x1ZGU8UGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFN0b3JhZ2UnXSwgdW5kZWZpbmVkPlxuICAgIH0pID0+IFN0b3JhZ2VcblxuICAgIC8qKlxuICAgICAqIEdsb2JhbCBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgYWRkR2xvYmFsQXR0cmlidXRlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEdsb2JhbEF0dHJpYnV0ZXMnXVxuICAgIH0pID0+IEdsb2JhbEF0dHJpYnV0ZXMgfCB7fVxuXG4gICAgLyoqXG4gICAgICogUmF3XG4gICAgICovXG4gICAgYWRkQ29tbWFuZHM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkQ29tbWFuZHMnXVxuICAgIH0pID0+IFBhcnRpYWw8UmF3Q29tbWFuZHM+XG5cbiAgICAvKipcbiAgICAgKiBLZXlib2FyZCBzaG9ydGN1dHNcbiAgICAgKi9cbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRLZXlib2FyZFNob3J0Y3V0cyddXG4gICAgfSkgPT4ge1xuICAgICAgW2tleTogc3RyaW5nXTogS2V5Ym9hcmRTaG9ydGN1dENvbW1hbmRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnB1dCBydWxlc1xuICAgICAqL1xuICAgIGFkZElucHV0UnVsZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkSW5wdXRSdWxlcyddXG4gICAgfSkgPT4gSW5wdXRSdWxlW11cblxuICAgIC8qKlxuICAgICAqIFBhc3RlIHJ1bGVzXG4gICAgICovXG4gICAgYWRkUGFzdGVSdWxlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRQYXN0ZVJ1bGVzJ11cbiAgICB9KSA9PiBQYXN0ZVJ1bGVbXVxuXG4gICAgLyoqXG4gICAgICogUHJvc2VNaXJyb3IgcGx1Z2luc1xuICAgICAqL1xuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRQcm9zZU1pcnJvclBsdWdpbnMnXVxuICAgIH0pID0+IFBsdWdpbltdXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbnNpb25zXG4gICAgICovXG4gICAgYWRkRXh0ZW5zaW9ucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEV4dGVuc2lvbnMnXVxuICAgIH0pID0+IEV4dGVuc2lvbnNcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBOb2RlIFNjaGVtYVxuICAgICAqL1xuICAgIGV4dGVuZE5vZGVTY2hlbWE/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZXh0ZW5kTm9kZVNjaGVtYSddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHRlbnNpb246IE5vZGUsXG4gICAgICAgICkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIE1hcmsgU2NoZW1hXG4gICAgICovXG4gICAgZXh0ZW5kTWFya1NjaGVtYT86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydleHRlbmRNYXJrU2NoZW1hJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4dGVuc2lvbjogTWFyayxcbiAgICAgICAgKSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIG5vdCByZWFkeSB5ZXQuXG4gICAgICovXG4gICAgb25CZWZvcmVDcmVhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25CZWZvcmVDcmVhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIHJlYWR5LlxuICAgICAqL1xuICAgIG9uQ3JlYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQ3JlYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRlbnQgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25VcGRhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25VcGRhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0aW9uIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uU2VsZWN0aW9uVXBkYXRlPzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uU2VsZWN0aW9uVXBkYXRlJ11cbiAgICAgICAgfSkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBzdGF0ZSBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblRyYW5zYWN0aW9uPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblRyYW5zYWN0aW9uJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25cbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cbiAgICAgKi9cbiAgICBvbkZvY3VzPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkZvY3VzJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBldmVudDogRm9jdXNFdmVudFxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpc27igJl0IGZvY3VzZWQgYW55bW9yZS5cbiAgICAgKi9cbiAgICBvbkJsdXI/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uQmx1ciddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZXZlbnQ6IEZvY3VzRXZlbnRcbiAgICAgICAgICB9LFxuICAgICAgICApID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgZGVzdHJveWVkLlxuICAgICAqL1xuICAgIG9uRGVzdHJveT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxFeHRlbnNpb25Db25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkRlc3Ryb3knXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEV4dGVuc2lvbjxPcHRpb25zID0gYW55LCBTdG9yYWdlID0gYW55PiB7XG4gIHR5cGUgPSAnZXh0ZW5zaW9uJ1xuXG4gIG5hbWUgPSAnZXh0ZW5zaW9uJ1xuXG4gIHBhcmVudDogRXh0ZW5zaW9uIHwgbnVsbCA9IG51bGxcblxuICBjaGlsZDogRXh0ZW5zaW9uIHwgbnVsbCA9IG51bGxcblxuICBvcHRpb25zOiBPcHRpb25zXG5cbiAgc3RvcmFnZTogU3RvcmFnZVxuXG4gIGNvbmZpZzogRXh0ZW5zaW9uQ29uZmlnID0ge1xuICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICBkZWZhdWx0T3B0aW9uczoge30sXG4gIH1cblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFBhcnRpYWw8RXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PiA9IHt9KSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIC4uLmNvbmZpZyxcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lXG5cbiAgICBpZiAoY29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHt0aGlzLm5hbWV9XCIuYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5jb25maWcuZGVmYXVsdE9wdGlvbnNcblxuICAgIGlmICh0aGlzLmNvbmZpZy5hZGRPcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkT3B0aW9ucyddPih0aGlzLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPih0aGlzLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApIHx8IHt9XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlPE8gPSBhbnksIFMgPSBhbnk+KGNvbmZpZzogUGFydGlhbDxFeHRlbnNpb25Db25maWc8TywgUz4+ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEV4dGVuc2lvbjxPLCBTPihjb25maWcpXG4gIH1cblxuICBjb25maWd1cmUob3B0aW9uczogUGFydGlhbDxPcHRpb25zPiA9IHt9KSB7XG4gICAgLy8gcmV0dXJuIGEgbmV3IGluc3RhbmNlIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgZXh0ZW5zaW9uXG4gICAgLy8gd2l0aCBkaWZmZXJlbnQgY2FsbHMgb2YgYGNvbmZpZ3VyZWBcbiAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmV4dGVuZCgpXG5cbiAgICBleHRlbnNpb24ub3B0aW9ucyA9IG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMgYXMgUmVjb3JkPHN0cmluZywgYW55Piwgb3B0aW9ucykgYXMgT3B0aW9uc1xuXG4gICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4oZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG5cbiAgZXh0ZW5kPEV4dGVuZGVkT3B0aW9ucyA9IE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZSA9IFN0b3JhZ2U+KFxuICAgIGV4dGVuZGVkQ29uZmlnOiBQYXJ0aWFsPEV4dGVuc2lvbkNvbmZpZzxFeHRlbmRlZE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZT4+ID0ge30sXG4gICkge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5ldyBFeHRlbnNpb248RXh0ZW5kZWRPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2U+KHsgLi4udGhpcy5jb25maWcsIC4uLmV4dGVuZGVkQ29uZmlnIH0pXG5cbiAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpc1xuXG4gICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvblxuXG4gICAgZXh0ZW5zaW9uLm5hbWUgPSBleHRlbmRlZENvbmZpZy5uYW1lID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZVxuXG4gICAgaWYgKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke2V4dGVuc2lvbi5uYW1lfVwiLmAsXG4gICAgICApXG4gICAgfVxuXG4gICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZE9wdGlvbnMnXT4oZXh0ZW5zaW9uLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPihleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICByZXR1cm4gZXh0ZW5zaW9uXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IFJhbmdlLCBUZXh0U2VyaWFsaXplciB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dEJldHdlZW4oXG4gIHN0YXJ0Tm9kZTogUHJvc2VNaXJyb3JOb2RlLFxuICByYW5nZTogUmFuZ2UsXG4gIG9wdGlvbnM/OiB7XG4gICAgYmxvY2tTZXBhcmF0b3I/OiBzdHJpbmdcbiAgICB0ZXh0U2VyaWFsaXplcnM/OiBSZWNvcmQ8c3RyaW5nLCBUZXh0U2VyaWFsaXplcj5cbiAgfSxcbik6IHN0cmluZyB7XG4gIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHJhbmdlXG4gIGNvbnN0IHsgYmxvY2tTZXBhcmF0b3IgPSAnXFxuXFxuJywgdGV4dFNlcmlhbGl6ZXJzID0ge30gfSA9IG9wdGlvbnMgfHwge31cbiAgbGV0IHRleHQgPSAnJ1xuICBsZXQgc2VwYXJhdGVkID0gdHJ1ZVxuXG4gIHN0YXJ0Tm9kZS5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MsIHBhcmVudCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCB0ZXh0U2VyaWFsaXplciA9IHRleHRTZXJpYWxpemVycz8uW25vZGUudHlwZS5uYW1lXVxuXG4gICAgaWYgKHRleHRTZXJpYWxpemVyKSB7XG4gICAgICBpZiAobm9kZS5pc0Jsb2NrICYmICFzZXBhcmF0ZWQpIHtcbiAgICAgICAgdGV4dCArPSBibG9ja1NlcGFyYXRvclxuICAgICAgICBzZXBhcmF0ZWQgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdGV4dCArPSB0ZXh0U2VyaWFsaXplcih7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBwb3MsXG4gICAgICAgICAgcGFyZW50LFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHJhbmdlLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgIHRleHQgKz0gbm9kZT8udGV4dD8uc2xpY2UoTWF0aC5tYXgoZnJvbSwgcG9zKSAtIHBvcywgdG8gLSBwb3MpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHNlcGFyYXRlZCA9IGZhbHNlXG4gICAgfSBlbHNlIGlmIChub2RlLmlzQmxvY2sgJiYgIXNlcGFyYXRlZCkge1xuICAgICAgdGV4dCArPSBibG9ja1NlcGFyYXRvclxuICAgICAgc2VwYXJhdGVkID0gdHJ1ZVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gdGV4dFxufVxuIiwgImltcG9ydCB7IFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IFRleHRTZXJpYWxpemVyIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHNjaGVtYTogU2NoZW1hKTogUmVjb3JkPHN0cmluZywgVGV4dFNlcmlhbGl6ZXI+IHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhzY2hlbWEubm9kZXMpXG4gICAgICAuZmlsdGVyKChbLCBub2RlXSkgPT4gbm9kZS5zcGVjLnRvVGV4dClcbiAgICAgIC5tYXAoKFtuYW1lLCBub2RlXSkgPT4gW25hbWUsIG5vZGUuc3BlYy50b1RleHRdKSxcbiAgKVxufVxuIiwgImltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnLi4vRXh0ZW5zaW9uLmpzJ1xuaW1wb3J0IHsgZ2V0VGV4dEJldHdlZW4gfSBmcm9tICcuLi9oZWxwZXJzL2dldFRleHRCZXR3ZWVuLmpzJ1xuaW1wb3J0IHsgZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYS5qcydcblxuZXhwb3J0IGNvbnN0IENsaXBib2FyZFRleHRTZXJpYWxpemVyID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdjbGlwYm9hcmRUZXh0U2VyaWFsaXplcicsXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdjbGlwYm9hcmRUZXh0U2VyaWFsaXplcicpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGNsaXBib2FyZFRleHRTZXJpYWxpemVyOiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpc1xuICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSwgc2NoZW1hIH0gPSBlZGl0b3JcbiAgICAgICAgICAgIGNvbnN0IHsgZG9jLCBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gICAgICAgICAgICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBmcm9tID0gTWF0aC5taW4oLi4ucmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS4kZnJvbS5wb3MpKVxuICAgICAgICAgICAgY29uc3QgdG8gPSBNYXRoLm1heCguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiR0by5wb3MpKVxuICAgICAgICAgICAgY29uc3QgdGV4dFNlcmlhbGl6ZXJzID0gZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWEpXG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHsgZnJvbSwgdG8gfVxuXG4gICAgICAgICAgICByZXR1cm4gZ2V0VGV4dEJldHdlZW4oZG9jLCByYW5nZSwge1xuICAgICAgICAgICAgICB0ZXh0U2VyaWFsaXplcnMsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBibHVyOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgZm9jdXMgZnJvbSB0aGUgZWRpdG9yLlxuICAgICAgICovXG4gICAgICBibHVyOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgYmx1cjogUmF3Q29tbWFuZHNbJ2JsdXInXSA9ICgpID0+ICh7IGVkaXRvciwgdmlldyB9KSA9PiB7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgaWYgKCFlZGl0b3IuaXNEZXN0cm95ZWQpIHtcbiAgICAgICh2aWV3LmRvbSBhcyBIVE1MRWxlbWVudCkuYmx1cigpXG5cbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCByZW1vdmUgdGhlIGNhcmV0IG9uIGJsdXIgYnV0IHNhZmFyaSBkb2VzIG5vdC5cbiAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8yNDA1XG4gICAgICB3aW5kb3c/LmdldFNlbGVjdGlvbigpPy5yZW1vdmVBbGxSYW5nZXMoKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBjbGVhckNvbnRlbnQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogQ2xlYXIgdGhlIHdob2xlIGRvY3VtZW50LlxuICAgICAgICovXG4gICAgICBjbGVhckNvbnRlbnQ6IChlbWl0VXBkYXRlPzogYm9vbGVhbikgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFyQ29udGVudDogUmF3Q29tbWFuZHNbJ2NsZWFyQ29udGVudCddID0gKGVtaXRVcGRhdGUgPSBmYWxzZSkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICByZXR1cm4gY29tbWFuZHMuc2V0Q29udGVudCgnJywgZW1pdFVwZGF0ZSlcbn1cbiIsICJpbXBvcnQgeyBsaWZ0VGFyZ2V0IH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBjbGVhck5vZGVzOiB7XG4gICAgICAvKipcbiAgICAgICAqIE5vcm1hbGl6ZSBub2RlcyB0byBhIHNpbXBsZSBwYXJhZ3JhcGguXG4gICAgICAgKi9cbiAgICAgIGNsZWFyTm9kZXM6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjbGVhck5vZGVzOiBSYXdDb21tYW5kc1snY2xlYXJOb2RlcyddID0gKCkgPT4gKHsgc3RhdGUsIHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0clxuICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uXG5cbiAgaWYgKCFkaXNwYXRjaCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByYW5nZXMuZm9yRWFjaCgoeyAkZnJvbSwgJHRvIH0pID0+IHtcbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKCRmcm9tLnBvcywgJHRvLnBvcywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgaWYgKG5vZGUudHlwZS5pc1RleHQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgZG9jLCBtYXBwaW5nIH0gPSB0clxuICAgICAgY29uc3QgJG1hcHBlZEZyb20gPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcChwb3MpKVxuICAgICAgY29uc3QgJG1hcHBlZFRvID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAocG9zICsgbm9kZS5ub2RlU2l6ZSkpXG4gICAgICBjb25zdCBub2RlUmFuZ2UgPSAkbWFwcGVkRnJvbS5ibG9ja1JhbmdlKCRtYXBwZWRUbylcblxuICAgICAgaWYgKCFub2RlUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhcmdldExpZnREZXB0aCA9IGxpZnRUYXJnZXQobm9kZVJhbmdlKVxuXG4gICAgICBpZiAobm9kZS50eXBlLmlzVGV4dGJsb2NrKSB7XG4gICAgICAgIGNvbnN0IHsgZGVmYXVsdFR5cGUgfSA9ICRtYXBwZWRGcm9tLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkbWFwcGVkRnJvbS5pbmRleCgpKVxuXG4gICAgICAgIHRyLnNldE5vZGVNYXJrdXAobm9kZVJhbmdlLnN0YXJ0LCBkZWZhdWx0VHlwZSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldExpZnREZXB0aCB8fCB0YXJnZXRMaWZ0RGVwdGggPT09IDApIHtcbiAgICAgICAgdHIubGlmdChub2RlUmFuZ2UsIHRhcmdldExpZnREZXB0aClcbiAgICAgIH1cbiAgICB9KVxuICB9KVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgQ29tbWFuZCwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGNvbW1hbmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogRGVmaW5lIGEgY29tbWFuZCBpbmxpbmUuXG4gICAgICAgKi9cbiAgICAgIGNvbW1hbmQ6IChmbjogKHByb3BzOiBQYXJhbWV0ZXJzPENvbW1hbmQ+WzBdKSA9PiBib29sZWFuKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY29tbWFuZDogUmF3Q29tbWFuZHNbJ2NvbW1hbmQnXSA9IGZuID0+IHByb3BzID0+IHtcbiAgcmV0dXJuIGZuKHByb3BzKVxufVxuIiwgImltcG9ydCB7IGNyZWF0ZVBhcmFncmFwaE5lYXIgYXMgb3JpZ2luYWxDcmVhdGVQYXJhZ3JhcGhOZWFyIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGNyZWF0ZVBhcmFncmFwaE5lYXI6IHtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIGEgcGFyYWdyYXBoIG5lYXJieS5cbiAgICAgICAqL1xuICAgICAgY3JlYXRlUGFyYWdyYXBoTmVhcjogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlUGFyYWdyYXBoTmVhcjogUmF3Q29tbWFuZHNbJ2NyZWF0ZVBhcmFncmFwaE5lYXInXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbENyZWF0ZVBhcmFncmFwaE5lYXIoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgY3V0OiB7XG4gICAgICAvKipcbiAgICAgICAqIEN1dHMgY29udGVudCBmcm9tIGEgcmFuZ2UgYW5kIGluc2VydHMgaXQgYXQgYSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgICAqL1xuICAgICAgY3V0OiAoeyBmcm9tLCB0byB9OiB7IGZyb206IG51bWJlciwgdG86IG51bWJlciB9LCB0YXJnZXRQb3M6IG51bWJlcikgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGN1dDogUmF3Q29tbWFuZHNbJ2N1dCddID0gKG9yaWdpblJhbmdlLCB0YXJnZXRQb3MpID0+ICh7IGVkaXRvciwgdHIgfSkgPT4ge1xuICBjb25zdCB7IHN0YXRlIH0gPSBlZGl0b3JcblxuICBjb25zdCBjb250ZW50U2xpY2UgPSBzdGF0ZS5kb2Muc2xpY2Uob3JpZ2luUmFuZ2UuZnJvbSwgb3JpZ2luUmFuZ2UudG8pXG5cbiAgdHIuZGVsZXRlUmFuZ2Uob3JpZ2luUmFuZ2UuZnJvbSwgb3JpZ2luUmFuZ2UudG8pXG4gIGNvbnN0IG5ld1BvcyA9IHRyLm1hcHBpbmcubWFwKHRhcmdldFBvcylcblxuICB0ci5pbnNlcnQobmV3UG9zLCBjb250ZW50U2xpY2UuY29udGVudClcblxuICB0ci5zZXRTZWxlY3Rpb24obmV3IFRleHRTZWxlY3Rpb24odHIuZG9jLnJlc29sdmUobmV3UG9zIC0gMSkpKVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGRlbGV0ZUN1cnJlbnROb2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIERlbGV0ZSB0aGUgbm9kZSB0aGF0IGN1cnJlbnRseSBoYXMgdGhlIHNlbGVjdGlvbiBhbmNob3IuXG4gICAgICAgKi9cbiAgICAgIGRlbGV0ZUN1cnJlbnROb2RlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZGVsZXRlQ3VycmVudE5vZGU6IFJhd0NvbW1hbmRzWydkZWxldGVDdXJyZW50Tm9kZSddID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IGN1cnJlbnROb2RlID0gc2VsZWN0aW9uLiRhbmNob3Iubm9kZSgpXG5cbiAgLy8gaWYgdGhlcmUgaXMgY29udGVudCBpbnNpZGUgdGhlIGN1cnJlbnQgbm9kZSwgYnJlYWsgb3V0IG9mIHRoaXMgY29tbWFuZFxuICBpZiAoY3VycmVudE5vZGUuY29udGVudC5zaXplID4gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgJHBvcyA9IHRyLnNlbGVjdGlvbi4kYW5jaG9yXG5cbiAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoIC09IDEpIHtcbiAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGRlcHRoKVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gY3VycmVudE5vZGUudHlwZSkge1xuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSAkcG9zLmJlZm9yZShkZXB0aClcbiAgICAgICAgY29uc3QgdG8gPSAkcG9zLmFmdGVyKGRlcHRoKVxuXG4gICAgICAgIHRyLmRlbGV0ZShmcm9tLCB0bykuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGRlbGV0ZU5vZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogRGVsZXRlIGEgbm9kZS5cbiAgICAgICAqL1xuICAgICAgZGVsZXRlTm9kZTogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZGVsZXRlTm9kZTogUmF3Q29tbWFuZHNbJ2RlbGV0ZU5vZGUnXSA9IHR5cGVPck5hbWUgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0ICRwb3MgPSB0ci5zZWxlY3Rpb24uJGFuY2hvclxuXG4gIGZvciAobGV0IGRlcHRoID0gJHBvcy5kZXB0aDsgZGVwdGggPiAwOyBkZXB0aCAtPSAxKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShkZXB0aClcblxuICAgIGlmIChub2RlLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCBmcm9tID0gJHBvcy5iZWZvcmUoZGVwdGgpXG4gICAgICAgIGNvbnN0IHRvID0gJHBvcy5hZnRlcihkZXB0aClcblxuICAgICAgICB0ci5kZWxldGUoZnJvbSwgdG8pLnNjcm9sbEludG9WaWV3KClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cbiIsICJpbXBvcnQgeyBSYW5nZSwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGRlbGV0ZVJhbmdlOiB7XG4gICAgICAvKipcbiAgICAgICAqIERlbGV0ZSBhIGdpdmVuIHJhbmdlLlxuICAgICAgICovXG4gICAgICBkZWxldGVSYW5nZTogKHJhbmdlOiBSYW5nZSkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlbGV0ZVJhbmdlOiBSYXdDb21tYW5kc1snZGVsZXRlUmFuZ2UnXSA9IHJhbmdlID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHJhbmdlXG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdHIuZGVsZXRlKGZyb20sIHRvKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBkZWxldGVTZWxlY3Rpb24gYXMgb3JpZ2luYWxEZWxldGVTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZGVsZXRlU2VsZWN0aW9uOiB7XG4gICAgICAvKipcbiAgICAgICAqIERlbGV0ZSB0aGUgc2VsZWN0aW9uLCBpZiB0aGVyZSBpcyBvbmUuXG4gICAgICAgKi9cbiAgICAgIGRlbGV0ZVNlbGVjdGlvbjogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZGVsZXRlU2VsZWN0aW9uOiBSYXdDb21tYW5kc1snZGVsZXRlU2VsZWN0aW9uJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxEZWxldGVTZWxlY3Rpb24oc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBlbnRlcjoge1xuICAgICAgLyoqXG4gICAgICAgKiBUcmlnZ2VyIGVudGVyLlxuICAgICAgICovXG4gICAgICBlbnRlcjogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGVudGVyOiBSYXdDb21tYW5kc1snZW50ZXInXSA9ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgcmV0dXJuIGNvbW1hbmRzLmtleWJvYXJkU2hvcnRjdXQoJ0VudGVyJylcbn1cbiIsICJpbXBvcnQgeyBleGl0Q29kZSBhcyBvcmlnaW5hbEV4aXRDb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGV4aXRDb2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIEV4aXQgZnJvbSBhIGNvZGUgYmxvY2suXG4gICAgICAgKi9cbiAgICAgIGV4aXRDb2RlOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBleGl0Q29kZTogUmF3Q29tbWFuZHNbJ2V4aXRDb2RlJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxFeGl0Q29kZShzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgaXNSZWdFeHAgfSBmcm9tICcuL2lzUmVnRXhwLmpzJ1xuXG4vKipcbiAqIENoZWNrIGlmIG9iamVjdDEgaW5jbHVkZXMgb2JqZWN0MlxuICogQHBhcmFtIG9iamVjdDEgT2JqZWN0XG4gKiBAcGFyYW0gb2JqZWN0MiBPYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdEluY2x1ZGVzKFxuICBvYmplY3QxOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBvYmplY3QyOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBvcHRpb25zOiB7IHN0cmljdDogYm9vbGVhbiB9ID0geyBzdHJpY3Q6IHRydWUgfSxcbik6IGJvb2xlYW4ge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0MilcblxuICBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBrZXlzLmV2ZXJ5KGtleSA9PiB7XG4gICAgaWYgKG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0MltrZXldID09PSBvYmplY3QxW2tleV1cbiAgICB9XG5cbiAgICBpZiAoaXNSZWdFeHAob2JqZWN0MltrZXldKSkge1xuICAgICAgcmV0dXJuIG9iamVjdDJba2V5XS50ZXN0KG9iamVjdDFba2V5XSlcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0MltrZXldID09PSBvYmplY3QxW2tleV1cbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBNYXJrIGFzIFByb3NlTWlycm9yTWFyaywgTWFya1R5cGUsIFJlc29sdmVkUG9zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG9iamVjdEluY2x1ZGVzIH0gZnJvbSAnLi4vdXRpbGl0aWVzL29iamVjdEluY2x1ZGVzLmpzJ1xuXG5mdW5jdGlvbiBmaW5kTWFya0luU2V0KFxuICBtYXJrczogUHJvc2VNaXJyb3JNYXJrW10sXG4gIHR5cGU6IE1hcmtUeXBlLFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30sXG4pOiBQcm9zZU1pcnJvck1hcmsgfCB1bmRlZmluZWQge1xuICByZXR1cm4gbWFya3MuZmluZChpdGVtID0+IHtcbiAgICByZXR1cm4gaXRlbS50eXBlID09PSB0eXBlICYmIG9iamVjdEluY2x1ZGVzKGl0ZW0uYXR0cnMsIGF0dHJpYnV0ZXMpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGlzTWFya0luU2V0KFxuICBtYXJrczogUHJvc2VNaXJyb3JNYXJrW10sXG4gIHR5cGU6IE1hcmtUeXBlLFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30sXG4pOiBib29sZWFuIHtcbiAgcmV0dXJuICEhZmluZE1hcmtJblNldChtYXJrcywgdHlwZSwgYXR0cmlidXRlcylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmtSYW5nZShcbiAgJHBvczogUmVzb2x2ZWRQb3MsXG4gIHR5cGU6IE1hcmtUeXBlLFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30sXG4pOiBSYW5nZSB8IHZvaWQge1xuICBpZiAoISRwb3MgfHwgIXR5cGUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGxldCBzdGFydCA9ICRwb3MucGFyZW50LmNoaWxkQWZ0ZXIoJHBvcy5wYXJlbnRPZmZzZXQpXG5cbiAgaWYgKCRwb3MucGFyZW50T2Zmc2V0ID09PSBzdGFydC5vZmZzZXQgJiYgc3RhcnQub2Zmc2V0ICE9PSAwKSB7XG4gICAgc3RhcnQgPSAkcG9zLnBhcmVudC5jaGlsZEJlZm9yZSgkcG9zLnBhcmVudE9mZnNldClcbiAgfVxuXG4gIGlmICghc3RhcnQubm9kZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgbWFyayA9IGZpbmRNYXJrSW5TZXQoWy4uLnN0YXJ0Lm5vZGUubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKVxuXG4gIGlmICghbWFyaykge1xuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IHN0YXJ0SW5kZXggPSBzdGFydC5pbmRleFxuICBsZXQgc3RhcnRQb3MgPSAkcG9zLnN0YXJ0KCkgKyBzdGFydC5vZmZzZXRcbiAgbGV0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIDFcbiAgbGV0IGVuZFBvcyA9IHN0YXJ0UG9zICsgc3RhcnQubm9kZS5ub2RlU2l6ZVxuXG4gIGZpbmRNYXJrSW5TZXQoWy4uLnN0YXJ0Lm5vZGUubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKVxuXG4gIHdoaWxlIChzdGFydEluZGV4ID4gMCAmJiBtYXJrLmlzSW5TZXQoJHBvcy5wYXJlbnQuY2hpbGQoc3RhcnRJbmRleCAtIDEpLm1hcmtzKSkge1xuICAgIHN0YXJ0SW5kZXggLT0gMVxuICAgIHN0YXJ0UG9zIC09ICRwb3MucGFyZW50LmNoaWxkKHN0YXJ0SW5kZXgpLm5vZGVTaXplXG4gIH1cblxuICB3aGlsZSAoXG4gICAgZW5kSW5kZXggPCAkcG9zLnBhcmVudC5jaGlsZENvdW50XG4gICAgJiYgaXNNYXJrSW5TZXQoWy4uLiRwb3MucGFyZW50LmNoaWxkKGVuZEluZGV4KS5tYXJrc10sIHR5cGUsIGF0dHJpYnV0ZXMpXG4gICkge1xuICAgIGVuZFBvcyArPSAkcG9zLnBhcmVudC5jaGlsZChlbmRJbmRleCkubm9kZVNpemVcbiAgICBlbmRJbmRleCArPSAxXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZyb206IHN0YXJ0UG9zLFxuICAgIHRvOiBlbmRQb3MsXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSwgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmtUeXBlKG5hbWVPclR5cGU6IHN0cmluZyB8IE1hcmtUeXBlLCBzY2hlbWE6IFNjaGVtYSk6IE1hcmtUeXBlIHtcbiAgaWYgKHR5cGVvZiBuYW1lT3JUeXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmICghc2NoZW1hLm1hcmtzW25hbWVPclR5cGVdKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYFRoZXJlIGlzIG5vIG1hcmsgdHlwZSBuYW1lZCAnJHtuYW1lT3JUeXBlfScuIE1heWJlIHlvdSBmb3Jnb3QgdG8gYWRkIHRoZSBleHRlbnNpb24/YCxcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gc2NoZW1hLm1hcmtzW25hbWVPclR5cGVdXG4gIH1cblxuICByZXR1cm4gbmFtZU9yVHlwZVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRNYXJrUmFuZ2UgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtSYW5nZS5qcydcbmltcG9ydCB7IGdldE1hcmtUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrVHlwZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBleHRlbmRNYXJrUmFuZ2U6IHtcbiAgICAgIC8qKlxuICAgICAgICogRXh0ZW5kcyB0aGUgdGV4dCBzZWxlY3Rpb24gdG8gdGhlIGN1cnJlbnQgbWFyay5cbiAgICAgICAqL1xuICAgICAgZXh0ZW5kTWFya1JhbmdlOiAoXG4gICAgICAgIHR5cGVPck5hbWU6IHN0cmluZyB8IE1hcmtUeXBlLFxuICAgICAgICBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PixcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZXh0ZW5kTWFya1JhbmdlOiBSYXdDb21tYW5kc1snZXh0ZW5kTWFya1JhbmdlJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgeyBkb2MsIHNlbGVjdGlvbiB9ID0gdHJcbiAgY29uc3QgeyAkZnJvbSwgZnJvbSwgdG8gfSA9IHNlbGVjdGlvblxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHJhbmdlID0gZ2V0TWFya1JhbmdlKCRmcm9tLCB0eXBlLCBhdHRyaWJ1dGVzKVxuXG4gICAgaWYgKHJhbmdlICYmIHJhbmdlLmZyb20gPD0gZnJvbSAmJiByYW5nZS50byA+PSB0bykge1xuICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCByYW5nZS5mcm9tLCByYW5nZS50bylcblxuICAgICAgdHIuc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IENvbW1hbmQsIENvbW1hbmRQcm9wcywgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGZpcnN0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFJ1bnMgb25lIGNvbW1hbmQgYWZ0ZXIgdGhlIG90aGVyIGFuZCBzdG9wcyBhdCB0aGUgZmlyc3Qgd2hpY2ggcmV0dXJucyB0cnVlLlxuICAgICAgICovXG4gICAgICBmaXJzdDogKGNvbW1hbmRzOiBDb21tYW5kW10gfCAoKHByb3BzOiBDb21tYW5kUHJvcHMpID0+IENvbW1hbmRbXSkpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBmaXJzdDogUmF3Q29tbWFuZHNbJ2ZpcnN0J10gPSBjb21tYW5kcyA9PiBwcm9wcyA9PiB7XG4gIGNvbnN0IGl0ZW1zID0gdHlwZW9mIGNvbW1hbmRzID09PSAnZnVuY3Rpb24nXG4gICAgPyBjb21tYW5kcyhwcm9wcylcbiAgICA6IGNvbW1hbmRzXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChpdGVtc1tpXShwcm9wcykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCAiaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1RleHRTZWxlY3Rpb24odmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBUZXh0U2VsZWN0aW9uIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvblxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBtaW5NYXgodmFsdWUgPSAwLCBtaW4gPSAwLCBtYXggPSAwKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRm9jdXNQb3NpdGlvbiB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgbWluTWF4IH0gZnJvbSAnLi4vdXRpbGl0aWVzL21pbk1heC5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVGb2N1c1Bvc2l0aW9uKFxuICBkb2M6IFByb3NlTWlycm9yTm9kZSxcbiAgcG9zaXRpb246IEZvY3VzUG9zaXRpb24gPSBudWxsLFxuKTogU2VsZWN0aW9uIHwgbnVsbCB7XG4gIGlmICghcG9zaXRpb24pIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3Qgc2VsZWN0aW9uQXRTdGFydCA9IFNlbGVjdGlvbi5hdFN0YXJ0KGRvYylcbiAgY29uc3Qgc2VsZWN0aW9uQXRFbmQgPSBTZWxlY3Rpb24uYXRFbmQoZG9jKVxuXG4gIGlmIChwb3NpdGlvbiA9PT0gJ3N0YXJ0JyB8fCBwb3NpdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBzZWxlY3Rpb25BdFN0YXJ0XG4gIH1cblxuICBpZiAocG9zaXRpb24gPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbkF0RW5kXG4gIH1cblxuICBjb25zdCBtaW5Qb3MgPSBzZWxlY3Rpb25BdFN0YXJ0LmZyb21cbiAgY29uc3QgbWF4UG9zID0gc2VsZWN0aW9uQXRFbmQudG9cblxuICBpZiAocG9zaXRpb24gPT09ICdhbGwnKSB7XG4gICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uY3JlYXRlKFxuICAgICAgZG9jLFxuICAgICAgbWluTWF4KDAsIG1pblBvcywgbWF4UG9zKSxcbiAgICAgIG1pbk1heChkb2MuY29udGVudC5zaXplLCBtaW5Qb3MsIG1heFBvcyksXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIFRleHRTZWxlY3Rpb24uY3JlYXRlKFxuICAgIGRvYyxcbiAgICBtaW5NYXgocG9zaXRpb24sIG1pblBvcywgbWF4UG9zKSxcbiAgICBtaW5NYXgocG9zaXRpb24sIG1pblBvcywgbWF4UG9zKSxcbiAgKVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBpc2lPUygpOiBib29sZWFuIHtcbiAgcmV0dXJuIFtcbiAgICAnaVBhZCBTaW11bGF0b3InLFxuICAgICdpUGhvbmUgU2ltdWxhdG9yJyxcbiAgICAnaVBvZCBTaW11bGF0b3InLFxuICAgICdpUGFkJyxcbiAgICAnaVBob25lJyxcbiAgICAnaVBvZCcsXG4gIF0uaW5jbHVkZXMobmF2aWdhdG9yLnBsYXRmb3JtKVxuICAvLyBpUGFkIG9uIGlPUyAxMyBkZXRlY3Rpb25cbiAgfHwgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ01hYycpICYmICdvbnRvdWNoZW5kJyBpbiBkb2N1bWVudClcbn1cbiIsICJpbXBvcnQgeyBpc1RleHRTZWxlY3Rpb24gfSBmcm9tICcuLi9oZWxwZXJzL2lzVGV4dFNlbGVjdGlvbi5qcydcbmltcG9ydCB7IHJlc29sdmVGb2N1c1Bvc2l0aW9uIH0gZnJvbSAnLi4vaGVscGVycy9yZXNvbHZlRm9jdXNQb3NpdGlvbi5qcydcbmltcG9ydCB7IEZvY3VzUG9zaXRpb24sIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBpc2lPUyB9IGZyb20gJy4uL3V0aWxpdGllcy9pc2lPUy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGZvY3VzOiB7XG4gICAgICAvKipcbiAgICAgICAqIEZvY3VzIHRoZSBlZGl0b3IgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgICovXG4gICAgICBmb2N1czogKFxuICAgICAgICBwb3NpdGlvbj86IEZvY3VzUG9zaXRpb24sXG4gICAgICAgIG9wdGlvbnM/OiB7XG4gICAgICAgICAgc2Nyb2xsSW50b1ZpZXc/OiBib29sZWFuLFxuICAgICAgICB9LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZm9jdXM6IFJhd0NvbW1hbmRzWydmb2N1cyddID0gKHBvc2l0aW9uID0gbnVsbCwgb3B0aW9ucyA9IHt9KSA9PiAoe1xuICBlZGl0b3IsXG4gIHZpZXcsXG4gIHRyLFxuICBkaXNwYXRjaCxcbn0pID0+IHtcbiAgb3B0aW9ucyA9IHtcbiAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAuLi5vcHRpb25zLFxuICB9XG5cbiAgY29uc3QgZGVsYXllZEZvY3VzID0gKCkgPT4ge1xuICAgIC8vIGZvY3VzIHdpdGhpbiBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBicmVha3MgZm9jdXMgb24gaU9TXG4gICAgLy8gc28gd2UgaGF2ZSB0byBjYWxsIHRoaXNcbiAgICBpZiAoaXNpT1MoKSkge1xuICAgICAgKHZpZXcuZG9tIGFzIEhUTUxFbGVtZW50KS5mb2N1cygpXG4gICAgfVxuXG4gICAgLy8gRm9yIFJlYWN0IHdlIGhhdmUgdG8gZm9jdXMgYXN5bmNocm9ub3VzbHkuIE90aGVyd2lzZSB3aWxkIHRoaW5ncyBoYXBwZW4uXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzE1MjBcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKCFlZGl0b3IuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgdmlldy5mb2N1cygpXG5cbiAgICAgICAgaWYgKG9wdGlvbnM/LnNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgICAgZWRpdG9yLmNvbW1hbmRzLnNjcm9sbEludG9WaWV3KClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBpZiAoKHZpZXcuaGFzRm9jdXMoKSAmJiBwb3NpdGlvbiA9PT0gbnVsbCkgfHwgcG9zaXRpb24gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIHdlIGRvbuKAmXQgdHJ5IHRvIHJlc29sdmUgYSBOb2RlU2VsZWN0aW9uIG9yIENlbGxTZWxlY3Rpb25cbiAgaWYgKGRpc3BhdGNoICYmIHBvc2l0aW9uID09PSBudWxsICYmICFpc1RleHRTZWxlY3Rpb24oZWRpdG9yLnN0YXRlLnNlbGVjdGlvbikpIHtcbiAgICBkZWxheWVkRm9jdXMoKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBwYXNzIHRocm91Z2ggdHIuZG9jIGluc3RlYWQgb2YgZWRpdG9yLnN0YXRlLmRvY1xuICAvLyBzaW5jZSB0cmFuc2FjdGlvbnMgY291bGQgY2hhbmdlIHRoZSBlZGl0b3JzIHN0YXRlIGJlZm9yZSB0aGlzIGNvbW1hbmQgaGFzIGJlZW4gcnVuXG4gIGNvbnN0IHNlbGVjdGlvbiA9IHJlc29sdmVGb2N1c1Bvc2l0aW9uKHRyLmRvYywgcG9zaXRpb24pIHx8IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb25cbiAgY29uc3QgaXNTYW1lU2VsZWN0aW9uID0gZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5lcShzZWxlY3Rpb24pXG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgaWYgKCFpc1NhbWVTZWxlY3Rpb24pIHtcbiAgICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pXG4gICAgfVxuXG4gICAgLy8gYHRyLnNldFNlbGVjdGlvbmAgcmVzZXRzIHRoZSBzdG9yZWQgbWFya3NcbiAgICAvLyBzbyB3ZeKAmWxsIHJlc3RvcmUgdGhlbSBpZiB0aGUgc2VsZWN0aW9uIGlzIHRoZSBzYW1lIGFzIGJlZm9yZVxuICAgIGlmIChpc1NhbWVTZWxlY3Rpb24gJiYgdHIuc3RvcmVkTWFya3MpIHtcbiAgICAgIHRyLnNldFN0b3JlZE1hcmtzKHRyLnN0b3JlZE1hcmtzKVxuICAgIH1cblxuICAgIGRlbGF5ZWRGb2N1cygpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IENvbW1hbmRQcm9wcywgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGZvckVhY2g6IHtcbiAgICAgIC8qKlxuICAgICAgICogTG9vcCB0aHJvdWdoIGFuIGFycmF5IG9mIGl0ZW1zLlxuICAgICAgICovXG4gICAgICBmb3JFYWNoOiA8VD4oXG4gICAgICAgIGl0ZW1zOiBUW10sXG4gICAgICAgIGZuOiAoXG4gICAgICAgICAgaXRlbTogVCxcbiAgICAgICAgICBwcm9wczogQ29tbWFuZFByb3BzICYge1xuICAgICAgICAgICAgaW5kZXg6IG51bWJlcixcbiAgICAgICAgICB9LFxuICAgICAgICApID0+IGJvb2xlYW4sXG4gICAgICApID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBmb3JFYWNoOiBSYXdDb21tYW5kc1snZm9yRWFjaCddID0gKGl0ZW1zLCBmbikgPT4gcHJvcHMgPT4ge1xuICByZXR1cm4gaXRlbXMuZXZlcnkoKGl0ZW0sIGluZGV4KSA9PiBmbihpdGVtLCB7IC4uLnByb3BzLCBpbmRleCB9KSlcbn1cbiIsICJpbXBvcnQgeyBQYXJzZU9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBDb250ZW50LCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgaW5zZXJ0Q29udGVudDoge1xuICAgICAgLyoqXG4gICAgICAgKiBJbnNlcnQgYSBub2RlIG9yIHN0cmluZyBvZiBIVE1MIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICovXG4gICAgICBpbnNlcnRDb250ZW50OiAoXG4gICAgICAgIHZhbHVlOiBDb250ZW50LFxuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgIHBhcnNlT3B0aW9ucz86IFBhcnNlT3B0aW9uc1xuICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbj86IGJvb2xlYW5cbiAgICAgICAgfSxcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgaW5zZXJ0Q29udGVudDogUmF3Q29tbWFuZHNbJ2luc2VydENvbnRlbnQnXSA9ICh2YWx1ZSwgb3B0aW9ucykgPT4gKHsgdHIsIGNvbW1hbmRzIH0pID0+IHtcbiAgcmV0dXJuIGNvbW1hbmRzLmluc2VydENvbnRlbnRBdChcbiAgICB7IGZyb206IHRyLnNlbGVjdGlvbi5mcm9tLCB0bzogdHIuc2VsZWN0aW9uLnRvIH0sXG4gICAgdmFsdWUsXG4gICAgb3B0aW9ucyxcbiAgKVxufVxuIiwgImNvbnN0IHJlbW92ZVdoaXRlc3BhY2VzID0gKG5vZGU6IEhUTUxFbGVtZW50KSA9PiB7XG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzXG5cbiAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXVxuXG4gICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAzICYmIGNoaWxkLm5vZGVWYWx1ZSAmJiAvXihcXG5cXHNcXHN8XFxuKSQvLnRlc3QoY2hpbGQubm9kZVZhbHVlKSkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZClcbiAgICB9IGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICByZW1vdmVXaGl0ZXNwYWNlcyhjaGlsZCBhcyBIVE1MRWxlbWVudClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudEZyb21TdHJpbmcodmFsdWU6IHN0cmluZyk6IEhUTUxFbGVtZW50IHtcbiAgLy8gYWRkIGEgd3JhcHBlciB0byBwcmVzZXJ2ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gIGNvbnN0IHdyYXBwZWRWYWx1ZSA9IGA8Ym9keT4ke3ZhbHVlfTwvYm9keT5gXG5cbiAgY29uc3QgaHRtbCA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHdyYXBwZWRWYWx1ZSwgJ3RleHQvaHRtbCcpLmJvZHlcblxuICByZXR1cm4gcmVtb3ZlV2hpdGVzcGFjZXMoaHRtbClcbn1cbiIsICJpbXBvcnQge1xuICBET01QYXJzZXIsXG4gIEZyYWdtZW50LFxuICBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSxcbiAgUGFyc2VPcHRpb25zLFxuICBTY2hlbWEsXG59IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IENvbnRlbnQgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGVsZW1lbnRGcm9tU3RyaW5nIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2VsZW1lbnRGcm9tU3RyaW5nLmpzJ1xuXG5leHBvcnQgdHlwZSBDcmVhdGVOb2RlRnJvbUNvbnRlbnRPcHRpb25zID0ge1xuICBzbGljZT86IGJvb2xlYW5cbiAgcGFyc2VPcHRpb25zPzogUGFyc2VPcHRpb25zXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoXG4gIGNvbnRlbnQ6IENvbnRlbnQsXG4gIHNjaGVtYTogU2NoZW1hLFxuICBvcHRpb25zPzogQ3JlYXRlTm9kZUZyb21Db250ZW50T3B0aW9ucyxcbik6IFByb3NlTWlycm9yTm9kZSB8IEZyYWdtZW50IHtcbiAgb3B0aW9ucyA9IHtcbiAgICBzbGljZTogdHJ1ZSxcbiAgICBwYXJzZU9wdGlvbnM6IHt9LFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdvYmplY3QnICYmIGNvbnRlbnQgIT09IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudCkgJiYgY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tQXJyYXkoY29udGVudC5tYXAoaXRlbSA9PiBzY2hlbWEubm9kZUZyb21KU09OKGl0ZW0pKSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNjaGVtYS5ub2RlRnJvbUpTT04oY29udGVudClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBJbnZhbGlkIGNvbnRlbnQuJywgJ1Bhc3NlZCB2YWx1ZTonLCBjb250ZW50LCAnRXJyb3I6JywgZXJyb3IpXG5cbiAgICAgIHJldHVybiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoJycsIHNjaGVtYSwgb3B0aW9ucylcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgcGFyc2VyID0gRE9NUGFyc2VyLmZyb21TY2hlbWEoc2NoZW1hKVxuXG4gICAgcmV0dXJuIG9wdGlvbnMuc2xpY2VcbiAgICAgID8gcGFyc2VyLnBhcnNlU2xpY2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKS5jb250ZW50XG4gICAgICA6IHBhcnNlci5wYXJzZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KCcnLCBzY2hlbWEsIG9wdGlvbnMpXG59XG4iLCAiaW1wb3J0IHsgU2VsZWN0aW9uLCBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBSZXBsYWNlQXJvdW5kU3RlcCwgUmVwbGFjZVN0ZXAgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3Itc3RhdGUvYmxvYi9tYXN0ZXIvc3JjL3NlbGVjdGlvbi5qcyNMNDY2XG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHI6IFRyYW5zYWN0aW9uLCBzdGFydExlbjogbnVtYmVyLCBiaWFzOiBudW1iZXIpIHtcbiAgY29uc3QgbGFzdCA9IHRyLnN0ZXBzLmxlbmd0aCAtIDFcblxuICBpZiAobGFzdCA8IHN0YXJ0TGVuKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBzdGVwID0gdHIuc3RlcHNbbGFzdF1cblxuICBpZiAoIShzdGVwIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXAgfHwgc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VBcm91bmRTdGVwKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgbWFwID0gdHIubWFwcGluZy5tYXBzW2xhc3RdXG4gIGxldCBlbmQgPSAwXG5cbiAgbWFwLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4ge1xuICAgIGlmIChlbmQgPT09IDApIHtcbiAgICAgIGVuZCA9IG5ld1RvXG4gICAgfVxuICB9KVxuXG4gIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShlbmQpLCBiaWFzKSlcbn1cbiIsICJpbXBvcnQgeyBGcmFnbWVudCwgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsIFBhcnNlT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGNyZWF0ZU5vZGVGcm9tQ29udGVudCB9IGZyb20gJy4uL2hlbHBlcnMvY3JlYXRlTm9kZUZyb21Db250ZW50LmpzJ1xuaW1wb3J0IHsgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQgfSBmcm9tICcuLi9oZWxwZXJzL3NlbGVjdGlvblRvSW5zZXJ0aW9uRW5kLmpzJ1xuaW1wb3J0IHsgQ29udGVudCwgUmFuZ2UsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBpbnNlcnRDb250ZW50QXQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSW5zZXJ0IGEgbm9kZSBvciBzdHJpbmcgb2YgSFRNTCBhdCBhIHNwZWNpZmljIHBvc2l0aW9uLlxuICAgICAgICovXG4gICAgICBpbnNlcnRDb250ZW50QXQ6IChcbiAgICAgICAgcG9zaXRpb246IG51bWJlciB8IFJhbmdlLFxuICAgICAgICB2YWx1ZTogQ29udGVudCxcbiAgICAgICAgb3B0aW9ucz86IHtcbiAgICAgICAgICBwYXJzZU9wdGlvbnM/OiBQYXJzZU9wdGlvbnNcbiAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24/OiBib29sZWFuXG4gICAgICAgIH0sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaXNGcmFnbWVudCA9IChub2RlT3JGcmFnbWVudDogUHJvc2VNaXJyb3JOb2RlIHwgRnJhZ21lbnQpOiBub2RlT3JGcmFnbWVudCBpcyBGcmFnbWVudCA9PiB7XG4gIHJldHVybiBub2RlT3JGcmFnbWVudC50b1N0cmluZygpLnN0YXJ0c1dpdGgoJzwnKVxufVxuXG5leHBvcnQgY29uc3QgaW5zZXJ0Q29udGVudEF0OiBSYXdDb21tYW5kc1snaW5zZXJ0Q29udGVudEF0J10gPSAocG9zaXRpb24sIHZhbHVlLCBvcHRpb25zKSA9PiAoeyB0ciwgZGlzcGF0Y2gsIGVkaXRvciB9KSA9PiB7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBwYXJzZU9wdGlvbnM6IHt9LFxuICAgICAgdXBkYXRlU2VsZWN0aW9uOiB0cnVlLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50ID0gY3JlYXRlTm9kZUZyb21Db250ZW50KHZhbHVlLCBlZGl0b3Iuc2NoZW1hLCB7XG4gICAgICBwYXJzZU9wdGlvbnM6IHtcbiAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAnZnVsbCcsXG4gICAgICAgIC4uLm9wdGlvbnMucGFyc2VPcHRpb25zLFxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgLy8gZG9u4oCZdCBkaXNwYXRjaCBhbiBlbXB0eSBmcmFnbWVudCBiZWNhdXNlIHRoaXMgY2FuIGxlYWQgdG8gc3RyYW5nZSBlcnJvcnNcbiAgICBpZiAoY29udGVudC50b1N0cmluZygpID09PSAnPD4nKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGxldCB7IGZyb20sIHRvIH0gPSB0eXBlb2YgcG9zaXRpb24gPT09ICdudW1iZXInID8geyBmcm9tOiBwb3NpdGlvbiwgdG86IHBvc2l0aW9uIH0gOiB7IGZyb206IHBvc2l0aW9uLmZyb20sIHRvOiBwb3NpdGlvbi50byB9XG5cbiAgICBsZXQgaXNPbmx5VGV4dENvbnRlbnQgPSB0cnVlXG4gICAgbGV0IGlzT25seUJsb2NrQ29udGVudCA9IHRydWVcbiAgICBjb25zdCBub2RlcyA9IGlzRnJhZ21lbnQoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdXG5cbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgLy8gY2hlY2sgaWYgYWRkZWQgbm9kZSBpcyB2YWxpZFxuICAgICAgbm9kZS5jaGVjaygpXG5cbiAgICAgIGlzT25seVRleHRDb250ZW50ID0gaXNPbmx5VGV4dENvbnRlbnQgPyBub2RlLmlzVGV4dCAmJiBub2RlLm1hcmtzLmxlbmd0aCA9PT0gMCA6IGZhbHNlXG5cbiAgICAgIGlzT25seUJsb2NrQ29udGVudCA9IGlzT25seUJsb2NrQ29udGVudCA/IG5vZGUuaXNCbG9jayA6IGZhbHNlXG4gICAgfSlcblxuICAgIC8vIGNoZWNrIGlmIHdlIGNhbiByZXBsYWNlIHRoZSB3cmFwcGluZyBub2RlIGJ5XG4gICAgLy8gdGhlIG5ld2x5IGluc2VydGVkIGNvbnRlbnRcbiAgICAvLyBleGFtcGxlOlxuICAgIC8vIHJlcGxhY2UgYW4gZW1wdHkgcGFyYWdyYXBoIGJ5IGFuIGluc2VydGVkIGltYWdlXG4gICAgLy8gaW5zdGVhZCBvZiBpbnNlcnRpbmcgdGhlIGltYWdlIGJlbG93IHRoZSBwYXJhZ3JhcGhcbiAgICBpZiAoZnJvbSA9PT0gdG8gJiYgaXNPbmx5QmxvY2tDb250ZW50KSB7XG4gICAgICBjb25zdCB7IHBhcmVudCB9ID0gdHIuZG9jLnJlc29sdmUoZnJvbSlcbiAgICAgIGNvbnN0IGlzRW1wdHlUZXh0QmxvY2sgPSBwYXJlbnQuaXNUZXh0YmxvY2sgJiYgIXBhcmVudC50eXBlLnNwZWMuY29kZSAmJiAhcGFyZW50LmNoaWxkQ291bnRcblxuICAgICAgaWYgKGlzRW1wdHlUZXh0QmxvY2spIHtcbiAgICAgICAgZnJvbSAtPSAxXG4gICAgICAgIHRvICs9IDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBvbmx5IHBsYWluIHRleHQgd2UgaGF2ZSB0byB1c2UgYGluc2VydFRleHRgXG4gICAgLy8gYmVjYXVzZSB0aGlzIHdpbGwga2VlcCB0aGUgY3VycmVudCBtYXJrc1xuICAgIGlmIChpc09ubHlUZXh0Q29udGVudCkge1xuICAgICAgLy8gaWYgdmFsdWUgaXMgc3RyaW5nLCB3ZSBjYW4gdXNlIGl0IGRpcmVjdGx5XG4gICAgICAvLyBvdGhlcndpc2UgaWYgaXQgaXMgYW4gYXJyYXksIHdlIGhhdmUgdG8gam9pbiBpdFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRyLmluc2VydFRleHQodmFsdWUubWFwKHYgPT4gdi50ZXh0IHx8ICcnKS5qb2luKCcnKSwgZnJvbSwgdG8pXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgISF2YWx1ZSAmJiAhIXZhbHVlLnRleHQpIHtcbiAgICAgICAgdHIuaW5zZXJ0VGV4dCh2YWx1ZS50ZXh0LCBmcm9tLCB0bylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyLmluc2VydFRleHQodmFsdWUgYXMgc3RyaW5nLCBmcm9tLCB0bylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHIucmVwbGFjZVdpdGgoZnJvbSwgdG8sIGNvbnRlbnQpXG4gICAgfVxuXG4gICAgLy8gc2V0IGN1cnNvciBhdCBlbmQgb2YgaW5zZXJ0ZWQgY29udGVudFxuICAgIGlmIChvcHRpb25zLnVwZGF0ZVNlbGVjdGlvbikge1xuICAgICAgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIHRyLnN0ZXBzLmxlbmd0aCAtIDEsIC0xKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHtcbiAgam9pbkJhY2t3YXJkIGFzIG9yaWdpbmFsSm9pbkJhY2t3YXJkLFxuICBqb2luRG93biBhcyBvcmlnaW5hbEpvaW5Eb3duLFxuICBqb2luRm9yd2FyZCBhcyBvcmlnaW5hbEpvaW5Gb3J3YXJkLFxuICBqb2luVXAgYXMgb3JpZ2luYWxKb2luVXAsXG59IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBqb2luVXA6IHtcbiAgICAgIC8qKlxuICAgICAgICogSm9pbiB0d28gbm9kZXMgVXAuXG4gICAgICAgKi9cbiAgICAgIGpvaW5VcDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgICBqb2luRG93bjoge1xuICAgICAgLyoqXG4gICAgICAgKiBKb2luIHR3byBub2RlcyBEb3duLlxuICAgICAgICovXG4gICAgICBqb2luRG93bjogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgICBqb2luQmFja3dhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSm9pbiB0d28gbm9kZXMgQmFja3dhcmRzLlxuICAgICAgICovXG4gICAgICBqb2luQmFja3dhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gICAgam9pbkZvcndhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSm9pbiB0d28gbm9kZXMgRm9yd2FyZHMuXG4gICAgICAgKi9cbiAgICAgIGpvaW5Gb3J3YXJkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBqb2luVXA6IFJhd0NvbW1hbmRzWydqb2luVXAnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEpvaW5VcChzdGF0ZSwgZGlzcGF0Y2gpXG59XG5cbmV4cG9ydCBjb25zdCBqb2luRG93bjogUmF3Q29tbWFuZHNbJ2pvaW5Eb3duJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxKb2luRG93bihzdGF0ZSwgZGlzcGF0Y2gpXG59XG5cbmV4cG9ydCBjb25zdCBqb2luQmFja3dhcmQ6IFJhd0NvbW1hbmRzWydqb2luQmFja3dhcmQnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbEpvaW5CYWNrd2FyZChzdGF0ZSwgZGlzcGF0Y2gpXG59XG5cbmV4cG9ydCBjb25zdCBqb2luRm9yd2FyZDogUmF3Q29tbWFuZHNbJ2pvaW5Gb3J3YXJkJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxKb2luRm9yd2FyZChzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgam9pblBvaW50IH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBqb2luSXRlbUJhY2t3YXJkOiB7XG4gICAgICAvKipcbiAgICAgICAqIEpvaW4gdHdvIG5vZGVzIEZvcndhcmRzLlxuICAgICAgICovXG4gICAgICBqb2luSXRlbUJhY2t3YXJkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBqb2luSXRlbUJhY2t3YXJkOiBSYXdDb21tYW5kc1snam9pbkl0ZW1CYWNrd2FyZCddID0gKCkgPT4gKHtcbiAgdHIsIHN0YXRlLCBkaXNwYXRjaCxcbn0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wb3MsIC0xKVxuXG4gICAgaWYgKHBvaW50ID09PSBudWxsIHx8IHBvaW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRyLmpvaW4ocG9pbnQsIDIpXG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGRpc3BhdGNoKHRyKVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG4iLCAiaW1wb3J0IHsgam9pblBvaW50IH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBqb2luSXRlbUZvcndhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogSm9pbiB0d28gbm9kZXMgRm9yd2FyZHMuXG4gICAgICAgKi9cbiAgICAgIGpvaW5JdGVtRm9yd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgam9pbkl0ZW1Gb3J3YXJkOiBSYXdDb21tYW5kc1snam9pbkl0ZW1Gb3J3YXJkJ10gPSAoKSA9PiAoe1xuICBzdGF0ZSxcbiAgZGlzcGF0Y2gsXG4gIHRyLFxufSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBvcywgKzEpXG5cbiAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdHIuam9pbihwb2ludCwgMilcblxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgZGlzcGF0Y2godHIpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG4iLCAiaW1wb3J0IHsgam9pblRleHRibG9ja0JhY2t3YXJkIGFzIG9yaWdpbmFsQ29tbWFuZCB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBqb2luVGV4dGJsb2NrQmFja3dhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogQSBtb3JlIGxpbWl0ZWQgZm9ybSBvZiBqb2luQmFja3dhcmQgdGhhdCBvbmx5IHRyaWVzIHRvIGpvaW4gdGhlIGN1cnJlbnQgdGV4dGJsb2NrIHRvIHRoZSBvbmUgYmVmb3JlIGl0LCBpZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jay5cbiAgICAgICAqL1xuICAgICAgam9pblRleHRibG9ja0JhY2t3YXJkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBqb2luVGV4dGJsb2NrQmFja3dhcmQ6IFJhd0NvbW1hbmRzWydqb2luVGV4dGJsb2NrQmFja3dhcmQnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbENvbW1hbmQoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IGpvaW5UZXh0YmxvY2tGb3J3YXJkIGFzIG9yaWdpbmFsQ29tbWFuZCB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBqb2luVGV4dGJsb2NrRm9yd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBBIG1vcmUgbGltaXRlZCBmb3JtIG9mIGpvaW5Gb3J3YXJkIHRoYXQgb25seSB0cmllcyB0byBqb2luIHRoZSBjdXJyZW50IHRleHRibG9jayB0byB0aGUgb25lIGFmdGVyIGl0LCBpZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2suXG4gICAgICAgKi9cbiAgICAgIGpvaW5UZXh0YmxvY2tGb3J3YXJkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBqb2luVGV4dGJsb2NrRm9yd2FyZDogUmF3Q29tbWFuZHNbJ2pvaW5UZXh0YmxvY2tGb3J3YXJkJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxDb21tYW5kKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNNYWNPUygpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnXG4gICAgPyAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbiAgICA6IGZhbHNlXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGlzaU9TIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2lzaU9TLmpzJ1xuaW1wb3J0IHsgaXNNYWNPUyB9IGZyb20gJy4uL3V0aWxpdGllcy9pc01hY09TLmpzJ1xuXG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWU6IHN0cmluZykge1xuICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pXG4gIGxldCByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXVxuXG4gIGlmIChyZXN1bHQgPT09ICdTcGFjZScpIHtcbiAgICByZXN1bHQgPSAnICdcbiAgfVxuXG4gIGxldCBhbHRcbiAgbGV0IGN0cmxcbiAgbGV0IHNoaWZ0XG4gIGxldCBtZXRhXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICBjb25zdCBtb2QgPSBwYXJ0c1tpXVxuXG4gICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSkge1xuICAgICAgbWV0YSA9IHRydWVcbiAgICB9IGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSkge1xuICAgICAgYWx0ID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSkge1xuICAgICAgY3RybCA9IHRydWVcbiAgICB9IGVsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKSB7XG4gICAgICBzaGlmdCA9IHRydWVcbiAgICB9IGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QobW9kKSkge1xuICAgICAgaWYgKGlzaU9TKCkgfHwgaXNNYWNPUygpKSB7XG4gICAgICAgIG1ldGEgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHJsID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiAke21vZH1gKVxuICAgIH1cbiAgfVxuXG4gIGlmIChhbHQpIHtcbiAgICByZXN1bHQgPSBgQWx0LSR7cmVzdWx0fWBcbiAgfVxuXG4gIGlmIChjdHJsKSB7XG4gICAgcmVzdWx0ID0gYEN0cmwtJHtyZXN1bHR9YFxuICB9XG5cbiAgaWYgKG1ldGEpIHtcbiAgICByZXN1bHQgPSBgTWV0YS0ke3Jlc3VsdH1gXG4gIH1cblxuICBpZiAoc2hpZnQpIHtcbiAgICByZXN1bHQgPSBgU2hpZnQtJHtyZXN1bHR9YFxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAga2V5Ym9hcmRTaG9ydGN1dDoge1xuICAgICAgLyoqXG4gICAgICAgKiBUcmlnZ2VyIGEga2V5Ym9hcmQgc2hvcnRjdXQuXG4gICAgICAgKi9cbiAgICAgIGtleWJvYXJkU2hvcnRjdXQ6IChuYW1lOiBzdHJpbmcpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBrZXlib2FyZFNob3J0Y3V0OiBSYXdDb21tYW5kc1sna2V5Ym9hcmRTaG9ydGN1dCddID0gbmFtZSA9PiAoe1xuICBlZGl0b3IsXG4gIHZpZXcsXG4gIHRyLFxuICBkaXNwYXRjaCxcbn0pID0+IHtcbiAgY29uc3Qga2V5cyA9IG5vcm1hbGl6ZUtleU5hbWUobmFtZSkuc3BsaXQoLy0oPyEkKS8pXG4gIGNvbnN0IGtleSA9IGtleXMuZmluZChpdGVtID0+ICFbJ0FsdCcsICdDdHJsJywgJ01ldGEnLCAnU2hpZnQnXS5pbmNsdWRlcyhpdGVtKSlcbiAgY29uc3QgZXZlbnQgPSBuZXcgS2V5Ym9hcmRFdmVudCgna2V5ZG93bicsIHtcbiAgICBrZXk6IGtleSA9PT0gJ1NwYWNlJ1xuICAgICAgPyAnICdcbiAgICAgIDoga2V5LFxuICAgIGFsdEtleToga2V5cy5pbmNsdWRlcygnQWx0JyksXG4gICAgY3RybEtleToga2V5cy5pbmNsdWRlcygnQ3RybCcpLFxuICAgIG1ldGFLZXk6IGtleXMuaW5jbHVkZXMoJ01ldGEnKSxcbiAgICBzaGlmdEtleToga2V5cy5pbmNsdWRlcygnU2hpZnQnKSxcbiAgICBidWJibGVzOiB0cnVlLFxuICAgIGNhbmNlbGFibGU6IHRydWUsXG4gIH0pXG5cbiAgY29uc3QgY2FwdHVyZWRUcmFuc2FjdGlvbiA9IGVkaXRvci5jYXB0dXJlVHJhbnNhY3Rpb24oKCkgPT4ge1xuICAgIHZpZXcuc29tZVByb3AoJ2hhbmRsZUtleURvd24nLCBmID0+IGYodmlldywgZXZlbnQpKVxuICB9KVxuXG4gIGNhcHR1cmVkVHJhbnNhY3Rpb24/LnN0ZXBzLmZvckVhY2goc3RlcCA9PiB7XG4gICAgY29uc3QgbmV3U3RlcCA9IHN0ZXAubWFwKHRyLm1hcHBpbmcpXG5cbiAgICBpZiAobmV3U3RlcCAmJiBkaXNwYXRjaCkge1xuICAgICAgdHIubWF5YmVTdGVwKG5ld1N0ZXApXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBOb2RlUmFuZ2UgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG9iamVjdEluY2x1ZGVzIH0gZnJvbSAnLi4vdXRpbGl0aWVzL29iamVjdEluY2x1ZGVzLmpzJ1xuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuL2dldE5vZGVUeXBlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNOb2RlQWN0aXZlKFxuICBzdGF0ZTogRWRpdG9yU3RhdGUsXG4gIHR5cGVPck5hbWU6IE5vZGVUeXBlIHwgc3RyaW5nIHwgbnVsbCxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgZnJvbSwgdG8sIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb25cbiAgY29uc3QgdHlwZSA9IHR5cGVPck5hbWUgPyBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpIDogbnVsbFxuXG4gIGNvbnN0IG5vZGVSYW5nZXM6IE5vZGVSYW5nZVtdID0gW11cblxuICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByZWxhdGl2ZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpXG4gICAgY29uc3QgcmVsYXRpdmVUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBub2RlLm5vZGVTaXplKVxuXG4gICAgbm9kZVJhbmdlcy5wdXNoKHtcbiAgICAgIG5vZGUsXG4gICAgICBmcm9tOiByZWxhdGl2ZUZyb20sXG4gICAgICB0bzogcmVsYXRpdmVUbyxcbiAgICB9KVxuICB9KVxuXG4gIGNvbnN0IHNlbGVjdGlvblJhbmdlID0gdG8gLSBmcm9tXG4gIGNvbnN0IG1hdGNoZWROb2RlUmFuZ2VzID0gbm9kZVJhbmdlc1xuICAgIC5maWx0ZXIobm9kZVJhbmdlID0+IHtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZS5uYW1lID09PSBub2RlUmFuZ2Uubm9kZS50eXBlLm5hbWVcbiAgICB9KVxuICAgIC5maWx0ZXIobm9kZVJhbmdlID0+IG9iamVjdEluY2x1ZGVzKG5vZGVSYW5nZS5ub2RlLmF0dHJzLCBhdHRyaWJ1dGVzLCB7IHN0cmljdDogZmFsc2UgfSkpXG5cbiAgaWYgKGVtcHR5KSB7XG4gICAgcmV0dXJuICEhbWF0Y2hlZE5vZGVSYW5nZXMubGVuZ3RoXG4gIH1cblxuICBjb25zdCByYW5nZSA9IG1hdGNoZWROb2RlUmFuZ2VzLnJlZHVjZSgoc3VtLCBub2RlUmFuZ2UpID0+IHN1bSArIG5vZGVSYW5nZS50byAtIG5vZGVSYW5nZS5mcm9tLCAwKVxuXG4gIHJldHVybiByYW5nZSA+PSBzZWxlY3Rpb25SYW5nZVxufVxuIiwgImltcG9ydCB7IGxpZnQgYXMgb3JpZ2luYWxMaWZ0IH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcbmltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgaXNOb2RlQWN0aXZlIH0gZnJvbSAnLi4vaGVscGVycy9pc05vZGVBY3RpdmUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgbGlmdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFuIGV4aXN0aW5nIHdyYXAuXG4gICAgICAgKi9cbiAgICAgIGxpZnQ6ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGxpZnQ6IFJhd0NvbW1hbmRzWydsaWZ0J10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCBpc0FjdGl2ZSA9IGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcylcblxuICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gb3JpZ2luYWxMaWZ0KHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBsaWZ0RW1wdHlCbG9jayBhcyBvcmlnaW5hbExpZnRFbXB0eUJsb2NrIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGxpZnRFbXB0eUJsb2NrOiB7XG4gICAgICAvKipcbiAgICAgICAqIExpZnQgYmxvY2sgaWYgZW1wdHkuXG4gICAgICAgKi9cbiAgICAgIGxpZnRFbXB0eUJsb2NrOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbGlmdEVtcHR5QmxvY2s6IFJhd0NvbW1hbmRzWydsaWZ0RW1wdHlCbG9jayddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsTGlmdEVtcHR5QmxvY2soc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IGxpZnRMaXN0SXRlbSBhcyBvcmlnaW5hbExpZnRMaXN0SXRlbSB9IGZyb20gJ0B0aXB0YXAvcG0vc2NoZW1hLWxpc3QnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBsaWZ0TGlzdEl0ZW06IHtcbiAgICAgIC8qKlxuICAgICAgICogTGlmdCB0aGUgbGlzdCBpdGVtIGludG8gYSB3cmFwcGluZyBsaXN0LlxuICAgICAgICovXG4gICAgICBsaWZ0TGlzdEl0ZW06ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbGlmdExpc3RJdGVtOiBSYXdDb21tYW5kc1snbGlmdExpc3RJdGVtJ10gPSB0eXBlT3JOYW1lID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgcmV0dXJuIG9yaWdpbmFsTGlmdExpc3RJdGVtKHR5cGUpKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBuZXdsaW5lSW5Db2RlIGFzIG9yaWdpbmFsTmV3bGluZUluQ29kZSB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBuZXdsaW5lSW5Db2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIEFkZCBhIG5ld2xpbmUgY2hhcmFjdGVyIGluIGNvZGUuXG4gICAgICAgKi9cbiAgICAgIG5ld2xpbmVJbkNvZGU6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG5ld2xpbmVJbkNvZGU6IFJhd0NvbW1hbmRzWyduZXdsaW5lSW5Db2RlJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxOZXdsaW5lSW5Db2RlKHN0YXRlLCBkaXNwYXRjaClcbn1cbiIsICJpbXBvcnQgeyBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUobmFtZTogc3RyaW5nLCBzY2hlbWE6IFNjaGVtYSk6ICdub2RlJyB8ICdtYXJrJyB8IG51bGwge1xuICBpZiAoc2NoZW1hLm5vZGVzW25hbWVdKSB7XG4gICAgcmV0dXJuICdub2RlJ1xuICB9XG5cbiAgaWYgKHNjaGVtYS5tYXJrc1tuYW1lXSkge1xuICAgIHJldHVybiAnbWFyaydcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG4iLCAiLyoqXG4gKiBSZW1vdmUgYSBwcm9wZXJ0eSBvciBhbiBhcnJheSBvZiBwcm9wZXJ0aWVzIGZyb20gYW4gb2JqZWN0XG4gKiBAcGFyYW0gb2JqIE9iamVjdFxuICogQHBhcmFtIGtleSBLZXkgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVQcm9wcyhvYmo6IFJlY29yZDxzdHJpbmcsIGFueT4sIHByb3BPclByb3BzOiBzdHJpbmcgfCBzdHJpbmdbXSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCBwcm9wcyA9IHR5cGVvZiBwcm9wT3JQcm9wcyA9PT0gJ3N0cmluZydcbiAgICA/IFtwcm9wT3JQcm9wc11cbiAgICA6IHByb3BPclByb3BzXG5cbiAgcmV0dXJuIE9iamVjdFxuICAgIC5rZXlzKG9iailcbiAgICAucmVkdWNlKChuZXdPYmo6IFJlY29yZDxzdHJpbmcsIGFueT4sIHByb3ApID0+IHtcbiAgICAgIGlmICghcHJvcHMuaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgICAgbmV3T2JqW3Byb3BdID0gb2JqW3Byb3BdXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdPYmpcbiAgICB9LCB7fSlcbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZGVsZXRlUHJvcHMgfSBmcm9tICcuLi91dGlsaXRpZXMvZGVsZXRlUHJvcHMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICByZXNldEF0dHJpYnV0ZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVzZXRzIHNvbWUgbm9kZSBhdHRyaWJ1dGVzIHRvIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAgICovXG4gICAgICByZXNldEF0dHJpYnV0ZXM6IChcbiAgICAgICAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUgfCBNYXJrVHlwZSxcbiAgICAgICAgYXR0cmlidXRlczogc3RyaW5nIHwgc3RyaW5nW10sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlc2V0QXR0cmlidXRlczogUmF3Q29tbWFuZHNbJ3Jlc2V0QXR0cmlidXRlcyddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMpID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBsZXQgbm9kZVR5cGU6IE5vZGVUeXBlIHwgbnVsbCA9IG51bGxcbiAgbGV0IG1hcmtUeXBlOiBNYXJrVHlwZSB8IG51bGwgPSBudWxsXG5cbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKFxuICAgIHR5cGVvZiB0eXBlT3JOYW1lID09PSAnc3RyaW5nJyA/IHR5cGVPck5hbWUgOiB0eXBlT3JOYW1lLm5hbWUsXG4gICAgc3RhdGUuc2NoZW1hLFxuICApXG5cbiAgaWYgKCFzY2hlbWFUeXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgbm9kZVR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lIGFzIE5vZGVUeXBlLCBzdGF0ZS5zY2hlbWEpXG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgbWFya1R5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lIGFzIE1hcmtUeXBlLCBzdGF0ZS5zY2hlbWEpXG4gIH1cblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5zZWxlY3Rpb24ucmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbihyYW5nZS4kZnJvbS5wb3MsIHJhbmdlLiR0by5wb3MsIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKG5vZGVUeXBlICYmIG5vZGVUeXBlID09PSBub2RlLnR5cGUpIHtcbiAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdW5kZWZpbmVkLCBkZWxldGVQcm9wcyhub2RlLmF0dHJzLCBhdHRyaWJ1dGVzKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXJrVHlwZSAmJiBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgIG5vZGUubWFya3MuZm9yRWFjaChtYXJrID0+IHtcbiAgICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgIHRyLmFkZE1hcmsoXG4gICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgIHBvcyArIG5vZGUubm9kZVNpemUsXG4gICAgICAgICAgICAgICAgbWFya1R5cGUuY3JlYXRlKGRlbGV0ZVByb3BzKG1hcmsuYXR0cnMsIGF0dHJpYnV0ZXMpKSxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNjcm9sbEludG9WaWV3OiB7XG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCB0aGUgc2VsZWN0aW9uIGludG8gdmlldy5cbiAgICAgICAqL1xuICAgICAgc2Nyb2xsSW50b1ZpZXc6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzY3JvbGxJbnRvVmlldzogUmF3Q29tbWFuZHNbJ3Njcm9sbEludG9WaWV3J10gPSAoKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5zY3JvbGxJbnRvVmlldygpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZWxlY3RBbGw6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0IHRoZSB3aG9sZSBkb2N1bWVudC5cbiAgICAgICAqL1xuICAgICAgc2VsZWN0QWxsOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2VsZWN0QWxsOiBSYXdDb21tYW5kc1snc2VsZWN0QWxsJ10gPSAoKSA9PiAoeyB0ciwgY29tbWFuZHMgfSkgPT4ge1xuICByZXR1cm4gY29tbWFuZHMuc2V0VGV4dFNlbGVjdGlvbih7XG4gICAgZnJvbTogMCxcbiAgICB0bzogdHIuZG9jLmNvbnRlbnQuc2l6ZSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBzZWxlY3ROb2RlQmFja3dhcmQgYXMgb3JpZ2luYWxTZWxlY3ROb2RlQmFja3dhcmQgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2VsZWN0Tm9kZUJhY2t3YXJkOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNlbGVjdCBhIG5vZGUgYmFja3dhcmQuXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdE5vZGVCYWNrd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2VsZWN0Tm9kZUJhY2t3YXJkOiBSYXdDb21tYW5kc1snc2VsZWN0Tm9kZUJhY2t3YXJkJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3ROb2RlQmFja3dhcmQoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IHNlbGVjdE5vZGVGb3J3YXJkIGFzIG9yaWdpbmFsU2VsZWN0Tm9kZUZvcndhcmQgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2VsZWN0Tm9kZUZvcndhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0IGEgbm9kZSBmb3J3YXJkLlxuICAgICAgICovXG4gICAgICBzZWxlY3ROb2RlRm9yd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2VsZWN0Tm9kZUZvcndhcmQ6IFJhd0NvbW1hbmRzWydzZWxlY3ROb2RlRm9yd2FyZCddID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0Tm9kZUZvcndhcmQoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IHNlbGVjdFBhcmVudE5vZGUgYXMgb3JpZ2luYWxTZWxlY3RQYXJlbnROb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNlbGVjdFBhcmVudE5vZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0IHRoZSBwYXJlbnQgbm9kZS5cbiAgICAgICAqL1xuICAgICAgc2VsZWN0UGFyZW50Tm9kZTogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2VsZWN0UGFyZW50Tm9kZTogUmF3Q29tbWFuZHNbJ3NlbGVjdFBhcmVudE5vZGUnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbFNlbGVjdFBhcmVudE5vZGUoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgIi8vIEB0cy1pZ25vcmVcbi8vIFRPRE86IGFkZCB0eXBlcyB0byBAdHlwZXMvcHJvc2VtaXJyb3ItY29tbWFuZHNcbmltcG9ydCB7IHNlbGVjdFRleHRibG9ja0VuZCBhcyBvcmlnaW5hbFNlbGVjdFRleHRibG9ja0VuZCB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZWxlY3RUZXh0YmxvY2tFbmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogTW92ZXMgdGhlIGN1cnNvciB0byB0aGUgZW5kIG9mIGN1cnJlbnQgdGV4dCBibG9jay5cbiAgICAgICAqL1xuICAgICAgc2VsZWN0VGV4dGJsb2NrRW5kOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZWxlY3RUZXh0YmxvY2tFbmQ6IFJhd0NvbW1hbmRzWydzZWxlY3RUZXh0YmxvY2tFbmQnXSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIHJldHVybiBvcmlnaW5hbFNlbGVjdFRleHRibG9ja0VuZChzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiLy8gQHRzLWlnbm9yZVxuLy8gVE9ETzogYWRkIHR5cGVzIHRvIEB0eXBlcy9wcm9zZW1pcnJvci1jb21tYW5kc1xuaW1wb3J0IHsgc2VsZWN0VGV4dGJsb2NrU3RhcnQgYXMgb3JpZ2luYWxTZWxlY3RUZXh0YmxvY2tTdGFydCB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZWxlY3RUZXh0YmxvY2tTdGFydDoge1xuICAgICAgLyoqXG4gICAgICAgKiBNb3ZlcyB0aGUgY3Vyc29yIHRvIHRoZSBzdGFydCBvZiBjdXJyZW50IHRleHQgYmxvY2suXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdFRleHRibG9ja1N0YXJ0OiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZWxlY3RUZXh0YmxvY2tTdGFydDogUmF3Q29tbWFuZHNbJ3NlbGVjdFRleHRibG9ja1N0YXJ0J10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICByZXR1cm4gb3JpZ2luYWxTZWxlY3RUZXh0YmxvY2tTdGFydChzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsIFBhcnNlT3B0aW9ucywgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgQ29udGVudCB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY3JlYXRlTm9kZUZyb21Db250ZW50IH0gZnJvbSAnLi9jcmVhdGVOb2RlRnJvbUNvbnRlbnQuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEb2N1bWVudChcbiAgY29udGVudDogQ29udGVudCxcbiAgc2NoZW1hOiBTY2hlbWEsXG4gIHBhcnNlT3B0aW9uczogUGFyc2VPcHRpb25zID0ge30sXG4pOiBQcm9zZU1pcnJvck5vZGUge1xuICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KGNvbnRlbnQsIHNjaGVtYSwgeyBzbGljZTogZmFsc2UsIHBhcnNlT3B0aW9ucyB9KSBhcyBQcm9zZU1pcnJvck5vZGVcbn1cbiIsICJpbXBvcnQgeyBQYXJzZU9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBjcmVhdGVEb2N1bWVudCB9IGZyb20gJy4uL2hlbHBlcnMvY3JlYXRlRG9jdW1lbnQuanMnXG5pbXBvcnQgeyBDb250ZW50LCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2V0Q29udGVudDoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZXBsYWNlIHRoZSB3aG9sZSBkb2N1bWVudCB3aXRoIG5ldyBjb250ZW50LlxuICAgICAgICovXG4gICAgICBzZXRDb250ZW50OiAoXG4gICAgICAgIGNvbnRlbnQ6IENvbnRlbnQsXG4gICAgICAgIGVtaXRVcGRhdGU/OiBib29sZWFuLFxuICAgICAgICBwYXJzZU9wdGlvbnM/OiBQYXJzZU9wdGlvbnMsXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNldENvbnRlbnQ6IFJhd0NvbW1hbmRzWydzZXRDb250ZW50J10gPSAoY29udGVudCwgZW1pdFVwZGF0ZSA9IGZhbHNlLCBwYXJzZU9wdGlvbnMgPSB7fSkgPT4gKHsgdHIsIGVkaXRvciwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IGRvYyB9ID0gdHJcbiAgY29uc3QgZG9jdW1lbnQgPSBjcmVhdGVEb2N1bWVudChjb250ZW50LCBlZGl0b3Iuc2NoZW1hLCBwYXJzZU9wdGlvbnMpXG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgdHIucmVwbGFjZVdpdGgoMCwgZG9jLmNvbnRlbnQuc2l6ZSwgZG9jdW1lbnQpLnNldE1ldGEoJ3ByZXZlbnRVcGRhdGUnLCAhZW1pdFVwZGF0ZSlcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgTWFyaywgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4vZ2V0TWFya1R5cGUuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJrQXR0cmlidXRlcyhcbiAgc3RhdGU6IEVkaXRvclN0YXRlLFxuICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBNYXJrVHlwZSxcbik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCB7IGZyb20sIHRvLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uXG4gIGNvbnN0IG1hcmtzOiBNYXJrW10gPSBbXVxuXG4gIGlmIChlbXB0eSkge1xuICAgIGlmIChzdGF0ZS5zdG9yZWRNYXJrcykge1xuICAgICAgbWFya3MucHVzaCguLi5zdGF0ZS5zdG9yZWRNYXJrcylcbiAgICB9XG5cbiAgICBtYXJrcy5wdXNoKC4uLnN0YXRlLnNlbGVjdGlvbi4kaGVhZC5tYXJrcygpKVxuICB9IGVsc2Uge1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIG5vZGUgPT4ge1xuICAgICAgbWFya3MucHVzaCguLi5ub2RlLm1hcmtzKVxuICAgIH0pXG4gIH1cblxuICBjb25zdCBtYXJrID0gbWFya3MuZmluZChtYXJrSXRlbSA9PiBtYXJrSXRlbS50eXBlLm5hbWUgPT09IHR5cGUubmFtZSlcblxuICBpZiAoIW1hcmspIHtcbiAgICByZXR1cm4ge31cbiAgfVxuXG4gIHJldHVybiB7IC4uLm1hcmsuYXR0cnMgfVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgYFRyYW5zZm9ybWAgYmFzZWQgb24gYWxsIHN0ZXBzIG9mIHRoZSBwYXNzZWQgdHJhbnNhY3Rpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZVRyYW5zYWN0aW9uU3RlcHMoXG4gIG9sZERvYzogUHJvc2VNaXJyb3JOb2RlLFxuICB0cmFuc2FjdGlvbnM6IFRyYW5zYWN0aW9uW10sXG4pOiBUcmFuc2Zvcm0ge1xuICBjb25zdCB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKG9sZERvYylcblxuICB0cmFuc2FjdGlvbnMuZm9yRWFjaCh0cmFuc2FjdGlvbiA9PiB7XG4gICAgdHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaChzdGVwID0+IHtcbiAgICAgIHRyYW5zZm9ybS5zdGVwKHN0ZXApXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gdHJhbnNmb3JtXG59XG4iLCAiaW1wb3J0IHsgQ29udGVudE1hdGNoLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0QmxvY2tBdChtYXRjaDogQ29udGVudE1hdGNoKTogTm9kZVR5cGUgfCBudWxsIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkgKz0gMSkge1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gbWF0Y2guZWRnZShpKVxuXG4gICAgaWYgKHR5cGUuaXNUZXh0YmxvY2sgJiYgIXR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSB7XG4gICAgICByZXR1cm4gdHlwZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBOb2RlV2l0aFBvcywgUHJlZGljYXRlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQ2hpbGRyZW4obm9kZTogUHJvc2VNaXJyb3JOb2RlLCBwcmVkaWNhdGU6IFByZWRpY2F0ZSk6IE5vZGVXaXRoUG9zW10ge1xuICBjb25zdCBub2Rlc1dpdGhQb3M6IE5vZGVXaXRoUG9zW10gPSBbXVxuXG4gIG5vZGUuZGVzY2VuZGFudHMoKGNoaWxkLCBwb3MpID0+IHtcbiAgICBpZiAocHJlZGljYXRlKGNoaWxkKSkge1xuICAgICAgbm9kZXNXaXRoUG9zLnB1c2goe1xuICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgcG9zLFxuICAgICAgfSlcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIG5vZGVzV2l0aFBvc1xufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgTm9kZVdpdGhQb3MsIFByZWRpY2F0ZSwgUmFuZ2UgfSBmcm9tICcuLi90eXBlcy5qcydcblxuLyoqXG4gKiBTYW1lIGFzIGBmaW5kQ2hpbGRyZW5gIGJ1dCBzZWFyY2hlcyBvbmx5IHdpdGhpbiBhIGByYW5nZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQ2hpbGRyZW5JblJhbmdlKFxuICBub2RlOiBQcm9zZU1pcnJvck5vZGUsXG4gIHJhbmdlOiBSYW5nZSxcbiAgcHJlZGljYXRlOiBQcmVkaWNhdGUsXG4pOiBOb2RlV2l0aFBvc1tdIHtcbiAgY29uc3Qgbm9kZXNXaXRoUG9zOiBOb2RlV2l0aFBvc1tdID0gW11cblxuICAvLyBpZiAocmFuZ2UuZnJvbSA9PT0gcmFuZ2UudG8pIHtcbiAgLy8gICBjb25zdCBub2RlQXQgPSBub2RlLm5vZGVBdChyYW5nZS5mcm9tKVxuXG4gIC8vICAgaWYgKG5vZGVBdCkge1xuICAvLyAgICAgbm9kZXNXaXRoUG9zLnB1c2goe1xuICAvLyAgICAgICBub2RlOiBub2RlQXQsXG4gIC8vICAgICAgIHBvczogcmFuZ2UuZnJvbSxcbiAgLy8gICAgIH0pXG4gIC8vICAgfVxuICAvLyB9XG5cbiAgbm9kZS5ub2Rlc0JldHdlZW4ocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIChjaGlsZCwgcG9zKSA9PiB7XG4gICAgaWYgKHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgIHBvcyxcbiAgICAgIH0pXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBub2Rlc1dpdGhQb3Ncbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgUmVzb2x2ZWRQb3MgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBQcmVkaWNhdGUgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zKFxuICAkcG9zOiBSZXNvbHZlZFBvcyxcbiAgcHJlZGljYXRlOiBQcmVkaWNhdGUsXG4pOlxuICB8IHtcbiAgICAgIHBvczogbnVtYmVyXG4gICAgICBzdGFydDogbnVtYmVyXG4gICAgICBkZXB0aDogbnVtYmVyXG4gICAgICBub2RlOiBQcm9zZU1pcnJvck5vZGVcbiAgICB9XG4gIHwgdW5kZWZpbmVkIHtcbiAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGg7IGkgPiAwOyBpIC09IDEpIHtcbiAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGkpXG5cbiAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3M6IGkgPiAwID8gJHBvcy5iZWZvcmUoaSkgOiAwLFxuICAgICAgICBzdGFydDogJHBvcy5zdGFydChpKSxcbiAgICAgICAgZGVwdGg6IGksXG4gICAgICAgIG5vZGUsXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHsgU2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgUHJlZGljYXRlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBmaW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1BvcyB9IGZyb20gJy4vZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUGFyZW50Tm9kZShwcmVkaWNhdGU6IFByZWRpY2F0ZSkge1xuICByZXR1cm4gKHNlbGVjdGlvbjogU2VsZWN0aW9uKSA9PiBmaW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1BvcyhzZWxlY3Rpb24uJGZyb20sIHByZWRpY2F0ZSlcbn1cbiIsICJpbXBvcnQgeyBET01TZXJpYWxpemVyLCBGcmFnbWVudCwgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhUTUxGcm9tRnJhZ21lbnQoZnJhZ21lbnQ6IEZyYWdtZW50LCBzY2hlbWE6IFNjaGVtYSk6IHN0cmluZyB7XG4gIGNvbnN0IGRvY3VtZW50RnJhZ21lbnQgPSBET01TZXJpYWxpemVyLmZyb21TY2hlbWEoc2NoZW1hKS5zZXJpYWxpemVGcmFnbWVudChmcmFnbWVudClcblxuICBjb25zdCB0ZW1wb3JhcnlEb2N1bWVudCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgpXG4gIGNvbnN0IGNvbnRhaW5lciA9IHRlbXBvcmFyeURvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50RnJhZ21lbnQpXG5cbiAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbn1cbiIsICJpbXBvcnQgeyBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBFZGl0b3IgfSBmcm9tICcuLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBFeHRlbnNpb25NYW5hZ2VyIH0gZnJvbSAnLi4vRXh0ZW5zaW9uTWFuYWdlci5qcydcbmltcG9ydCB7IEV4dGVuc2lvbnMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zIH0gZnJvbSAnLi9nZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjaGVtYShleHRlbnNpb25zOiBFeHRlbnNpb25zLCBlZGl0b3I/OiBFZGl0b3IpOiBTY2hlbWEge1xuICBjb25zdCByZXNvbHZlZEV4dGVuc2lvbnMgPSBFeHRlbnNpb25NYW5hZ2VyLnJlc29sdmUoZXh0ZW5zaW9ucylcblxuICByZXR1cm4gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMocmVzb2x2ZWRFeHRlbnNpb25zLCBlZGl0b3IpXG59XG4iLCAiaW1wb3J0IHsgTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEV4dGVuc2lvbnMsIEpTT05Db250ZW50IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRIVE1MRnJvbUZyYWdtZW50IH0gZnJvbSAnLi9nZXRIVE1MRnJvbUZyYWdtZW50LmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hIH0gZnJvbSAnLi9nZXRTY2hlbWEuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUhUTUwoZG9jOiBKU09OQ29udGVudCwgZXh0ZW5zaW9uczogRXh0ZW5zaW9ucyk6IHN0cmluZyB7XG4gIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKVxuICBjb25zdCBjb250ZW50Tm9kZSA9IE5vZGUuZnJvbUpTT04oc2NoZW1hLCBkb2MpXG5cbiAgcmV0dXJuIGdldEhUTUxGcm9tRnJhZ21lbnQoY29udGVudE5vZGUuY29udGVudCwgc2NoZW1hKVxufVxuIiwgImltcG9ydCB7IERPTVBhcnNlciB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEV4dGVuc2lvbnMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGVsZW1lbnRGcm9tU3RyaW5nIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2VsZW1lbnRGcm9tU3RyaW5nLmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hIH0gZnJvbSAnLi9nZXRTY2hlbWEuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUpTT04oaHRtbDogc3RyaW5nLCBleHRlbnNpb25zOiBFeHRlbnNpb25zKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKVxuICBjb25zdCBkb20gPSBlbGVtZW50RnJvbVN0cmluZyhodG1sKVxuXG4gIHJldHVybiBET01QYXJzZXIuZnJvbVNjaGVtYShzY2hlbWEpLnBhcnNlKGRvbSkudG9KU09OKClcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IFRleHRTZXJpYWxpemVyIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRUZXh0QmV0d2VlbiB9IGZyb20gJy4vZ2V0VGV4dEJldHdlZW4uanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXh0KFxuICBub2RlOiBQcm9zZU1pcnJvck5vZGUsXG4gIG9wdGlvbnM/OiB7XG4gICAgYmxvY2tTZXBhcmF0b3I/OiBzdHJpbmdcbiAgICB0ZXh0U2VyaWFsaXplcnM/OiBSZWNvcmQ8c3RyaW5nLCBUZXh0U2VyaWFsaXplcj5cbiAgfSxcbikge1xuICBjb25zdCByYW5nZSA9IHtcbiAgICBmcm9tOiAwLFxuICAgIHRvOiBub2RlLmNvbnRlbnQuc2l6ZSxcbiAgfVxuXG4gIHJldHVybiBnZXRUZXh0QmV0d2Vlbihub2RlLCByYW5nZSwgb3B0aW9ucylcbn1cbiIsICJpbXBvcnQgeyBOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgRXh0ZW5zaW9ucywgSlNPTkNvbnRlbnQsIFRleHRTZXJpYWxpemVyIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWEgfSBmcm9tICcuL2dldFNjaGVtYS5qcydcbmltcG9ydCB7IGdldFRleHQgfSBmcm9tICcuL2dldFRleHQuanMnXG5pbXBvcnQgeyBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hIH0gZnJvbSAnLi9nZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVUZXh0KFxuICBkb2M6IEpTT05Db250ZW50LFxuICBleHRlbnNpb25zOiBFeHRlbnNpb25zLFxuICBvcHRpb25zPzoge1xuICAgIGJsb2NrU2VwYXJhdG9yPzogc3RyaW5nXG4gICAgdGV4dFNlcmlhbGl6ZXJzPzogUmVjb3JkPHN0cmluZywgVGV4dFNlcmlhbGl6ZXI+XG4gIH0sXG4pOiBzdHJpbmcge1xuICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gJ1xcblxcbicsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9XG4gIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKVxuICBjb25zdCBjb250ZW50Tm9kZSA9IE5vZGUuZnJvbUpTT04oc2NoZW1hLCBkb2MpXG5cbiAgcmV0dXJuIGdldFRleHQoY29udGVudE5vZGUsIHtcbiAgICBibG9ja1NlcGFyYXRvcixcbiAgICB0ZXh0U2VyaWFsaXplcnM6IHtcbiAgICAgIC4uLmdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hKSxcbiAgICAgIC4uLnRleHRTZXJpYWxpemVycyxcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IE5vZGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuL2dldE5vZGVUeXBlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZUF0dHJpYnV0ZXMoXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZSxcbiAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsXG4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgeyBmcm9tLCB0byB9ID0gc3RhdGUuc2VsZWN0aW9uXG4gIGNvbnN0IG5vZGVzOiBOb2RlW10gPSBbXVxuXG4gIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIG5vZGUgPT4ge1xuICAgIG5vZGVzLnB1c2gobm9kZSlcbiAgfSlcblxuICBjb25zdCBub2RlID0gbm9kZXMucmV2ZXJzZSgpLmZpbmQobm9kZUl0ZW0gPT4gbm9kZUl0ZW0udHlwZS5uYW1lID09PSB0eXBlLm5hbWUpXG5cbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cblxuICByZXR1cm4geyAuLi5ub2RlLmF0dHJzIH1cbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRNYXJrQXR0cmlidXRlcyB9IGZyb20gJy4vZ2V0TWFya0F0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXROb2RlQXR0cmlidXRlcyB9IGZyb20gJy4vZ2V0Tm9kZUF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSB9IGZyb20gJy4vZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVzKFxuICBzdGF0ZTogRWRpdG9yU3RhdGUsXG4gIHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlIHwgTWFya1R5cGUsXG4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKFxuICAgIHR5cGVvZiB0eXBlT3JOYW1lID09PSAnc3RyaW5nJyA/IHR5cGVPck5hbWUgOiB0eXBlT3JOYW1lLm5hbWUsXG4gICAgc3RhdGUuc2NoZW1hLFxuICApXG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdub2RlJykge1xuICAgIHJldHVybiBnZXROb2RlQXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSBhcyBOb2RlVHlwZSlcbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcbiAgICByZXR1cm4gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUgYXMgTWFya1R5cGUpXG4gIH1cblxuICByZXR1cm4ge31cbn1cbiIsICIvKipcbiAqIFJlbW92ZXMgZHVwbGljYXRlZCB2YWx1ZXMgd2l0aGluIGFuIGFycmF5LlxuICogU3VwcG9ydHMgbnVtYmVycywgc3RyaW5ncyBhbmQgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZXM8VD4oYXJyYXk6IFRbXSwgYnkgPSBKU09OLnN0cmluZ2lmeSk6IFRbXSB7XG4gIGNvbnN0IHNlZW46IFJlY29yZDxhbnksIGFueT4gPSB7fVxuXG4gIHJldHVybiBhcnJheS5maWx0ZXIoaXRlbSA9PiB7XG4gICAgY29uc3Qga2V5ID0gYnkoaXRlbSlcblxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2Vlbiwga2V5KVxuICAgICAgPyBmYWxzZVxuICAgICAgOiAoc2VlbltrZXldID0gdHJ1ZSlcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBTdGVwLCBUcmFuc2Zvcm0gfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IHJlbW92ZUR1cGxpY2F0ZXMgfSBmcm9tICcuLi91dGlsaXRpZXMvcmVtb3ZlRHVwbGljYXRlcy5qcydcblxuZXhwb3J0IHR5cGUgQ2hhbmdlZFJhbmdlID0ge1xuICBvbGRSYW5nZTogUmFuZ2UsXG4gIG5ld1JhbmdlOiBSYW5nZSxcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGR1cGxpY2F0ZWQgcmFuZ2VzIGFuZCByYW5nZXMgdGhhdCBhcmVcbiAqIGZ1bGx5IGNhcHR1cmVkIGJ5IG90aGVyIHJhbmdlcy5cbiAqL1xuZnVuY3Rpb24gc2ltcGxpZnlDaGFuZ2VkUmFuZ2VzKGNoYW5nZXM6IENoYW5nZWRSYW5nZVtdKTogQ2hhbmdlZFJhbmdlW10ge1xuICBjb25zdCB1bmlxdWVDaGFuZ2VzID0gcmVtb3ZlRHVwbGljYXRlcyhjaGFuZ2VzKVxuXG4gIHJldHVybiB1bmlxdWVDaGFuZ2VzLmxlbmd0aCA9PT0gMVxuICAgID8gdW5pcXVlQ2hhbmdlc1xuICAgIDogdW5pcXVlQ2hhbmdlcy5maWx0ZXIoKGNoYW5nZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3QgPSB1bmlxdWVDaGFuZ2VzLmZpbHRlcigoXywgaSkgPT4gaSAhPT0gaW5kZXgpXG5cbiAgICAgIHJldHVybiAhcmVzdC5zb21lKG90aGVyQ2hhbmdlID0+IHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZS5vbGRSYW5nZS5mcm9tID49IG90aGVyQ2hhbmdlLm9sZFJhbmdlLmZyb21cbiAgICAgICAgICAmJiBjaGFuZ2Uub2xkUmFuZ2UudG8gPD0gb3RoZXJDaGFuZ2Uub2xkUmFuZ2UudG9cbiAgICAgICAgICAmJiBjaGFuZ2UubmV3UmFuZ2UuZnJvbSA+PSBvdGhlckNoYW5nZS5uZXdSYW5nZS5mcm9tXG4gICAgICAgICAgJiYgY2hhbmdlLm5ld1JhbmdlLnRvIDw9IG90aGVyQ2hhbmdlLm5ld1JhbmdlLnRvXG4gICAgICB9KVxuICAgIH0pXG59XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgY2hhbmdlZCByYW5nZXNcbiAqIGJhc2VkIG9uIHRoZSBmaXJzdCBhbmQgbGFzdCBzdGF0ZSBvZiBhbGwgc3RlcHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGFuZ2VkUmFuZ2VzKHRyYW5zZm9ybTogVHJhbnNmb3JtKTogQ2hhbmdlZFJhbmdlW10ge1xuICBjb25zdCB7IG1hcHBpbmcsIHN0ZXBzIH0gPSB0cmFuc2Zvcm1cbiAgY29uc3QgY2hhbmdlczogQ2hhbmdlZFJhbmdlW10gPSBbXVxuXG4gIG1hcHBpbmcubWFwcy5mb3JFYWNoKChzdGVwTWFwLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHJhbmdlczogUmFuZ2VbXSA9IFtdXG5cbiAgICAvLyBUaGlzIGFjY291bnRzIGZvciBzdGVwIGNoYW5nZXMgd2hlcmUgbm8gcmFuZ2Ugd2FzIGFjdHVhbGx5IGFsdGVyZWRcbiAgICAvLyBlLmcuIHdoZW4gc2V0dGluZyBhIG1hcmssIG5vZGUgYXR0cmlidXRlLCBldGMuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICghc3RlcE1hcC5yYW5nZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSBzdGVwc1tpbmRleF0gYXMgU3RlcCAmIHtcbiAgICAgICAgZnJvbT86IG51bWJlcixcbiAgICAgICAgdG8/OiBudW1iZXIsXG4gICAgICB9XG5cbiAgICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQgfHwgdG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGVwTWFwLmZvckVhY2goKGZyb20sIHRvKSA9PiB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmFuZ2VzLmZvckVhY2goKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgY29uc3QgbmV3U3RhcnQgPSBtYXBwaW5nLnNsaWNlKGluZGV4KS5tYXAoZnJvbSwgLTEpXG4gICAgICBjb25zdCBuZXdFbmQgPSBtYXBwaW5nLnNsaWNlKGluZGV4KS5tYXAodG8pXG4gICAgICBjb25zdCBvbGRTdGFydCA9IG1hcHBpbmcuaW52ZXJ0KCkubWFwKG5ld1N0YXJ0LCAtMSlcbiAgICAgIGNvbnN0IG9sZEVuZCA9IG1hcHBpbmcuaW52ZXJ0KCkubWFwKG5ld0VuZClcblxuICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgb2xkUmFuZ2U6IHtcbiAgICAgICAgICBmcm9tOiBvbGRTdGFydCxcbiAgICAgICAgICB0bzogb2xkRW5kLFxuICAgICAgICB9LFxuICAgICAgICBuZXdSYW5nZToge1xuICAgICAgICAgIGZyb206IG5ld1N0YXJ0LFxuICAgICAgICAgIHRvOiBuZXdFbmQsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHNpbXBsaWZ5Q2hhbmdlZFJhbmdlcyhjaGFuZ2VzKVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgSlNPTkNvbnRlbnQgfSBmcm9tICcuLi90eXBlcy5qcydcblxuaW50ZXJmYWNlIERlYnVnSlNPTkNvbnRlbnQgZXh0ZW5kcyBKU09OQ29udGVudCB7XG4gIGZyb206IG51bWJlclxuICB0bzogbnVtYmVyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWJ1Z0pTT04obm9kZTogUHJvc2VNaXJyb3JOb2RlLCBzdGFydE9mZnNldCA9IDApOiBEZWJ1Z0pTT05Db250ZW50IHtcbiAgY29uc3QgaXNUb3BOb2RlID0gbm9kZS50eXBlID09PSBub2RlLnR5cGUuc2NoZW1hLnRvcE5vZGVUeXBlXG4gIGNvbnN0IGluY3JlbWVudCA9IGlzVG9wTm9kZSA/IDAgOiAxXG4gIGNvbnN0IGZyb20gPSBzdGFydE9mZnNldFxuICBjb25zdCB0byA9IGZyb20gKyBub2RlLm5vZGVTaXplXG4gIGNvbnN0IG1hcmtzID0gbm9kZS5tYXJrcy5tYXAobWFyayA9PiB7XG4gICAgY29uc3Qgb3V0cHV0OiB7IHR5cGU6IHN0cmluZzsgYXR0cnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+IH0gPSB7XG4gICAgICB0eXBlOiBtYXJrLnR5cGUubmFtZSxcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmtleXMobWFyay5hdHRycykubGVuZ3RoKSB7XG4gICAgICBvdXRwdXQuYXR0cnMgPSB7IC4uLm1hcmsuYXR0cnMgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXRcbiAgfSlcbiAgY29uc3QgYXR0cnMgPSB7IC4uLm5vZGUuYXR0cnMgfVxuICBjb25zdCBvdXRwdXQ6IERlYnVnSlNPTkNvbnRlbnQgPSB7XG4gICAgdHlwZTogbm9kZS50eXBlLm5hbWUsXG4gICAgZnJvbSxcbiAgICB0byxcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhhdHRycykubGVuZ3RoKSB7XG4gICAgb3V0cHV0LmF0dHJzID0gYXR0cnNcbiAgfVxuXG4gIGlmIChtYXJrcy5sZW5ndGgpIHtcbiAgICBvdXRwdXQubWFya3MgPSBtYXJrc1xuICB9XG5cbiAgaWYgKG5vZGUuY29udGVudC5jaGlsZENvdW50KSB7XG4gICAgb3V0cHV0LmNvbnRlbnQgPSBbXVxuXG4gICAgbm9kZS5mb3JFYWNoKChjaGlsZCwgb2Zmc2V0KSA9PiB7XG4gICAgICBvdXRwdXQuY29udGVudD8ucHVzaChnZXREZWJ1Z0pTT04oY2hpbGQsIHN0YXJ0T2Zmc2V0ICsgb2Zmc2V0ICsgaW5jcmVtZW50KSlcbiAgICB9KVxuICB9XG5cbiAgaWYgKG5vZGUudGV4dCkge1xuICAgIG91dHB1dC50ZXh0ID0gbm9kZS50ZXh0XG4gIH1cblxuICByZXR1cm4gb3V0cHV0XG59XG4iLCAiaW1wb3J0IHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBNYXJrUmFuZ2UgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGdldE1hcmtSYW5nZSB9IGZyb20gJy4vZ2V0TWFya1JhbmdlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFya3NCZXR3ZWVuKGZyb206IG51bWJlciwgdG86IG51bWJlciwgZG9jOiBQcm9zZU1pcnJvck5vZGUpOiBNYXJrUmFuZ2VbXSB7XG4gIGNvbnN0IG1hcmtzOiBNYXJrUmFuZ2VbXSA9IFtdXG5cbiAgLy8gZ2V0IGFsbCBpbmNsdXNpdmUgbWFya3Mgb24gZW1wdHkgc2VsZWN0aW9uXG4gIGlmIChmcm9tID09PSB0bykge1xuICAgIGRvY1xuICAgICAgLnJlc29sdmUoZnJvbSlcbiAgICAgIC5tYXJrcygpXG4gICAgICAuZm9yRWFjaChtYXJrID0+IHtcbiAgICAgICAgY29uc3QgJHBvcyA9IGRvYy5yZXNvbHZlKGZyb20gLSAxKVxuICAgICAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkcG9zLCBtYXJrLnR5cGUpXG5cbiAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgbWFyayxcbiAgICAgICAgICAuLi5yYW5nZSxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgaWYgKCFub2RlIHx8IG5vZGU/Lm5vZGVTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIG1hcmtzLnB1c2goXG4gICAgICAgIC4uLm5vZGUubWFya3MubWFwKG1hcmsgPT4gKHtcbiAgICAgICAgICBmcm9tOiBwb3MsXG4gICAgICAgICAgdG86IHBvcyArIG5vZGUubm9kZVNpemUsXG4gICAgICAgICAgbWFyayxcbiAgICAgICAgfSkpLFxuICAgICAgKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gbWFya3Ncbn1cbiIsICJpbXBvcnQgeyBOb2RlLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IG5vZGUgb2YgYSBnaXZlbiB0eXBlIG9yIG5hbWUgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICogQHBhcmFtIHN0YXRlIFRoZSBlZGl0b3Igc3RhdGUuXG4gKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgbm9kZSB0eXBlIG9yIG5hbWUuXG4gKiBAcGFyYW0gcG9zIFRoZSBwb3NpdGlvbiB0byBzdGFydCBzZWFyY2hpbmcgZnJvbS5cbiAqIEBwYXJhbSBtYXhEZXB0aCBUaGUgbWF4aW11bSBkZXB0aCB0byBzZWFyY2guXG4gKiBAcmV0dXJucyBUaGUgbm9kZSBhbmQgdGhlIGRlcHRoIGFzIGFuIGFycmF5LlxuICovXG5leHBvcnQgY29uc3QgZ2V0Tm9kZUF0UG9zaXRpb24gPSAoc3RhdGU6IEVkaXRvclN0YXRlLCB0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgcG9zOiBudW1iZXIsIG1heERlcHRoID0gMjApID0+IHtcbiAgY29uc3QgJHBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKHBvcylcblxuICBsZXQgY3VycmVudERlcHRoID0gbWF4RGVwdGhcbiAgbGV0IG5vZGU6IE5vZGUgfCBudWxsID0gbnVsbFxuXG4gIHdoaWxlIChjdXJyZW50RGVwdGggPiAwICYmIG5vZGUgPT09IG51bGwpIHtcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9ICRwb3Mubm9kZShjdXJyZW50RGVwdGgpXG5cbiAgICBpZiAoY3VycmVudE5vZGU/LnR5cGUubmFtZSA9PT0gdHlwZU9yTmFtZSkge1xuICAgICAgbm9kZSA9IGN1cnJlbnROb2RlXG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnREZXB0aCAtPSAxXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtub2RlLCBjdXJyZW50RGVwdGhdIGFzIFtOb2RlIHwgbnVsbCwgbnVtYmVyXVxufVxuIiwgImltcG9ydCB7IEV4dGVuc2lvbkF0dHJpYnV0ZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKFxuICBleHRlbnNpb25BdHRyaWJ1dGVzOiBFeHRlbnNpb25BdHRyaWJ1dGVbXSxcbiAgdHlwZU5hbWU6IHN0cmluZyxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdFxuICAgIC5lbnRyaWVzKGF0dHJpYnV0ZXMpXG4gICAgLmZpbHRlcigoW25hbWVdKSA9PiB7XG4gICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGUgPSBleHRlbnNpb25BdHRyaWJ1dGVzLmZpbmQoaXRlbSA9PiB7XG4gICAgICAgIHJldHVybiBpdGVtLnR5cGUgPT09IHR5cGVOYW1lICYmIGl0ZW0ubmFtZSA9PT0gbmFtZVxuICAgICAgfSlcblxuICAgICAgaWYgKCFleHRlbnNpb25BdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGUuYXR0cmlidXRlLmtlZXBPblNwbGl0XG4gICAgfSkpXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBNYXJrUmFuZ2UgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG9iamVjdEluY2x1ZGVzIH0gZnJvbSAnLi4vdXRpbGl0aWVzL29iamVjdEluY2x1ZGVzLmpzJ1xuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuL2dldE1hcmtUeXBlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNNYXJrQWN0aXZlKFxuICBzdGF0ZTogRWRpdG9yU3RhdGUsXG4gIHR5cGVPck5hbWU6IE1hcmtUeXBlIHwgc3RyaW5nIHwgbnVsbCxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uXG4gIGNvbnN0IHR5cGUgPSB0eXBlT3JOYW1lID8gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKSA6IG51bGxcblxuICBpZiAoZW1wdHkpIHtcbiAgICByZXR1cm4gISEoc3RhdGUuc3RvcmVkTWFya3MgfHwgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXG4gICAgICAuZmlsdGVyKG1hcmsgPT4ge1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gbWFyay50eXBlLm5hbWVcbiAgICAgIH0pXG4gICAgICAuZmluZChtYXJrID0+IG9iamVjdEluY2x1ZGVzKG1hcmsuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSlcbiAgfVxuXG4gIGxldCBzZWxlY3Rpb25SYW5nZSA9IDBcbiAgY29uc3QgbWFya1JhbmdlczogTWFya1JhbmdlW10gPSBbXVxuXG4gIHJhbmdlcy5mb3JFYWNoKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIGNvbnN0IGZyb20gPSAkZnJvbS5wb3NcbiAgICBjb25zdCB0byA9ICR0by5wb3NcblxuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmICghbm9kZS5pc1RleHQgJiYgIW5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCByZWxhdGl2ZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpXG4gICAgICBjb25zdCByZWxhdGl2ZVRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUubm9kZVNpemUpXG4gICAgICBjb25zdCByYW5nZSA9IHJlbGF0aXZlVG8gLSByZWxhdGl2ZUZyb21cblxuICAgICAgc2VsZWN0aW9uUmFuZ2UgKz0gcmFuZ2VcblxuICAgICAgbWFya1Jhbmdlcy5wdXNoKFxuICAgICAgICAuLi5ub2RlLm1hcmtzLm1hcChtYXJrID0+ICh7XG4gICAgICAgICAgbWFyayxcbiAgICAgICAgICBmcm9tOiByZWxhdGl2ZUZyb20sXG4gICAgICAgICAgdG86IHJlbGF0aXZlVG8sXG4gICAgICAgIH0pKSxcbiAgICAgIClcbiAgICB9KVxuICB9KVxuXG4gIGlmIChzZWxlY3Rpb25SYW5nZSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gY2FsY3VsYXRlIHJhbmdlIG9mIG1hdGNoZWQgbWFya1xuICBjb25zdCBtYXRjaGVkUmFuZ2UgPSBtYXJrUmFuZ2VzXG4gICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4ge1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09IG1hcmtSYW5nZS5tYXJrLnR5cGUubmFtZVxuICAgIH0pXG4gICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4gb2JqZWN0SW5jbHVkZXMobWFya1JhbmdlLm1hcmsuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSlcbiAgICAucmVkdWNlKChzdW0sIG1hcmtSYW5nZSkgPT4gc3VtICsgbWFya1JhbmdlLnRvIC0gbWFya1JhbmdlLmZyb20sIDApXG5cbiAgLy8gY2FsY3VsYXRlIHJhbmdlIG9mIG1hcmtzIHRoYXQgZXhjbHVkZXMgdGhlIHNlYXJjaGVkIG1hcmtcbiAgLy8gZm9yIGV4YW1wbGUgYGNvZGVgIGRvZXNu4oCZdCBhbGxvdyBhbnkgb3RoZXIgbWFya3NcbiAgY29uc3QgZXhjbHVkZWRSYW5nZSA9IG1hcmtSYW5nZXNcbiAgICAuZmlsdGVyKG1hcmtSYW5nZSA9PiB7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcmtSYW5nZS5tYXJrLnR5cGUgIT09IHR5cGUgJiYgbWFya1JhbmdlLm1hcmsudHlwZS5leGNsdWRlcyh0eXBlKVxuICAgIH0pXG4gICAgLnJlZHVjZSgoc3VtLCBtYXJrUmFuZ2UpID0+IHN1bSArIG1hcmtSYW5nZS50byAtIG1hcmtSYW5nZS5mcm9tLCAwKVxuXG4gIC8vIHdlIG9ubHkgaW5jbHVkZSB0aGUgcmVzdWx0IG9mIGBleGNsdWRlZFJhbmdlYFxuICAvLyBpZiB0aGVyZSBpcyBhIG1hdGNoIGF0IGFsbFxuICBjb25zdCByYW5nZSA9IG1hdGNoZWRSYW5nZSA+IDAgPyBtYXRjaGVkUmFuZ2UgKyBleGNsdWRlZFJhbmdlIDogbWF0Y2hlZFJhbmdlXG5cbiAgcmV0dXJuIHJhbmdlID49IHNlbGVjdGlvblJhbmdlXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSB9IGZyb20gJy4vZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUuanMnXG5pbXBvcnQgeyBpc01hcmtBY3RpdmUgfSBmcm9tICcuL2lzTWFya0FjdGl2ZS5qcydcbmltcG9ydCB7IGlzTm9kZUFjdGl2ZSB9IGZyb20gJy4vaXNOb2RlQWN0aXZlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNBY3RpdmUoXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZSxcbiAgbmFtZTogc3RyaW5nIHwgbnVsbCxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogYm9vbGVhbiB7XG4gIGlmICghbmFtZSkge1xuICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG51bGwsIGF0dHJpYnV0ZXMpIHx8IGlzTWFya0FjdGl2ZShzdGF0ZSwgbnVsbCwgYXR0cmlidXRlcylcbiAgfVxuXG4gIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShuYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdub2RlJykge1xuICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMpXG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgcmV0dXJuIGlzTWFya0FjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcylcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgZmluZFBhcmVudE5vZGUgfSBmcm9tICcuL2ZpbmRQYXJlbnROb2RlLmpzJ1xuXG5leHBvcnQgY29uc3QgaXNBdEVuZE9mTm9kZSA9IChzdGF0ZTogRWRpdG9yU3RhdGUsIG5vZGVUeXBlPzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHsgJGZyb20sICR0bywgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uXG5cbiAgaWYgKG5vZGVUeXBlKSB7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlLm5hbWUgPT09IG5vZGVUeXBlKShzdGF0ZS5zZWxlY3Rpb24pXG5cbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0ICRwYXJlbnRQb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwYXJlbnROb2RlLnBvcyArIDEpXG5cbiAgICBpZiAoJGFuY2hvci5wb3MgKyAxID09PSAkcGFyZW50UG9zLmVuZCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKCR0by5wYXJlbnRPZmZzZXQgPCAkdG8ucGFyZW50Lm5vZGVTaXplIC0gMiB8fCAkZnJvbS5wb3MgIT09ICR0by5wb3MpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgY29uc3QgaXNBdFN0YXJ0T2ZOb2RlID0gKHN0YXRlOiBFZGl0b3JTdGF0ZSkgPT4ge1xuICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvblxuXG4gIGlmICgkZnJvbS5wYXJlbnRPZmZzZXQgPiAwIHx8ICRmcm9tLnBvcyAhPT0gJHRvLnBvcykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBOb2RlQ29uZmlnIH0gZnJvbSAnLi4vaW5kZXguanMnXG5pbXBvcnQgeyBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgc3BsaXRFeHRlbnNpb25zIH0gZnJvbSAnLi9zcGxpdEV4dGVuc2lvbnMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xpc3QobmFtZTogc3RyaW5nLCBleHRlbnNpb25zOiBFeHRlbnNpb25zKTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgbm9kZUV4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKVxuICBjb25zdCBleHRlbnNpb24gPSBub2RlRXh0ZW5zaW9ucy5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09PSBuYW1lKVxuXG4gIGlmICghZXh0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICB9XG4gIGNvbnN0IGdyb3VwID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2dyb3VwJ10+KGV4dGVuc2lvbiwgJ2dyb3VwJywgY29udGV4dCkpXG5cbiAgaWYgKHR5cGVvZiBncm91cCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBncm91cC5zcGxpdCgnICcpLmluY2x1ZGVzKCdsaXN0Jylcbn1cbiIsICJpbXBvcnQgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVFbXB0eShub2RlOiBQcm9zZU1pcnJvck5vZGUpOiBib29sZWFuIHtcbiAgY29uc3QgZGVmYXVsdENvbnRlbnQgPSBub2RlLnR5cGUuY3JlYXRlQW5kRmlsbCgpPy50b0pTT04oKVxuICBjb25zdCBjb250ZW50ID0gbm9kZS50b0pTT04oKVxuXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShkZWZhdWx0Q29udGVudCkgPT09IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpXG59XG4iLCAiaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vZGVTZWxlY3Rpb24odmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBOb2RlU2VsZWN0aW9uIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvblxufVxuIiwgImltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnXG5cbmltcG9ydCB7IG1pbk1heCB9IGZyb20gJy4uL3V0aWxpdGllcy9taW5NYXguanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBwb3NUb0RPTVJlY3QodmlldzogRWRpdG9yVmlldywgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyKTogRE9NUmVjdCB7XG4gIGNvbnN0IG1pblBvcyA9IDBcbiAgY29uc3QgbWF4UG9zID0gdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplXG4gIGNvbnN0IHJlc29sdmVkRnJvbSA9IG1pbk1heChmcm9tLCBtaW5Qb3MsIG1heFBvcylcbiAgY29uc3QgcmVzb2x2ZWRFbmQgPSBtaW5NYXgodG8sIG1pblBvcywgbWF4UG9zKVxuICBjb25zdCBzdGFydCA9IHZpZXcuY29vcmRzQXRQb3MocmVzb2x2ZWRGcm9tKVxuICBjb25zdCBlbmQgPSB2aWV3LmNvb3Jkc0F0UG9zKHJlc29sdmVkRW5kLCAtMSlcbiAgY29uc3QgdG9wID0gTWF0aC5taW4oc3RhcnQudG9wLCBlbmQudG9wKVxuICBjb25zdCBib3R0b20gPSBNYXRoLm1heChzdGFydC5ib3R0b20sIGVuZC5ib3R0b20pXG4gIGNvbnN0IGxlZnQgPSBNYXRoLm1pbihzdGFydC5sZWZ0LCBlbmQubGVmdClcbiAgY29uc3QgcmlnaHQgPSBNYXRoLm1heChzdGFydC5yaWdodCwgZW5kLnJpZ2h0KVxuICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdFxuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3BcbiAgY29uc3QgeCA9IGxlZnRcbiAgY29uc3QgeSA9IHRvcFxuICBjb25zdCBkYXRhID0ge1xuICAgIHRvcCxcbiAgICBib3R0b20sXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5LFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIHRvSlNPTjogKCkgPT4gZGF0YSxcbiAgfVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlLCBSZXNvbHZlZFBvcyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSwgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRNYXJrQXR0cmlidXRlcyB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya0F0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBpc1RleHRTZWxlY3Rpb24gfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNldE1hcms6IHtcbiAgICAgIC8qKlxuICAgICAgICogQWRkIGEgbWFyayB3aXRoIG5ldyBhdHRyaWJ1dGVzLlxuICAgICAgICovXG4gICAgICBzZXRNYXJrOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTWFya1R5cGUsIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhblNldE1hcmsoc3RhdGU6IEVkaXRvclN0YXRlLCB0cjogVHJhbnNhY3Rpb24sIG5ld01hcmtUeXBlOiBNYXJrVHlwZSkge1xuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHJcbiAgbGV0IGN1cnNvcjogUmVzb2x2ZWRQb3MgfCBudWxsID0gbnVsbFxuXG4gIGlmIChpc1RleHRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGN1cnNvciA9IHNlbGVjdGlvbi4kY3Vyc29yXG4gIH1cblxuICBpZiAoY3Vyc29yKSB7XG4gICAgY29uc3QgY3VycmVudE1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3MgPz8gY3Vyc29yLm1hcmtzKClcblxuICAgIC8vIFRoZXJlIGNhbiBiZSBubyBjdXJyZW50IG1hcmtzIHRoYXQgZXhjbHVkZSB0aGUgbmV3IG1hcmtcbiAgICByZXR1cm4gKFxuICAgICAgISFuZXdNYXJrVHlwZS5pc0luU2V0KGN1cnJlbnRNYXJrcylcbiAgICAgIHx8ICFjdXJyZW50TWFya3Muc29tZShtYXJrID0+IG1hcmsudHlwZS5leGNsdWRlcyhuZXdNYXJrVHlwZSkpXG4gICAgKVxuICB9XG5cbiAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvblxuXG4gIHJldHVybiByYW5nZXMuc29tZSgoeyAkZnJvbSwgJHRvIH0pID0+IHtcbiAgICBsZXQgc29tZU5vZGVTdXBwb3J0c01hcmsgPSAkZnJvbS5kZXB0aCA9PT0gMFxuICAgICAgPyBzdGF0ZS5kb2MuaW5saW5lQ29udGVudCAmJiBzdGF0ZS5kb2MudHlwZS5hbGxvd3NNYXJrVHlwZShuZXdNYXJrVHlwZSlcbiAgICAgIDogZmFsc2VcblxuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgX3BvcywgcGFyZW50KSA9PiB7XG4gICAgICAvLyBJZiB3ZSBhbHJlYWR5IGZvdW5kIGEgbWFyayB0aGF0IHdlIGNhbiBlbmFibGUsIHJldHVybiBmYWxzZSB0byBieXBhc3MgdGhlIHJlbWFpbmluZyBzZWFyY2hcbiAgICAgIGlmIChzb21lTm9kZVN1cHBvcnRzTWFyaykge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuaXNJbmxpbmUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50QWxsb3dzTWFya1R5cGUgPSAhcGFyZW50IHx8IHBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKVxuICAgICAgICBjb25zdCBjdXJyZW50TWFya3NBbGxvd01hcmtUeXBlID0gISFuZXdNYXJrVHlwZS5pc0luU2V0KG5vZGUubWFya3MpXG4gICAgICAgICAgfHwgIW5vZGUubWFya3Muc29tZShvdGhlck1hcmsgPT4gb3RoZXJNYXJrLnR5cGUuZXhjbHVkZXMobmV3TWFya1R5cGUpKVxuXG4gICAgICAgIHNvbWVOb2RlU3VwcG9ydHNNYXJrID0gcGFyZW50QWxsb3dzTWFya1R5cGUgJiYgY3VycmVudE1hcmtzQWxsb3dNYXJrVHlwZVxuICAgICAgfVxuICAgICAgcmV0dXJuICFzb21lTm9kZVN1cHBvcnRzTWFya1xuICAgIH0pXG5cbiAgICByZXR1cm4gc29tZU5vZGVTdXBwb3J0c01hcmtcbiAgfSlcbn1cbmV4cG9ydCBjb25zdCBzZXRNYXJrOiBSYXdDb21tYW5kc1snc2V0TWFyayddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0clxuICBjb25zdCB7IGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvblxuICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGlmIChlbXB0eSkge1xuICAgICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlKVxuXG4gICAgICB0ci5hZGRTdG9yZWRNYXJrKFxuICAgICAgICB0eXBlLmNyZWF0ZSh7XG4gICAgICAgICAgLi4ub2xkQXR0cmlidXRlcyxcbiAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICBjb25zdCBmcm9tID0gcmFuZ2UuJGZyb20ucG9zXG4gICAgICAgIGNvbnN0IHRvID0gcmFuZ2UuJHRvLnBvc1xuXG4gICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICBjb25zdCB0cmltbWVkRnJvbSA9IE1hdGgubWF4KHBvcywgZnJvbSlcbiAgICAgICAgICBjb25zdCB0cmltbWVkVG8gPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0bylcbiAgICAgICAgICBjb25zdCBzb21lSGFzTWFyayA9IG5vZGUubWFya3MuZmluZChtYXJrID0+IG1hcmsudHlwZSA9PT0gdHlwZSlcblxuICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBtYXJrIG9mIHRoaXMgdHlwZVxuICAgICAgICAgIC8vIHdlIGtub3cgdGhhdCB3ZSBoYXZlIHRvIG1lcmdlIGl0cyBhdHRyaWJ1dGVzXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGFkZCBhIGZyZXNoIG5ldyBtYXJrXG4gICAgICAgICAgaWYgKHNvbWVIYXNNYXJrKSB7XG4gICAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgICAgICAgIGlmICh0eXBlID09PSBtYXJrLnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKFxuICAgICAgICAgICAgICAgICAgdHJpbW1lZEZyb20sXG4gICAgICAgICAgICAgICAgICB0cmltbWVkVG8sXG4gICAgICAgICAgICAgICAgICB0eXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyLmFkZE1hcmsodHJpbW1lZEZyb20sIHRyaW1tZWRUbywgdHlwZS5jcmVhdGUoYXR0cmlidXRlcykpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FuU2V0TWFyayhzdGF0ZSwgdHIsIHR5cGUpXG59XG4iLCAiaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNldE1ldGE6IHtcbiAgICAgIC8qKlxuICAgICAgICogU3RvcmUgYSBtZXRhZGF0YSBwcm9wZXJ0eSBpbiB0aGUgY3VycmVudCB0cmFuc2FjdGlvbi5cbiAgICAgICAqL1xuICAgICAgc2V0TWV0YTogKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2V0TWV0YTogUmF3Q29tbWFuZHNbJ3NldE1ldGEnXSA9IChrZXksIHZhbHVlKSA9PiAoeyB0ciB9KSA9PiB7XG4gIHRyLnNldE1ldGEoa2V5LCB2YWx1ZSlcblxuICByZXR1cm4gdHJ1ZVxufVxuIiwgImltcG9ydCB7IHNldEJsb2NrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5pbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZXROb2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlcGxhY2UgYSBnaXZlbiByYW5nZSB3aXRoIGEgbm9kZS5cbiAgICAgICAqL1xuICAgICAgc2V0Tm9kZTogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2V0Tm9kZTogUmF3Q29tbWFuZHNbJ3NldE5vZGUnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCwgY2hhaW4gfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIC8vIFRPRE86IHVzZSBhIGZhbGxiYWNrIGxpa2UgaW5zZXJ0Q29udGVudD9cbiAgaWYgKCF0eXBlLmlzVGV4dGJsb2NrKSB7XG4gICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBDdXJyZW50bHkgXCJzZXROb2RlKClcIiBvbmx5IHN1cHBvcnRzIHRleHQgYmxvY2sgbm9kZXMuJylcblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICBjaGFpbigpXG4gICAgLy8gdHJ5IHRvIGNvbnZlcnQgbm9kZSB0byBkZWZhdWx0IG5vZGUgaWYgbmVlZGVkXG4gICAgICAuY29tbWFuZCgoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhblNldEJsb2NrID0gc2V0QmxvY2tUeXBlKHR5cGUsIGF0dHJpYnV0ZXMpKHN0YXRlKVxuXG4gICAgICAgIGlmIChjYW5TZXRCbG9jaykge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpXG4gICAgICB9KVxuICAgICAgLmNvbW1hbmQoKHsgc3RhdGU6IHVwZGF0ZWRTdGF0ZSB9KSA9PiB7XG4gICAgICAgIHJldHVybiBzZXRCbG9ja1R5cGUodHlwZSwgYXR0cmlidXRlcykodXBkYXRlZFN0YXRlLCBkaXNwYXRjaClcbiAgICAgIH0pXG4gICAgICAucnVuKClcbiAgKVxufVxuIiwgImltcG9ydCB7IE5vZGVTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgbWluTWF4IH0gZnJvbSAnLi4vdXRpbGl0aWVzL21pbk1heC5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNldE5vZGVTZWxlY3Rpb246IHtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIE5vZGVTZWxlY3Rpb24uXG4gICAgICAgKi9cbiAgICAgIHNldE5vZGVTZWxlY3Rpb246IChwb3NpdGlvbjogbnVtYmVyKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZXROb2RlU2VsZWN0aW9uOiBSYXdDb21tYW5kc1snc2V0Tm9kZVNlbGVjdGlvbiddID0gcG9zaXRpb24gPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgeyBkb2MgfSA9IHRyXG4gICAgY29uc3QgZnJvbSA9IG1pbk1heChwb3NpdGlvbiwgMCwgZG9jLmNvbnRlbnQuc2l6ZSlcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIGZyb20pXG5cbiAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgUmFuZ2UsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBtaW5NYXggfSBmcm9tICcuLi91dGlsaXRpZXMvbWluTWF4LmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2V0VGV4dFNlbGVjdGlvbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgVGV4dFNlbGVjdGlvbi5cbiAgICAgICAqL1xuICAgICAgc2V0VGV4dFNlbGVjdGlvbjogKHBvc2l0aW9uOiBudW1iZXIgfCBSYW5nZSkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2V0VGV4dFNlbGVjdGlvbjogUmF3Q29tbWFuZHNbJ3NldFRleHRTZWxlY3Rpb24nXSA9IHBvc2l0aW9uID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHsgZG9jIH0gPSB0clxuICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHR5cGVvZiBwb3NpdGlvbiA9PT0gJ251bWJlcicgPyB7IGZyb206IHBvc2l0aW9uLCB0bzogcG9zaXRpb24gfSA6IHBvc2l0aW9uXG4gICAgY29uc3QgbWluUG9zID0gVGV4dFNlbGVjdGlvbi5hdFN0YXJ0KGRvYykuZnJvbVxuICAgIGNvbnN0IG1heFBvcyA9IFRleHRTZWxlY3Rpb24uYXRFbmQoZG9jKS50b1xuICAgIGNvbnN0IHJlc29sdmVkRnJvbSA9IG1pbk1heChmcm9tLCBtaW5Qb3MsIG1heFBvcylcbiAgICBjb25zdCByZXNvbHZlZEVuZCA9IG1pbk1heCh0bywgbWluUG9zLCBtYXhQb3MpXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCByZXNvbHZlZEZyb20sIHJlc29sdmVkRW5kKVxuXG4gICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbilcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgc2lua0xpc3RJdGVtIGFzIG9yaWdpbmFsU2lua0xpc3RJdGVtIH0gZnJvbSAnQHRpcHRhcC9wbS9zY2hlbWEtbGlzdCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNpbmtMaXN0SXRlbToge1xuICAgICAgLyoqXG4gICAgICAgKiBTaW5rIHRoZSBsaXN0IGl0ZW0gZG93biBpbnRvIGFuIGlubmVyIGxpc3QuXG4gICAgICAgKi9cbiAgICAgIHNpbmtMaXN0SXRlbTogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzaW5rTGlzdEl0ZW06IFJhd0NvbW1hbmRzWydzaW5rTGlzdEl0ZW0nXSA9IHR5cGVPck5hbWUgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcblxuICByZXR1cm4gb3JpZ2luYWxTaW5rTGlzdEl0ZW0odHlwZSkoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCB7IEVkaXRvclN0YXRlLCBOb2RlU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IGNhblNwbGl0IH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IGRlZmF1bHRCbG9ja0F0IH0gZnJvbSAnLi4vaGVscGVycy9kZWZhdWx0QmxvY2tBdC5qcydcbmltcG9ydCB7IGdldFNwbGl0dGVkQXR0cmlidXRlcyB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZnVuY3Rpb24gZW5zdXJlTWFya3Moc3RhdGU6IEVkaXRvclN0YXRlLCBzcGxpdHRhYmxlTWFya3M/OiBzdHJpbmdbXSkge1xuICBjb25zdCBtYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzIHx8IChzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSlcblxuICBpZiAobWFya3MpIHtcbiAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzPy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpXG5cbiAgICBzdGF0ZS50ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKVxuICB9XG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzcGxpdEJsb2NrOiB7XG4gICAgICAvKipcbiAgICAgICAqIEZvcmtzIGEgbmV3IG5vZGUgZnJvbSBhbiBleGlzdGluZyBub2RlLlxuICAgICAgICovXG4gICAgICBzcGxpdEJsb2NrOiAob3B0aW9ucz86IHsga2VlcE1hcmtzPzogYm9vbGVhbiB9KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzcGxpdEJsb2NrOiBSYXdDb21tYW5kc1snc3BsaXRCbG9jayddID0gKHsga2VlcE1hcmtzID0gdHJ1ZSB9ID0ge30pID0+ICh7XG4gIHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGVkaXRvcixcbn0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdHJcbiAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzZWxlY3Rpb25cbiAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmF0dHJpYnV0ZXNcbiAgY29uc3QgbmV3QXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhcbiAgICBleHRlbnNpb25BdHRyaWJ1dGVzLFxuICAgICRmcm9tLm5vZGUoKS50eXBlLm5hbWUsXG4gICAgJGZyb20ubm9kZSgpLmF0dHJzLFxuICApXG5cbiAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc2VsZWN0aW9uLm5vZGUuaXNCbG9jaykge1xuICAgIGlmICghJGZyb20ucGFyZW50T2Zmc2V0IHx8ICFjYW5TcGxpdChkb2MsICRmcm9tLnBvcykpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgaWYgKGtlZXBNYXJrcykge1xuICAgICAgICBlbnN1cmVNYXJrcyhzdGF0ZSwgZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuc3BsaXR0YWJsZU1hcmtzKVxuICAgICAgfVxuXG4gICAgICB0ci5zcGxpdCgkZnJvbS5wb3MpLnNjcm9sbEludG9WaWV3KClcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKCEkZnJvbS5wYXJlbnQuaXNCbG9jaykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgYXRFbmQgPSAkdG8ucGFyZW50T2Zmc2V0ID09PSAkdG8ucGFyZW50LmNvbnRlbnQuc2l6ZVxuXG4gICAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgIHRyLmRlbGV0ZVNlbGVjdGlvbigpXG4gICAgfVxuXG4gICAgY29uc3QgZGVmbHQgPSAkZnJvbS5kZXB0aCA9PT0gMFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogZGVmYXVsdEJsb2NrQXQoJGZyb20ubm9kZSgtMSkuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcigtMSkpKVxuXG4gICAgbGV0IHR5cGVzID0gYXRFbmQgJiYgZGVmbHRcbiAgICAgID8gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogZGVmbHQsXG4gICAgICAgICAgYXR0cnM6IG5ld0F0dHJpYnV0ZXMsXG4gICAgICAgIH0sXG4gICAgICBdXG4gICAgICA6IHVuZGVmaW5lZFxuXG4gICAgbGV0IGNhbiA9IGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpXG5cbiAgICBpZiAoXG4gICAgICAhdHlwZXNcbiAgICAgICAgJiYgIWNhblxuICAgICAgICAmJiBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIGRlZmx0ID8gW3sgdHlwZTogZGVmbHQgfV0gOiB1bmRlZmluZWQpXG4gICAgKSB7XG4gICAgICBjYW4gPSB0cnVlXG4gICAgICB0eXBlcyA9IGRlZmx0XG4gICAgICAgID8gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IGRlZmx0LFxuICAgICAgICAgICAgYXR0cnM6IG5ld0F0dHJpYnV0ZXMsXG4gICAgICAgICAgfSxcbiAgICAgICAgXVxuICAgICAgICA6IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmIChjYW4pIHtcbiAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKVxuXG4gICAgICBpZiAoZGVmbHQgJiYgIWF0RW5kICYmICEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJGZyb20ucGFyZW50LnR5cGUgIT09IGRlZmx0KSB7XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gdHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpXG4gICAgICAgIGNvbnN0ICRmaXJzdCA9IHRyLmRvYy5yZXNvbHZlKGZpcnN0KVxuXG4gICAgICAgIGlmICgkZnJvbS5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkZmlyc3QuaW5kZXgoKSwgJGZpcnN0LmluZGV4KCkgKyAxLCBkZWZsdCkpIHtcbiAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKSwgZGVmbHQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2VlcE1hcmtzKSB7XG4gICAgICBlbnN1cmVNYXJrcyhzdGF0ZSwgZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuc3BsaXR0YWJsZU1hcmtzKVxuICAgIH1cblxuICAgIHRyLnNjcm9sbEludG9WaWV3KClcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHtcbiAgRnJhZ21lbnQsIE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLCBOb2RlVHlwZSwgU2xpY2UsXG59IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IGNhblNwbGl0IH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGdldFNwbGl0dGVkQXR0cmlidXRlcyB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNwbGl0TGlzdEl0ZW06IHtcbiAgICAgIC8qKlxuICAgICAgICogU3BsaXRzIG9uZSBsaXN0IGl0ZW0gaW50byB0d28gbGlzdCBpdGVtcy5cbiAgICAgICAqL1xuICAgICAgc3BsaXRMaXN0SXRlbTogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzcGxpdExpc3RJdGVtOiBSYXdDb21tYW5kc1snc3BsaXRMaXN0SXRlbSddID0gdHlwZU9yTmFtZSA9PiAoe1xuICB0ciwgc3RhdGUsIGRpc3BhdGNoLCBlZGl0b3IsXG59KSA9PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uXG5cbiAgLy8gQHRzLWlnbm9yZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBjb25zdCBub2RlOiBQcm9zZU1pcnJvck5vZGUgPSBzdGF0ZS5zZWxlY3Rpb24ubm9kZVxuXG4gIGlmICgobm9kZSAmJiBub2RlLmlzQmxvY2spIHx8ICRmcm9tLmRlcHRoIDwgMiB8fCAhJGZyb20uc2FtZVBhcmVudCgkdG8pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBncmFuZFBhcmVudCA9ICRmcm9tLm5vZGUoLTEpXG5cbiAgaWYgKGdyYW5kUGFyZW50LnR5cGUgIT09IHR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5hdHRyaWJ1dGVzXG5cbiAgaWYgKCRmcm9tLnBhcmVudC5jb250ZW50LnNpemUgPT09IDAgJiYgJGZyb20ubm9kZSgtMSkuY2hpbGRDb3VudCA9PT0gJGZyb20uaW5kZXhBZnRlcigtMSkpIHtcbiAgICAvLyBJbiBhbiBlbXB0eSBibG9jay4gSWYgdGhpcyBpcyBhIG5lc3RlZCBsaXN0LCB0aGUgd3JhcHBpbmdcbiAgICAvLyBsaXN0IGl0ZW0gc2hvdWxkIGJlIHNwbGl0LiBPdGhlcndpc2UsIGJhaWwgb3V0IGFuZCBsZXQgbmV4dFxuICAgIC8vIGNvbW1hbmQgaGFuZGxlIGxpZnRpbmcuXG4gICAgaWYgKFxuICAgICAgJGZyb20uZGVwdGggPT09IDJcbiAgICAgICAgfHwgJGZyb20ubm9kZSgtMykudHlwZSAhPT0gdHlwZVxuICAgICAgICB8fCAkZnJvbS5pbmRleCgtMikgIT09ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgLSAxXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGxldCB3cmFwID0gRnJhZ21lbnQuZW1wdHlcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBjb25zdCBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogM1xuXG4gICAgICAvLyBCdWlsZCBhIGZyYWdtZW50IGNvbnRhaW5pbmcgZW1wdHkgdmVyc2lvbnMgb2YgdGhlIHN0cnVjdHVyZVxuICAgICAgLy8gZnJvbSB0aGUgb3V0ZXIgbGlzdCBpdGVtIHRvIHRoZSBwYXJlbnQgbm9kZSBvZiB0aGUgY3Vyc29yXG4gICAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGggLSBkZXB0aEJlZm9yZTsgZCA+PSAkZnJvbS5kZXB0aCAtIDM7IGQgLT0gMSkge1xuICAgICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkod3JhcCkpXG4gICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBjb25zdCBkZXB0aEFmdGVyID0gJGZyb20uaW5kZXhBZnRlcigtMSkgPCAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50ID8gMSA6ICRmcm9tLmluZGV4QWZ0ZXIoLTIpIDwgJGZyb20ubm9kZSgtMykuY2hpbGRDb3VudCA/IDIgOiAzXG5cbiAgICAgIC8vIEFkZCBhIHNlY29uZCBsaXN0IGl0ZW0gd2l0aCBhbiBlbXB0eSBkZWZhdWx0IHN0YXJ0IG5vZGVcbiAgICAgIGNvbnN0IG5ld05leHRUeXBlQXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhcbiAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcyxcbiAgICAgICAgJGZyb20ubm9kZSgpLnR5cGUubmFtZSxcbiAgICAgICAgJGZyb20ubm9kZSgpLmF0dHJzLFxuICAgICAgKVxuICAgICAgY29uc3QgbmV4dFR5cGUgPSB0eXBlLmNvbnRlbnRNYXRjaC5kZWZhdWx0VHlwZT8uY3JlYXRlQW5kRmlsbChuZXdOZXh0VHlwZUF0dHJpYnV0ZXMpIHx8IHVuZGVmaW5lZFxuXG4gICAgICB3cmFwID0gd3JhcC5hcHBlbmQoRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZUFuZEZpbGwobnVsbCwgbmV4dFR5cGUpIHx8IHVuZGVmaW5lZCkpXG5cbiAgICAgIGNvbnN0IHN0YXJ0ID0gJGZyb20uYmVmb3JlKCRmcm9tLmRlcHRoIC0gKGRlcHRoQmVmb3JlIC0gMSkpXG5cbiAgICAgIHRyLnJlcGxhY2Uoc3RhcnQsICRmcm9tLmFmdGVyKC1kZXB0aEFmdGVyKSwgbmV3IFNsaWNlKHdyYXAsIDQgLSBkZXB0aEJlZm9yZSwgMCkpXG5cbiAgICAgIGxldCBzZWwgPSAtMVxuXG4gICAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKHN0YXJ0LCB0ci5kb2MuY29udGVudC5zaXplLCAobiwgcG9zKSA9PiB7XG4gICAgICAgIGlmIChzZWwgPiAtMSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4uaXNUZXh0YmxvY2sgJiYgbi5jb250ZW50LnNpemUgPT09IDApIHtcbiAgICAgICAgICBzZWwgPSBwb3MgKyAxXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGlmIChzZWwgPiAtMSkge1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKHNlbCkpKVxuICAgICAgfVxuXG4gICAgICB0ci5zY3JvbGxJbnRvVmlldygpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNvbnN0IG5leHRUeXBlID0gJHRvLnBvcyA9PT0gJGZyb20uZW5kKCkgPyBncmFuZFBhcmVudC5jb250ZW50TWF0Y2hBdCgwKS5kZWZhdWx0VHlwZSA6IG51bGxcblxuICBjb25zdCBuZXdUeXBlQXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhcbiAgICBleHRlbnNpb25BdHRyaWJ1dGVzLFxuICAgIGdyYW5kUGFyZW50LnR5cGUubmFtZSxcbiAgICBncmFuZFBhcmVudC5hdHRycyxcbiAgKVxuICBjb25zdCBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgPSBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMoXG4gICAgZXh0ZW5zaW9uQXR0cmlidXRlcyxcbiAgICAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLFxuICAgICRmcm9tLm5vZGUoKS5hdHRycyxcbiAgKVxuXG4gIHRyLmRlbGV0ZSgkZnJvbS5wb3MsICR0by5wb3MpXG5cbiAgY29uc3QgdHlwZXMgPSBuZXh0VHlwZVxuICAgID8gW1xuICAgICAgeyB0eXBlLCBhdHRyczogbmV3VHlwZUF0dHJpYnV0ZXMgfSxcbiAgICAgIHsgdHlwZTogbmV4dFR5cGUsIGF0dHJzOiBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgfSxcbiAgICBdXG4gICAgOiBbeyB0eXBlLCBhdHRyczogbmV3VHlwZUF0dHJpYnV0ZXMgfV1cblxuICBpZiAoIWNhblNwbGl0KHRyLmRvYywgJGZyb20ucG9zLCAyKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHsgc3BsaXR0YWJsZU1hcmtzIH0gPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlclxuICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKVxuXG4gICAgdHIuc3BsaXQoJGZyb20ucG9zLCAyLCB0eXBlcykuc2Nyb2xsSW50b1ZpZXcoKVxuXG4gICAgaWYgKCFtYXJrcyB8fCAhZGlzcGF0Y2gpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpXG5cbiAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBjYW5Kb2luIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IGZpbmRQYXJlbnROb2RlIH0gZnJvbSAnLi4vaGVscGVycy9maW5kUGFyZW50Tm9kZS5qcydcbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGlzTGlzdCB9IGZyb20gJy4uL2hlbHBlcnMvaXNMaXN0LmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuY29uc3Qgam9pbkxpc3RCYWNrd2FyZHMgPSAodHI6IFRyYW5zYWN0aW9uLCBsaXN0VHlwZTogTm9kZVR5cGUpOiBib29sZWFuID0+IHtcbiAgY29uc3QgbGlzdCA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlID09PSBsaXN0VHlwZSkodHIuc2VsZWN0aW9uKVxuXG4gIGlmICghbGlzdCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShNYXRoLm1heCgwLCBsaXN0LnBvcyAtIDEpKS5iZWZvcmUobGlzdC5kZXB0aClcblxuICBpZiAoYmVmb3JlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3Qgbm9kZUJlZm9yZSA9IHRyLmRvYy5ub2RlQXQoYmVmb3JlKVxuICBjb25zdCBjYW5Kb2luQmFja3dhcmRzID0gbGlzdC5ub2RlLnR5cGUgPT09IG5vZGVCZWZvcmU/LnR5cGUgJiYgY2FuSm9pbih0ci5kb2MsIGxpc3QucG9zKVxuXG4gIGlmICghY2FuSm9pbkJhY2t3YXJkcykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB0ci5qb2luKGxpc3QucG9zKVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmNvbnN0IGpvaW5MaXN0Rm9yd2FyZHMgPSAodHI6IFRyYW5zYWN0aW9uLCBsaXN0VHlwZTogTm9kZVR5cGUpOiBib29sZWFuID0+IHtcbiAgY29uc3QgbGlzdCA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlID09PSBsaXN0VHlwZSkodHIuc2VsZWN0aW9uKVxuXG4gIGlmICghbGlzdCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBhZnRlciA9IHRyLmRvYy5yZXNvbHZlKGxpc3Quc3RhcnQpLmFmdGVyKGxpc3QuZGVwdGgpXG5cbiAgaWYgKGFmdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3Qgbm9kZUFmdGVyID0gdHIuZG9jLm5vZGVBdChhZnRlcilcbiAgY29uc3QgY2FuSm9pbkZvcndhcmRzID0gbGlzdC5ub2RlLnR5cGUgPT09IG5vZGVBZnRlcj8udHlwZSAmJiBjYW5Kb2luKHRyLmRvYywgYWZ0ZXIpXG5cbiAgaWYgKCFjYW5Kb2luRm9yd2FyZHMpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgdHIuam9pbihhZnRlcilcblxuICByZXR1cm4gdHJ1ZVxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdG9nZ2xlTGlzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgbGlzdCB0eXBlcy5cbiAgICAgICAqL1xuICAgICAgdG9nZ2xlTGlzdDogKGxpc3RUeXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgaXRlbVR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBrZWVwTWFya3M/OiBib29sZWFuLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRvZ2dsZUxpc3Q6IFJhd0NvbW1hbmRzWyd0b2dnbGVMaXN0J10gPSAobGlzdFR5cGVPck5hbWUsIGl0ZW1UeXBlT3JOYW1lLCBrZWVwTWFya3MsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHtcbiAgZWRpdG9yLCB0ciwgc3RhdGUsIGRpc3BhdGNoLCBjaGFpbiwgY29tbWFuZHMsIGNhbixcbn0pID0+IHtcbiAgY29uc3QgeyBleHRlbnNpb25zLCBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyXG4gIGNvbnN0IGxpc3RUeXBlID0gZ2V0Tm9kZVR5cGUobGlzdFR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgaXRlbVR5cGUgPSBnZXROb2RlVHlwZShpdGVtVHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlXG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc2VsZWN0aW9uXG4gIGNvbnN0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pXG5cbiAgY29uc3QgbWFya3MgPSBzdG9yZWRNYXJrcyB8fCAoc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXG5cbiAgaWYgKCFyYW5nZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgcGFyZW50TGlzdCA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gaXNMaXN0KG5vZGUudHlwZS5uYW1lLCBleHRlbnNpb25zKSkoc2VsZWN0aW9uKVxuXG4gIGlmIChyYW5nZS5kZXB0aCA+PSAxICYmIHBhcmVudExpc3QgJiYgcmFuZ2UuZGVwdGggLSBwYXJlbnRMaXN0LmRlcHRoIDw9IDEpIHtcbiAgICAvLyByZW1vdmUgbGlzdFxuICAgIGlmIChwYXJlbnRMaXN0Lm5vZGUudHlwZSA9PT0gbGlzdFR5cGUpIHtcbiAgICAgIHJldHVybiBjb21tYW5kcy5saWZ0TGlzdEl0ZW0oaXRlbVR5cGUpXG4gICAgfVxuXG4gICAgLy8gY2hhbmdlIGxpc3QgdHlwZVxuICAgIGlmIChcbiAgICAgIGlzTGlzdChwYXJlbnRMaXN0Lm5vZGUudHlwZS5uYW1lLCBleHRlbnNpb25zKVxuICAgICAgICAmJiBsaXN0VHlwZS52YWxpZENvbnRlbnQocGFyZW50TGlzdC5ub2RlLmNvbnRlbnQpXG4gICAgICAgICYmIGRpc3BhdGNoXG4gICAgKSB7XG4gICAgICByZXR1cm4gY2hhaW4oKVxuICAgICAgICAuY29tbWFuZCgoKSA9PiB7XG4gICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwYXJlbnRMaXN0LnBvcywgbGlzdFR5cGUpXG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9KVxuICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEJhY2t3YXJkcyh0ciwgbGlzdFR5cGUpKVxuICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgIC5ydW4oKVxuICAgIH1cbiAgfVxuICBpZiAoIWtlZXBNYXJrcyB8fCAhbWFya3MgfHwgIWRpc3BhdGNoKSB7XG5cbiAgICByZXR1cm4gY2hhaW4oKVxuICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgbm9kZSB0byBkZWZhdWx0IG5vZGUgaWYgbmVlZGVkXG4gICAgICAuY29tbWFuZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbldyYXBJbkxpc3QgPSBjYW4oKS53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxuXG4gICAgICAgIGlmIChjYW5XcmFwSW5MaXN0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKClcbiAgICAgIH0pXG4gICAgICAud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcylcbiAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0QmFja3dhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAucnVuKClcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgY2hhaW4oKVxuICAgIC8vIHRyeSB0byBjb252ZXJ0IG5vZGUgdG8gZGVmYXVsdCBub2RlIGlmIG5lZWRlZFxuICAgICAgLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICBjb25zdCBjYW5XcmFwSW5MaXN0ID0gY2FuKCkud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcylcblxuICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSlcblxuICAgICAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKVxuXG4gICAgICAgIGlmIChjYW5XcmFwSW5MaXN0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKClcbiAgICAgIH0pXG4gICAgICAud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcylcbiAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0QmFja3dhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAucnVuKClcbiAgKVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtUeXBlLmpzJ1xuaW1wb3J0IHsgaXNNYXJrQWN0aXZlIH0gZnJvbSAnLi4vaGVscGVycy9pc01hcmtBY3RpdmUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdG9nZ2xlTWFyazoge1xuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBtYXJrIG9uIGFuZCBvZmYuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZU1hcms6IChcbiAgICAgICAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTWFya1R5cGUsXG4gICAgICAgIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFJlbW92ZXMgdGhlIG1hcmsgZXZlbiBhY3Jvc3MgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGV4dGVuZEVtcHR5TWFya1JhbmdlPzogYm9vbGVhblxuICAgICAgICB9LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVNYXJrOiBSYXdDb21tYW5kc1sndG9nZ2xlTWFyayddID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSwgb3B0aW9ucyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICBjb25zdCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlID0gZmFsc2UgfSA9IG9wdGlvbnNcbiAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgY29uc3QgaXNBY3RpdmUgPSBpc01hcmtBY3RpdmUoc3RhdGUsIHR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgaWYgKGlzQWN0aXZlKSB7XG4gICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0eXBlLCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlIH0pXG4gIH1cblxuICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0eXBlLCBhdHRyaWJ1dGVzKVxufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgaXNOb2RlQWN0aXZlIH0gZnJvbSAnLi4vaGVscGVycy9pc05vZGVBY3RpdmUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdG9nZ2xlTm9kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBub2RlIHdpdGggYW5vdGhlciBub2RlLlxuICAgICAgICovXG4gICAgICB0b2dnbGVOb2RlOiAoXG4gICAgICAgIHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLFxuICAgICAgICB0b2dnbGVUeXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSxcbiAgICAgICAgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRvZ2dsZU5vZGU6IFJhd0NvbW1hbmRzWyd0b2dnbGVOb2RlJ10gPSAodHlwZU9yTmFtZSwgdG9nZ2xlVHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCB0b2dnbGVUeXBlID0gZ2V0Tm9kZVR5cGUodG9nZ2xlVHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCBpc0FjdGl2ZSA9IGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcylcblxuICBpZiAoaXNBY3RpdmUpIHtcbiAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0b2dnbGVUeXBlKVxuICB9XG5cbiAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodHlwZSwgYXR0cmlidXRlcylcbn1cbiIsICJpbXBvcnQgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGlzTm9kZUFjdGl2ZSB9IGZyb20gJy4uL2hlbHBlcnMvaXNOb2RlQWN0aXZlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHRvZ2dsZVdyYXA6IHtcbiAgICAgIC8qKlxuICAgICAgICogV3JhcHMgbm9kZXMgaW4gYW5vdGhlciBub2RlLCBvciByZW1vdmVzIGFuIGV4aXN0aW5nIHdyYXAuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZVdyYXA6ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRvZ2dsZVdyYXA6IFJhd0NvbW1hbmRzWyd0b2dnbGVXcmFwJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCBpc0FjdGl2ZSA9IGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcylcblxuICBpZiAoaXNBY3RpdmUpIHtcbiAgICByZXR1cm4gY29tbWFuZHMubGlmdCh0eXBlKVxuICB9XG5cbiAgcmV0dXJuIGNvbW1hbmRzLndyYXBJbih0eXBlLCBhdHRyaWJ1dGVzKVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB1bmRvSW5wdXRSdWxlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFVuZG8gYW4gaW5wdXQgcnVsZS5cbiAgICAgICAqL1xuICAgICAgdW5kb0lucHV0UnVsZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHVuZG9JbnB1dFJ1bGU6IFJhd0NvbW1hbmRzWyd1bmRvSW5wdXRSdWxlJ10gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCBwbHVnaW5zID0gc3RhdGUucGx1Z2luc1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbaV1cbiAgICBsZXQgdW5kb2FibGVcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBpZiAocGx1Z2luLnNwZWMuaXNJbnB1dFJ1bGVzICYmICh1bmRvYWJsZSA9IHBsdWdpbi5nZXRTdGF0ZShzdGF0ZSkpKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgdHIgPSBzdGF0ZS50clxuICAgICAgICBjb25zdCB0b1VuZG8gPSB1bmRvYWJsZS50cmFuc2Zvcm1cblxuICAgICAgICBmb3IgKGxldCBqID0gdG9VbmRvLnN0ZXBzLmxlbmd0aCAtIDE7IGogPj0gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgdHIuc3RlcCh0b1VuZG8uc3RlcHNbal0uaW52ZXJ0KHRvVW5kby5kb2NzW2pdKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bmRvYWJsZS50ZXh0KSB7XG4gICAgICAgICAgY29uc3QgbWFya3MgPSB0ci5kb2MucmVzb2x2ZSh1bmRvYWJsZS5mcm9tKS5tYXJrcygpXG5cbiAgICAgICAgICB0ci5yZXBsYWNlV2l0aCh1bmRvYWJsZS5mcm9tLCB1bmRvYWJsZS50bywgc3RhdGUuc2NoZW1hLnRleHQodW5kb2FibGUudGV4dCwgbWFya3MpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyLmRlbGV0ZSh1bmRvYWJsZS5mcm9tLCB1bmRvYWJsZS50bylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB1bnNldEFsbE1hcmtzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBhbGwgbWFya3MgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICovXG4gICAgICB1bnNldEFsbE1hcmtzOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdW5zZXRBbGxNYXJrczogUmF3Q29tbWFuZHNbJ3Vuc2V0QWxsTWFya3MnXSA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0clxuICBjb25zdCB7IGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvblxuXG4gIGlmIChlbXB0eSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICB0ci5yZW1vdmVNYXJrKHJhbmdlLiRmcm9tLnBvcywgcmFuZ2UuJHRvLnBvcylcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgeyBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE1hcmtSYW5nZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1JhbmdlLmpzJ1xuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtUeXBlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHVuc2V0TWFyazoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgYWxsIG1hcmtzIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAqL1xuICAgICAgdW5zZXRNYXJrOiAoXG4gICAgICAgIHR5cGVPck5hbWU6IHN0cmluZyB8IE1hcmtUeXBlLFxuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFJlbW92ZXMgdGhlIG1hcmsgZXZlbiBhY3Jvc3MgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGV4dGVuZEVtcHR5TWFya1JhbmdlPzogYm9vbGVhblxuICAgICAgICB9LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB1bnNldE1hcms6IFJhd0NvbW1hbmRzWyd1bnNldE1hcmsnXSA9ICh0eXBlT3JOYW1lLCBvcHRpb25zID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlID0gZmFsc2UgfSA9IG9wdGlvbnNcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyXG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgJGZyb20sIGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvblxuXG4gIGlmICghZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKGVtcHR5ICYmIGV4dGVuZEVtcHR5TWFya1JhbmdlKSB7XG4gICAgbGV0IHsgZnJvbSwgdG8gfSA9IHNlbGVjdGlvblxuICAgIGNvbnN0IGF0dHJzID0gJGZyb20ubWFya3MoKS5maW5kKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKT8uYXR0cnNcbiAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cnMpXG5cbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgIGZyb20gPSByYW5nZS5mcm9tXG4gICAgICB0byA9IHJhbmdlLnRvXG4gICAgfVxuXG4gICAgdHIucmVtb3ZlTWFyayhmcm9tLCB0bywgdHlwZSlcbiAgfSBlbHNlIHtcbiAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICB0ci5yZW1vdmVNYXJrKHJhbmdlLiRmcm9tLnBvcywgcmFuZ2UuJHRvLnBvcywgdHlwZSlcbiAgICB9KVxuICB9XG5cbiAgdHIucmVtb3ZlU3RvcmVkTWFyayh0eXBlKVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgTWFya1R5cGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtUeXBlLmpzJ1xuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUgfSBmcm9tICcuLi9oZWxwZXJzL2dldFNjaGVtYVR5cGVOYW1lQnlOYW1lLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHVwZGF0ZUF0dHJpYnV0ZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlIGF0dHJpYnV0ZXMgb2YgYSBub2RlIG9yIG1hcmsuXG4gICAgICAgKi9cbiAgICAgIHVwZGF0ZUF0dHJpYnV0ZXM6IChcbiAgICAgICAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUgfCBNYXJrVHlwZSxcbiAgICAgICAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PixcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdXBkYXRlQXR0cmlidXRlczogUmF3Q29tbWFuZHNbJ3VwZGF0ZUF0dHJpYnV0ZXMnXSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBsZXQgbm9kZVR5cGU6IE5vZGVUeXBlIHwgbnVsbCA9IG51bGxcbiAgbGV0IG1hcmtUeXBlOiBNYXJrVHlwZSB8IG51bGwgPSBudWxsXG5cbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKFxuICAgIHR5cGVvZiB0eXBlT3JOYW1lID09PSAnc3RyaW5nJyA/IHR5cGVPck5hbWUgOiB0eXBlT3JOYW1lLm5hbWUsXG4gICAgc3RhdGUuc2NoZW1hLFxuICApXG5cbiAgaWYgKCFzY2hlbWFUeXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgbm9kZVR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lIGFzIE5vZGVUeXBlLCBzdGF0ZS5zY2hlbWEpXG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgbWFya1R5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lIGFzIE1hcmtUeXBlLCBzdGF0ZS5zY2hlbWEpXG4gIH1cblxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB0ci5zZWxlY3Rpb24ucmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgY29uc3QgZnJvbSA9IHJhbmdlLiRmcm9tLnBvc1xuICAgICAgY29uc3QgdG8gPSByYW5nZS4kdG8ucG9zXG5cbiAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKG5vZGVUeXBlICYmIG5vZGVUeXBlID09PSBub2RlLnR5cGUpIHtcbiAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAuLi5ub2RlLmF0dHJzLFxuICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hcmtUeXBlICYmIG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgbm9kZS5tYXJrcy5mb3JFYWNoKG1hcmsgPT4ge1xuICAgICAgICAgICAgaWYgKG1hcmtUeXBlID09PSBtYXJrLnR5cGUpIHtcbiAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZEZyb20gPSBNYXRoLm1heChwb3MsIGZyb20pXG4gICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRUbyA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKVxuXG4gICAgICAgICAgICAgIHRyLmFkZE1hcmsoXG4gICAgICAgICAgICAgICAgdHJpbW1lZEZyb20sXG4gICAgICAgICAgICAgICAgdHJpbW1lZFRvLFxuICAgICAgICAgICAgICAgIG1hcmtUeXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAuLi5tYXJrLmF0dHJzLFxuICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgd3JhcEluIGFzIG9yaWdpbmFsV3JhcEluIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcbmltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHdyYXBJbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwcyBub2RlcyBpbiBhbm90aGVyIG5vZGUuXG4gICAgICAgKi9cbiAgICAgIHdyYXBJbjogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgd3JhcEluOiBSYXdDb21tYW5kc1snd3JhcEluJ10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIHJldHVybiBvcmlnaW5hbFdyYXBJbih0eXBlLCBhdHRyaWJ1dGVzKShzdGF0ZSwgZGlzcGF0Y2gpXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgd3JhcEluTGlzdCBhcyBvcmlnaW5hbFdyYXBJbkxpc3QgfSBmcm9tICdAdGlwdGFwL3BtL3NjaGVtYS1saXN0J1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgd3JhcEluTGlzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwIGEgbm9kZSBpbiBhIGxpc3QuXG4gICAgICAgKi9cbiAgICAgIHdyYXBJbkxpc3Q6ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHdyYXBJbkxpc3Q6IFJhd0NvbW1hbmRzWyd3cmFwSW5MaXN0J10gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gIHJldHVybiBvcmlnaW5hbFdyYXBJbkxpc3QodHlwZSwgYXR0cmlidXRlcykoc3RhdGUsIGRpc3BhdGNoKVxufVxuIiwgImltcG9ydCAqIGFzIGNvbW1hbmRzIGZyb20gJy4uL2NvbW1hbmRzL2luZGV4LmpzJ1xuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnLi4vRXh0ZW5zaW9uLmpzJ1xuXG5leHBvcnQgKiBmcm9tICcuLi9jb21tYW5kcy9pbmRleC5qcydcblxuZXhwb3J0IGNvbnN0IENvbW1hbmRzID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdjb21tYW5kcycsXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbW1hbmRzLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5cbmV4cG9ydCBjb25zdCBFZGl0YWJsZSA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAnZWRpdGFibGUnLFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnZWRpdGFibGUnKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBlZGl0YWJsZTogKCkgPT4gdGhpcy5lZGl0b3Iub3B0aW9ucy5lZGl0YWJsZSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5cbmV4cG9ydCBjb25zdCBGb2N1c0V2ZW50cyA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAnZm9jdXNFdmVudHMnLFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpc1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2ZvY3VzRXZlbnRzJyksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICBmb2N1czogKHZpZXcsIGV2ZW50OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgICBlZGl0b3IuaXNGb2N1c2VkID0gdHJ1ZVxuXG4gICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZWRpdG9yLnN0YXRlLnRyXG4gICAgICAgICAgICAgICAgLnNldE1ldGEoJ2ZvY3VzJywgeyBldmVudCB9KVxuICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdhZGRUb0hpc3RvcnknLCBmYWxzZSlcblxuICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKVxuXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJsdXI6ICh2aWV3LCBldmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgZWRpdG9yLmlzRm9jdXNlZCA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBlZGl0b3Iuc3RhdGUudHJcbiAgICAgICAgICAgICAgICAuc2V0TWV0YSgnYmx1cicsIHsgZXZlbnQgfSlcbiAgICAgICAgICAgICAgICAuc2V0TWV0YSgnYWRkVG9IaXN0b3J5JywgZmFsc2UpXG5cbiAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbilcblxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXksIFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IENvbW1hbmRNYW5hZ2VyIH0gZnJvbSAnLi4vQ29tbWFuZE1hbmFnZXIuanMnXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5pbXBvcnQgeyBjcmVhdGVDaGFpbmFibGVTdGF0ZSB9IGZyb20gJy4uL2hlbHBlcnMvY3JlYXRlQ2hhaW5hYmxlU3RhdGUuanMnXG5pbXBvcnQgeyBpc2lPUyB9IGZyb20gJy4uL3V0aWxpdGllcy9pc2lPUy5qcydcbmltcG9ydCB7IGlzTWFjT1MgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNNYWNPUy5qcydcblxuZXhwb3J0IGNvbnN0IEtleW1hcCA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAna2V5bWFwJyxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICBjb25zdCBoYW5kbGVCYWNrc3BhY2UgPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAoKSA9PiBjb21tYW5kcy51bmRvSW5wdXRSdWxlKCksXG5cbiAgICAgIC8vIG1heWJlIGNvbnZlcnQgZmlyc3QgdGV4dCBibG9jayBub2RlIHRvIGRlZmF1bHQgbm9kZVxuICAgICAgKCkgPT4gY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHRyXG4gICAgICAgIGNvbnN0IHsgZW1wdHksICRhbmNob3IgfSA9IHNlbGVjdGlvblxuICAgICAgICBjb25zdCB7IHBvcywgcGFyZW50IH0gPSAkYW5jaG9yXG4gICAgICAgIGNvbnN0ICRwYXJlbnRQb3MgPSAkYW5jaG9yLnBhcmVudC5pc1RleHRibG9jayA/IHRyLmRvYy5yZXNvbHZlKHBvcyAtIDEpIDogJGFuY2hvclxuICAgICAgICBjb25zdCBwYXJlbnRJc0lzb2xhdGluZyA9ICRwYXJlbnRQb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmdcblxuICAgICAgICBjb25zdCBwYXJlbnRQb3MgPSAkYW5jaG9yLnBvcyAtICRhbmNob3IucGFyZW50T2Zmc2V0XG5cbiAgICAgICAgY29uc3QgaXNBdFN0YXJ0ID0gKHBhcmVudElzSXNvbGF0aW5nICYmICRwYXJlbnRQb3MucGFyZW50LmNoaWxkQ291bnQgPT09IDEpXG4gICAgICAgICAgPyBwYXJlbnRQb3MgPT09ICRhbmNob3IucG9zXG4gICAgICAgICAgOiBTZWxlY3Rpb24uYXRTdGFydChkb2MpLmZyb20gPT09IHBvc1xuXG4gICAgICAgIGlmICghZW1wdHkgfHwgIWlzQXRTdGFydCB8fCAhcGFyZW50LnR5cGUuaXNUZXh0YmxvY2sgfHwgcGFyZW50LnRleHRDb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKVxuICAgICAgfSksXG5cbiAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuam9pbkJhY2t3YXJkKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5zZWxlY3ROb2RlQmFja3dhcmQoKSxcbiAgICBdKVxuXG4gICAgY29uc3QgaGFuZGxlRGVsZXRlID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZmlyc3QoKHsgY29tbWFuZHMgfSkgPT4gW1xuICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlU2VsZWN0aW9uKCksXG4gICAgICAoKSA9PiBjb21tYW5kcy5kZWxldGVDdXJyZW50Tm9kZSgpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuam9pbkZvcndhcmQoKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLnNlbGVjdE5vZGVGb3J3YXJkKCksXG4gICAgXSlcblxuICAgIGNvbnN0IGhhbmRsZUVudGVyID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZmlyc3QoKHsgY29tbWFuZHMgfSkgPT4gW1xuICAgICAgKCkgPT4gY29tbWFuZHMubmV3bGluZUluQ29kZSgpLFxuICAgICAgKCkgPT4gY29tbWFuZHMuY3JlYXRlUGFyYWdyYXBoTmVhcigpLFxuICAgICAgKCkgPT4gY29tbWFuZHMubGlmdEVtcHR5QmxvY2soKSxcbiAgICAgICgpID0+IGNvbW1hbmRzLnNwbGl0QmxvY2soKSxcbiAgICBdKVxuXG4gICAgY29uc3QgYmFzZUtleW1hcCA9IHtcbiAgICAgIEVudGVyOiBoYW5kbGVFbnRlcixcbiAgICAgICdNb2QtRW50ZXInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5leGl0Q29kZSgpLFxuICAgICAgQmFja3NwYWNlOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAnTW9kLUJhY2tzcGFjZSc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICdTaGlmdC1CYWNrc3BhY2UnOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICBEZWxldGU6IGhhbmRsZURlbGV0ZSxcbiAgICAgICdNb2QtRGVsZXRlJzogaGFuZGxlRGVsZXRlLFxuICAgICAgJ01vZC1hJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0QWxsKCksXG4gICAgfVxuXG4gICAgY29uc3QgcGNLZXltYXAgPSB7XG4gICAgICAuLi5iYXNlS2V5bWFwLFxuICAgIH1cblxuICAgIGNvbnN0IG1hY0tleW1hcCA9IHtcbiAgICAgIC4uLmJhc2VLZXltYXAsXG4gICAgICAnQ3RybC1oJzogaGFuZGxlQmFja3NwYWNlLFxuICAgICAgJ0FsdC1CYWNrc3BhY2UnOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAnQ3RybC1kJzogaGFuZGxlRGVsZXRlLFxuICAgICAgJ0N0cmwtQWx0LUJhY2tzcGFjZSc6IGhhbmRsZURlbGV0ZSxcbiAgICAgICdBbHQtRGVsZXRlJzogaGFuZGxlRGVsZXRlLFxuICAgICAgJ0FsdC1kJzogaGFuZGxlRGVsZXRlLFxuICAgICAgJ0N0cmwtYSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNlbGVjdFRleHRibG9ja1N0YXJ0KCksXG4gICAgICAnQ3RybC1lJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0VGV4dGJsb2NrRW5kKCksXG4gICAgfVxuXG4gICAgaWYgKGlzaU9TKCkgfHwgaXNNYWNPUygpKSB7XG4gICAgICByZXR1cm4gbWFjS2V5bWFwXG4gICAgfVxuXG4gICAgcmV0dXJuIHBjS2V5bWFwXG4gIH0sXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICAvLyBXaXRoIHRoaXMgcGx1Z2luIHdlIGNoZWNrIGlmIHRoZSB3aG9sZSBkb2N1bWVudCB3YXMgc2VsZWN0ZWQgYW5kIGRlbGV0ZWQuXG4gICAgICAvLyBJbiB0aGlzIGNhc2Ugd2Ugd2lsbCBhZGRpdGlvbmFsbHkgY2FsbCBgY2xlYXJOb2RlcygpYCB0byBjb252ZXJ0IGUuZy4gYSBoZWFkaW5nXG4gICAgICAvLyB0byBhIHBhcmFncmFwaCBpZiBuZWNlc3NhcnkuXG4gICAgICAvLyBUaGlzIGlzIGFuIGFsdGVybmF0aXZlIHRvIFByb3NlTWlycm9yJ3MgYEFsbFNlbGVjdGlvbmAsIHdoaWNoIGRvZXNu4oCZdCB3b3JrIHdlbGxcbiAgICAgIC8vIHdpdGggbWFueSBvdGhlciBjb21tYW5kcy5cbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2NsZWFyRG9jdW1lbnQnKSxcbiAgICAgICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRvY0NoYW5nZXMgPSB0cmFuc2FjdGlvbnMuc29tZSh0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgJiYgIW9sZFN0YXRlLmRvYy5lcShuZXdTdGF0ZS5kb2MpXG5cbiAgICAgICAgICBpZiAoIWRvY0NoYW5nZXMpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHsgZW1wdHksIGZyb20sIHRvIH0gPSBvbGRTdGF0ZS5zZWxlY3Rpb25cbiAgICAgICAgICBjb25zdCBhbGxGcm9tID0gU2VsZWN0aW9uLmF0U3RhcnQob2xkU3RhdGUuZG9jKS5mcm9tXG4gICAgICAgICAgY29uc3QgYWxsRW5kID0gU2VsZWN0aW9uLmF0RW5kKG9sZFN0YXRlLmRvYykudG9cbiAgICAgICAgICBjb25zdCBhbGxXYXNTZWxlY3RlZCA9IGZyb20gPT09IGFsbEZyb20gJiYgdG8gPT09IGFsbEVuZFxuXG4gICAgICAgICAgaWYgKGVtcHR5IHx8ICFhbGxXYXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaXNFbXB0eSA9IG5ld1N0YXRlLmRvYy50ZXh0QmV0d2VlbigwLCBuZXdTdGF0ZS5kb2MuY29udGVudC5zaXplLCAnICcsICcgJykubGVuZ3RoID09PSAwXG5cbiAgICAgICAgICBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHRyID0gbmV3U3RhdGUudHJcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGNyZWF0ZUNoYWluYWJsZVN0YXRlKHtcbiAgICAgICAgICAgIHN0YXRlOiBuZXdTdGF0ZSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cixcbiAgICAgICAgICB9KVxuICAgICAgICAgIGNvbnN0IHsgY29tbWFuZHMgfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGNvbW1hbmRzLmNsZWFyTm9kZXMoKVxuXG4gICAgICAgICAgaWYgKCF0ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0clxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcblxuZXhwb3J0IGNvbnN0IFRhYmluZGV4ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICd0YWJpbmRleCcsXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCd0YWJpbmRleCcpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuZWRpdG9yLmlzRWRpdGFibGUgPyB7IHRhYmluZGV4OiAnMCcgfSA6IHt9LFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQge1xuICBGcmFnbWVudCwgTm9kZSwgUmVzb2x2ZWRQb3MsXG59IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgQ29udGVudCwgUmFuZ2UgfSBmcm9tICcuL3R5cGVzLmpzJ1xuXG5leHBvcnQgY2xhc3MgTm9kZVBvcyB7XG4gIHByaXZhdGUgcmVzb2x2ZWRQb3M6IFJlc29sdmVkUG9zXG5cbiAgcHJpdmF0ZSBpc0Jsb2NrOiBib29sZWFuXG5cbiAgcHJpdmF0ZSBlZGl0b3I6IEVkaXRvclxuXG4gIHByaXZhdGUgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLnR5cGUubmFtZVxuICB9XG5cbiAgY29uc3RydWN0b3IocG9zOiBSZXNvbHZlZFBvcywgZWRpdG9yOiBFZGl0b3IsIGlzQmxvY2sgPSBmYWxzZSwgbm9kZTogTm9kZSB8IG51bGwgPSBudWxsKSB7XG4gICAgdGhpcy5pc0Jsb2NrID0gaXNCbG9ja1xuICAgIHRoaXMucmVzb2x2ZWRQb3MgPSBwb3NcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICAgIHRoaXMuY3VycmVudE5vZGUgPSBub2RlXG4gIH1cblxuICBwcml2YXRlIGN1cnJlbnROb2RlOiBOb2RlIHwgbnVsbCA9IG51bGxcblxuICBnZXQgbm9kZSgpOiBOb2RlIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50Tm9kZSB8fCB0aGlzLnJlc29sdmVkUG9zLm5vZGUoKVxuICB9XG5cbiAgZ2V0IGVsZW1lbnQoKTogSFRNTEVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLmVkaXRvci52aWV3LmRvbUF0UG9zKHRoaXMucG9zKS5ub2RlIGFzIEhUTUxFbGVtZW50XG4gIH1cblxuICBwdWJsaWMgYWN0dWFsRGVwdGg6IG51bWJlciB8IG51bGwgPSBudWxsXG5cbiAgZ2V0IGRlcHRoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuYWN0dWFsRGVwdGggPz8gdGhpcy5yZXNvbHZlZFBvcy5kZXB0aFxuICB9XG5cbiAgZ2V0IHBvcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmVkUG9zLnBvc1xuICB9XG5cbiAgZ2V0IGNvbnRlbnQoKTogRnJhZ21lbnQge1xuICAgIHJldHVybiB0aGlzLm5vZGUuY29udGVudFxuICB9XG5cbiAgc2V0IGNvbnRlbnQoY29udGVudDogQ29udGVudCkge1xuICAgIGxldCBmcm9tID0gdGhpcy5mcm9tXG4gICAgbGV0IHRvID0gdGhpcy50b1xuXG4gICAgaWYgKHRoaXMuaXNCbG9jaykge1xuICAgICAgaWYgKHRoaXMuY29udGVudC5zaXplID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFlvdSBjYW7igJl0IHNldCBjb250ZW50IG9uIGEgYmxvY2sgbm9kZS4gVHJpZWQgdG8gc2V0IGNvbnRlbnQgb24gJHt0aGlzLm5hbWV9IGF0ICR7dGhpcy5wb3N9YClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGZyb20gPSB0aGlzLmZyb20gKyAxXG4gICAgICB0byA9IHRoaXMudG8gLSAxXG4gICAgfVxuXG4gICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuaW5zZXJ0Q29udGVudEF0KHsgZnJvbSwgdG8gfSwgY29udGVudClcbiAgfVxuXG4gIGdldCBhdHRyaWJ1dGVzKCkgOiB7IFtrZXk6IHN0cmluZ106IGFueSB9IHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLmF0dHJzXG4gIH1cblxuICBnZXQgdGV4dENvbnRlbnQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLnRleHRDb250ZW50XG4gIH1cblxuICBnZXQgc2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLm5vZGUubm9kZVNpemVcbiAgfVxuXG4gIGdldCBmcm9tKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuaXNCbG9jaykge1xuICAgICAgcmV0dXJuIHRoaXMucG9zXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRQb3Muc3RhcnQodGhpcy5yZXNvbHZlZFBvcy5kZXB0aClcbiAgfVxuXG4gIGdldCByYW5nZSgpOiBSYW5nZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb206IHRoaXMuZnJvbSxcbiAgICAgIHRvOiB0aGlzLnRvLFxuICAgIH1cbiAgfVxuXG4gIGdldCB0bygpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLmlzQmxvY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnBvcyArIHRoaXMuc2l6ZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlc29sdmVkUG9zLmVuZCh0aGlzLnJlc29sdmVkUG9zLmRlcHRoKSArICh0aGlzLm5vZGUuaXNUZXh0ID8gMCA6IDEpXG4gIH1cblxuICBnZXQgcGFyZW50KCk6IE5vZGVQb3MgfCBudWxsIHtcbiAgICBpZiAodGhpcy5kZXB0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnRQb3MgPSB0aGlzLnJlc29sdmVkUG9zLnN0YXJ0KHRoaXMucmVzb2x2ZWRQb3MuZGVwdGggLSAxKVxuICAgIGNvbnN0ICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHBhcmVudFBvcylcblxuICAgIHJldHVybiBuZXcgTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvcilcbiAgfVxuXG4gIGdldCBiZWZvcmUoKTogTm9kZVBvcyB8IG51bGwge1xuICAgIGxldCAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0aGlzLmZyb20gLSAodGhpcy5pc0Jsb2NrID8gMSA6IDIpKVxuXG4gICAgaWYgKCRwb3MuZGVwdGggIT09IHRoaXMuZGVwdGgpIHtcbiAgICAgICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHRoaXMuZnJvbSAtIDMpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yKVxuICB9XG5cbiAgZ2V0IGFmdGVyKCk6IE5vZGVQb3MgfCBudWxsIHtcbiAgICBsZXQgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy50byArICh0aGlzLmlzQmxvY2sgPyAyIDogMSkpXG5cbiAgICBpZiAoJHBvcy5kZXB0aCAhPT0gdGhpcy5kZXB0aCkge1xuICAgICAgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy50byArIDMpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yKVxuICB9XG5cbiAgZ2V0IGNoaWxkcmVuKCk6IE5vZGVQb3NbXSB7XG4gICAgY29uc3QgY2hpbGRyZW46IE5vZGVQb3NbXSA9IFtdXG5cbiAgICB0aGlzLm5vZGUuY29udGVudC5mb3JFYWNoKChub2RlLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IGlzQmxvY2sgPSBub2RlLmlzQmxvY2sgJiYgIW5vZGUuaXNUZXh0YmxvY2tcblxuICAgICAgY29uc3QgdGFyZ2V0UG9zID0gdGhpcy5wb3MgKyBvZmZzZXQgKyAoaXNCbG9jayA/IDAgOiAxKVxuICAgICAgY29uc3QgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGFyZ2V0UG9zKVxuXG4gICAgICBpZiAoIWlzQmxvY2sgJiYgJHBvcy5kZXB0aCA8PSB0aGlzLmRlcHRoKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBjaGlsZE5vZGVQb3MgPSBuZXcgTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvciwgaXNCbG9jaywgaXNCbG9jayA/IG5vZGUgOiBudWxsKVxuXG4gICAgICBpZiAoaXNCbG9jaykge1xuICAgICAgICBjaGlsZE5vZGVQb3MuYWN0dWFsRGVwdGggPSB0aGlzLmRlcHRoICsgMVxuICAgICAgfVxuXG4gICAgICBjaGlsZHJlbi5wdXNoKG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yLCBpc0Jsb2NrLCBpc0Jsb2NrID8gbm9kZSA6IG51bGwpKVxuICAgIH0pXG5cbiAgICByZXR1cm4gY2hpbGRyZW5cbiAgfVxuXG4gIGdldCBmaXJzdENoaWxkKCk6IE5vZGVQb3MgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXSB8fCBudWxsXG4gIH1cblxuICBnZXQgbGFzdENoaWxkKCk6IE5vZGVQb3MgfCBudWxsIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW5cblxuICAgIHJldHVybiBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSB8fCBudWxsXG4gIH1cblxuICBjbG9zZXN0KHNlbGVjdG9yOiBzdHJpbmcsIGF0dHJpYnV0ZXM6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fSk6IE5vZGVQb3MgfCBudWxsIHtcbiAgICBsZXQgbm9kZTogTm9kZVBvcyB8IG51bGwgPSBudWxsXG4gICAgbGV0IGN1cnJlbnROb2RlID0gdGhpcy5wYXJlbnRcblxuICAgIHdoaWxlIChjdXJyZW50Tm9kZSAmJiAhbm9kZSkge1xuICAgICAgaWYgKGN1cnJlbnROb2RlLm5vZGUudHlwZS5uYW1lID09PSBzZWxlY3Rvcikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IG5vZGVBdHRyaWJ1dGVzID0gY3VycmVudE5vZGUubm9kZS5hdHRyc1xuICAgICAgICAgIGNvbnN0IGF0dHJLZXlzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcylcblxuICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhdHRyS2V5cy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGF0dHJLZXlzW2luZGV4XVxuXG4gICAgICAgICAgICBpZiAobm9kZUF0dHJpYnV0ZXNba2V5XSAhPT0gYXR0cmlidXRlc1trZXldKSB7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBjdXJyZW50Tm9kZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIHF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3I6IHN0cmluZywgYXR0cmlidXRlczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9KTogTm9kZVBvcyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IsIGF0dHJpYnV0ZXMsIHRydWUpWzBdIHx8IG51bGxcbiAgfVxuXG4gIHF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3I6IHN0cmluZywgYXR0cmlidXRlczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9LCBmaXJzdEl0ZW1Pbmx5ID0gZmFsc2UpOiBOb2RlUG9zW10ge1xuICAgIGxldCBub2RlczogTm9kZVBvc1tdID0gW11cblxuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBjaGlsZHJlbiByZWN1cnNpdmVseSBmaW5kaW5nIGFsbCBub2RlcyB3aGljaCBtYXRjaCB0aGUgc2VsZWN0b3Igd2l0aCB0aGUgbm9kZSBuYW1lXG4gICAgaWYgKHRoaXMuaXNCbG9jayB8fCAhdGhpcy5jaGlsZHJlbiB8fCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5vZGVzXG4gICAgfVxuXG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkUG9zID0+IHtcbiAgICAgIGlmIChjaGlsZFBvcy5ub2RlLnR5cGUubmFtZSA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBub2RlQXR0cmlidXRlcyA9IGNoaWxkUG9zLm5vZGUuYXR0cnNcbiAgICAgICAgICBjb25zdCBhdHRyS2V5cyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpXG5cbiAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXR0cktleXMubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBhdHRyS2V5c1tpbmRleF1cblxuICAgICAgICAgICAgaWYgKG5vZGVBdHRyaWJ1dGVzW2tleV0gIT09IGF0dHJpYnV0ZXNba2V5XSkge1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2Rlcy5wdXNoKGNoaWxkUG9zKVxuXG4gICAgICAgIGlmIChmaXJzdEl0ZW1Pbmx5KSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQoY2hpbGRQb3MucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpXG4gICAgfSlcblxuICAgIHJldHVybiBub2Rlc1xuICB9XG5cbiAgc2V0QXR0cmlidXRlKGF0dHJpYnV0ZXM6IHsgW2tleTogc3RyaW5nXTogYW55IH0pIHtcbiAgICBjb25zdCBvbGRTZWxlY3Rpb24gPSB0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb25cblxuICAgIHRoaXMuZWRpdG9yLmNoYWluKCkuc2V0VGV4dFNlbGVjdGlvbih0aGlzLmZyb20pLnVwZGF0ZUF0dHJpYnV0ZXModGhpcy5ub2RlLnR5cGUubmFtZSwgYXR0cmlidXRlcykuc2V0VGV4dFNlbGVjdGlvbihvbGRTZWxlY3Rpb24uZnJvbSlcbiAgICAgIC5ydW4oKVxuICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IHN0eWxlID0gYC5Qcm9zZU1pcnJvciB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbn1cblxuLlByb3NlTWlycm9yIHtcbiAgd29yZC13cmFwOiBicmVhay13b3JkO1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG4gIHdoaXRlLXNwYWNlOiBicmVhay1zcGFjZXM7XG4gIC13ZWJraXQtZm9udC12YXJpYW50LWxpZ2F0dXJlczogbm9uZTtcbiAgZm9udC12YXJpYW50LWxpZ2F0dXJlczogbm9uZTtcbiAgZm9udC1mZWF0dXJlLXNldHRpbmdzOiBcImxpZ2FcIiAwOyAvKiB0aGUgYWJvdmUgZG9lc24ndCBzZWVtIHRvIHdvcmsgaW4gRWRnZSAqL1xufVxuXG4uUHJvc2VNaXJyb3IgW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdIHtcbiAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcbn1cblxuLlByb3NlTWlycm9yIFtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXSBbY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiXSB7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbn1cblxuLlByb3NlTWlycm9yIHByZSB7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbn1cblxuaW1nLlByb3NlTWlycm9yLXNlcGFyYXRvciB7XG4gIGRpc3BsYXk6IGlubGluZSAhaW1wb3J0YW50O1xuICBib3JkZXI6IG5vbmUgIWltcG9ydGFudDtcbiAgbWFyZ2luOiAwICFpbXBvcnRhbnQ7XG4gIHdpZHRoOiAxcHggIWltcG9ydGFudDtcbiAgaGVpZ2h0OiAxcHggIWltcG9ydGFudDtcbn1cblxuLlByb3NlTWlycm9yLWdhcGN1cnNvciB7XG4gIGRpc3BsYXk6IG5vbmU7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIG1hcmdpbjogMDtcbn1cblxuLlByb3NlTWlycm9yLWdhcGN1cnNvcjphZnRlciB7XG4gIGNvbnRlbnQ6IFwiXCI7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogLTJweDtcbiAgd2lkdGg6IDIwcHg7XG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCBibGFjaztcbiAgYW5pbWF0aW9uOiBQcm9zZU1pcnJvci1jdXJzb3ItYmxpbmsgMS4xcyBzdGVwcygyLCBzdGFydCkgaW5maW5pdGU7XG59XG5cbkBrZXlmcmFtZXMgUHJvc2VNaXJyb3ItY3Vyc29yLWJsaW5rIHtcbiAgdG8ge1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgfVxufVxuXG4uUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvbiAqOjpzZWxlY3Rpb24ge1xuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbn1cblxuLlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb24gKjo6LW1vei1zZWxlY3Rpb24ge1xuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbn1cblxuLlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb24gKiB7XG4gIGNhcmV0LWNvbG9yOiB0cmFuc3BhcmVudDtcbn1cblxuLlByb3NlTWlycm9yLWZvY3VzZWQgLlByb3NlTWlycm9yLWdhcGN1cnNvciB7XG4gIGRpc3BsYXk6IGJsb2NrO1xufVxuXG4udGlwcHktYm94W2RhdGEtYW5pbWF0aW9uPWZhZGVdW2RhdGEtc3RhdGU9aGlkZGVuXSB7XG4gIG9wYWNpdHk6IDBcbn1gXG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlVGFnKHN0eWxlOiBzdHJpbmcsIG5vbmNlPzogc3RyaW5nLCBzdWZmaXg/OiBzdHJpbmcpOiBIVE1MU3R5bGVFbGVtZW50IHtcbiAgY29uc3QgdGlwdGFwU3R5bGVUYWcgPSAoPEhUTUxTdHlsZUVsZW1lbnQ+ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc3R5bGVbZGF0YS10aXB0YXAtc3R5bGUke3N1ZmZpeCA/IGAtJHtzdWZmaXh9YCA6ICcnfV1gKSlcblxuICBpZiAodGlwdGFwU3R5bGVUYWcgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdGlwdGFwU3R5bGVUYWdcbiAgfVxuXG4gIGNvbnN0IHN0eWxlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcblxuICBpZiAobm9uY2UpIHtcbiAgICBzdHlsZU5vZGUuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKVxuICB9XG5cbiAgc3R5bGVOb2RlLnNldEF0dHJpYnV0ZShgZGF0YS10aXB0YXAtc3R5bGUke3N1ZmZpeCA/IGAtJHtzdWZmaXh9YCA6ICcnfWAsICcnKVxuICBzdHlsZU5vZGUuaW5uZXJIVE1MID0gc3R5bGVcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzdHlsZU5vZGUpXG5cbiAgcmV0dXJuIHN0eWxlTm9kZVxufVxuIiwgImltcG9ydCB7XG4gIE1hcmtUeXBlLCBOb2RlVHlwZSwgU2NoZW1hLFxufSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHtcbiAgRWRpdG9yU3RhdGUsIFBsdWdpbiwgUGx1Z2luS2V5LCBUcmFuc2FjdGlvbixcbn0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnXG5cbmltcG9ydCB7IENvbW1hbmRNYW5hZ2VyIH0gZnJvbSAnLi9Db21tYW5kTWFuYWdlci5qcydcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4vRXZlbnRFbWl0dGVyLmpzJ1xuaW1wb3J0IHsgRXh0ZW5zaW9uTWFuYWdlciB9IGZyb20gJy4vRXh0ZW5zaW9uTWFuYWdlci5qcydcbmltcG9ydCAqIGFzIGV4dGVuc2lvbnMgZnJvbSAnLi9leHRlbnNpb25zL2luZGV4LmpzJ1xuaW1wb3J0IHsgY3JlYXRlRG9jdW1lbnQgfSBmcm9tICcuL2hlbHBlcnMvY3JlYXRlRG9jdW1lbnQuanMnXG5pbXBvcnQgeyBnZXRBdHRyaWJ1dGVzIH0gZnJvbSAnLi9oZWxwZXJzL2dldEF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXRIVE1MRnJvbUZyYWdtZW50IH0gZnJvbSAnLi9oZWxwZXJzL2dldEhUTUxGcm9tRnJhZ21lbnQuanMnXG5pbXBvcnQgeyBnZXRUZXh0IH0gZnJvbSAnLi9oZWxwZXJzL2dldFRleHQuanMnXG5pbXBvcnQgeyBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hIH0gZnJvbSAnLi9oZWxwZXJzL2dldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEuanMnXG5pbXBvcnQgeyBpc0FjdGl2ZSB9IGZyb20gJy4vaGVscGVycy9pc0FjdGl2ZS5qcydcbmltcG9ydCB7IGlzTm9kZUVtcHR5IH0gZnJvbSAnLi9oZWxwZXJzL2lzTm9kZUVtcHR5LmpzJ1xuaW1wb3J0IHsgcmVzb2x2ZUZvY3VzUG9zaXRpb24gfSBmcm9tICcuL2hlbHBlcnMvcmVzb2x2ZUZvY3VzUG9zaXRpb24uanMnXG5pbXBvcnQgeyBOb2RlUG9zIH0gZnJvbSAnLi9Ob2RlUG9zLmpzJ1xuaW1wb3J0IHsgc3R5bGUgfSBmcm9tICcuL3N0eWxlLmpzJ1xuaW1wb3J0IHtcbiAgQ2FuQ29tbWFuZHMsXG4gIENoYWluZWRDb21tYW5kcyxcbiAgRWRpdG9yRXZlbnRzLFxuICBFZGl0b3JPcHRpb25zLFxuICBKU09OQ29udGVudCxcbiAgU2luZ2xlQ29tbWFuZHMsXG4gIFRleHRTZXJpYWxpemVyLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY3JlYXRlU3R5bGVUYWcgfSBmcm9tICcuL3V0aWxpdGllcy9jcmVhdGVTdHlsZVRhZy5qcydcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL3V0aWxpdGllcy9pc0Z1bmN0aW9uLmpzJ1xuXG5leHBvcnQgeyBleHRlbnNpb25zIH1cblxuZXhwb3J0IGludGVyZmFjZSBIVE1MRWxlbWVudCB7XG4gIGVkaXRvcj86IEVkaXRvclxufVxuXG5leHBvcnQgY2xhc3MgRWRpdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyPEVkaXRvckV2ZW50cz4ge1xuICBwcml2YXRlIGNvbW1hbmRNYW5hZ2VyITogQ29tbWFuZE1hbmFnZXJcblxuICBwdWJsaWMgZXh0ZW5zaW9uTWFuYWdlciE6IEV4dGVuc2lvbk1hbmFnZXJcblxuICBwcml2YXRlIGNzcyE6IEhUTUxTdHlsZUVsZW1lbnRcblxuICBwdWJsaWMgc2NoZW1hITogU2NoZW1hXG5cbiAgcHVibGljIHZpZXchOiBFZGl0b3JWaWV3XG5cbiAgcHVibGljIGlzRm9jdXNlZCA9IGZhbHNlXG5cbiAgcHVibGljIGV4dGVuc2lvblN0b3JhZ2U6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fVxuXG4gIHB1YmxpYyBvcHRpb25zOiBFZGl0b3JPcHRpb25zID0ge1xuICAgIGVsZW1lbnQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgIGNvbnRlbnQ6ICcnLFxuICAgIGluamVjdENTUzogdHJ1ZSxcbiAgICBpbmplY3ROb25jZTogdW5kZWZpbmVkLFxuICAgIGV4dGVuc2lvbnM6IFtdLFxuICAgIGF1dG9mb2N1czogZmFsc2UsXG4gICAgZWRpdGFibGU6IHRydWUsXG4gICAgZWRpdG9yUHJvcHM6IHt9LFxuICAgIHBhcnNlT3B0aW9uczoge30sXG4gICAgZW5hYmxlSW5wdXRSdWxlczogdHJ1ZSxcbiAgICBlbmFibGVQYXN0ZVJ1bGVzOiB0cnVlLFxuICAgIGVuYWJsZUNvcmVFeHRlbnNpb25zOiB0cnVlLFxuICAgIG9uQmVmb3JlQ3JlYXRlOiAoKSA9PiBudWxsLFxuICAgIG9uQ3JlYXRlOiAoKSA9PiBudWxsLFxuICAgIG9uVXBkYXRlOiAoKSA9PiBudWxsLFxuICAgIG9uU2VsZWN0aW9uVXBkYXRlOiAoKSA9PiBudWxsLFxuICAgIG9uVHJhbnNhY3Rpb246ICgpID0+IG51bGwsXG4gICAgb25Gb2N1czogKCkgPT4gbnVsbCxcbiAgICBvbkJsdXI6ICgpID0+IG51bGwsXG4gICAgb25EZXN0cm95OiAoKSA9PiBudWxsLFxuICB9XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogUGFydGlhbDxFZGl0b3JPcHRpb25zPiA9IHt9KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKVxuICAgIHRoaXMuY3JlYXRlRXh0ZW5zaW9uTWFuYWdlcigpXG4gICAgdGhpcy5jcmVhdGVDb21tYW5kTWFuYWdlcigpXG4gICAgdGhpcy5jcmVhdGVTY2hlbWEoKVxuICAgIHRoaXMub24oJ2JlZm9yZUNyZWF0ZScsIHRoaXMub3B0aW9ucy5vbkJlZm9yZUNyZWF0ZSlcbiAgICB0aGlzLmVtaXQoJ2JlZm9yZUNyZWF0ZScsIHsgZWRpdG9yOiB0aGlzIH0pXG4gICAgdGhpcy5jcmVhdGVWaWV3KClcbiAgICB0aGlzLmluamVjdENTUygpXG4gICAgdGhpcy5vbignY3JlYXRlJywgdGhpcy5vcHRpb25zLm9uQ3JlYXRlKVxuICAgIHRoaXMub24oJ3VwZGF0ZScsIHRoaXMub3B0aW9ucy5vblVwZGF0ZSlcbiAgICB0aGlzLm9uKCdzZWxlY3Rpb25VcGRhdGUnLCB0aGlzLm9wdGlvbnMub25TZWxlY3Rpb25VcGRhdGUpXG4gICAgdGhpcy5vbigndHJhbnNhY3Rpb24nLCB0aGlzLm9wdGlvbnMub25UcmFuc2FjdGlvbilcbiAgICB0aGlzLm9uKCdmb2N1cycsIHRoaXMub3B0aW9ucy5vbkZvY3VzKVxuICAgIHRoaXMub24oJ2JsdXInLCB0aGlzLm9wdGlvbnMub25CbHVyKVxuICAgIHRoaXMub24oJ2Rlc3Ryb3knLCB0aGlzLm9wdGlvbnMub25EZXN0cm95KVxuXG4gICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29tbWFuZHMuZm9jdXModGhpcy5vcHRpb25zLmF1dG9mb2N1cylcbiAgICAgIHRoaXMuZW1pdCgnY3JlYXRlJywgeyBlZGl0b3I6IHRoaXMgfSlcbiAgICB9LCAwKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkaXRvciBzdG9yYWdlLlxuICAgKi9cbiAgcHVibGljIGdldCBzdG9yYWdlKCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgIHJldHVybiB0aGlzLmV4dGVuc2lvblN0b3JhZ2VcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBvYmplY3Qgb2YgYWxsIHJlZ2lzdGVyZWQgY29tbWFuZHMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGNvbW1hbmRzKCk6IFNpbmdsZUNvbW1hbmRzIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jb21tYW5kc1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNvbW1hbmQgY2hhaW4gdG8gY2FsbCBtdWx0aXBsZSBjb21tYW5kcyBhdCBvbmNlLlxuICAgKi9cbiAgcHVibGljIGNoYWluKCk6IENoYWluZWRDb21tYW5kcyB7XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZE1hbmFnZXIuY2hhaW4oKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgY29tbWFuZCBvciBhIGNvbW1hbmQgY2hhaW4gY2FuIGJlIGV4ZWN1dGVkLiBXaXRob3V0IGV4ZWN1dGluZyBpdC5cbiAgICovXG4gIHB1YmxpYyBjYW4oKTogQ2FuQ29tbWFuZHMge1xuICAgIHJldHVybiB0aGlzLmNvbW1hbmRNYW5hZ2VyLmNhbigpXG4gIH1cblxuICAvKipcbiAgICogSW5qZWN0IENTUyBzdHlsZXMuXG4gICAqL1xuICBwcml2YXRlIGluamVjdENTUygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmluamVjdENTUyAmJiBkb2N1bWVudCkge1xuICAgICAgdGhpcy5jc3MgPSBjcmVhdGVTdHlsZVRhZyhzdHlsZSwgdGhpcy5vcHRpb25zLmluamVjdE5vbmNlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZWRpdG9yIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIEEgbGlzdCBvZiBvcHRpb25zXG4gICAqL1xuICBwdWJsaWMgc2V0T3B0aW9ucyhvcHRpb25zOiBQYXJ0aWFsPEVkaXRvck9wdGlvbnM+ID0ge30pOiB2b2lkIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH1cblxuICAgIGlmICghdGhpcy52aWV3IHx8ICF0aGlzLnN0YXRlIHx8IHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMpIHtcbiAgICAgIHRoaXMudmlldy5zZXRQcm9wcyh0aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMpXG4gICAgfVxuXG4gICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHRoaXMuc3RhdGUpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGVkaXRhYmxlIHN0YXRlIG9mIHRoZSBlZGl0b3IuXG4gICAqL1xuICBwdWJsaWMgc2V0RWRpdGFibGUoZWRpdGFibGU6IGJvb2xlYW4sIGVtaXRVcGRhdGUgPSB0cnVlKTogdm9pZCB7XG4gICAgdGhpcy5zZXRPcHRpb25zKHsgZWRpdGFibGUgfSlcblxuICAgIGlmIChlbWl0VXBkYXRlKSB7XG4gICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHsgZWRpdG9yOiB0aGlzLCB0cmFuc2FjdGlvbjogdGhpcy5zdGF0ZS50ciB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVkaXRvciBpcyBlZGl0YWJsZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgaXNFZGl0YWJsZSgpOiBib29sZWFuIHtcbiAgICAvLyBzaW5jZSBwbHVnaW5zIGFyZSBhcHBsaWVkIGFmdGVyIGNyZWF0aW5nIHRoZSB2aWV3XG4gICAgLy8gYGVkaXRhYmxlYCBpcyBhbHdheXMgYHRydWVgIGZvciBvbmUgdGljay5cbiAgICAvLyB0aGF04oCZcyB3aHkgd2UgYWxzbyBoYXZlIHRvIGNoZWNrIGZvciBgb3B0aW9ucy5lZGl0YWJsZWBcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmVkaXRhYmxlICYmIHRoaXMudmlldyAmJiB0aGlzLnZpZXcuZWRpdGFibGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGl0b3Igc3RhdGUuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0YXRlKCk6IEVkaXRvclN0YXRlIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LnN0YXRlXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBQcm9zZU1pcnJvciBwbHVnaW4uXG4gICAqXG4gICAqIEBwYXJhbSBwbHVnaW4gQSBQcm9zZU1pcnJvciBwbHVnaW5cbiAgICogQHBhcmFtIGhhbmRsZVBsdWdpbnMgQ29udHJvbCBob3cgdG8gbWVyZ2UgdGhlIHBsdWdpbiBpbnRvIHRoZSBleGlzdGluZyBwbHVnaW5zLlxuICAgKi9cbiAgcHVibGljIHJlZ2lzdGVyUGx1Z2luKFxuICAgIHBsdWdpbjogUGx1Z2luLFxuICAgIGhhbmRsZVBsdWdpbnM/OiAobmV3UGx1Z2luOiBQbHVnaW4sIHBsdWdpbnM6IFBsdWdpbltdKSA9PiBQbHVnaW5bXSxcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgcGx1Z2lucyA9IGlzRnVuY3Rpb24oaGFuZGxlUGx1Z2lucylcbiAgICAgID8gaGFuZGxlUGx1Z2lucyhwbHVnaW4sIFsuLi50aGlzLnN0YXRlLnBsdWdpbnNdKVxuICAgICAgOiBbLi4udGhpcy5zdGF0ZS5wbHVnaW5zLCBwbHVnaW5dXG5cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUucmVjb25maWd1cmUoeyBwbHVnaW5zIH0pXG5cbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpXG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlciBhIFByb3NlTWlycm9yIHBsdWdpbi5cbiAgICpcbiAgICogQHBhcmFtIG5hbWVPclBsdWdpbktleSBUaGUgcGx1Z2lucyBuYW1lXG4gICAqL1xuICBwdWJsaWMgdW5yZWdpc3RlclBsdWdpbihuYW1lT3JQbHVnaW5LZXk6IHN0cmluZyB8IFBsdWdpbktleSk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgbmFtZSA9IHR5cGVvZiBuYW1lT3JQbHVnaW5LZXkgPT09ICdzdHJpbmcnID8gYCR7bmFtZU9yUGx1Z2luS2V5fSRgIDogbmFtZU9yUGx1Z2luS2V5LmtleVxuXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHBsdWdpbnM6IHRoaXMuc3RhdGUucGx1Z2lucy5maWx0ZXIocGx1Z2luID0+ICFwbHVnaW4ua2V5LnN0YXJ0c1dpdGgobmFtZSkpLFxuICAgIH0pXG5cbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBleHRlbnNpb24gbWFuYWdlci5cbiAgICovXG4gIHByaXZhdGUgY3JlYXRlRXh0ZW5zaW9uTWFuYWdlcigpOiB2b2lkIHtcbiAgICBjb25zdCBjb3JlRXh0ZW5zaW9ucyA9IHRoaXMub3B0aW9ucy5lbmFibGVDb3JlRXh0ZW5zaW9ucyA/IE9iamVjdC52YWx1ZXMoZXh0ZW5zaW9ucykgOiBbXVxuICAgIGNvbnN0IGFsbEV4dGVuc2lvbnMgPSBbLi4uY29yZUV4dGVuc2lvbnMsIC4uLnRoaXMub3B0aW9ucy5leHRlbnNpb25zXS5maWx0ZXIoZXh0ZW5zaW9uID0+IHtcbiAgICAgIHJldHVybiBbJ2V4dGVuc2lvbicsICdub2RlJywgJ21hcmsnXS5pbmNsdWRlcyhleHRlbnNpb24/LnR5cGUpXG4gICAgfSlcblxuICAgIHRoaXMuZXh0ZW5zaW9uTWFuYWdlciA9IG5ldyBFeHRlbnNpb25NYW5hZ2VyKGFsbEV4dGVuc2lvbnMsIHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBjb21tYW5kIG1hbmFnZXIuXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZUNvbW1hbmRNYW5hZ2VyKCk6IHZvaWQge1xuICAgIHRoaXMuY29tbWFuZE1hbmFnZXIgPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgICAgZWRpdG9yOiB0aGlzLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFByb3NlTWlycm9yIHNjaGVtYS5cbiAgICovXG4gIHByaXZhdGUgY3JlYXRlU2NoZW1hKCk6IHZvaWQge1xuICAgIHRoaXMuc2NoZW1hID0gdGhpcy5leHRlbnNpb25NYW5hZ2VyLnNjaGVtYVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQcm9zZU1pcnJvciB2aWV3LlxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVWaWV3KCk6IHZvaWQge1xuICAgIGNvbnN0IGRvYyA9IGNyZWF0ZURvY3VtZW50KHRoaXMub3B0aW9ucy5jb250ZW50LCB0aGlzLnNjaGVtYSwgdGhpcy5vcHRpb25zLnBhcnNlT3B0aW9ucylcbiAgICBjb25zdCBzZWxlY3Rpb24gPSByZXNvbHZlRm9jdXNQb3NpdGlvbihkb2MsIHRoaXMub3B0aW9ucy5hdXRvZm9jdXMpXG5cbiAgICB0aGlzLnZpZXcgPSBuZXcgRWRpdG9yVmlldyh0aGlzLm9wdGlvbnMuZWxlbWVudCwge1xuICAgICAgLi4udGhpcy5vcHRpb25zLmVkaXRvclByb3BzLFxuICAgICAgZGlzcGF0Y2hUcmFuc2FjdGlvbjogdGhpcy5kaXNwYXRjaFRyYW5zYWN0aW9uLmJpbmQodGhpcyksXG4gICAgICBzdGF0ZTogRWRpdG9yU3RhdGUuY3JlYXRlKHtcbiAgICAgICAgZG9jLFxuICAgICAgICBzZWxlY3Rpb246IHNlbGVjdGlvbiB8fCB1bmRlZmluZWQsXG4gICAgICB9KSxcbiAgICB9KVxuXG4gICAgLy8gYGVkaXRvci52aWV3YCBpcyBub3QgeWV0IGF2YWlsYWJsZSBhdCB0aGlzIHRpbWUuXG4gICAgLy8gVGhlcmVmb3JlIHdlIHdpbGwgYWRkIGFsbCBwbHVnaW5zIGFuZCBub2RlIHZpZXdzIGRpcmVjdGx5IGFmdGVyd2FyZHMuXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHtcbiAgICAgIHBsdWdpbnM6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5wbHVnaW5zLFxuICAgIH0pXG5cbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUobmV3U3RhdGUpXG5cbiAgICB0aGlzLmNyZWF0ZU5vZGVWaWV3cygpXG4gICAgdGhpcy5wcmVwZW5kQ2xhc3MoKVxuXG4gICAgLy8gTGV04oCZcyBzdG9yZSB0aGUgZWRpdG9yIGluc3RhbmNlIGluIHRoZSBET00gZWxlbWVudC5cbiAgICAvLyBTbyB3ZeKAmWxsIGhhdmUgYWNjZXNzIHRvIGl0IGZvciB0ZXN0cy5cbiAgICBjb25zdCBkb20gPSB0aGlzLnZpZXcuZG9tIGFzIEhUTUxFbGVtZW50XG5cbiAgICBkb20uZWRpdG9yID0gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYWxsIG5vZGUgdmlld3MuXG4gICAqL1xuICBwdWJsaWMgY3JlYXRlTm9kZVZpZXdzKCk6IHZvaWQge1xuICAgIHRoaXMudmlldy5zZXRQcm9wcyh7XG4gICAgICBub2RlVmlld3M6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5ub2RlVmlld3MsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwZW5kIGNsYXNzIG5hbWUgdG8gZWxlbWVudC5cbiAgICovXG4gIHB1YmxpYyBwcmVwZW5kQ2xhc3MoKTogdm9pZCB7XG4gICAgdGhpcy52aWV3LmRvbS5jbGFzc05hbWUgPSBgdGlwdGFwICR7dGhpcy52aWV3LmRvbS5jbGFzc05hbWV9YFxuICB9XG5cbiAgcHVibGljIGlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSBmYWxzZVxuXG4gIHByaXZhdGUgY2FwdHVyZWRUcmFuc2FjdGlvbjogVHJhbnNhY3Rpb24gfCBudWxsID0gbnVsbFxuXG4gIHB1YmxpYyBjYXB0dXJlVHJhbnNhY3Rpb24oZm46IEZ1bmN0aW9uKSB7XG4gICAgdGhpcy5pc0NhcHR1cmluZ1RyYW5zYWN0aW9uID0gdHJ1ZVxuICAgIGZuKClcbiAgICB0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSBmYWxzZVxuXG4gICAgY29uc3QgdHIgPSB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb25cblxuICAgIHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbiA9IG51bGxcblxuICAgIHJldHVybiB0clxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjYWxsYmFjayBvdmVyIHdoaWNoIHRvIHNlbmQgdHJhbnNhY3Rpb25zIChzdGF0ZSB1cGRhdGVzKSBwcm9kdWNlZCBieSB0aGUgdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uIEFuIGVkaXRvciBzdGF0ZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBkaXNwYXRjaFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbik6IHZvaWQge1xuICAgIC8vIGlmIHRoZSBlZGl0b3IgLyB0aGUgdmlldyBvZiB0aGUgZWRpdG9yIHdhcyBkZXN0cm95ZWRcbiAgICAvLyB0aGUgdHJhbnNhY3Rpb24gc2hvdWxkIG5vdCBiZSBkaXNwYXRjaGVkIGFzIHRoZXJlIGlzIG5vIHZpZXcgYW55bW9yZS5cbiAgICBpZiAodGhpcy52aWV3LmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0NhcHR1cmluZ1RyYW5zYWN0aW9uKSB7XG4gICAgICBpZiAoIXRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbikge1xuICAgICAgICB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvblxuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0cmFuc2FjdGlvbi5zdGVwcy5mb3JFYWNoKHN0ZXAgPT4gdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uPy5zdGVwKHN0ZXApKVxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUuYXBwbHkodHJhbnNhY3Rpb24pXG4gICAgY29uc3Qgc2VsZWN0aW9uSGFzQ2hhbmdlZCA9ICF0aGlzLnN0YXRlLnNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pXG5cbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpXG4gICAgdGhpcy5lbWl0KCd0cmFuc2FjdGlvbicsIHtcbiAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgIH0pXG5cbiAgICBpZiAoc2VsZWN0aW9uSGFzQ2hhbmdlZCkge1xuICAgICAgdGhpcy5lbWl0KCdzZWxlY3Rpb25VcGRhdGUnLCB7XG4gICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IGZvY3VzID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgnZm9jdXMnKVxuICAgIGNvbnN0IGJsdXIgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCdibHVyJylcblxuICAgIGlmIChmb2N1cykge1xuICAgICAgdGhpcy5lbWl0KCdmb2N1cycsIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICBldmVudDogZm9jdXMuZXZlbnQsXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoYmx1cikge1xuICAgICAgdGhpcy5lbWl0KCdibHVyJywge1xuICAgICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICAgIGV2ZW50OiBibHVyLmV2ZW50LFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKCF0cmFuc2FjdGlvbi5kb2NDaGFuZ2VkIHx8IHRyYW5zYWN0aW9uLmdldE1ldGEoJ3ByZXZlbnRVcGRhdGUnKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB7XG4gICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhdHRyaWJ1dGVzIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZSBvciBtYXJrLlxuICAgKi9cbiAgcHVibGljIGdldEF0dHJpYnV0ZXMobmFtZU9yVHlwZTogc3RyaW5nIHwgTm9kZVR5cGUgfCBNYXJrVHlwZSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgIHJldHVybiBnZXRBdHRyaWJ1dGVzKHRoaXMuc3RhdGUsIG5hbWVPclR5cGUpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGUgb3IgbWFyayBpcyBhY3RpdmUuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIG5vZGUgb3IgbWFya1xuICAgKiBAcGFyYW0gYXR0cmlidXRlcyBBdHRyaWJ1dGVzIG9mIHRoZSBub2RlIG9yIG1hcmtcbiAgICovXG4gIHB1YmxpYyBpc0FjdGl2ZShuYW1lOiBzdHJpbmcsIGF0dHJpYnV0ZXM/OiB7fSk6IGJvb2xlYW5cbiAgcHVibGljIGlzQWN0aXZlKGF0dHJpYnV0ZXM6IHt9KTogYm9vbGVhblxuICBwdWJsaWMgaXNBY3RpdmUobmFtZU9yQXR0cmlidXRlczogc3RyaW5nLCBhdHRyaWJ1dGVzT3JVbmRlZmluZWQ/OiB7fSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbmFtZU9yQXR0cmlidXRlcyA9PT0gJ3N0cmluZycgPyBuYW1lT3JBdHRyaWJ1dGVzIDogbnVsbFxuXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHR5cGVvZiBuYW1lT3JBdHRyaWJ1dGVzID09PSAnc3RyaW5nJyA/IGF0dHJpYnV0ZXNPclVuZGVmaW5lZCA6IG5hbWVPckF0dHJpYnV0ZXNcblxuICAgIHJldHVybiBpc0FjdGl2ZSh0aGlzLnN0YXRlLCBuYW1lLCBhdHRyaWJ1dGVzKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyBnZXRKU09OKCk6IEpTT05Db250ZW50IHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5kb2MudG9KU09OKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRvY3VtZW50IGFzIEhUTUwuXG4gICAqL1xuICBwdWJsaWMgZ2V0SFRNTCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBnZXRIVE1MRnJvbUZyYWdtZW50KHRoaXMuc3RhdGUuZG9jLmNvbnRlbnQsIHRoaXMuc2NoZW1hKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgdGV4dC5cbiAgICovXG4gIHB1YmxpYyBnZXRUZXh0KG9wdGlvbnM/OiB7XG4gICAgYmxvY2tTZXBhcmF0b3I/OiBzdHJpbmdcbiAgICB0ZXh0U2VyaWFsaXplcnM/OiBSZWNvcmQ8c3RyaW5nLCBUZXh0U2VyaWFsaXplcj5cbiAgfSk6IHN0cmluZyB7XG4gICAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgcmV0dXJuIGdldFRleHQodGhpcy5zdGF0ZS5kb2MsIHtcbiAgICAgIGJsb2NrU2VwYXJhdG9yLFxuICAgICAgdGV4dFNlcmlhbGl6ZXJzOiB7XG4gICAgICAgIC4uLmdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEodGhpcy5zY2hlbWEpLFxuICAgICAgICAuLi50ZXh0U2VyaWFsaXplcnMsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlcmUgaXMgbm8gY29udGVudC5cbiAgICovXG4gIHB1YmxpYyBnZXQgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNOb2RlRW1wdHkodGhpcy5zdGF0ZS5kb2MpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBmb3IgdGhlIGN1cnJlbnQgZG9jdW1lbnQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBwdWJsaWMgZ2V0Q2hhcmFjdGVyQ291bnQoKTogbnVtYmVyIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnW3RpcHRhcCB3YXJuXTogXCJlZGl0b3IuZ2V0Q2hhcmFjdGVyQ291bnQoKVwiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJlZGl0b3Iuc3RvcmFnZS5jaGFyYWN0ZXJDb3VudC5jaGFyYWN0ZXJzKClcIiBpbnN0ZWFkLicsXG4gICAgKVxuXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSAtIDJcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBlZGl0b3IuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knKVxuXG4gICAgaWYgKHRoaXMudmlldykge1xuICAgICAgdGhpcy52aWV3LmRlc3Ryb3koKVxuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZWRpdG9yIGlzIGFscmVhZHkgZGVzdHJveWVkLlxuICAgKi9cbiAgcHVibGljIGdldCBpc0Rlc3Ryb3llZCgpOiBib29sZWFuIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuICF0aGlzLnZpZXc/LmRvY1ZpZXdcbiAgfVxuXG4gIHB1YmxpYyAkbm9kZShzZWxlY3Rvcjogc3RyaW5nLCBhdHRyaWJ1dGVzPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfSk6IE5vZGVQb3MgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy4kZG9jPy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yLCBhdHRyaWJ1dGVzKSB8fCBudWxsXG4gIH1cblxuICBwdWJsaWMgJG5vZGVzKHNlbGVjdG9yOiBzdHJpbmcsIGF0dHJpYnV0ZXM/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9KTogTm9kZVBvc1tdIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuJGRvYz8ucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciwgYXR0cmlidXRlcykgfHwgbnVsbFxuICB9XG5cbiAgcHVibGljICRwb3MocG9zOiBudW1iZXIpIHtcbiAgICBjb25zdCAkcG9zID0gdGhpcy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MpXG5cbiAgICByZXR1cm4gbmV3IE5vZGVQb3MoJHBvcywgdGhpcylcbiAgfVxuXG4gIGdldCAkZG9jKCkge1xuICAgIHJldHVybiB0aGlzLiRwb3MoMClcbiAgfVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya3NCZXR3ZWVuIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrc0JldHdlZW4uanMnXG5pbXBvcnQgeyBJbnB1dFJ1bGUsIElucHV0UnVsZUZpbmRlciB9IGZyb20gJy4uL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIHRoYXQgYWRkcyBhIG1hcmsgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyB0eXBlZCBpbnRvIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFya0lucHV0UnVsZShjb25maWc6IHtcbiAgZmluZDogSW5wdXRSdWxlRmluZGVyXG4gIHR5cGU6IE1hcmtUeXBlXG4gIGdldEF0dHJpYnV0ZXM/OlxuICAgIHwgUmVjb3JkPHN0cmluZywgYW55PlxuICAgIHwgKChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5KSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgIHwgZmFsc2VcbiAgICB8IG51bGxcbn0pIHtcbiAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaClcblxuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGVcbiAgICAgIGNvbnN0IGNhcHR1cmVHcm91cCA9IG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdXG4gICAgICBjb25zdCBmdWxsTWF0Y2ggPSBtYXRjaFswXVxuXG4gICAgICBpZiAoY2FwdHVyZUdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0U3BhY2VzID0gZnVsbE1hdGNoLnNlYXJjaCgvXFxTLylcbiAgICAgICAgY29uc3QgdGV4dFN0YXJ0ID0gcmFuZ2UuZnJvbSArIGZ1bGxNYXRjaC5pbmRleE9mKGNhcHR1cmVHcm91cClcbiAgICAgICAgY29uc3QgdGV4dEVuZCA9IHRleHRTdGFydCArIGNhcHR1cmVHcm91cC5sZW5ndGhcblxuICAgICAgICBjb25zdCBleGNsdWRlZE1hcmtzID0gZ2V0TWFya3NCZXR3ZWVuKHJhbmdlLmZyb20sIHJhbmdlLnRvLCBzdGF0ZS5kb2MpXG4gICAgICAgICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gaXRlbS5tYXJrLnR5cGUuZXhjbHVkZWQgYXMgTWFya1R5cGVbXVxuXG4gICAgICAgICAgICByZXR1cm4gZXhjbHVkZWQuZmluZCh0eXBlID0+IHR5cGUgPT09IGNvbmZpZy50eXBlICYmIHR5cGUgIT09IGl0ZW0ubWFyay50eXBlKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0udG8gPiB0ZXh0U3RhcnQpXG5cbiAgICAgICAgaWYgKGV4Y2x1ZGVkTWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0RW5kIDwgcmFuZ2UudG8pIHtcbiAgICAgICAgICB0ci5kZWxldGUodGV4dEVuZCwgcmFuZ2UudG8pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dFN0YXJ0ID4gcmFuZ2UuZnJvbSkge1xuICAgICAgICAgIHRyLmRlbGV0ZShyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIHRleHRTdGFydClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1hcmtFbmQgPSByYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMgKyBjYXB0dXJlR3JvdXAubGVuZ3RoXG5cbiAgICAgICAgdHIuYWRkTWFyayhyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIG1hcmtFbmQsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzIHx8IHt9KSlcblxuICAgICAgICB0ci5yZW1vdmVTdG9yZWRNYXJrKGNvbmZpZy50eXBlKVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBJbnB1dFJ1bGUsIElucHV0UnVsZUZpbmRlciB9IGZyb20gJy4uL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIHRoYXQgYWRkcyBhIG5vZGUgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyB0eXBlZCBpbnRvIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9kZUlucHV0UnVsZShjb25maWc6IHtcbiAgLyoqXG4gICAqIFRoZSByZWdleCB0byBtYXRjaC5cbiAgICovXG4gIGZpbmQ6IElucHV0UnVsZUZpbmRlclxuXG4gIC8qKlxuICAgKiBUaGUgbm9kZSB0eXBlIHRvIGFkZC5cbiAgICovXG4gIHR5cGU6IE5vZGVUeXBlXG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgbm9kZVxuICAgKiBjYW4gYWxzbyBiZSBhbiBvYmplY3Qgb2YgYXR0cmlidXRlc1xuICAgKi9cbiAgZ2V0QXR0cmlidXRlcz86XG4gICAgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgfCAoKG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkpID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgfCBmYWxzZVxuICAgIHwgbnVsbFxufSkge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKSB8fCB7fVxuICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGVcbiAgICAgIGNvbnN0IHN0YXJ0ID0gcmFuZ2UuZnJvbVxuICAgICAgbGV0IGVuZCA9IHJhbmdlLnRvXG5cbiAgICAgIGNvbnN0IG5ld05vZGUgPSBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcylcblxuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKVxuICAgICAgICBsZXQgbWF0Y2hTdGFydCA9IHN0YXJ0ICsgb2Zmc2V0XG5cbiAgICAgICAgaWYgKG1hdGNoU3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICBtYXRjaFN0YXJ0ID0gZW5kXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kID0gbWF0Y2hTdGFydCArIG1hdGNoWzFdLmxlbmd0aFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5zZXJ0IGxhc3QgdHlwZWQgY2hhcmFjdGVyXG4gICAgICAgIGNvbnN0IGxhc3RDaGFyID0gbWF0Y2hbMF1bbWF0Y2hbMF0ubGVuZ3RoIC0gMV1cblxuICAgICAgICB0ci5pbnNlcnRUZXh0KGxhc3RDaGFyLCBzdGFydCArIG1hdGNoWzBdLmxlbmd0aCAtIDEpXG5cbiAgICAgICAgLy8gaW5zZXJ0IG5vZGUgZnJvbSBpbnB1dCBydWxlXG4gICAgICAgIHRyLnJlcGxhY2VXaXRoKG1hdGNoU3RhcnQsIGVuZCwgbmV3Tm9kZSlcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0pIHtcbiAgICAgICAgdHIuaW5zZXJ0KHN0YXJ0IC0gMSwgY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMpKS5kZWxldGUoXG4gICAgICAgICAgdHIubWFwcGluZy5tYXAoc3RhcnQpLFxuICAgICAgICAgIHRyLm1hcHBpbmcubWFwKGVuZCksXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBJbnB1dFJ1bGUsIElucHV0UnVsZUZpbmRlciB9IGZyb20gJy4uL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIHRoYXQgY2hhbmdlcyB0aGUgdHlwZSBvZiBhIHRleHRibG9jayB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuIFdoZW4gdXNpbmcgYSByZWd1bGFyIGV4cHJlc2lvbiB5b3XigJlsbFxuICogcHJvYmFibHkgd2FudCB0aGUgcmVnZXhwIHRvIHN0YXJ0IHdpdGggYF5gLCBzbyB0aGF0IHRoZSBwYXR0ZXJuIGNhblxuICogb25seSBvY2N1ciBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKGNvbmZpZzoge1xuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXJcbiAgdHlwZTogTm9kZVR5cGVcbiAgZ2V0QXR0cmlidXRlcz86XG4gICAgfCBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgfCAoKG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkpID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgfCBmYWxzZVxuICAgIHwgbnVsbFxufSkge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBjb25zdCAkc3RhcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShyYW5nZS5mcm9tKVxuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCkgfHwge31cblxuICAgICAgaWYgKCEkc3RhcnQubm9kZSgtMSkuY2FuUmVwbGFjZVdpdGgoJHN0YXJ0LmluZGV4KC0xKSwgJHN0YXJ0LmluZGV4QWZ0ZXIoLTEpLCBjb25maWcudHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgc3RhdGUudHJcbiAgICAgICAgLmRlbGV0ZShyYW5nZS5mcm9tLCByYW5nZS50bylcbiAgICAgICAgLnNldEJsb2NrVHlwZShyYW5nZS5mcm9tLCByYW5nZS5mcm9tLCBjb25maWcudHlwZSwgYXR0cmlidXRlcylcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IElucHV0UnVsZSwgSW5wdXRSdWxlRmluZGVyIH0gZnJvbSAnLi4vSW5wdXRSdWxlLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCByZXBsYWNlcyB0ZXh0IHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHRJbnB1dFJ1bGUoY29uZmlnOiB7XG4gIGZpbmQ6IElucHV0UnVsZUZpbmRlcixcbiAgcmVwbGFjZTogc3RyaW5nLFxufSkge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBsZXQgaW5zZXJ0ID0gY29uZmlnLnJlcGxhY2VcbiAgICAgIGxldCBzdGFydCA9IHJhbmdlLmZyb21cbiAgICAgIGNvbnN0IGVuZCA9IHJhbmdlLnRvXG5cbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXRjaFswXS5sYXN0SW5kZXhPZihtYXRjaFsxXSlcblxuICAgICAgICBpbnNlcnQgKz0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0ICsgbWF0Y2hbMV0ubGVuZ3RoKVxuICAgICAgICBzdGFydCArPSBvZmZzZXRcblxuICAgICAgICBjb25zdCBjdXRPZmYgPSBzdGFydCAtIGVuZFxuXG4gICAgICAgIGlmIChjdXRPZmYgPiAwKSB7XG4gICAgICAgICAgaW5zZXJ0ID0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0IC0gY3V0T2ZmLCBvZmZzZXQpICsgaW5zZXJ0XG4gICAgICAgICAgc3RhcnQgPSBlbmRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS50ci5pbnNlcnRUZXh0KGluc2VydCwgc3RhcnQsIGVuZClcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBjYW5Kb2luLCBmaW5kV3JhcHBpbmcgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSAnLi4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgSW5wdXRSdWxlLCBJbnB1dFJ1bGVGaW5kZXIgfSBmcm9tICcuLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4uL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5cbi8qKlxuICogQnVpbGQgYW4gaW5wdXQgcnVsZSBmb3IgYXV0b21hdGljYWxseSB3cmFwcGluZyBhIHRleHRibG9jayB3aGVuIGFcbiAqIGdpdmVuIHN0cmluZyBpcyB0eXBlZC4gV2hlbiB1c2luZyBhIHJlZ3VsYXIgZXhwcmVzaW9uIHlvdeKAmWxsXG4gKiBwcm9iYWJseSB3YW50IHRoZSByZWdleHAgdG8gc3RhcnQgd2l0aCBgXmAsIHNvIHRoYXQgdGhlIHBhdHRlcm4gY2FuXG4gKiBvbmx5IG9jY3VyIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jay5cbiAqXG4gKiBgdHlwZWAgaXMgdGhlIHR5cGUgb2Ygbm9kZSB0byB3cmFwIGluLlxuICpcbiAqIEJ5IGRlZmF1bHQsIGlmIHRoZXJl4oCZcyBhIG5vZGUgd2l0aCB0aGUgc2FtZSB0eXBlIGFib3ZlIHRoZSBuZXdseVxuICogd3JhcHBlZCBub2RlLCB0aGUgcnVsZSB3aWxsIHRyeSB0byBqb2luIHRob3NlXG4gKiB0d28gbm9kZXMuIFlvdSBjYW4gcGFzcyBhIGpvaW4gcHJlZGljYXRlLCB3aGljaCB0YWtlcyBhIHJlZ3VsYXJcbiAqIGV4cHJlc3Npb24gbWF0Y2ggYW5kIHRoZSBub2RlIGJlZm9yZSB0aGUgd3JhcHBlZCBub2RlLCBhbmQgY2FuXG4gKiByZXR1cm4gYSBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgYSBqb2luIHNob3VsZCBoYXBwZW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwcGluZ0lucHV0UnVsZShjb25maWc6IHtcbiAgZmluZDogSW5wdXRSdWxlRmluZGVyLFxuICB0eXBlOiBOb2RlVHlwZSxcbiAga2VlcE1hcmtzPzogYm9vbGVhbixcbiAga2VlcEF0dHJpYnV0ZXM/OiBib29sZWFuLFxuICBlZGl0b3I/OiBFZGl0b3JcbiAgZ2V0QXR0cmlidXRlcz86XG4gIHwgUmVjb3JkPHN0cmluZywgYW55PlxuICB8ICgobWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgfCBmYWxzZVxuICB8IG51bGxcbiAgLFxuICBqb2luUHJlZGljYXRlPzogKG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXksIG5vZGU6IFByb3NlTWlycm9yTm9kZSkgPT4gYm9vbGVhbixcbn0pIHtcbiAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7XG4gICAgICBzdGF0ZSwgcmFuZ2UsIG1hdGNoLCBjaGFpbixcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKSB8fCB7fVxuICAgICAgY29uc3QgdHIgPSBzdGF0ZS50ci5kZWxldGUocmFuZ2UuZnJvbSwgcmFuZ2UudG8pXG4gICAgICBjb25zdCAkc3RhcnQgPSB0ci5kb2MucmVzb2x2ZShyYW5nZS5mcm9tKVxuICAgICAgY29uc3QgYmxvY2tSYW5nZSA9ICRzdGFydC5ibG9ja1JhbmdlKClcbiAgICAgIGNvbnN0IHdyYXBwaW5nID0gYmxvY2tSYW5nZSAmJiBmaW5kV3JhcHBpbmcoYmxvY2tSYW5nZSwgY29uZmlnLnR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgICAgIGlmICghd3JhcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgdHIud3JhcChibG9ja1JhbmdlLCB3cmFwcGluZylcblxuICAgICAgaWYgKGNvbmZpZy5rZWVwTWFya3MgJiYgY29uZmlnLmVkaXRvcikge1xuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlXG4gICAgICAgIGNvbnN0IHsgc3BsaXR0YWJsZU1hcmtzIH0gPSBjb25maWcuZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXJcbiAgICAgICAgY29uc3QgbWFya3MgPSBzdG9yZWRNYXJrcyB8fCAoc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXG5cbiAgICAgICAgaWYgKG1hcmtzKSB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpXG5cbiAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICAgIC8qKiBJZiB0aGUgbm9kZVR5cGUgaXMgYGJ1bGxldExpc3RgIG9yIGBvcmRlcmVkTGlzdGAgc2V0IHRoZSBgbm9kZVR5cGVgIGFzIGBsaXN0SXRlbWAgKi9cbiAgICAgICAgY29uc3Qgbm9kZVR5cGUgPSBjb25maWcudHlwZS5uYW1lID09PSAnYnVsbGV0TGlzdCcgfHwgY29uZmlnLnR5cGUubmFtZSA9PT0gJ29yZGVyZWRMaXN0JyA/ICdsaXN0SXRlbScgOiAndGFza0xpc3QnXG5cbiAgICAgICAgY2hhaW4oKS51cGRhdGVBdHRyaWJ1dGVzKG5vZGVUeXBlLCBhdHRyaWJ1dGVzKS5ydW4oKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShyYW5nZS5mcm9tIC0gMSkubm9kZUJlZm9yZVxuXG4gICAgICBpZiAoXG4gICAgICAgIGJlZm9yZVxuICAgICAgICAmJiBiZWZvcmUudHlwZSA9PT0gY29uZmlnLnR5cGVcbiAgICAgICAgJiYgY2FuSm9pbih0ci5kb2MsIHJhbmdlLmZyb20gLSAxKVxuICAgICAgICAmJiAoIWNvbmZpZy5qb2luUHJlZGljYXRlIHx8IGNvbmZpZy5qb2luUHJlZGljYXRlKG1hdGNoLCBiZWZvcmUpKVxuICAgICAgKSB7XG4gICAgICAgIHRyLmpvaW4ocmFuZ2UuZnJvbSAtIDEpXG4gICAgICB9XG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQge1xuICBET01PdXRwdXRTcGVjLCBNYXJrIGFzIFByb3NlTWlycm9yTWFyaywgTWFya1NwZWMsIE1hcmtUeXBlLFxufSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgUGx1Z2luLCBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgZ2V0RXh0ZW5zaW9uRmllbGQgfSBmcm9tICcuL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBNYXJrQ29uZmlnIH0gZnJvbSAnLi9pbmRleC5qcydcbmltcG9ydCB7IElucHV0UnVsZSB9IGZyb20gJy4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vTm9kZS5qcydcbmltcG9ydCB7IFBhc3RlUnVsZSB9IGZyb20gJy4vUGFzdGVSdWxlLmpzJ1xuaW1wb3J0IHtcbiAgQW55Q29uZmlnLFxuICBBdHRyaWJ1dGVzLFxuICBFeHRlbnNpb25zLFxuICBHbG9iYWxBdHRyaWJ1dGVzLFxuICBLZXlib2FyZFNob3J0Y3V0Q29tbWFuZCxcbiAgUGFyZW50Q29uZmlnLFxuICBSYXdDb21tYW5kcyxcbn0gZnJvbSAnLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcbmltcG9ydCB7IG1lcmdlRGVlcCB9IGZyb20gJy4vdXRpbGl0aWVzL21lcmdlRGVlcC5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBleHBvcnQgaW50ZXJmYWNlIE1hcmtDb25maWc8T3B0aW9ucyA9IGFueSwgU3RvcmFnZSA9IGFueT4ge1xuICAgIFtrZXk6IHN0cmluZ106IGFueVxuXG4gICAgLyoqXG4gICAgICogTmFtZVxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZ1xuXG4gICAgLyoqXG4gICAgICogUHJpb3JpdHlcbiAgICAgKi9cbiAgICBwcmlvcml0eT86IG51bWJlclxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBvcHRpb25zXG4gICAgICovXG4gICAgZGVmYXVsdE9wdGlvbnM/OiBPcHRpb25zXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IE9wdGlvbnNcbiAgICAgKi9cbiAgICBhZGRPcHRpb25zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgcGFyZW50OiBFeGNsdWRlPFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkT3B0aW9ucyddLCB1bmRlZmluZWQ+XG4gICAgfSkgPT4gT3B0aW9uc1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBTdG9yYWdlXG4gICAgICovXG4gICAgYWRkU3RvcmFnZT86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHBhcmVudDogRXhjbHVkZTxQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFN0b3JhZ2UnXSwgdW5kZWZpbmVkPlxuICAgIH0pID0+IFN0b3JhZ2VcblxuICAgIC8qKlxuICAgICAqIEdsb2JhbCBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgYWRkR2xvYmFsQXR0cmlidXRlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRHbG9iYWxBdHRyaWJ1dGVzJ11cbiAgICB9KSA9PiBHbG9iYWxBdHRyaWJ1dGVzIHwge31cblxuICAgIC8qKlxuICAgICAqIFJhd1xuICAgICAqL1xuICAgIGFkZENvbW1hbmRzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkQ29tbWFuZHMnXVxuICAgIH0pID0+IFBhcnRpYWw8UmF3Q29tbWFuZHM+XG5cbiAgICAvKipcbiAgICAgKiBLZXlib2FyZCBzaG9ydGN1dHNcbiAgICAgKi9cbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEtleWJvYXJkU2hvcnRjdXRzJ11cbiAgICB9KSA9PiB7XG4gICAgICBba2V5OiBzdHJpbmddOiBLZXlib2FyZFNob3J0Y3V0Q29tbWFuZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElucHV0IHJ1bGVzXG4gICAgICovXG4gICAgYWRkSW5wdXRSdWxlcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZElucHV0UnVsZXMnXVxuICAgIH0pID0+IElucHV0UnVsZVtdXG5cbiAgICAvKipcbiAgICAgKiBQYXN0ZSBydWxlc1xuICAgICAqL1xuICAgIGFkZFBhc3RlUnVsZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRQYXN0ZVJ1bGVzJ11cbiAgICB9KSA9PiBQYXN0ZVJ1bGVbXVxuXG4gICAgLyoqXG4gICAgICogUHJvc2VNaXJyb3IgcGx1Z2luc1xuICAgICAqL1xuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZFByb3NlTWlycm9yUGx1Z2lucyddXG4gICAgfSkgPT4gUGx1Z2luW11cblxuICAgIC8qKlxuICAgICAqIEV4dGVuc2lvbnNcbiAgICAgKi9cbiAgICBhZGRFeHRlbnNpb25zPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEV4dGVuc2lvbnMnXVxuICAgIH0pID0+IEV4dGVuc2lvbnNcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBOb2RlIFNjaGVtYVxuICAgICAqL1xuICAgIGV4dGVuZE5vZGVTY2hlbWE/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4dGVuZE5vZGVTY2hlbWEnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXh0ZW5zaW9uOiBOb2RlLFxuICAgICAgICApID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBNYXJrIFNjaGVtYVxuICAgICAqL1xuICAgIGV4dGVuZE1hcmtTY2hlbWE/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4dGVuZE1hcmtTY2hlbWEnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXh0ZW5zaW9uOiBNYXJrLFxuICAgICAgICApID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgbm90IHJlYWR5IHlldC5cbiAgICAgKi9cbiAgICBvbkJlZm9yZUNyZWF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkJlZm9yZUNyZWF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgcmVhZHkuXG4gICAgICovXG4gICAgb25DcmVhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25DcmVhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGVudCBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblVwZGF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBNYXJrVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblVwZGF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3Rpb24gaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25TZWxlY3Rpb25VcGRhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25TZWxlY3Rpb25VcGRhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIHN0YXRlIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uVHJhbnNhY3Rpb24/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25UcmFuc2FjdGlvbiddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGZvY3VzZWQuXG4gICAgICovXG4gICAgb25Gb2N1cz86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkZvY3VzJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBldmVudDogRm9jdXNFdmVudFxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpc27igJl0IGZvY3VzZWQgYW55bW9yZS5cbiAgICAgKi9cbiAgICBvbkJsdXI/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25CbHVyJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBldmVudDogRm9jdXNFdmVudFxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgb25EZXN0cm95PzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE1hcmtUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uRGVzdHJveSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIEtlZXAgbWFyayBhZnRlciBzcGxpdCBub2RlXG4gICAgICovXG4gICAga2VlcE9uU3BsaXQ/OiBib29sZWFuIHwgKCgpID0+IGJvb2xlYW4pXG5cbiAgICAvKipcbiAgICAgKiBJbmNsdXNpdmVcbiAgICAgKi9cbiAgICBpbmNsdXNpdmU/OlxuICAgICAgfCBNYXJrU3BlY1snaW5jbHVzaXZlJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnaW5jbHVzaXZlJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTWFya1NwZWNbJ2luY2x1c2l2ZSddKVxuXG4gICAgLyoqXG4gICAgICogRXhjbHVkZXNcbiAgICAgKi9cbiAgICBleGNsdWRlcz86XG4gICAgICB8IE1hcmtTcGVjWydleGNsdWRlcyddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4Y2x1ZGVzJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTWFya1NwZWNbJ2V4Y2x1ZGVzJ10pXG5cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGlzIE1hcmsgYXMgZXhpdGFibGVcbiAgICAgKi9cbiAgICBleGl0YWJsZT86IGJvb2xlYW4gfCAoKCkgPT4gYm9vbGVhbilcblxuICAgIC8qKlxuICAgICAqIEdyb3VwXG4gICAgICovXG4gICAgZ3JvdXA/OlxuICAgICAgfCBNYXJrU3BlY1snZ3JvdXAnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydncm91cCddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE1hcmtTcGVjWydncm91cCddKVxuXG4gICAgLyoqXG4gICAgICogU3Bhbm5pbmdcbiAgICAgKi9cbiAgICBzcGFubmluZz86XG4gICAgICB8IE1hcmtTcGVjWydzcGFubmluZyddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3NwYW5uaW5nJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTWFya1NwZWNbJ3NwYW5uaW5nJ10pXG5cbiAgICAvKipcbiAgICAgKiBDb2RlXG4gICAgICovXG4gICAgY29kZT86XG4gICAgICB8IGJvb2xlYW5cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnY29kZSddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IGJvb2xlYW4pXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBIVE1MXG4gICAgICovXG4gICAgcGFyc2VIVE1MPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3BhcnNlSFRNTCddXG4gICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICB9KSA9PiBNYXJrU3BlY1sncGFyc2VET00nXVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIEhUTUxcbiAgICAgKi9cbiAgICByZW5kZXJIVE1MPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydyZW5kZXJIVE1MJ11cbiAgICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIG1hcms6IFByb3NlTWlycm9yTWFya1xuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICAgICAgICB9LFxuICAgICAgICApID0+IERPTU91dHB1dFNwZWMpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBhZGRBdHRyaWJ1dGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEF0dHJpYnV0ZXMnXVxuICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgfSkgPT4gQXR0cmlidXRlcyB8IHt9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1hcms8T3B0aW9ucyA9IGFueSwgU3RvcmFnZSA9IGFueT4ge1xuICB0eXBlID0gJ21hcmsnXG5cbiAgbmFtZSA9ICdtYXJrJ1xuXG4gIHBhcmVudDogTWFyayB8IG51bGwgPSBudWxsXG5cbiAgY2hpbGQ6IE1hcmsgfCBudWxsID0gbnVsbFxuXG4gIG9wdGlvbnM6IE9wdGlvbnNcblxuICBzdG9yYWdlOiBTdG9yYWdlXG5cbiAgY29uZmlnOiBNYXJrQ29uZmlnID0ge1xuICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICBkZWZhdWx0T3B0aW9uczoge30sXG4gIH1cblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFBhcnRpYWw8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj4gPSB7fSkge1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICAuLi5jb25maWcsXG4gICAgfVxuXG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25maWcubmFtZVxuXG4gICAgaWYgKGNvbmZpZy5kZWZhdWx0T3B0aW9ucyAmJiBPYmplY3Qua2V5cyhjb25maWcuZGVmYXVsdE9wdGlvbnMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7dGhpcy5uYW1lfVwiLmAsXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGBhZGRPcHRpb25zYCBmYWxsYmFja1xuICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuY29uZmlnLmRlZmF1bHRPcHRpb25zXG5cbiAgICBpZiAodGhpcy5jb25maWcuYWRkT3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gY2FsbE9yUmV0dXJuKFxuICAgICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZE9wdGlvbnMnXT4odGhpcywgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4odGhpcywgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKSB8fCB7fVxuICB9XG5cbiAgc3RhdGljIGNyZWF0ZTxPID0gYW55LCBTID0gYW55Pihjb25maWc6IFBhcnRpYWw8TWFya0NvbmZpZzxPLCBTPj4gPSB7fSkge1xuICAgIHJldHVybiBuZXcgTWFyazxPLCBTPihjb25maWcpXG4gIH1cblxuICBjb25maWd1cmUob3B0aW9uczogUGFydGlhbDxPcHRpb25zPiA9IHt9KSB7XG4gICAgLy8gcmV0dXJuIGEgbmV3IGluc3RhbmNlIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgZXh0ZW5zaW9uXG4gICAgLy8gd2l0aCBkaWZmZXJlbnQgY2FsbHMgb2YgYGNvbmZpZ3VyZWBcbiAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmV4dGVuZCgpXG5cbiAgICBleHRlbnNpb24ub3B0aW9ucyA9IG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMgYXMgUmVjb3JkPHN0cmluZywgYW55Piwgb3B0aW9ucykgYXMgT3B0aW9uc1xuXG4gICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4oZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG5cbiAgZXh0ZW5kPEV4dGVuZGVkT3B0aW9ucyA9IE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZSA9IFN0b3JhZ2U+KFxuICAgIGV4dGVuZGVkQ29uZmlnOiBQYXJ0aWFsPE1hcmtDb25maWc8RXh0ZW5kZWRPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2U+PiA9IHt9LFxuICApIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSBuZXcgTWFyazxFeHRlbmRlZE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZT4oeyAuLi50aGlzLmNvbmZpZywgLi4uZXh0ZW5kZWRDb25maWcgfSlcblxuICAgIGV4dGVuc2lvbi5wYXJlbnQgPSB0aGlzXG5cbiAgICB0aGlzLmNoaWxkID0gZXh0ZW5zaW9uXG5cbiAgICBleHRlbnNpb24ubmFtZSA9IGV4dGVuZGVkQ29uZmlnLm5hbWUgPyBleHRlbmRlZENvbmZpZy5uYW1lIDogZXh0ZW5zaW9uLnBhcmVudC5uYW1lXG5cbiAgICBpZiAoZXh0ZW5kZWRDb25maWcuZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7ZXh0ZW5zaW9uLm5hbWV9XCIuYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICBleHRlbnNpb24ub3B0aW9ucyA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkT3B0aW9ucyddPihleHRlbnNpb24sICdhZGRPcHRpb25zJywge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIH0pLFxuICAgIClcblxuICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRTdG9yYWdlJ10+KGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIH0pLFxuICAgIClcblxuICAgIHJldHVybiBleHRlbnNpb25cbiAgfVxuXG4gIHN0YXRpYyBoYW5kbGVFeGl0KHsgZWRpdG9yLCBtYXJrIH06IHsgZWRpdG9yOiBFZGl0b3I7IG1hcms6IE1hcmsgfSkge1xuICAgIGNvbnN0IHsgdHIgfSA9IGVkaXRvci5zdGF0ZVxuICAgIGNvbnN0IGN1cnJlbnRQb3MgPSBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLiRmcm9tXG4gICAgY29uc3QgaXNBdEVuZCA9IGN1cnJlbnRQb3MucG9zID09PSBjdXJyZW50UG9zLmVuZCgpXG5cbiAgICBpZiAoaXNBdEVuZCkge1xuICAgICAgY29uc3QgY3VycmVudE1hcmtzID0gY3VycmVudFBvcy5tYXJrcygpXG4gICAgICBjb25zdCBpc0luTWFyayA9ICEhY3VycmVudE1hcmtzLmZpbmQobSA9PiBtPy50eXBlLm5hbWUgPT09IG1hcmsubmFtZSlcblxuICAgICAgaWYgKCFpc0luTWFyaykge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVtb3ZlTWFyayA9IGN1cnJlbnRNYXJrcy5maW5kKG0gPT4gbT8udHlwZS5uYW1lID09PSBtYXJrLm5hbWUpXG5cbiAgICAgIGlmIChyZW1vdmVNYXJrKSB7XG4gICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsocmVtb3ZlTWFyaylcbiAgICAgIH1cbiAgICAgIHRyLmluc2VydFRleHQoJyAnLCBjdXJyZW50UG9zLnBvcylcblxuICAgICAgZWRpdG9yLnZpZXcuZGlzcGF0Y2godHIpXG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBET01PdXRwdXRTcGVjLCBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgTm9kZVNwZWMsIE5vZGVUeXBlLFxufSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgUGx1Z2luLCBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHsgZ2V0RXh0ZW5zaW9uRmllbGQgfSBmcm9tICcuL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBOb2RlQ29uZmlnIH0gZnJvbSAnLi9pbmRleC5qcydcbmltcG9ydCB7IElucHV0UnVsZSB9IGZyb20gJy4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgUGFzdGVSdWxlIH0gZnJvbSAnLi9QYXN0ZVJ1bGUuanMnXG5pbXBvcnQge1xuICBBbnlDb25maWcsXG4gIEF0dHJpYnV0ZXMsXG4gIEV4dGVuc2lvbnMsXG4gIEdsb2JhbEF0dHJpYnV0ZXMsXG4gIEtleWJvYXJkU2hvcnRjdXRDb21tYW5kLFxuICBOb2RlVmlld1JlbmRlcmVyLFxuICBQYXJlbnRDb25maWcsXG4gIFJhd0NvbW1hbmRzLFxufSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgbWVyZ2VEZWVwIH0gZnJvbSAnLi91dGlsaXRpZXMvbWVyZ2VEZWVwLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBOb2RlQ29uZmlnPE9wdGlvbnMgPSBhbnksIFN0b3JhZ2UgPSBhbnk+IHtcbiAgICBba2V5OiBzdHJpbmddOiBhbnlcblxuICAgIC8qKlxuICAgICAqIE5hbWVcbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmdcblxuICAgIC8qKlxuICAgICAqIFByaW9yaXR5XG4gICAgICovXG4gICAgcHJpb3JpdHk/OiBudW1iZXJcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgb3B0aW9uc1xuICAgICAqL1xuICAgIGRlZmF1bHRPcHRpb25zPzogT3B0aW9uc1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBPcHRpb25zXG4gICAgICovXG4gICAgYWRkT3B0aW9ucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIHBhcmVudDogRXhjbHVkZTxQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZE9wdGlvbnMnXSwgdW5kZWZpbmVkPlxuICAgIH0pID0+IE9wdGlvbnNcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgU3RvcmFnZVxuICAgICAqL1xuICAgIGFkZFN0b3JhZ2U/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBwYXJlbnQ6IEV4Y2x1ZGU8UGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRTdG9yYWdlJ10sIHVuZGVmaW5lZD5cbiAgICB9KSA9PiBTdG9yYWdlXG5cbiAgICAvKipcbiAgICAgKiBHbG9iYWwgYXR0cmlidXRlc1xuICAgICAqL1xuICAgIGFkZEdsb2JhbEF0dHJpYnV0ZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkR2xvYmFsQXR0cmlidXRlcyddXG4gICAgfSkgPT4gR2xvYmFsQXR0cmlidXRlcyB8IHt9XG5cbiAgICAvKipcbiAgICAgKiBSYXdcbiAgICAgKi9cbiAgICBhZGRDb21tYW5kcz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZENvbW1hbmRzJ11cbiAgICB9KSA9PiBQYXJ0aWFsPFJhd0NvbW1hbmRzPlxuXG4gICAgLyoqXG4gICAgICogS2V5Ym9hcmQgc2hvcnRjdXRzXG4gICAgICovXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRLZXlib2FyZFNob3J0Y3V0cyddXG4gICAgfSkgPT4ge1xuICAgICAgW2tleTogc3RyaW5nXTogS2V5Ym9hcmRTaG9ydGN1dENvbW1hbmRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnB1dCBydWxlc1xuICAgICAqL1xuICAgIGFkZElucHV0UnVsZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRJbnB1dFJ1bGVzJ11cbiAgICB9KSA9PiBJbnB1dFJ1bGVbXVxuXG4gICAgLyoqXG4gICAgICogUGFzdGUgcnVsZXNcbiAgICAgKi9cbiAgICBhZGRQYXN0ZVJ1bGVzPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkUGFzdGVSdWxlcyddXG4gICAgfSkgPT4gUGFzdGVSdWxlW11cblxuICAgIC8qKlxuICAgICAqIFByb3NlTWlycm9yIHBsdWdpbnNcbiAgICAgKi9cbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRQcm9zZU1pcnJvclBsdWdpbnMnXVxuICAgIH0pID0+IFBsdWdpbltdXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbnNpb25zXG4gICAgICovXG4gICAgYWRkRXh0ZW5zaW9ucz86ICh0aGlzOiB7XG4gICAgICBuYW1lOiBzdHJpbmdcbiAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRFeHRlbnNpb25zJ11cbiAgICB9KSA9PiBFeHRlbnNpb25zXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgTm9kZSBTY2hlbWFcbiAgICAgKi9cbiAgICBleHRlbmROb2RlU2NoZW1hPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydleHRlbmROb2RlU2NoZW1hJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4dGVuc2lvbjogTm9kZSxcbiAgICAgICAgKSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQgTWFyayBTY2hlbWFcbiAgICAgKi9cbiAgICBleHRlbmRNYXJrU2NoZW1hPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydleHRlbmRNYXJrU2NoZW1hJ11cbiAgICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXh0ZW5zaW9uOiBOb2RlLFxuICAgICAgICApID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgbm90IHJlYWR5IHlldC5cbiAgICAgKi9cbiAgICBvbkJlZm9yZUNyZWF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkJlZm9yZUNyZWF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgaXMgcmVhZHkuXG4gICAgICovXG4gICAgb25DcmVhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25DcmVhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udGVudCBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBvblVwZGF0ZT86XG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvblVwZGF0ZSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3Rpb24gaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgb25TZWxlY3Rpb25VcGRhdGU/OlxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25TZWxlY3Rpb25VcGRhdGUnXVxuICAgICAgICB9KSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIHN0YXRlIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG9uVHJhbnNhY3Rpb24/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25UcmFuc2FjdGlvbiddXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiB2b2lkKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdG9yIGlzIGZvY3VzZWQuXG4gICAgICovXG4gICAgb25Gb2N1cz86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgICAgdHlwZTogTm9kZVR5cGVcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydvbkZvY3VzJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBldmVudDogRm9jdXNFdmVudFxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpc27igJl0IGZvY3VzZWQgYW55bW9yZS5cbiAgICAgKi9cbiAgICBvbkJsdXI/OlxuICAgICAgfCAoKFxuICAgICAgICAgIHRoaXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnb25CbHVyJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBldmVudDogRm9jdXNFdmVudFxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gdm9pZClcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgb25EZXN0cm95PzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ29uRGVzdHJveSddXG4gICAgICAgIH0pID0+IHZvaWQpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIE5vZGUgVmlld1xuICAgICAqL1xuICAgIGFkZE5vZGVWaWV3PzpcbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IE5vZGVUeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZE5vZGVWaWV3J11cbiAgICAgICAgfSkgPT4gTm9kZVZpZXdSZW5kZXJlcilcbiAgICAgIHwgbnVsbFxuXG4gICAgLyoqXG4gICAgICogVG9wTm9kZVxuICAgICAqL1xuICAgIHRvcE5vZGU/OiBib29sZWFuXG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50XG4gICAgICovXG4gICAgY29udGVudD86XG4gICAgICB8IE5vZGVTcGVjWydjb250ZW50J11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnY29udGVudCddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydjb250ZW50J10pXG5cbiAgICAvKipcbiAgICAgKiBNYXJrc1xuICAgICAqL1xuICAgIG1hcmtzPzpcbiAgICAgIHwgTm9kZVNwZWNbJ21hcmtzJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnbWFya3MnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snbWFya3MnXSlcblxuICAgIC8qKlxuICAgICAqIEdyb3VwXG4gICAgICovXG4gICAgZ3JvdXA/OlxuICAgICAgfCBOb2RlU3BlY1snZ3JvdXAnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydncm91cCddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydncm91cCddKVxuXG4gICAgLyoqXG4gICAgICogSW5saW5lXG4gICAgICovXG4gICAgaW5saW5lPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2lubGluZSddXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2lubGluZSddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydpbmxpbmUnXSlcblxuICAgIC8qKlxuICAgICAqIEF0b21cbiAgICAgKi9cbiAgICBhdG9tPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2F0b20nXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhdG9tJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ2F0b20nXSlcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdGFibGVcbiAgICAgKi9cbiAgICBzZWxlY3RhYmxlPzpcbiAgICAgIHwgTm9kZVNwZWNbJ3NlbGVjdGFibGUnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydzZWxlY3RhYmxlJ11cbiAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgfSkgPT4gTm9kZVNwZWNbJ3NlbGVjdGFibGUnXSlcblxuICAgIC8qKlxuICAgICAqIERyYWdnYWJsZVxuICAgICAqL1xuICAgIGRyYWdnYWJsZT86XG4gICAgICB8IE5vZGVTcGVjWydkcmFnZ2FibGUnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydkcmFnZ2FibGUnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snZHJhZ2dhYmxlJ10pXG5cbiAgICAvKipcbiAgICAgKiBDb2RlXG4gICAgICovXG4gICAgY29kZT86XG4gICAgICB8IE5vZGVTcGVjWydjb2RlJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnY29kZSddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWydjb2RlJ10pXG5cbiAgICAvKipcbiAgICAgKiBXaGl0ZXNwYWNlXG4gICAgICovXG4gICAgd2hpdGVzcGFjZT86XG4gICAgICB8IE5vZGVTcGVjWyd3aGl0ZXNwYWNlJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+Plsnd2hpdGVzcGFjZSddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0pID0+IE5vZGVTcGVjWyd3aGl0ZXNwYWNlJ10pXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmluZ1xuICAgICAqL1xuICAgIGRlZmluaW5nPzpcbiAgICAgIHwgTm9kZVNwZWNbJ2RlZmluaW5nJ11cbiAgICAgIHwgKCh0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZGVmaW5pbmcnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snZGVmaW5pbmcnXSlcblxuICAgIC8qKlxuICAgICAqIElzb2xhdGluZ1xuICAgICAqL1xuICAgIGlzb2xhdGluZz86XG4gICAgICB8IE5vZGVTcGVjWydpc29sYXRpbmcnXVxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydpc29sYXRpbmcnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9KSA9PiBOb2RlU3BlY1snaXNvbGF0aW5nJ10pXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBIVE1MXG4gICAgICovXG4gICAgcGFyc2VIVE1MPzogKHRoaXM6IHtcbiAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3BhcnNlSFRNTCddXG4gICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICB9KSA9PiBOb2RlU3BlY1sncGFyc2VET00nXVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIEhUTUxcbiAgICAgKi9cbiAgICByZW5kZXJIVE1MPzpcbiAgICAgIHwgKChcbiAgICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydyZW5kZXJIVE1MJ11cbiAgICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIG5vZGU6IFByb3NlTWlycm9yTm9kZVxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICAgICAgICB9LFxuICAgICAgICApID0+IERPTU91dHB1dFNwZWMpXG4gICAgICB8IG51bGxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBUZXh0XG4gICAgICovXG4gICAgcmVuZGVyVGV4dD86XG4gICAgICB8ICgoXG4gICAgICAgICAgdGhpczoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsncmVuZGVyVGV4dCddXG4gICAgICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBub2RlOiBQcm9zZU1pcnJvck5vZGVcbiAgICAgICAgICAgIHBvczogbnVtYmVyXG4gICAgICAgICAgICBwYXJlbnQ6IFByb3NlTWlycm9yTm9kZVxuICAgICAgICAgICAgaW5kZXg6IG51bWJlclxuICAgICAgICAgIH0sXG4gICAgICAgICkgPT4gc3RyaW5nKVxuICAgICAgfCBudWxsXG5cbiAgICAvKipcbiAgICAgKiBBZGQgQXR0cmlidXRlc1xuICAgICAqL1xuICAgIGFkZEF0dHJpYnV0ZXM/OiAodGhpczoge1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkQXR0cmlidXRlcyddXG4gICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICB9KSA9PiBBdHRyaWJ1dGVzIHwge31cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTm9kZTxPcHRpb25zID0gYW55LCBTdG9yYWdlID0gYW55PiB7XG4gIHR5cGUgPSAnbm9kZSdcblxuICBuYW1lID0gJ25vZGUnXG5cbiAgcGFyZW50OiBOb2RlIHwgbnVsbCA9IG51bGxcblxuICBjaGlsZDogTm9kZSB8IG51bGwgPSBudWxsXG5cbiAgb3B0aW9uczogT3B0aW9uc1xuXG4gIHN0b3JhZ2U6IFN0b3JhZ2VcblxuICBjb25maWc6IE5vZGVDb25maWcgPSB7XG4gICAgbmFtZTogdGhpcy5uYW1lLFxuICAgIGRlZmF1bHRPcHRpb25zOiB7fSxcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogUGFydGlhbDxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PiA9IHt9KSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIC4uLmNvbmZpZyxcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lXG5cbiAgICBpZiAoY29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHt0aGlzLm5hbWV9XCIuYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5jb25maWcuZGVmYXVsdE9wdGlvbnNcblxuICAgIGlmICh0aGlzLmNvbmZpZy5hZGRPcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkT3B0aW9ucyddPih0aGlzLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPih0aGlzLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApIHx8IHt9XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlPE8gPSBhbnksIFMgPSBhbnk+KGNvbmZpZzogUGFydGlhbDxOb2RlQ29uZmlnPE8sIFM+PiA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlPE8sIFM+KGNvbmZpZylcbiAgfVxuXG4gIGNvbmZpZ3VyZShvcHRpb25zOiBQYXJ0aWFsPE9wdGlvbnM+ID0ge30pIHtcbiAgICAvLyByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugc28gd2UgY2FuIHVzZSB0aGUgc2FtZSBleHRlbnNpb25cbiAgICAvLyB3aXRoIGRpZmZlcmVudCBjYWxscyBvZiBgY29uZmlndXJlYFxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuZXh0ZW5kKClcblxuICAgIGV4dGVuc2lvbi5vcHRpb25zID0gbWVyZ2VEZWVwKHRoaXMub3B0aW9ucyBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBvcHRpb25zKSBhcyBPcHRpb25zXG5cbiAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihcbiAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkU3RvcmFnZSddPihleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICB9KSxcbiAgICApXG5cbiAgICByZXR1cm4gZXh0ZW5zaW9uXG4gIH1cblxuICBleHRlbmQ8RXh0ZW5kZWRPcHRpb25zID0gT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlID0gU3RvcmFnZT4oXG4gICAgZXh0ZW5kZWRDb25maWc6IFBhcnRpYWw8Tm9kZUNvbmZpZzxFeHRlbmRlZE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZT4+ID0ge30sXG4gICkge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5ldyBOb2RlPEV4dGVuZGVkT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlPih7IC4uLnRoaXMuY29uZmlnLCAuLi5leHRlbmRlZENvbmZpZyB9KVxuXG4gICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXNcblxuICAgIHRoaXMuY2hpbGQgPSBleHRlbnNpb25cblxuICAgIGV4dGVuc2lvbi5uYW1lID0gZXh0ZW5kZWRDb25maWcubmFtZSA/IGV4dGVuZGVkQ29uZmlnLm5hbWUgOiBleHRlbnNpb24ucGFyZW50Lm5hbWVcblxuICAgIGlmIChleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucykge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHtleHRlbnNpb24ubmFtZX1cIi5gLFxuICAgICAgKVxuICAgIH1cblxuICAgIGV4dGVuc2lvbi5vcHRpb25zID0gY2FsbE9yUmV0dXJuKFxuICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRPcHRpb25zJ10+KGV4dGVuc2lvbiwgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgZXh0ZW5zaW9uLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oXG4gICAgICBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZFN0b3JhZ2UnXT4oZXh0ZW5zaW9uLCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgfSksXG4gICAgKVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzQW5kcm9pZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIG5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gJ0FuZHJvaWQnIHx8IC9hbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxufVxuIiwgImltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IE5vZGVTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgTm9kZVZpZXcgYXMgUHJvc2VNaXJyb3JOb2RlVmlldyB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldydcblxuaW1wb3J0IHsgRWRpdG9yIGFzIENvcmVFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuL05vZGUuanMnXG5pbXBvcnQgeyBEZWNvcmF0aW9uV2l0aFR5cGUsIE5vZGVWaWV3UmVuZGVyZXJPcHRpb25zLCBOb2RlVmlld1JlbmRlcmVyUHJvcHMgfSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgaXNBbmRyb2lkIH0gZnJvbSAnLi91dGlsaXRpZXMvaXNBbmRyb2lkLmpzJ1xuaW1wb3J0IHsgaXNpT1MgfSBmcm9tICcuL3V0aWxpdGllcy9pc2lPUy5qcydcblxuZXhwb3J0IGNsYXNzIE5vZGVWaWV3PFxuICBDb21wb25lbnQsXG4gIE5vZGVFZGl0b3IgZXh0ZW5kcyBDb3JlRWRpdG9yID0gQ29yZUVkaXRvcixcbiAgT3B0aW9ucyBleHRlbmRzIE5vZGVWaWV3UmVuZGVyZXJPcHRpb25zID0gTm9kZVZpZXdSZW5kZXJlck9wdGlvbnMsXG4+IGltcGxlbWVudHMgUHJvc2VNaXJyb3JOb2RlVmlldyB7XG4gIGNvbXBvbmVudDogQ29tcG9uZW50XG5cbiAgZWRpdG9yOiBOb2RlRWRpdG9yXG5cbiAgb3B0aW9uczogT3B0aW9uc1xuXG4gIGV4dGVuc2lvbjogTm9kZVxuXG4gIG5vZGU6IFByb3NlTWlycm9yTm9kZVxuXG4gIGRlY29yYXRpb25zOiBEZWNvcmF0aW9uV2l0aFR5cGVbXVxuXG4gIGdldFBvczogYW55XG5cbiAgaXNEcmFnZ2luZyA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3IoY29tcG9uZW50OiBDb21wb25lbnQsIHByb3BzOiBOb2RlVmlld1JlbmRlcmVyUHJvcHMsIG9wdGlvbnM/OiBQYXJ0aWFsPE9wdGlvbnM+KSB7XG4gICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnRcbiAgICB0aGlzLmVkaXRvciA9IHByb3BzLmVkaXRvciBhcyBOb2RlRWRpdG9yXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgc3RvcEV2ZW50OiBudWxsLFxuICAgICAgaWdub3JlTXV0YXRpb246IG51bGwsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0gYXMgT3B0aW9uc1xuICAgIHRoaXMuZXh0ZW5zaW9uID0gcHJvcHMuZXh0ZW5zaW9uXG4gICAgdGhpcy5ub2RlID0gcHJvcHMubm9kZVxuICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBwcm9wcy5kZWNvcmF0aW9ucyBhcyBEZWNvcmF0aW9uV2l0aFR5cGVbXVxuICAgIHRoaXMuZ2V0UG9zID0gcHJvcHMuZ2V0UG9zXG4gICAgdGhpcy5tb3VudCgpXG4gIH1cblxuICBtb3VudCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICByZXR1cm5cbiAgfVxuXG4gIGdldCBkb20oKTogSFRNTEVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLmVkaXRvci52aWV3LmRvbSBhcyBIVE1MRWxlbWVudFxuICB9XG5cbiAgZ2V0IGNvbnRlbnRET00oKTogSFRNTEVsZW1lbnQgfCBudWxsIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgb25EcmFnU3RhcnQoZXZlbnQ6IERyYWdFdmVudCkge1xuICAgIGNvbnN0IHsgdmlldyB9ID0gdGhpcy5lZGl0b3JcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnRcblxuICAgIC8vIGdldCB0aGUgZHJhZyBoYW5kbGUgZWxlbWVudFxuICAgIC8vIGBjbG9zZXN0YCBpcyBub3QgYXZhaWxhYmxlIGZvciB0ZXh0IG5vZGVzIHNvIHdlIG1heSBoYXZlIHRvIHVzZSBpdHMgcGFyZW50XG4gICAgY29uc3QgZHJhZ0hhbmRsZSA9IHRhcmdldC5ub2RlVHlwZSA9PT0gM1xuICAgICAgPyB0YXJnZXQucGFyZW50RWxlbWVudD8uY2xvc2VzdCgnW2RhdGEtZHJhZy1oYW5kbGVdJylcbiAgICAgIDogdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWRyYWctaGFuZGxlXScpXG5cbiAgICBpZiAoIXRoaXMuZG9tIHx8IHRoaXMuY29udGVudERPTT8uY29udGFpbnModGFyZ2V0KSB8fCAhZHJhZ0hhbmRsZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHggPSAwXG4gICAgbGV0IHkgPSAwXG5cbiAgICAvLyBjYWxjdWxhdGUgb2Zmc2V0IGZvciBkcmFnIGVsZW1lbnQgaWYgd2UgdXNlIGEgZGlmZmVyZW50IGRyYWcgaGFuZGxlIGVsZW1lbnRcbiAgICBpZiAodGhpcy5kb20gIT09IGRyYWdIYW5kbGUpIHtcbiAgICAgIGNvbnN0IGRvbUJveCA9IHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICBjb25zdCBoYW5kbGVCb3ggPSBkcmFnSGFuZGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICAgIC8vIEluIFJlYWN0LCB3ZSBoYXZlIHRvIGdvIHRocm91Z2ggbmF0aXZlRXZlbnQgdG8gcmVhY2ggb2Zmc2V0WC9vZmZzZXRZLlxuICAgICAgY29uc3Qgb2Zmc2V0WCA9IGV2ZW50Lm9mZnNldFggPz8gKGV2ZW50IGFzIGFueSkubmF0aXZlRXZlbnQ/Lm9mZnNldFhcbiAgICAgIGNvbnN0IG9mZnNldFkgPSBldmVudC5vZmZzZXRZID8/IChldmVudCBhcyBhbnkpLm5hdGl2ZUV2ZW50Py5vZmZzZXRZXG5cbiAgICAgIHggPSBoYW5kbGVCb3gueCAtIGRvbUJveC54ICsgb2Zmc2V0WFxuICAgICAgeSA9IGhhbmRsZUJveC55IC0gZG9tQm94LnkgKyBvZmZzZXRZXG4gICAgfVxuXG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyPy5zZXREcmFnSW1hZ2UodGhpcy5kb20sIHgsIHkpXG5cbiAgICAvLyB3ZSBuZWVkIHRvIHRlbGwgUHJvc2VNaXJyb3IgdGhhdCB3ZSB3YW50IHRvIG1vdmUgdGhlIHdob2xlIG5vZGVcbiAgICAvLyBzbyB3ZSBjcmVhdGUgYSBOb2RlU2VsZWN0aW9uXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIHRoaXMuZ2V0UG9zKCkpXG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pXG5cbiAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKVxuICB9XG5cbiAgc3RvcEV2ZW50KGV2ZW50OiBFdmVudCkge1xuICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnN0b3BFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zdG9wRXZlbnQoeyBldmVudCB9KVxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudFxuICAgIGNvbnN0IGlzSW5FbGVtZW50ID0gdGhpcy5kb20uY29udGFpbnModGFyZ2V0KSAmJiAhdGhpcy5jb250ZW50RE9NPy5jb250YWlucyh0YXJnZXQpXG5cbiAgICAvLyBhbnkgZXZlbnQgZnJvbSBjaGlsZCBub2RlcyBzaG91bGQgYmUgaGFuZGxlZCBieSBQcm9zZU1pcnJvclxuICAgIGlmICghaXNJbkVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGlzRHJhZ0V2ZW50ID0gZXZlbnQudHlwZS5zdGFydHNXaXRoKCdkcmFnJylcbiAgICBjb25zdCBpc0Ryb3BFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdkcm9wJ1xuICAgIGNvbnN0IGlzSW5wdXQgPSBbJ0lOUFVUJywgJ0JVVFRPTicsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXS5pbmNsdWRlcyh0YXJnZXQudGFnTmFtZSkgfHwgdGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlXG5cbiAgICAvLyBhbnkgaW5wdXQgZXZlbnQgd2l0aGluIG5vZGUgdmlld3Mgc2hvdWxkIGJlIGlnbm9yZWQgYnkgUHJvc2VNaXJyb3JcbiAgICBpZiAoaXNJbnB1dCAmJiAhaXNEcm9wRXZlbnQgJiYgIWlzRHJhZ0V2ZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IHsgaXNFZGl0YWJsZSB9ID0gdGhpcy5lZGl0b3JcbiAgICBjb25zdCB7IGlzRHJhZ2dpbmcgfSA9IHRoaXNcbiAgICBjb25zdCBpc0RyYWdnYWJsZSA9ICEhdGhpcy5ub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGVcbiAgICBjb25zdCBpc1NlbGVjdGFibGUgPSBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZSh0aGlzLm5vZGUpXG4gICAgY29uc3QgaXNDb3B5RXZlbnQgPSBldmVudC50eXBlID09PSAnY29weSdcbiAgICBjb25zdCBpc1Bhc3RlRXZlbnQgPSBldmVudC50eXBlID09PSAncGFzdGUnXG4gICAgY29uc3QgaXNDdXRFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdjdXQnXG4gICAgY29uc3QgaXNDbGlja0V2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bidcblxuICAgIC8vIFByb3NlTWlycm9yIHRyaWVzIHRvIGRyYWcgc2VsZWN0YWJsZSBub2Rlc1xuICAgIC8vIGV2ZW4gaWYgYGRyYWdnYWJsZWAgaXMgc2V0IHRvIGBmYWxzZWBcbiAgICAvLyB0aGlzIGZpeCBwcmV2ZW50cyB0aGF0XG4gICAgaWYgKCFpc0RyYWdnYWJsZSAmJiBpc1NlbGVjdGFibGUgJiYgaXNEcmFnRXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICB9XG5cbiAgICBpZiAoaXNEcmFnZ2FibGUgJiYgaXNEcmFnRXZlbnQgJiYgIWlzRHJhZ2dpbmcpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIHdlIGhhdmUgdG8gc3RvcmUgdGhhdCBkcmFnZ2luZyBzdGFydGVkXG4gICAgaWYgKGlzRHJhZ2dhYmxlICYmIGlzRWRpdGFibGUgJiYgIWlzRHJhZ2dpbmcgJiYgaXNDbGlja0V2ZW50KSB7XG4gICAgICBjb25zdCBkcmFnSGFuZGxlID0gdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWRyYWctaGFuZGxlXScpXG4gICAgICBjb25zdCBpc1ZhbGlkRHJhZ0hhbmRsZSA9IGRyYWdIYW5kbGUgJiYgKHRoaXMuZG9tID09PSBkcmFnSGFuZGxlIHx8IHRoaXMuZG9tLmNvbnRhaW5zKGRyYWdIYW5kbGUpKVxuXG4gICAgICBpZiAoaXNWYWxpZERyYWdIYW5kbGUpIHtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZVxuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgJ2RyYWdlbmQnLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IG9uY2U6IHRydWUgfSxcbiAgICAgICAgKVxuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgJ2Ryb3AnLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IG9uY2U6IHRydWUgfSxcbiAgICAgICAgKVxuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgJ21vdXNldXAnLFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IG9uY2U6IHRydWUgfSxcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRoZXNlIGV2ZW50cyBhcmUgaGFuZGxlZCBieSBwcm9zZW1pcnJvclxuICAgIGlmIChcbiAgICAgIGlzRHJhZ2dpbmdcbiAgICAgIHx8IGlzRHJvcEV2ZW50XG4gICAgICB8fCBpc0NvcHlFdmVudFxuICAgICAgfHwgaXNQYXN0ZUV2ZW50XG4gICAgICB8fCBpc0N1dEV2ZW50XG4gICAgICB8fCAoaXNDbGlja0V2ZW50ICYmIGlzU2VsZWN0YWJsZSlcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbjogTXV0YXRpb25SZWNvcmQgfCB7IHR5cGU6ICdzZWxlY3Rpb24nOyB0YXJnZXQ6IEVsZW1lbnQgfSkge1xuICAgIGlmICghdGhpcy5kb20gfHwgIXRoaXMuY29udGVudERPTSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbih7IG11dGF0aW9uIH0pXG4gICAgfVxuXG4gICAgLy8gYSBsZWFmL2F0b20gbm9kZSBpcyBsaWtlIGEgYmxhY2sgYm94IGZvciBQcm9zZU1pcnJvclxuICAgIC8vIGFuZCBzaG91bGQgYmUgZnVsbHkgaGFuZGxlZCBieSB0aGUgbm9kZSB2aWV3XG4gICAgaWYgKHRoaXMubm9kZS5pc0xlYWYgfHwgdGhpcy5ub2RlLmlzQXRvbSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBQcm9zZU1pcnJvciBzaG91bGQgaGFuZGxlIGFueSBzZWxlY3Rpb25zXG4gICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdzZWxlY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyB0cnkgdG8gcHJldmVudCBhIGJ1ZyBvbiBpT1MgYW5kIEFuZHJvaWQgdGhhdCB3aWxsIGJyZWFrIG5vZGUgdmlld3Mgb24gZW50ZXJcbiAgICAvLyB0aGlzIGlzIGJlY2F1c2UgUHJvc2VNaXJyb3IgY2Fu4oCZdCBwcmV2ZW50RGlzcGF0Y2ggb24gZW50ZXJcbiAgICAvLyB0aGlzIHdpbGwgbGVhZCB0byBhIHJlLXJlbmRlciBvZiB0aGUgbm9kZSB2aWV3IG9uIGVudGVyXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzEyMTRcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMjUzNFxuICAgIGlmIChcbiAgICAgIHRoaXMuZG9tLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldClcbiAgICAgICYmIG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnXG4gICAgICAmJiAoaXNpT1MoKSB8fCBpc0FuZHJvaWQoKSlcbiAgICAgICYmIHRoaXMuZWRpdG9yLmlzRm9jdXNlZFxuICAgICkge1xuICAgICAgY29uc3QgY2hhbmdlZE5vZGVzID0gW1xuICAgICAgICAuLi5BcnJheS5mcm9tKG11dGF0aW9uLmFkZGVkTm9kZXMpLFxuICAgICAgICAuLi5BcnJheS5mcm9tKG11dGF0aW9uLnJlbW92ZWROb2RlcyksXG4gICAgICBdIGFzIEhUTUxFbGVtZW50W11cblxuICAgICAgLy8gd2XigJlsbCBjaGVjayBpZiBldmVyeSBjaGFuZ2VkIG5vZGUgaXMgY29udGVudEVkaXRhYmxlXG4gICAgICAvLyB0byBtYWtlIHN1cmUgaXTigJlzIHByb2JhYmx5IG11dGF0ZWQgYnkgUHJvc2VNaXJyb3JcbiAgICAgIGlmIChjaGFuZ2VkTm9kZXMuZXZlcnkobm9kZSA9PiBub2RlLmlzQ29udGVudEVkaXRhYmxlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZSB3aWxsIGFsbG93IG11dGF0aW9uIGNvbnRlbnRET00gd2l0aCBhdHRyaWJ1dGVzXG4gICAgLy8gc28gd2UgY2FuIGZvciBleGFtcGxlIGFkZGluZyBjbGFzc2VzIHdpdGhpbiBvdXIgbm9kZSB2aWV3XG4gICAgaWYgKHRoaXMuY29udGVudERPTSA9PT0gbXV0YXRpb24udGFyZ2V0ICYmIG11dGF0aW9uLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBQcm9zZU1pcnJvciBzaG91bGQgaGFuZGxlIGFueSBjaGFuZ2VzIHdpdGhpbiBjb250ZW50RE9NXG4gICAgaWYgKHRoaXMuY29udGVudERPTS5jb250YWlucyhtdXRhdGlvbi50YXJnZXQpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlcyhhdHRyaWJ1dGVzOiB7fSkge1xuICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgY29uc3QgcG9zID0gdGhpcy5nZXRQb3MoKVxuXG4gICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdW5kZWZpbmVkLCB7XG4gICAgICAgIC4uLnRoaXMubm9kZS5hdHRycyxcbiAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSlcbiAgfVxuXG4gIGRlbGV0ZU5vZGUoKTogdm9pZCB7XG4gICAgY29uc3QgZnJvbSA9IHRoaXMuZ2V0UG9zKClcbiAgICBjb25zdCB0byA9IGZyb20gKyB0aGlzLm5vZGUubm9kZVNpemVcblxuICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmRlbGV0ZVJhbmdlKHsgZnJvbSwgdG8gfSlcbiAgfVxufVxuIiwgImltcG9ydCB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya3NCZXR3ZWVuIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrc0JldHdlZW4uanMnXG5pbXBvcnQgeyBQYXN0ZVJ1bGUsIFBhc3RlUnVsZUZpbmRlciB9IGZyb20gJy4uL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBwYXN0ZSBydWxlIHRoYXQgYWRkcyBhIG1hcmsgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyBwYXN0ZWQgaW50byBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcmtQYXN0ZVJ1bGUoY29uZmlnOiB7XG4gIGZpbmQ6IFBhc3RlUnVsZUZpbmRlclxuICB0eXBlOiBNYXJrVHlwZVxuICBnZXRBdHRyaWJ1dGVzPzpcbiAgICB8IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICB8ICgobWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSwgZXZlbnQ6IENsaXBib2FyZEV2ZW50KSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgIHwgZmFsc2VcbiAgICB8IG51bGxcbn0pIHtcbiAgcmV0dXJuIG5ldyBQYXN0ZVJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7XG4gICAgICBzdGF0ZSwgcmFuZ2UsIG1hdGNoLCBwYXN0ZUV2ZW50LFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gsIHBhc3RlRXZlbnQpXG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzID09PSBmYWxzZSB8fCBhdHRyaWJ1dGVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlXG4gICAgICBjb25zdCBjYXB0dXJlR3JvdXAgPSBtYXRjaFttYXRjaC5sZW5ndGggLSAxXVxuICAgICAgY29uc3QgZnVsbE1hdGNoID0gbWF0Y2hbMF1cbiAgICAgIGxldCBtYXJrRW5kID0gcmFuZ2UudG9cblxuICAgICAgaWYgKGNhcHR1cmVHcm91cCkge1xuICAgICAgICBjb25zdCBzdGFydFNwYWNlcyA9IGZ1bGxNYXRjaC5zZWFyY2goL1xcUy8pXG4gICAgICAgIGNvbnN0IHRleHRTdGFydCA9IHJhbmdlLmZyb20gKyBmdWxsTWF0Y2guaW5kZXhPZihjYXB0dXJlR3JvdXApXG4gICAgICAgIGNvbnN0IHRleHRFbmQgPSB0ZXh0U3RhcnQgKyBjYXB0dXJlR3JvdXAubGVuZ3RoXG5cbiAgICAgICAgY29uc3QgZXhjbHVkZWRNYXJrcyA9IGdldE1hcmtzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgc3RhdGUuZG9jKVxuICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBleGNsdWRlZCA9IGl0ZW0ubWFyay50eXBlLmV4Y2x1ZGVkIGFzIE1hcmtUeXBlW11cblxuICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVkLmZpbmQodHlwZSA9PiB0eXBlID09PSBjb25maWcudHlwZSAmJiB0eXBlICE9PSBpdGVtLm1hcmsudHlwZSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnRvID4gdGV4dFN0YXJ0KVxuXG4gICAgICAgIGlmIChleGNsdWRlZE1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dEVuZCA8IHJhbmdlLnRvKSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHRleHRFbmQsIHJhbmdlLnRvKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRTdGFydCA+IHJhbmdlLmZyb20pIHtcbiAgICAgICAgICB0ci5kZWxldGUocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCB0ZXh0U3RhcnQpXG4gICAgICAgIH1cblxuICAgICAgICBtYXJrRW5kID0gcmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzICsgY2FwdHVyZUdyb3VwLmxlbmd0aFxuXG4gICAgICAgIHRyLmFkZE1hcmsocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCBtYXJrRW5kLCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcyB8fCB7fSkpXG5cbiAgICAgICAgdHIucmVtb3ZlU3RvcmVkTWFyayhjb25maWcudHlwZSlcbiAgICAgIH1cbiAgICB9LFxuICB9KVxufVxuIiwgIi8vIHNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzY5Njk0ODZcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVGb3JSZWdFeChzdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBzdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJ1xufVxuIiwgImltcG9ydCB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgUGFzdGVSdWxlLCBQYXN0ZVJ1bGVGaW5kZXIgfSBmcm9tICcuLi9QYXN0ZVJ1bGUuanMnXG5pbXBvcnQgeyBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4uL3V0aWxpdGllcy9pbmRleC5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBwYXN0ZSBydWxlIHRoYXQgYWRkcyBhIG5vZGUgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyBwYXN0ZWQgaW50byBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vZGVQYXN0ZVJ1bGUoY29uZmlnOiB7XG4gIGZpbmQ6IFBhc3RlUnVsZUZpbmRlclxuICB0eXBlOiBOb2RlVHlwZVxuICBnZXRBdHRyaWJ1dGVzPzpcbiAgICB8IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICB8ICgobWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSwgZXZlbnQ6IENsaXBib2FyZEV2ZW50KSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgIHwgZmFsc2VcbiAgICB8IG51bGxcbn0pIHtcbiAgcmV0dXJuIG5ldyBQYXN0ZVJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXIoe1xuICAgICAgbWF0Y2gsIGNoYWluLCByYW5nZSwgcGFzdGVFdmVudCxcbiAgICB9KSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoLCBwYXN0ZUV2ZW50KVxuXG4gICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2guaW5wdXQpIHtcbiAgICAgICAgY2hhaW4oKS5kZWxldGVSYW5nZShyYW5nZSkuaW5zZXJ0Q29udGVudEF0KHJhbmdlLmZyb20sIHtcbiAgICAgICAgICB0eXBlOiBjb25maWcudHlwZS5uYW1lLFxuICAgICAgICAgIGF0dHJzOiBhdHRyaWJ1dGVzLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgUGFzdGVSdWxlLCBQYXN0ZVJ1bGVGaW5kZXIgfSBmcm9tICcuLi9QYXN0ZVJ1bGUuanMnXG5cbi8qKlxuICogQnVpbGQgYW4gcGFzdGUgcnVsZSB0aGF0IHJlcGxhY2VzIHRleHQgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyBwYXN0ZWQgaW50byBpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHRQYXN0ZVJ1bGUoY29uZmlnOiB7XG4gIGZpbmQ6IFBhc3RlUnVsZUZpbmRlcixcbiAgcmVwbGFjZTogc3RyaW5nLFxufSkge1xuICByZXR1cm4gbmV3IFBhc3RlUnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBsZXQgaW5zZXJ0ID0gY29uZmlnLnJlcGxhY2VcbiAgICAgIGxldCBzdGFydCA9IHJhbmdlLmZyb21cbiAgICAgIGNvbnN0IGVuZCA9IHJhbmdlLnRvXG5cbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXRjaFswXS5sYXN0SW5kZXhPZihtYXRjaFsxXSlcblxuICAgICAgICBpbnNlcnQgKz0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0ICsgbWF0Y2hbMV0ubGVuZ3RoKVxuICAgICAgICBzdGFydCArPSBvZmZzZXRcblxuICAgICAgICBjb25zdCBjdXRPZmYgPSBzdGFydCAtIGVuZFxuXG4gICAgICAgIGlmIChjdXRPZmYgPiAwKSB7XG4gICAgICAgICAgaW5zZXJ0ID0gbWF0Y2hbMF0uc2xpY2Uob2Zmc2V0IC0gY3V0T2ZmLCBvZmZzZXQpICsgaW5zZXJ0XG4gICAgICAgICAgc3RhcnQgPSBlbmRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS50ci5pbnNlcnRUZXh0KGluc2VydCwgc3RhcnQsIGVuZClcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGludGVyZmFjZSBUcmFja2VyUmVzdWx0IHtcbiAgcG9zaXRpb246IG51bWJlclxuICBkZWxldGVkOiBib29sZWFuXG59XG5cbmV4cG9ydCBjbGFzcyBUcmFja2VyIHtcbiAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uXG5cbiAgY3VycmVudFN0ZXA6IG51bWJlclxuXG4gIGNvbnN0cnVjdG9yKHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbikge1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvblxuICAgIHRoaXMuY3VycmVudFN0ZXAgPSB0aGlzLnRyYW5zYWN0aW9uLnN0ZXBzLmxlbmd0aFxuICB9XG5cbiAgbWFwKHBvc2l0aW9uOiBudW1iZXIpOiBUcmFja2VyUmVzdWx0IHtcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlXG5cbiAgICBjb25zdCBtYXBwZWRQb3NpdGlvbiA9IHRoaXMudHJhbnNhY3Rpb24uc3RlcHNcbiAgICAgIC5zbGljZSh0aGlzLmN1cnJlbnRTdGVwKVxuICAgICAgLnJlZHVjZSgobmV3UG9zaXRpb24sIHN0ZXApID0+IHtcbiAgICAgICAgY29uc3QgbWFwUmVzdWx0ID0gc3RlcC5nZXRNYXAoKS5tYXBSZXN1bHQobmV3UG9zaXRpb24pXG5cbiAgICAgICAgaWYgKG1hcFJlc3VsdC5kZWxldGVkKSB7XG4gICAgICAgICAgZGVsZXRlZCA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXBSZXN1bHQucG9zXG4gICAgICB9LCBwb3NpdGlvbilcblxuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogbWFwcGVkUG9zaXRpb24sXG4gICAgICBkZWxldGVkLFxuICAgIH1cbiAgfVxufVxuIiwgImV4cG9ydCB2YXIgdG9wID0gJ3RvcCc7XG5leHBvcnQgdmFyIGJvdHRvbSA9ICdib3R0b20nO1xuZXhwb3J0IHZhciByaWdodCA9ICdyaWdodCc7XG5leHBvcnQgdmFyIGxlZnQgPSAnbGVmdCc7XG5leHBvcnQgdmFyIGF1dG8gPSAnYXV0byc7XG5leHBvcnQgdmFyIGJhc2VQbGFjZW1lbnRzID0gW3RvcCwgYm90dG9tLCByaWdodCwgbGVmdF07XG5leHBvcnQgdmFyIHN0YXJ0ID0gJ3N0YXJ0JztcbmV4cG9ydCB2YXIgZW5kID0gJ2VuZCc7XG5leHBvcnQgdmFyIGNsaXBwaW5nUGFyZW50cyA9ICdjbGlwcGluZ1BhcmVudHMnO1xuZXhwb3J0IHZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XG5leHBvcnQgdmFyIHBvcHBlciA9ICdwb3BwZXInO1xuZXhwb3J0IHZhciByZWZlcmVuY2UgPSAncmVmZXJlbmNlJztcbmV4cG9ydCB2YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pO1xuZXhwb3J0IHZhciBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL1tdLmNvbmNhdChiYXNlUGxhY2VtZW50cywgW2F1dG9dKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQsIHBsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7IC8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXG5cbmV4cG9ydCB2YXIgYmVmb3JlUmVhZCA9ICdiZWZvcmVSZWFkJztcbmV4cG9ydCB2YXIgcmVhZCA9ICdyZWFkJztcbmV4cG9ydCB2YXIgYWZ0ZXJSZWFkID0gJ2FmdGVyUmVhZCc7IC8vIHB1cmUtbG9naWMgbW9kaWZpZXJzXG5cbmV4cG9ydCB2YXIgYmVmb3JlTWFpbiA9ICdiZWZvcmVNYWluJztcbmV4cG9ydCB2YXIgbWFpbiA9ICdtYWluJztcbmV4cG9ydCB2YXIgYWZ0ZXJNYWluID0gJ2FmdGVyTWFpbic7IC8vIG1vZGlmaWVyIHdpdGggdGhlIHB1cnBvc2UgdG8gd3JpdGUgdG8gdGhlIERPTSAob3Igd3JpdGUgaW50byBhIGZyYW1ld29yayBzdGF0ZSlcblxuZXhwb3J0IHZhciBiZWZvcmVXcml0ZSA9ICdiZWZvcmVXcml0ZSc7XG5leHBvcnQgdmFyIHdyaXRlID0gJ3dyaXRlJztcbmV4cG9ydCB2YXIgYWZ0ZXJXcml0ZSA9ICdhZnRlcldyaXRlJztcbmV4cG9ydCB2YXIgbW9kaWZpZXJQaGFzZXMgPSBbYmVmb3JlUmVhZCwgcmVhZCwgYWZ0ZXJSZWFkLCBiZWZvcmVNYWluLCBtYWluLCBhZnRlck1haW4sIGJlZm9yZVdyaXRlLCB3cml0ZSwgYWZ0ZXJXcml0ZV07IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVOYW1lKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQgPyAoZWxlbWVudC5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKSA6IG51bGw7XG59IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgaWYgKG5vZGUudG9TdHJpbmcoKSAhPT0gJ1tvYmplY3QgV2luZG93XScpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93IDogd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59IiwgImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xuICAvLyBJRSAxMSBoYXMgbm8gU2hhZG93Um9vdFxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuXG5leHBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9OyIsICJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBUaGlzIG1vZGlmaWVyIHRha2VzIHRoZSBzdHlsZXMgcHJlcGFyZWQgYnkgdGhlIGBjb21wdXRlU3R5bGVzYCBtb2RpZmllclxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlcyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG5cblxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuICB2YXIgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgbGVmdDogJzAnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICBtYXJnaW46ICcwJ1xuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgdmFyIHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHN0YXRlLnN0eWxlc1tuYW1lXSA6IGluaXRpYWxTdHlsZXNbbmFtZV0pOyAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxuXG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc3R5bGVbcHJvcGVydHldID0gJyc7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogYXBwbHlTdHlsZXMsXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ11cbn07IiwgImltcG9ydCB7IGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn0iLCAiZXhwb3J0IHZhciBtYXggPSBNYXRoLm1heDtcbmV4cG9ydCB2YXIgbWluID0gTWF0aC5taW47XG5leHBvcnQgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDsiLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VUFTdHJpbmcoKSB7XG4gIHZhciB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcblxuICBpZiAodWFEYXRhICE9IG51bGwgJiYgdWFEYXRhLmJyYW5kcyAmJiBBcnJheS5pc0FycmF5KHVhRGF0YS5icmFuZHMpKSB7XG4gICAgcmV0dXJuIHVhRGF0YS5icmFuZHMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5icmFuZCArIFwiL1wiICsgaXRlbS52ZXJzaW9uO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xufSIsICJpbXBvcnQgZ2V0VUFTdHJpbmcgZnJvbSBcIi4uL3V0aWxzL3VzZXJBZ2VudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNMYXlvdXRWaWV3cG9ydCgpIHtcbiAgcmV0dXJuICEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xufSIsICJpbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGlzTGF5b3V0Vmlld3BvcnQgZnJvbSBcIi4vaXNMYXlvdXRWaWV3cG9ydC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGluY2x1ZGVTY2FsZSwgaXNGaXhlZFN0cmF0ZWd5KSB7XG4gIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzRml4ZWRTdHJhdGVneSA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZFN0cmF0ZWd5ID0gZmFsc2U7XG4gIH1cblxuICB2YXIgY2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSAxO1xuICB2YXIgc2NhbGVZID0gMTtcblxuICBpZiAoaW5jbHVkZVNjYWxlICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICBzY2FsZVggPSBlbGVtZW50Lm9mZnNldFdpZHRoID4gMCA/IHJvdW5kKGNsaWVudFJlY3Qud2lkdGgpIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxIDogMTtcbiAgICBzY2FsZVkgPSBlbGVtZW50Lm9mZnNldEhlaWdodCA+IDAgPyByb3VuZChjbGllbnRSZWN0LmhlaWdodCkgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxIDogMTtcbiAgfVxuXG4gIHZhciBfcmVmID0gaXNFbGVtZW50KGVsZW1lbnQpID8gZ2V0V2luZG93KGVsZW1lbnQpIDogd2luZG93LFxuICAgICAgdmlzdWFsVmlld3BvcnQgPSBfcmVmLnZpc3VhbFZpZXdwb3J0O1xuXG4gIHZhciBhZGRWaXN1YWxPZmZzZXRzID0gIWlzTGF5b3V0Vmlld3BvcnQoKSAmJiBpc0ZpeGVkU3RyYXRlZ3k7XG4gIHZhciB4ID0gKGNsaWVudFJlY3QubGVmdCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCA6IDApKSAvIHNjYWxlWDtcbiAgdmFyIHkgPSAoY2xpZW50UmVjdC50b3AgKyAoYWRkVmlzdWFsT2Zmc2V0cyAmJiB2aXN1YWxWaWV3cG9ydCA/IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcCA6IDApKSAvIHNjYWxlWTtcbiAgdmFyIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlWDtcbiAgdmFyIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0IC8gc2NhbGVZO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB0b3A6IHksXG4gICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgbGVmdDogeCxcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn0iLCAiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjsgLy8gUmV0dXJucyB0aGUgbGF5b3V0IHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LiBMYXlvdXRcbi8vIG1lYW5zIGl0IGRvZXNuJ3QgdGFrZSBpbnRvIGFjY291bnQgdHJhbnNmb3Jtcy5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChlbGVtZW50KSB7XG4gIHZhciBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpOyAvLyBVc2UgdGhlIGNsaWVudFJlY3Qgc2l6ZXMgaWYgaXQncyBub3QgYmVlbiB0cmFuc2Zvcm1lZC5cbiAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMjIzXG5cbiAgdmFyIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LndpZHRoIC0gd2lkdGgpIDw9IDEpIHtcbiAgICB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC5oZWlnaHQgLSBoZWlnaHQpIDw9IDEpIHtcbiAgICBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgIHk6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufSIsICJpbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gIHZhciByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlICYmIGNoaWxkLmdldFJvb3ROb2RlKCk7IC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcblxuICBpZiAocGFyZW50LmNvbnRhaW5zKGNoaWxkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XG4gIGVsc2UgaWYgKHJvb3ROb2RlICYmIGlzU2hhZG93Um9vdChyb290Tm9kZSkpIHtcbiAgICAgIHZhciBuZXh0ID0gY2hpbGQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG5leHQgJiYgcGFyZW50LmlzU2FtZU5vZGUobmV4dCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ106IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG5cblxuICAgICAgICBuZXh0ID0gbmV4dC5wYXJlbnROb2RlIHx8IG5leHQuaG9zdDtcbiAgICAgIH0gd2hpbGUgKG5leHQpO1xuICAgIH0gLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuXG5cbiAgcmV0dXJuIGZhbHNlO1xufSIsICJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn0iLCAiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5kZXhPZihnZXROb2RlTmFtZShlbGVtZW50KSkgPj0gMDtcbn0iLCAiaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICByZXR1cm4gKChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgZWxlbWVudC5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XG59IiwgImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZ2V0Tm9kZU5hbWUoZWxlbWVudCkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuICgvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBlbGVtZW50LmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIGVsZW1lbnQucGFyZW50Tm9kZSB8fCAoIC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgaXNTaGFkb3dSb290KGVsZW1lbnQpID8gZWxlbWVudC5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgLy8gZmFsbGJhY2tcblxuICApO1xufSIsICJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgaXNUYWJsZUVsZW1lbnQgZnJvbSBcIi4vaXNUYWJsZUVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXRVQVN0cmluZyBmcm9tIFwiLi4vdXRpbHMvdXNlckFnZW50LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufSAvLyBgLm9mZnNldFBhcmVudGAgcmVwb3J0cyBgbnVsbGAgZm9yIGZpeGVkIGVsZW1lbnRzLCB3aGlsZSBhYnNvbHV0ZSBlbGVtZW50c1xuLy8gcmV0dXJuIHRoZSBjb250YWluaW5nIGJsb2NrXG5cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgdmFyIGlzRmlyZWZveCA9IC9maXJlZm94L2kudGVzdChnZXRVQVN0cmluZygpKTtcbiAgdmFyIGlzSUUgPSAvVHJpZGVudC9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG5cbiAgaWYgKGlzSUUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIC8vIEluIElFIDksIDEwIGFuZCAxMSBmaXhlZCBlbGVtZW50cyBjb250YWluaW5nIGJsb2NrIGlzIGFsd2F5cyBlc3RhYmxpc2hlZCBieSB0aGUgdmlld3BvcnRcbiAgICB2YXIgZWxlbWVudENzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICBpZiAoZWxlbWVudENzcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICBpZiAoaXNTaGFkb3dSb290KGN1cnJlbnROb2RlKSkge1xuICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuaG9zdDtcbiAgfVxuXG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiBbJ2h0bWwnLCAnYm9keSddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoY3VycmVudE5vZGUpKSA8IDApIHtcbiAgICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7IC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxuICAgIC8vIGNyZWF0ZSBhIGNvbnRhaW5pbmcgYmxvY2suXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcblxuICAgIGlmIChjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnXS5pbmRleE9mKGNzcy53aWxsQ2hhbmdlKSAhPT0gLTEgfHwgaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJyB8fCBpc0ZpcmVmb3ggJiYgY3NzLmZpbHRlciAmJiBjc3MuZmlsdGVyICE9PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSAvLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuXG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgaWYgKG9mZnNldFBhcmVudCAmJiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2h0bWwnIHx8IGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG59IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xufSIsICJpbXBvcnQgeyBtYXggYXMgbWF0aE1heCwgbWluIGFzIG1hdGhNaW4gfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gd2l0aGluKG1pbiwgdmFsdWUsIG1heCkge1xuICByZXR1cm4gbWF0aE1heChtaW4sIG1hdGhNaW4odmFsdWUsIG1heCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbk1heENsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xuICB2YXIgdiA9IHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpO1xuICByZXR1cm4gdiA+IG1heCA/IG1heCA6IHY7XG59IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEZyZXNoU2lkZU9iamVjdCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn0iLCAiaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XG59IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4cGFuZFRvSGFzaE1hcCh2YWx1ZSwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2hNYXAsIGtleSkge1xuICAgIGhhc2hNYXBba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBoYXNoTWFwO1xuICB9LCB7fSk7XG59IiwgImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBjb250YWlucyBmcm9tIFwiLi4vZG9tLXV0aWxzL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHdpdGhpbiB9IGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4uL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qc1wiO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tIFwiLi4vdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzXCI7XG5pbXBvcnQgeyBsZWZ0LCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHRvcCwgYm90dG9tIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHRvUGFkZGluZ09iamVjdCA9IGZ1bmN0aW9uIHRvUGFkZGluZ09iamVjdChwYWRkaW5nLCBzdGF0ZSkge1xuICBwYWRkaW5nID0gdHlwZW9mIHBhZGRpbmcgPT09ICdmdW5jdGlvbicgPyBwYWRkaW5nKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogcGFkZGluZztcbiAgcmV0dXJuIG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG59O1xuXG5mdW5jdGlvbiBhcnJvdyhfcmVmKSB7XG4gIHZhciBfc3RhdGUkbW9kaWZpZXJzRGF0YSQ7XG5cbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIGlmICghYXJyb3dFbGVtZW50IHx8ICFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhZGRpbmdPYmplY3QgPSB0b1BhZGRpbmdPYmplY3Qob3B0aW9ucy5wYWRkaW5nLCBzdGF0ZSk7XG4gIHZhciBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XG4gIHZhciBtaW5Qcm9wID0gYXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgdmFyIG1heFByb3AgPSBheGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgdmFyIGVuZERpZmYgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbbGVuXSArIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5wb3BwZXJbbGVuXTtcbiAgdmFyIHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gIHZhciBhcnJvd09mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChhcnJvd0VsZW1lbnQpO1xuICB2YXIgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcbiAgdmFyIGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyOyAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIHBvcHBlciBpZiB0aGUgY2VudGVyIHBvaW50IGlzXG4gIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcblxuICB2YXIgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgdmFyIG1heCA9IGNsaWVudFNpemUgLSBhcnJvd1JlY3RbbGVuXSAtIHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XG4gIHZhciBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICB2YXIgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBQcmV2ZW50cyBicmVha2luZyBzeW50YXggaGlnaGxpZ2h0aW5nLi4uXG5cbiAgdmFyIGF4aXNQcm9wID0gYXhpcztcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IChfc3RhdGUkbW9kaWZpZXJzRGF0YSQgPSB7fSwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkW2F4aXNQcm9wXSA9IG9mZnNldCwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkLmNlbnRlck9mZnNldCA9IG9mZnNldCAtIGNlbnRlciwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkKTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRlbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50LFxuICAgICAgYXJyb3dFbGVtZW50ID0gX29wdGlvbnMkZWxlbWVudCA9PT0gdm9pZCAwID8gJ1tkYXRhLXBvcHBlci1hcnJvd10nIDogX29wdGlvbnMkZWxlbWVudDtcblxuICBpZiAoYXJyb3dFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQ1NTIHNlbGVjdG9yXG5cblxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRhaW5zKHN0YXRlLmVsZW1lbnRzLnBvcHBlciwgYXJyb3dFbGVtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXRlLmVsZW1lbnRzLmFycm93ID0gYXJyb3dFbGVtZW50O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnYXJyb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogYXJyb3csXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J11cbn07IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xufSIsICJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIGVuZCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nXG59OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG5mdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUihfcmVmLCB3aW4pIHtcbiAgdmFyIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuICB2YXIgZHByID0gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgcmV0dXJuIHtcbiAgICB4OiByb3VuZCh4ICogZHByKSAvIGRwciB8fCAwLFxuICAgIHk6IHJvdW5kKHkgKiBkcHIpIC8gZHByIHx8IDBcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvU3R5bGVzKF9yZWYyKSB7XG4gIHZhciBfT2JqZWN0JGFzc2lnbjI7XG5cbiAgdmFyIHBvcHBlciA9IF9yZWYyLnBvcHBlcixcbiAgICAgIHBvcHBlclJlY3QgPSBfcmVmMi5wb3BwZXJSZWN0LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZjIucGxhY2VtZW50LFxuICAgICAgdmFyaWF0aW9uID0gX3JlZjIudmFyaWF0aW9uLFxuICAgICAgb2Zmc2V0cyA9IF9yZWYyLm9mZnNldHMsXG4gICAgICBwb3NpdGlvbiA9IF9yZWYyLnBvc2l0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX3JlZjIuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgYWRhcHRpdmUgPSBfcmVmMi5hZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9yZWYyLnJvdW5kT2Zmc2V0cyxcbiAgICAgIGlzRml4ZWQgPSBfcmVmMi5pc0ZpeGVkO1xuICB2YXIgX29mZnNldHMkeCA9IG9mZnNldHMueCxcbiAgICAgIHggPSBfb2Zmc2V0cyR4ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeCxcbiAgICAgIF9vZmZzZXRzJHkgPSBvZmZzZXRzLnksXG4gICAgICB5ID0gX29mZnNldHMkeSA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHk7XG5cbiAgdmFyIF9yZWYzID0gdHlwZW9mIHJvdW5kT2Zmc2V0cyA9PT0gJ2Z1bmN0aW9uJyA/IHJvdW5kT2Zmc2V0cyh7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pIDoge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuXG4gIHggPSBfcmVmMy54O1xuICB5ID0gX3JlZjMueTtcbiAgdmFyIGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XG4gIHZhciBoYXNZID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneScpO1xuICB2YXIgc2lkZVggPSBsZWZ0O1xuICB2YXIgc2lkZVkgPSB0b3A7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG5cbiAgaWYgKGFkYXB0aXZlKSB7XG4gICAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChwb3BwZXIpO1xuICAgIHZhciBoZWlnaHRQcm9wID0gJ2NsaWVudEhlaWdodCc7XG4gICAgdmFyIHdpZHRoUHJvcCA9ICdjbGllbnRXaWR0aCc7XG5cbiAgICBpZiAob2Zmc2V0UGFyZW50ID09PSBnZXRXaW5kb3cocG9wcGVyKSkge1xuICAgICAgb2Zmc2V0UGFyZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KHBvcHBlcik7XG5cbiAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gIT09ICdzdGF0aWMnICYmIHBvc2l0aW9uID09PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgIGhlaWdodFByb3AgPSAnc2Nyb2xsSGVpZ2h0JztcbiAgICAgICAgd2lkdGhQcm9wID0gJ3Njcm9sbFdpZHRoJztcbiAgICAgIH1cbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhc3RdOiBmb3JjZSB0eXBlIHJlZmluZW1lbnQsIHdlIGNvbXBhcmUgb2Zmc2V0UGFyZW50IHdpdGggd2luZG93IGFib3ZlLCBidXQgRmxvdyBkb2Vzbid0IGRldGVjdCBpdFxuXG5cbiAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQ7XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSB0b3AgfHwgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCBwbGFjZW1lbnQgPT09IHJpZ2h0KSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVkgPSBib3R0b207XG4gICAgICB2YXIgb2Zmc2V0WSA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LmhlaWdodCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgb2Zmc2V0UGFyZW50W2hlaWdodFByb3BdO1xuICAgICAgeSAtPSBvZmZzZXRZIC0gcG9wcGVyUmVjdC5oZWlnaHQ7XG4gICAgICB5ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSBsZWZ0IHx8IChwbGFjZW1lbnQgPT09IHRvcCB8fCBwbGFjZW1lbnQgPT09IGJvdHRvbSkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVYID0gcmlnaHQ7XG4gICAgICB2YXIgb2Zmc2V0WCA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LndpZHRoIDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbd2lkdGhQcm9wXTtcbiAgICAgIHggLT0gb2Zmc2V0WCAtIHBvcHBlclJlY3Qud2lkdGg7XG4gICAgICB4ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uXG4gIH0sIGFkYXB0aXZlICYmIHVuc2V0U2lkZXMpO1xuXG4gIHZhciBfcmVmNCA9IHJvdW5kT2Zmc2V0cyA9PT0gdHJ1ZSA/IHJvdW5kT2Zmc2V0c0J5RFBSKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSwgZ2V0V2luZG93KHBvcHBlcikpIDoge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuXG4gIHggPSBfcmVmNC54O1xuICB5ID0gX3JlZjQueTtcblxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uKSB7XG4gICAgdmFyIF9PYmplY3QkYXNzaWduO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduID0ge30sIF9PYmplY3QkYXNzaWduW3NpZGVZXSA9IGhhc1kgPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ25bc2lkZVhdID0gaGFzWCA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbi50cmFuc2Zvcm0gPSAod2luLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPD0gMSA/IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIgOiBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgsIDApXCIsIF9PYmplY3QkYXNzaWduKSk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24yID0ge30sIF9PYmplY3QkYXNzaWduMltzaWRlWV0gPSBoYXNZID8geSArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjJbc2lkZVhdID0gaGFzWCA/IHggKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yLnRyYW5zZm9ybSA9ICcnLCBfT2JqZWN0JGFzc2lnbjIpKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVN0eWxlcyhfcmVmNSkge1xuICB2YXIgc3RhdGUgPSBfcmVmNS5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmNS5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID0gb3B0aW9ucy5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRncHVBY2NlbGVyYXQsXG4gICAgICBfb3B0aW9ucyRhZGFwdGl2ZSA9IG9wdGlvbnMuYWRhcHRpdmUsXG4gICAgICBhZGFwdGl2ZSA9IF9vcHRpb25zJGFkYXB0aXZlID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWRhcHRpdmUsXG4gICAgICBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPSBvcHRpb25zLnJvdW5kT2Zmc2V0cyxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJvdW5kT2Zmc2V0cztcbiAgdmFyIGNvbW1vblN0eWxlcyA9IHtcbiAgICBwbGFjZW1lbnQ6IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KSxcbiAgICB2YXJpYXRpb246IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IGdwdUFjY2VsZXJhdGlvbixcbiAgICBpc0ZpeGVkOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnXG4gIH07XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5wb3BwZXIsIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLFxuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBhZGFwdGl2ZTogYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLmFycm93LCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGFkYXB0aXZlOiBmYWxzZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcGxhY2VtZW50Jzogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICBmbjogY29tcHV0ZVN0eWxlcyxcbiAgZGF0YToge31cbn07IiwgImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRXaW5kb3cuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgcGFzc2l2ZSA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRzY3JvbGwgPSBvcHRpb25zLnNjcm9sbCxcbiAgICAgIHNjcm9sbCA9IF9vcHRpb25zJHNjcm9sbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHNjcm9sbCxcbiAgICAgIF9vcHRpb25zJHJlc2l6ZSA9IG9wdGlvbnMucmVzaXplLFxuICAgICAgcmVzaXplID0gX29wdGlvbnMkcmVzaXplID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcmVzaXplO1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KHN0YXRlLmVsZW1lbnRzLnBvcHBlcik7XG4gIHZhciBzY3JvbGxQYXJlbnRzID0gW10uY29uY2F0KHN0YXRlLnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLCBzdGF0ZS5zY3JvbGxQYXJlbnRzLnBvcHBlcik7XG5cbiAgaWYgKHNjcm9sbCkge1xuICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICBzY3JvbGxQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgc2Nyb2xsUGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdldmVudExpc3RlbmVycycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogZnVuY3Rpb24gZm4oKSB7fSxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIGRhdGE6IHt9XG59OyIsICJ2YXIgaGFzaCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn0iLCAidmFyIGhhc2ggPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsICJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKG5vZGUpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhub2RlKTtcbiAgdmFyIHNjcm9sbExlZnQgPSB3aW4ucGFnZVhPZmZzZXQ7XG4gIHZhciBzY3JvbGxUb3AgPSB3aW4ucGFnZVlPZmZzZXQ7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcFxuICB9O1xufSIsICJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcbiAgLy8gaXQncyBub3QgYW4gaXNzdWUuIEkgZG9uJ3QgdGhpbmsgYW55b25lIGV2ZXIgc3BlY2lmaWVzIHdpZHRoIG9uIDxodG1sPlxuICAvLyBhbnl3YXkuXG4gIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXG4gIC8vIHRoaXMgKGUuZy4gRWRnZSAyMDE5LCBJRTExLCBTYWZhcmkpXG4gIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59IiwgImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGlzTGF5b3V0Vmlld3BvcnQgZnJvbSBcIi4vaXNMYXlvdXRWaWV3cG9ydC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG5cbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XG4gICAgdmFyIGxheW91dFZpZXdwb3J0ID0gaXNMYXlvdXRWaWV3cG9ydCgpO1xuXG4gICAgaWYgKGxheW91dFZpZXdwb3J0IHx8ICFsYXlvdXRWaWV3cG9ydCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxuICAgIHk6IHlcbiAgfTtcbn0iLCAiaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgeyBtYXggfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiOyAvLyBHZXRzIHRoZSBlbnRpcmUgc2l6ZSBvZiB0aGUgc2Nyb2xsYWJsZSBkb2N1bWVudCBhcmVhLCBldmVuIGV4dGVuZGluZyBvdXRzaWRlXG4vLyBvZiB0aGUgYDxodG1sPmAgYW5kIGA8Ym9keT5gIHJlY3QgYm91bmRzIGlmIGhvcml6b250YWxseSBzY3JvbGxhYmxlXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB3aW5TY3JvbGwgPSBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCk7XG4gIHZhciBib2R5ID0gKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5O1xuICB2YXIgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApO1xuICB2YXIgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keSA/IGJvZHkuc2Nyb2xsSGVpZ2h0IDogMCwgYm9keSA/IGJvZHkuY2xpZW50SGVpZ2h0IDogMCk7XG4gIHZhciB4ID0gLXdpblNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgdmFyIHkgPSAtd2luU2Nyb2xsLnNjcm9sbFRvcDtcblxuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShib2R5IHx8IGh0bWwpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApIC0gd2lkdGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn0iLCAiaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufSIsICJpbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChub2RlKSB7XG4gIGlmIChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmRleE9mKGdldE5vZGVOYW1lKG5vZGUpKSA+PSAwKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KG5vZGUpICYmIGlzU2Nyb2xsUGFyZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUobm9kZSkpO1xufSIsICJpbXBvcnQgZ2V0U2Nyb2xsUGFyZW50IGZyb20gXCIuL2dldFNjcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuLypcbmdpdmVuIGEgRE9NIGVsZW1lbnQsIHJldHVybiB0aGUgbGlzdCBvZiBhbGwgc2Nyb2xsIHBhcmVudHMsIHVwIHRoZSBsaXN0IG9mIGFuY2Vzb3JzXG51bnRpbCB3ZSBnZXQgdG8gdGhlIHRvcCB3aW5kb3cgb2JqZWN0LiBUaGlzIGxpc3QgaXMgd2hhdCB3ZSBhdHRhY2ggc2Nyb2xsIGxpc3RlbmVyc1xudG8sIGJlY2F1c2UgaWYgYW55IG9mIHRoZXNlIHBhcmVudCBlbGVtZW50cyBzY3JvbGwsIHdlJ2xsIG5lZWQgdG8gcmUtY2FsY3VsYXRlIHRoZVxucmVmZXJlbmNlIGVsZW1lbnQncyBwb3NpdGlvbi5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxpc3RTY3JvbGxQYXJlbnRzKGVsZW1lbnQsIGxpc3QpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgbGlzdCA9IFtdO1xuICB9XG5cbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChlbGVtZW50KTtcbiAgdmFyIGlzQm9keSA9IHNjcm9sbFBhcmVudCA9PT0gKChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keSk7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsUGFyZW50KTtcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IFt3aW5dLmNvbmNhdCh3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzU2Nyb2xsUGFyZW50KHNjcm9sbFBhcmVudCkgPyBzY3JvbGxQYXJlbnQgOiBbXSkgOiBzY3JvbGxQYXJlbnQ7XG4gIHZhciB1cGRhdGVkTGlzdCA9IGxpc3QuY29uY2F0KHRhcmdldCk7XG4gIHJldHVybiBpc0JvZHkgPyB1cGRhdGVkTGlzdCA6IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBpc0JvZHkgdGVsbHMgdXMgdGFyZ2V0IHdpbGwgYmUgYW4gSFRNTEVsZW1lbnQgaGVyZVxuICB1cGRhdGVkTGlzdC5jb25jYXQobGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZSh0YXJnZXQpKSk7XG59IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xuICAgIGxlZnQ6IHJlY3QueCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH0pO1xufSIsICJpbXBvcnQgeyB2aWV3cG9ydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZpZXdwb3J0UmVjdCBmcm9tIFwiLi9nZXRWaWV3cG9ydFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudFJlY3QgZnJvbSBcIi4vZ2V0RG9jdW1lbnRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBjb250YWlucyBmcm9tIFwiLi9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tIFwiLi4vdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgbWF4LCBtaW4gfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBmYWxzZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuICByZWN0LnRvcCA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIHJlY3QubGVmdCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC53aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3QuaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QueCA9IHJlY3QubGVmdDtcbiAgcmVjdC55ID0gcmVjdC50b3A7XG4gIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIHtcbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50ID09PSB2aWV3cG9ydCA/IHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSkgOiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpID8gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSA6IHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufSAvLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXG4vLyBgaW5pdGlhbGBcblxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkge1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gbGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG4gIHZhciBjYW5Fc2NhcGVDbGlwcGluZyA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24pID49IDA7XG4gIHZhciBjbGlwcGVyRWxlbWVudCA9IGNhbkVzY2FwZUNsaXBwaW5nICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIGlmICghaXNFbGVtZW50KGNsaXBwZXJFbGVtZW50KSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMTQxNFxuXG5cbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50cy5maWx0ZXIoZnVuY3Rpb24gKGNsaXBwaW5nUGFyZW50KSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiYgY29udGFpbnMoY2xpcHBpbmdQYXJlbnQsIGNsaXBwZXJFbGVtZW50KSAmJiBnZXROb2RlTmFtZShjbGlwcGluZ1BhcmVudCkgIT09ICdib2R5JztcbiAgfSk7XG59IC8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIHBhcmVudHNcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoZWxlbWVudCwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSwgc3RyYXRlZ3kpIHtcbiAgdmFyIG1haW5DbGlwcGluZ1BhcmVudHMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nUGFyZW50cycgPyBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gW10uY29uY2F0KG1haW5DbGlwcGluZ1BhcmVudHMsIFtyb290Qm91bmRhcnldKTtcbiAgdmFyIGZpcnN0Q2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNbMF07XG4gIHZhciBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ1BhcmVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2NSZWN0LCBjbGlwcGluZ1BhcmVudCkge1xuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkpO1xuICBjbGlwcGluZ1JlY3Qud2lkdGggPSBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LmhlaWdodCA9IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wO1xuICBjbGlwcGluZ1JlY3QueCA9IGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QueSA9IGNsaXBwaW5nUmVjdC50b3A7XG4gIHJldHVybiBjbGlwcGluZ1JlY3Q7XG59IiwgImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBzdGFydCwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBlbmQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufSIsICJpbXBvcnQgZ2V0Q2xpcHBpbmdSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4vY29tcHV0ZU9mZnNldHMuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuL3JlY3RUb0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCB7IGNsaXBwaW5nUGFyZW50cywgcmVmZXJlbmNlLCBwb3BwZXIsIGJvdHRvbSwgdG9wLCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4vbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuL2V4cGFuZFRvSGFzaE1hcC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBzdGF0ZS5wbGFjZW1lbnQgOiBfb3B0aW9ucyRwbGFjZW1lbnQsXG4gICAgICBfb3B0aW9ucyRzdHJhdGVneSA9IF9vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgc3RyYXRlZ3kgPSBfb3B0aW9ucyRzdHJhdGVneSA9PT0gdm9pZCAwID8gc3RhdGUuc3RyYXRlZ3kgOiBfb3B0aW9ucyRzdHJhdGVneSxcbiAgICAgIF9vcHRpb25zJGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zJGJvdW5kYXJ5ID09PSB2b2lkIDAgPyBjbGlwcGluZ1BhcmVudHMgOiBfb3B0aW9ucyRib3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9PT0gdm9pZCAwID8gdmlld3BvcnQgOiBfb3B0aW9ucyRyb290Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRlbGVtZW50Q29udGUgPSBfb3B0aW9ucy5lbGVtZW50Q29udGV4dCxcbiAgICAgIGVsZW1lbnRDb250ZXh0ID0gX29wdGlvbnMkZWxlbWVudENvbnRlID09PSB2b2lkIDAgPyBwb3BwZXIgOiBfb3B0aW9ucyRlbGVtZW50Q29udGUsXG4gICAgICBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9IF9vcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zJHBhZGRpbmcgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRwYWRkaW5nO1xuICB2YXIgcGFkZGluZ09iamVjdCA9IG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG4gIHZhciBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHJlZmVyZW5jZSA6IHBvcHBlcjtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICB2YXIgY2xpcHBpbmdDbGllbnRSZWN0ID0gZ2V0Q2xpcHBpbmdSZWN0KGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IGdldERvY3VtZW50RWxlbWVudChzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSk7XG4gIHZhciByZWZlcmVuY2VDbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICBlbGVtZW50OiBwb3BwZXJSZWN0LFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pO1xuICB2YXIgcG9wcGVyQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoT2JqZWN0LmFzc2lnbih7fSwgcG9wcGVyUmVjdCwgcG9wcGVyT2Zmc2V0cykpO1xuICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuXG4gIHZhciBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgfTtcbiAgdmFyIG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDsgLy8gT2Zmc2V0cyBjYW4gYmUgYXBwbGllZCBvbmx5IHRvIHRoZSBwb3BwZXIgZWxlbWVudFxuXG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0RGF0YVtwbGFjZW1lbnRdO1xuICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICB2YXIgYXhpcyA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAneScgOiAneCc7XG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvdmVyZmxvd09mZnNldHM7XG59IiwgImltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyB2YXJpYXRpb25QbGFjZW1lbnRzLCBiYXNlUGxhY2VtZW50cywgcGxhY2VtZW50cyBhcyBhbGxQbGFjZW1lbnRzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9IF9vcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9PT0gdm9pZCAwID8gYWxsUGxhY2VtZW50cyA6IF9vcHRpb25zJGFsbG93ZWRBdXRvUDtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpO1xuICB2YXIgcGxhY2VtZW50cyA9IHZhcmlhdGlvbiA/IGZsaXBWYXJpYXRpb25zID8gdmFyaWF0aW9uUGxhY2VtZW50cyA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcbiAgfSkgOiBiYXNlUGxhY2VtZW50cztcbiAgdmFyIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhbGxvd2VkQXV0b1BsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpID49IDA7XG4gIH0pO1xuXG4gIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV06IEZsb3cgc2VlbXMgdG8gaGF2ZSBwcm9ibGVtcyB3aXRoIHR3byBhcnJheSB1bmlvbnMuLi5cblxuXG4gIHZhciBvdmVyZmxvd3MgPSBhbGxvd2VkUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KVtnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCldO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG92ZXJmbG93cykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBvdmVyZmxvd3NbYV0gLSBvdmVyZmxvd3NbYl07XG4gIH0pO1xufSIsICJpbXBvcnQgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVBdXRvUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgYm90dG9tLCB0b3AsIHN0YXJ0LCByaWdodCwgbGVmdCwgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGlmIChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuXG5mdW5jdGlvbiBmbGlwKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzID0gb3B0aW9ucy5mYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRmbGlwVmFyaWF0aW8sXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBvcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cztcbiAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9IGJhc2VQbGFjZW1lbnQgPT09IHByZWZlcnJlZFBsYWNlbWVudDtcbiAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xuICB2YXIgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnRdLmNvbmNhdChmYWxsYmFja1BsYWNlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8gPyBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9uczogZmxpcFZhcmlhdGlvbnMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IGFsbG93ZWRBdXRvUGxhY2VtZW50c1xuICAgIH0pIDogcGxhY2VtZW50KTtcbiAgfSwgW10pO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBjaGVja3NNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBtYWtlRmFsbGJhY2tDaGVja3MgPSB0cnVlO1xuICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGxhY2VtZW50ID0gcGxhY2VtZW50c1tpXTtcblxuICAgIHZhciBfYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBpc1N0YXJ0VmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHN0YXJ0O1xuICAgIHZhciBpc1ZlcnRpY2FsID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKF9iYXNlUGxhY2VtZW50KSA+PSAwO1xuICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pO1xuICAgIHZhciBtYWluVmFyaWF0aW9uU2lkZSA9IGlzVmVydGljYWwgPyBpc1N0YXJ0VmFyaWF0aW9uID8gcmlnaHQgOiBsZWZ0IDogaXNTdGFydFZhcmlhdGlvbiA/IGJvdHRvbSA6IHRvcDtcblxuICAgIGlmIChyZWZlcmVuY2VSZWN0W2xlbl0gPiBwb3BwZXJSZWN0W2xlbl0pIHtcbiAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIH1cblxuICAgIHZhciBhbHRWYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIHZhciBjaGVja3MgPSBbXTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbbWFpblZhcmlhdGlvblNpZGVdIDw9IDAsIG92ZXJmbG93W2FsdFZhcmlhdGlvblNpZGVdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICByZXR1cm4gY2hlY2s7XG4gICAgfSkpIHtcbiAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XG4gIH1cblxuICBpZiAobWFrZUZhbGxiYWNrQ2hlY2tzKSB7XG4gICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMgXHUyMDEzIHJlc2VhcmNoIGxhdGVyXG4gICAgdmFyIG51bWJlck9mQ2hlY2tzID0gZmxpcFZhcmlhdGlvbnMgPyAzIDogMTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XG4gICAgICB2YXIgZml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHMuZmluZChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBjaGVja3MgPSBjaGVja3NNYXAuZ2V0KHBsYWNlbWVudCk7XG5cbiAgICAgICAgaWYgKGNoZWNrcykge1xuICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gZml0dGluZ1BsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kgPSBudW1iZXJPZkNoZWNrczsgX2kgPiAwOyBfaS0tKSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKF9pKTtcblxuICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnBsYWNlbWVudCAhPT0gZmlyc3RGaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XG4gICAgc3RhdGUucGxhY2VtZW50ID0gZmlyc3RGaXR0aW5nUGxhY2VtZW50O1xuICAgIHN0YXRlLnJlc2V0ID0gdHJ1ZTtcbiAgfVxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZmxpcCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBmbGlwLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddLFxuICBkYXRhOiB7XG4gICAgX3NraXA6IGZhbHNlXG4gIH1cbn07IiwgImltcG9ydCB7IHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCwgcHJldmVudGVkT2Zmc2V0cykge1xuICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XG4gICAgcHJldmVudGVkT2Zmc2V0cyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCAtIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoICsgcHJldmVudGVkT2Zmc2V0cy54LFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQgKyBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGggLSBwcmV2ZW50ZWRPZmZzZXRzLnhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5zb21lKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93W3NpZGVdID49IDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoaWRlKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHByZXZlbnRlZE9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdztcbiAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgfSk7XG4gIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgfSk7XG4gIHZhciByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhyZWZlcmVuY2VPdmVyZmxvdywgcmVmZXJlbmNlUmVjdCk7XG4gIHZhciBwb3BwZXJFc2NhcGVPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocG9wcGVyQWx0T3ZlcmZsb3csIHBvcHBlclJlY3QsIHByZXZlbnRlZE9mZnNldHMpO1xuICB2YXIgaXNSZWZlcmVuY2VIaWRkZW4gPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzKTtcbiAgdmFyIGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbjogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogaGFzUG9wcGVyRXNjYXBlZFxuICB9O1xuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW4nOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdoaWRlJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXSxcbiAgZm46IGhpZGVcbn07IiwgImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBwbGFjZW1lbnRzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgcmVjdHMsIG9mZnNldCkge1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIGludmVydERpc3RhbmNlID0gW2xlZnQsIHRvcF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8gLTEgOiAxO1xuXG4gIHZhciBfcmVmID0gdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IG9mZnNldChPYmplY3QuYXNzaWduKHt9LCByZWN0cywge1xuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pKSA6IG9mZnNldCxcbiAgICAgIHNraWRkaW5nID0gX3JlZlswXSxcbiAgICAgIGRpc3RhbmNlID0gX3JlZlsxXTtcblxuICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XG4gIGRpc3RhbmNlID0gKGRpc3RhbmNlIHx8IDApICogaW52ZXJ0RGlzdGFuY2U7XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IHtcbiAgICB4OiBkaXN0YW5jZSxcbiAgICB5OiBza2lkZGluZ1xuICB9IDoge1xuICAgIHg6IHNraWRkaW5nLFxuICAgIHk6IGRpc3RhbmNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9mZnNldChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYyLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRvZmZzZXQgPSBvcHRpb25zLm9mZnNldCxcbiAgICAgIG9mZnNldCA9IF9vcHRpb25zJG9mZnNldCA9PT0gdm9pZCAwID8gWzAsIDBdIDogX29wdGlvbnMkb2Zmc2V0O1xuICB2YXIgZGF0YSA9IHBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCBzdGF0ZS5yZWN0cywgb2Zmc2V0KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHZhciBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQgPSBkYXRhW3N0YXRlLnBsYWNlbWVudF0sXG4gICAgICB4ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50LngsXG4gICAgICB5ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50Lnk7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0geDtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSB5O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdvZmZzZXQnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIGZuOiBvZmZzZXRcbn07IiwgImltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZU9mZnNldHMuanNcIjtcblxuZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxuICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdyZWFkJyxcbiAgZm46IHBvcHBlck9mZnNldHMsXG4gIGRhdGE6IHt9XG59OyIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn0iLCAiaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCBzdGFydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEFsdEF4aXMgZnJvbSBcIi4uL3V0aWxzL2dldEFsdEF4aXMuanNcIjtcbmltcG9ydCB7IHdpdGhpbiwgd2l0aGluTWF4Q2xhbXAgfSBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi4vdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5pbXBvcnQgeyBtaW4gYXMgbWF0aE1pbiwgbWF4IGFzIG1hdGhNYXggfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXIgPSBvcHRpb25zLnRldGhlcixcbiAgICAgIHRldGhlciA9IF9vcHRpb25zJHRldGhlciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHRldGhlcixcbiAgICAgIF9vcHRpb25zJHRldGhlck9mZnNldCA9IG9wdGlvbnMudGV0aGVyT2Zmc2V0LFxuICAgICAgdGV0aGVyT2Zmc2V0ID0gX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkdGV0aGVyT2Zmc2V0O1xuICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeVxuICB9KTtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9ICF2YXJpYXRpb247XG4gIHZhciBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGFsdEF4aXMgPSBnZXRBbHRBeGlzKG1haW5BeGlzKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IHRldGhlck9mZnNldChPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHRldGhlck9mZnNldDtcbiAgdmFyIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXRWYWx1ZSA9PT0gJ251bWJlcicgPyB7XG4gICAgbWFpbkF4aXM6IHRldGhlck9mZnNldFZhbHVlLFxuICAgIGFsdEF4aXM6IHRldGhlck9mZnNldFZhbHVlXG4gIH0gOiBPYmplY3QuYXNzaWduKHtcbiAgICBtYWluQXhpczogMCxcbiAgICBhbHRBeGlzOiAwXG4gIH0sIHRldGhlck9mZnNldFZhbHVlKTtcbiAgdmFyIG9mZnNldE1vZGlmaWVyU3RhdGUgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldCA/IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0W3N0YXRlLnBsYWNlbWVudF0gOiBudWxsO1xuICB2YXIgZGF0YSA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQ7XG5cbiAgICB2YXIgbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgICB2YXIgYWx0U2lkZSA9IG1haW5BeGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc107XG4gICAgdmFyIG1pbiA9IG9mZnNldCArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICB2YXIgbWF4ID0gb2Zmc2V0IC0gb3ZlcmZsb3dbYWx0U2lkZV07XG4gICAgdmFyIGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xuICAgIHZhciBtaW5MZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gcmVmZXJlbmNlUmVjdFtsZW5dIDogcG9wcGVyUmVjdFtsZW5dO1xuICAgIHZhciBtYXhMZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gLXBvcHBlclJlY3RbbGVuXSA6IC1yZWZlcmVuY2VSZWN0W2xlbl07IC8vIFdlIG5lZWQgdG8gaW5jbHVkZSB0aGUgYXJyb3cgaW4gdGhlIGNhbGN1bGF0aW9uIHNvIHRoZSBhcnJvdyBkb2Vzbid0IGdvXG4gICAgLy8gb3V0c2lkZSB0aGUgcmVmZXJlbmNlIGJvdW5kc1xuXG4gICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICAgIHZhciBhcnJvd1JlY3QgPSB0ZXRoZXIgJiYgYXJyb3dFbGVtZW50ID8gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpIDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIHZhciBhcnJvd1BhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10gPyBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10ucGFkZGluZyA6IGdldEZyZXNoU2lkZU9iamVjdCgpO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNYXggPSBhcnJvd1BhZGRpbmdPYmplY3RbYWx0U2lkZV07IC8vIElmIHRoZSByZWZlcmVuY2UgbGVuZ3RoIGlzIHNtYWxsZXIgdGhhbiB0aGUgYXJyb3cgbGVuZ3RoLCB3ZSBkb24ndCB3YW50XG4gICAgLy8gdG8gaW5jbHVkZSBpdHMgZnVsbCBzaXplIGluIHRoZSBjYWxjdWxhdGlvbi4gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbFxuICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXG4gICAgLy8gcmVmZXJlbmNlIGlzIG5vdCBvdmVyZmxvd2luZyBhcyB3ZWxsIChlLmcuIHZpcnR1YWwgZWxlbWVudHMgd2l0aCBub1xuICAgIC8vIHdpZHRoIG9yIGhlaWdodClcblxuICAgIHZhciBhcnJvd0xlbiA9IHdpdGhpbigwLCByZWZlcmVuY2VSZWN0W2xlbl0sIGFycm93UmVjdFtsZW5dKTtcbiAgICB2YXIgbWluT2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiAtIGFkZGl0aXZlIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtaW5MZW4gLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWF4TGVuICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcbiAgICB2YXIgY2xpZW50T2Zmc2V0ID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBtYWluQXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDAgOiAwO1xuICAgIHZhciBvZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJCA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbbWFpbkF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkIDogMDtcbiAgICB2YXIgdGV0aGVyTWluID0gb2Zmc2V0ICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcbiAgICB2YXIgdGV0aGVyTWF4ID0gb2Zmc2V0ICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcbiAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1hdGhNaW4obWluLCB0ZXRoZXJNaW4pIDogbWluLCBvZmZzZXQsIHRldGhlciA/IG1hdGhNYXgobWF4LCB0ZXRoZXJNYXgpIDogbWF4KTtcbiAgICBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcbiAgfVxuXG4gIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkMjtcblxuICAgIHZhciBfbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gdG9wIDogbGVmdDtcblxuICAgIHZhciBfYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBib3R0b20gOiByaWdodDtcblxuICAgIHZhciBfb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcblxuICAgIHZhciBfbGVuID0gYWx0QXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcblxuICAgIHZhciBfbWF4ID0gX29mZnNldCAtIG92ZXJmbG93W19hbHRTaWRlXTtcblxuICAgIHZhciBpc09yaWdpblNpZGUgPSBbdG9wLCBsZWZ0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVthbHRBeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJDIgOiAwO1xuXG4gICAgdmFyIF90ZXRoZXJNaW4gPSBpc09yaWdpblNpZGUgPyBfbWluIDogX29mZnNldCAtIHJlZmVyZW5jZVJlY3RbX2xlbl0gLSBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcztcblxuICAgIHZhciBfdGV0aGVyTWF4ID0gaXNPcmlnaW5TaWRlID8gX29mZnNldCArIHJlZmVyZW5jZVJlY3RbX2xlbl0gKyBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcyA6IF9tYXg7XG5cbiAgICB2YXIgX3ByZXZlbnRlZE9mZnNldCA9IHRldGhlciAmJiBpc09yaWdpblNpZGUgPyB3aXRoaW5NYXhDbGFtcChfdGV0aGVyTWluLCBfb2Zmc2V0LCBfdGV0aGVyTWF4KSA6IHdpdGhpbih0ZXRoZXIgPyBfdGV0aGVyTWluIDogX21pbiwgX29mZnNldCwgdGV0aGVyID8gX3RldGhlck1heCA6IF9tYXgpO1xuXG4gICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogcHJldmVudE92ZXJmbG93LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddXG59OyIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRIVE1MRWxlbWVudFNjcm9sbChlbGVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgfTtcbn0iLCAiaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEhUTUxFbGVtZW50U2Nyb2xsIGZyb20gXCIuL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IGdldFdpbmRvdyhub2RlKSB8fCAhaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGwobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsKG5vZGUpO1xuICB9XG59IiwgImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZVNjcm9sbCBmcm9tIFwiLi9nZXROb2RlU2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudFNjYWxlZChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IHJvdW5kKHJlY3Qud2lkdGgpIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxO1xuICB2YXIgc2NhbGVZID0gcm91bmQocmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMTtcbiAgcmV0dXJuIHNjYWxlWCAhPT0gMSB8fCBzY2FsZVkgIT09IDE7XG59IC8vIFJldHVybnMgdGhlIGNvbXBvc2l0ZSByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC5cbi8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb21wb3NpdGVSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnQsIGlzRml4ZWQpIHtcbiAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudElzU2NhbGVkID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzRWxlbWVudFNjYWxlZChvZmZzZXRQYXJlbnQpO1xuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnRJc1NjYWxlZCwgaXNGaXhlZCk7XG4gIHZhciBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gICAgaXNTY3JvbGxQYXJlbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIG9mZnNldHMgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlKTtcbiAgICAgIG9mZnNldHMueCArPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSArPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufSIsICJpbXBvcnQgeyBtb2RpZmllclBoYXNlcyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBzb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5ODc1MjU1XG5cbmZ1bmN0aW9uIG9yZGVyKG1vZGlmaWVycykge1xuICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBtYXAuc2V0KG1vZGlmaWVyLm5hbWUsIG1vZGlmaWVyKTtcbiAgfSk7IC8vIE9uIHZpc2l0aW5nIG9iamVjdCwgY2hlY2sgZm9yIGl0cyBkZXBlbmRlbmNpZXMgYW5kIHZpc2l0IHRoZW0gcmVjdXJzaXZlbHlcblxuICBmdW5jdGlvbiBzb3J0KG1vZGlmaWVyKSB7XG4gICAgdmlzaXRlZC5hZGQobW9kaWZpZXIubmFtZSk7XG4gICAgdmFyIHJlcXVpcmVzID0gW10uY29uY2F0KG1vZGlmaWVyLnJlcXVpcmVzIHx8IFtdLCBtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcbiAgICByZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMoZGVwKSkge1xuICAgICAgICB2YXIgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XG5cbiAgICAgICAgaWYgKGRlcE1vZGlmaWVyKSB7XG4gICAgICAgICAgc29ydChkZXBNb2RpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN1bHQucHVzaChtb2RpZmllcik7XG4gIH1cblxuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAoIXZpc2l0ZWQuaGFzKG1vZGlmaWVyLm5hbWUpKSB7XG4gICAgICAvLyBjaGVjayBmb3IgdmlzaXRlZCBvYmplY3RcbiAgICAgIHNvcnQobW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9yZGVyTW9kaWZpZXJzKG1vZGlmaWVycykge1xuICAvLyBvcmRlciBiYXNlZCBvbiBkZXBlbmRlbmNpZXNcbiAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcihtb2RpZmllcnMpOyAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxuXG4gIHJldHVybiBtb2RpZmllclBoYXNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGhhc2UpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgIHJldHVybiBtb2RpZmllci5waGFzZSA9PT0gcGhhc2U7XG4gICAgfSkpO1xuICB9LCBbXSk7XG59IiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlYm91bmNlKGZuKSB7XG4gIHZhciBwZW5kaW5nO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVzb2x2ZShmbigpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGVuZGluZztcbiAgfTtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VCeU5hbWUobW9kaWZpZXJzKSB7XG4gIHZhciBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKGZ1bmN0aW9uIChtZXJnZWQsIGN1cnJlbnQpIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBtZXJnZWRbY3VycmVudC5uYW1lXTtcbiAgICBtZXJnZWRbY3VycmVudC5uYW1lXSA9IGV4aXN0aW5nID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIGN1cnJlbnQsIHtcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLm9wdGlvbnMsIGN1cnJlbnQub3B0aW9ucyksXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5kYXRhLCBjdXJyZW50LmRhdGEpXG4gICAgfSkgOiBjdXJyZW50O1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTsgLy8gSUUxMSBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC52YWx1ZXNcblxuICByZXR1cm4gT2JqZWN0LmtleXMobWVyZ2VkKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBtZXJnZWRba2V5XTtcbiAgfSk7XG59IiwgImltcG9ydCBnZXRDb21wb3NpdGVSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gXCIuL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgb3JkZXJNb2RpZmllcnMgZnJvbSBcIi4vdXRpbHMvb3JkZXJNb2RpZmllcnMuanNcIjtcbmltcG9ydCBkZWJvdW5jZSBmcm9tIFwiLi91dGlscy9kZWJvdW5jZS5qc1wiO1xuaW1wb3J0IG1lcmdlQnlOYW1lIGZyb20gXCIuL3V0aWxzL21lcmdlQnlOYW1lLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICBtb2RpZmllcnM6IFtdLFxuICBzdHJhdGVneTogJ2Fic29sdXRlJ1xufTtcblxuZnVuY3Rpb24gYXJlVmFsaWRFbGVtZW50cygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiAhYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuICEoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcHBlckdlbmVyYXRvcihnZW5lcmF0b3JPcHRpb25zKSB7XG4gIGlmIChnZW5lcmF0b3JPcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBnZW5lcmF0b3JPcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX2dlbmVyYXRvck9wdGlvbnMgPSBnZW5lcmF0b3JPcHRpb25zLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE1vZGlmaWVycyxcbiAgICAgIGRlZmF1bHRNb2RpZmllcnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPT09IHZvaWQgMCA/IFtdIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRPcHRpb25zLFxuICAgICAgZGVmYXVsdE9wdGlvbnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID09PSB2b2lkIDAgPyBERUZBVUxUX09QVElPTlMgOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgZGVmYXVsdE9wdGlvbnMpLFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2U6IHJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyOiBwb3BwZXJcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9O1xuICAgIHZhciBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgdmFyIGlzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgdmFyIGluc3RhbmNlID0ge1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyhzZXRPcHRpb25zQWN0aW9uKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHNldE9wdGlvbnNBY3Rpb24gPT09ICdmdW5jdGlvbicgPyBzZXRPcHRpb25zQWN0aW9uKHN0YXRlLm9wdGlvbnMpIDogc2V0T3B0aW9uc0FjdGlvbjtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBzdGF0ZS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIHN0YXRlLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogaXNFbGVtZW50KHJlZmVyZW5jZSkgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UpIDogcmVmZXJlbmNlLmNvbnRleHRFbGVtZW50ID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKVxuICAgICAgICB9OyAvLyBPcmRlcnMgdGhlIG1vZGlmaWVycyBiYXNlZCBvbiB0aGVpciBkZXBlbmRlbmNpZXMgYW5kIGBwaGFzZWBcbiAgICAgICAgLy8gcHJvcGVydGllc1xuXG4gICAgICAgIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnMobWVyZ2VCeU5hbWUoW10uY29uY2F0KGRlZmF1bHRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSkpOyAvLyBTdHJpcCBvdXQgZGlzYWJsZWQgbW9kaWZpZXJzXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uZW5hYmxlZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJ1bk1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9LFxuICAgICAgLy8gU3luYyB1cGRhdGUgXHUyMDEzIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcbiAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcbiAgICAgIC8vIGxvZ2ljLlxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xuICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxuICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICBpZiAoaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0YXRlJGVsZW1lbnRzID0gc3RhdGUuZWxlbWVudHMsXG4gICAgICAgICAgICByZWZlcmVuY2UgPSBfc3RhdGUkZWxlbWVudHMucmVmZXJlbmNlLFxuICAgICAgICAgICAgcG9wcGVyID0gX3N0YXRlJGVsZW1lbnRzLnBvcHBlcjsgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXG4gICAgICAgIC8vIGFueW1vcmVcblxuICAgICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xuXG5cbiAgICAgICAgc3RhdGUucmVjdHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBnZXRDb21wb3NpdGVSZWN0KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KHBvcHBlciksIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCcpLFxuICAgICAgICAgIHBvcHBlcjogZ2V0TGF5b3V0UmVjdChwb3BwZXIpXG4gICAgICAgIH07IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIHJlc2V0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZS4gVGhlXG4gICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXG4gICAgICAgIC8vIHBsYWNlbWVudCwgd2hpY2ggdGhlbiBuZWVkcyB0byByZS1ydW4gYWxsIHRoZSBtb2RpZmllcnMsIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIGxvZ2ljIHdhcyBwcmV2aW91c2x5IHJhbiBmb3IgdGhlIHByZXZpb3VzIHBsYWNlbWVudCBhbmQgaXMgdGhlcmVmb3JlXG4gICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxuXG4gICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50OyAvLyBPbiBlYWNoIHVwZGF0ZSBjeWNsZSwgdGhlIGBtb2RpZmllcnNEYXRhYCBwcm9wZXJ0eSBmb3IgZWFjaCBtb2RpZmllclxuICAgICAgICAvLyBpcyBmaWxsZWQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhIHNwZWNpZmllZCBieSB0aGUgbW9kaWZpZXIuIFRoaXMgbWVhbnNcbiAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0IGFuZCBpcyBmcmVzaCBvbiBlYWNoIHVwZGF0ZS5cbiAgICAgICAgLy8gVG8gZW5zdXJlIHBlcnNpc3RlbnQgZGF0YSwgdXNlIGAke25hbWV9I3BlcnNpc3RlbnRgXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5tb2RpZmllcnNEYXRhW21vZGlmaWVyLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kaWZpZXIuZGF0YSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGlmIChzdGF0ZS5yZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3N0YXRlJG9yZGVyZWRNb2RpZmllID0gc3RhdGUub3JkZXJlZE1vZGlmaWVyc1tpbmRleF0sXG4gICAgICAgICAgICAgIGZuID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLmZuLFxuICAgICAgICAgICAgICBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm9wdGlvbnMsXG4gICAgICAgICAgICAgIF9vcHRpb25zID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9PT0gdm9pZCAwID8ge30gOiBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyLFxuICAgICAgICAgICAgICBuYW1lID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm5hbWU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGZuKHtcbiAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICBvcHRpb25zOiBfb3B0aW9ucyxcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlXG4gICAgICAgICAgICB9KSB8fCBzdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBc3luYyBhbmQgb3B0aW1pc3RpY2FsbHkgb3B0aW1pemVkIHVwZGF0ZSBcdTIwMTMgaXQgd2lsbCBub3QgYmUgZXhlY3V0ZWQgaWZcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxuICAgICAgdXBkYXRlOiBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgcmVzb2x2ZShzdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIGlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmICghaXNEZXN0cm95ZWQgJiYgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIG9wdGlvbnMub25GaXJzdFVwZGF0ZShzdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgYmVmb3JlIHRoZSBmaXJzdFxuICAgIC8vIHVwZGF0ZSBjeWNsZSBydW5zLiBUaGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHVwZGF0ZVxuICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XG4gICAgLy8gb3RoZXIgbW9kaWZpZXJzIG5lZWQgdG8gdXNlLCBidXQgdGhlIG1vZGlmaWVyIGlzIHJ1biBhZnRlciB0aGUgZGVwZW5kZW50XG4gICAgLy8gb25lLlxuXG4gICAgZnVuY3Rpb24gcnVuTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICAgICAgX3JlZiRvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9ucyA9IF9yZWYkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJG9wdGlvbnMsXG4gICAgICAgICAgICBlZmZlY3QgPSBfcmVmLmVmZmVjdDtcblxuICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjbGVhbnVwRm4gPSBlZmZlY3Qoe1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBub29wRm4gPSBmdW5jdGlvbiBub29wRm4oKSB7fTtcblxuICAgICAgICAgIGVmZmVjdENsZWFudXBGbnMucHVzaChjbGVhbnVwRm4gfHwgbm9vcEZuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9KTtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59XG5leHBvcnQgdmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBkZXRlY3RPdmVyZmxvdyB9OyIsICJpbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbmltcG9ydCBvZmZzZXQgZnJvbSBcIi4vbW9kaWZpZXJzL29mZnNldC5qc1wiO1xuaW1wb3J0IGZsaXAgZnJvbSBcIi4vbW9kaWZpZXJzL2ZsaXAuanNcIjtcbmltcG9ydCBwcmV2ZW50T3ZlcmZsb3cgZnJvbSBcIi4vbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGFycm93IGZyb20gXCIuL21vZGlmaWVycy9hcnJvdy5qc1wiO1xuaW1wb3J0IGhpZGUgZnJvbSBcIi4vbW9kaWZpZXJzL2hpZGUuanNcIjtcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzLCBjb21wdXRlU3R5bGVzLCBhcHBseVN0eWxlcywgb2Zmc2V0LCBmbGlwLCBwcmV2ZW50T3ZlcmZsb3csIGFycm93LCBoaWRlXTtcbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVyc1xufSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyLCBwb3BwZXJHZW5lcmF0b3IsIGRlZmF1bHRNb2RpZmllcnMsIGRldGVjdE92ZXJmbG93IH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyIGFzIGNyZWF0ZVBvcHBlckxpdGUgfSBmcm9tIFwiLi9wb3BwZXItbGl0ZS5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCAqIGZyb20gXCIuL21vZGlmaWVycy9pbmRleC5qc1wiOyIsICJleHBvcnQgY29uc3QgUk9VTkRfQVJST1cgPVxuICAnPHN2ZyB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTAgNnMxLjc5Ni0uMDEzIDQuNjctMy42MTVDNS44NTEuOSA2LjkzLjAwNiA4IDBjMS4wNy0uMDA2IDIuMTQ4Ljg4NyAzLjM0MyAyLjM4NUMxNC4yMzMgNi4wMDUgMTYgNiAxNiA2SDB6XCI+PC9zdmc+JztcblxuZXhwb3J0IGNvbnN0IEJPWF9DTEFTUyA9IGBfX05BTUVTUEFDRV9QUkVGSVhfXy1ib3hgO1xuZXhwb3J0IGNvbnN0IENPTlRFTlRfQ0xBU1MgPSBgX19OQU1FU1BBQ0VfUFJFRklYX18tY29udGVudGA7XG5leHBvcnQgY29uc3QgQkFDS0RST1BfQ0xBU1MgPSBgX19OQU1FU1BBQ0VfUFJFRklYX18tYmFja2Ryb3BgO1xuZXhwb3J0IGNvbnN0IEFSUk9XX0NMQVNTID0gYF9fTkFNRVNQQUNFX1BSRUZJWF9fLWFycm93YDtcbmV4cG9ydCBjb25zdCBTVkdfQVJST1dfQ0xBU1MgPSBgX19OQU1FU1BBQ0VfUFJFRklYX18tc3ZnLWFycm93YDtcblxuZXhwb3J0IGNvbnN0IFRPVUNIX09QVElPTlMgPSB7cGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZX07XG5cbmV4cG9ydCBjb25zdCBUSVBQWV9ERUZBVUxUX0FQUEVORF9UTyA9ICgpID0+IGRvY3VtZW50LmJvZHk7XG4iLCAiaW1wb3J0IHtCYXNlUGxhY2VtZW50LCBQbGFjZW1lbnR9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaGFzT3duUHJvcGVydHkoXG4gIG9iajogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIGtleTogc3RyaW5nXG4pOiBib29sZWFuIHtcbiAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm48VD4oXG4gIHZhbHVlOiBUIHwgW1QgfCBudWxsLCBUIHwgbnVsbF0sXG4gIGluZGV4OiBudW1iZXIsXG4gIGRlZmF1bHRWYWx1ZTogVCB8IFtULCBUXVxuKTogVCB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IHYgPSB2YWx1ZVtpbmRleF07XG4gICAgcmV0dXJuIHYgPT0gbnVsbFxuICAgICAgPyBBcnJheS5pc0FycmF5KGRlZmF1bHRWYWx1ZSlcbiAgICAgICAgPyBkZWZhdWx0VmFsdWVbaW5kZXhdXG4gICAgICAgIDogZGVmYXVsdFZhbHVlXG4gICAgICA6IHY7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1R5cGUodmFsdWU6IGFueSwgdHlwZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IHN0ciA9IHt9LnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICByZXR1cm4gc3RyLmluZGV4T2YoJ1tvYmplY3QnKSA9PT0gMCAmJiBzdHIuaW5kZXhPZihgJHt0eXBlfV1gKSA+IC0xO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlV2l0aEFyZ3NPclJldHVybih2YWx1ZTogYW55LCBhcmdzOiBhbnlbXSk6IGFueSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZSguLi5hcmdzKSA6IHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2U8VD4oXG4gIGZuOiAoYXJnOiBUKSA9PiB2b2lkLFxuICBtczogbnVtYmVyXG4pOiAoYXJnOiBUKSA9PiB2b2lkIHtcbiAgLy8gQXZvaWQgd3JhcHBpbmcgaW4gYHNldFRpbWVvdXRgIGlmIG1zIGlzIDAgYW55d2F5XG4gIGlmIChtcyA9PT0gMCkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGxldCB0aW1lb3V0OiBhbnk7XG5cbiAgcmV0dXJuIChhcmcpOiB2b2lkID0+IHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZm4oYXJnKTtcbiAgICB9LCBtcyk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQcm9wZXJ0aWVzPFQ+KG9iajogVCwga2V5czogc3RyaW5nW10pOiBQYXJ0aWFsPFQ+IHtcbiAgY29uc3QgY2xvbmUgPSB7Li4ub2JqfTtcbiAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBkZWxldGUgKGNsb25lIGFzIGFueSlba2V5XTtcbiAgfSk7XG4gIHJldHVybiBjbG9uZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0QnlTcGFjZXModmFsdWU6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KC9cXHMrLykuZmlsdGVyKEJvb2xlYW4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheTxUPih2YWx1ZTogVCB8IFRbXSk6IFRbXSB7XG4gIHJldHVybiAoW10gYXMgVFtdKS5jb25jYXQodmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHVzaElmVW5pcXVlPFQ+KGFycjogVFtdLCB2YWx1ZTogVCk6IHZvaWQge1xuICBpZiAoYXJyLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgIGFyci5wdXNoKHZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kUHhJZk51bWJlcih2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyBgJHt2YWx1ZX1weGAgOiB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZTxUPihhcnI6IFRbXSk6IFRbXSB7XG4gIHJldHVybiBhcnIuZmlsdGVyKChpdGVtLCBpbmRleCkgPT4gYXJyLmluZGV4T2YoaXRlbSkgPT09IGluZGV4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE51bWJlcih2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB2YWx1ZSA6IHBhcnNlRmxvYXQodmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQ6IFBsYWNlbWVudCk6IEJhc2VQbGFjZW1lbnQge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF0gYXMgQmFzZVBsYWNlbWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5RnJvbSh2YWx1ZTogQXJyYXlMaWtlPGFueT4pOiBhbnlbXSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZFByb3BzKFxuICBvYmo6IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4pOiBQYXJ0aWFsPFJlY29yZDxzdHJpbmcsIHVua25vd24+PiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBpZiAob2JqW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgKGFjYyBhcyBhbnkpW2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG4iLCAiaW1wb3J0IHtSZWZlcmVuY2VFbGVtZW50LCBUYXJnZXRzfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7UG9wcGVyVHJlZURhdGF9IGZyb20gJy4vdHlwZXMtaW50ZXJuYWwnO1xuaW1wb3J0IHthcnJheUZyb20sIGlzVHlwZSwgbm9ybWFsaXplVG9BcnJheSwgZ2V0QmFzZVBsYWNlbWVudH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXYoKTogSFRNTERpdkVsZW1lbnQge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBFbGVtZW50IHwgRG9jdW1lbnRGcmFnbWVudCB7XG4gIHJldHVybiBbJ0VsZW1lbnQnLCAnRnJhZ21lbnQnXS5zb21lKCh0eXBlKSA9PiBpc1R5cGUodmFsdWUsIHR5cGUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZUxpc3QodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBOb2RlTGlzdCB7XG4gIHJldHVybiBpc1R5cGUodmFsdWUsICdOb2RlTGlzdCcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNNb3VzZUV2ZW50KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgTW91c2VFdmVudCB7XG4gIHJldHVybiBpc1R5cGUodmFsdWUsICdNb3VzZUV2ZW50Jyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlZmVyZW5jZUVsZW1lbnQodmFsdWU6IGFueSk6IHZhbHVlIGlzIFJlZmVyZW5jZUVsZW1lbnQge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX3RpcHB5ICYmIHZhbHVlLl90aXBweS5yZWZlcmVuY2UgPT09IHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFycmF5T2ZFbGVtZW50cyh2YWx1ZTogVGFyZ2V0cyk6IEVsZW1lbnRbXSB7XG4gIGlmIChpc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgcmV0dXJuIFt2YWx1ZV07XG4gIH1cblxuICBpZiAoaXNOb2RlTGlzdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gYXJyYXlGcm9tKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBhcnJheUZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkR1cmF0aW9uKFxuICBlbHM6IChIVE1MRGl2RWxlbWVudCB8IG51bGwpW10sXG4gIHZhbHVlOiBudW1iZXJcbik6IHZvaWQge1xuICBlbHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke3ZhbHVlfW1zYDtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0VmlzaWJpbGl0eVN0YXRlKFxuICBlbHM6IChIVE1MRGl2RWxlbWVudCB8IG51bGwpW10sXG4gIHN0YXRlOiAndmlzaWJsZScgfCAnaGlkZGVuJ1xuKTogdm9pZCB7XG4gIGVscy5mb3JFYWNoKChlbCkgPT4ge1xuICAgIGlmIChlbCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXRlJywgc3RhdGUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPd25lckRvY3VtZW50KFxuICBlbGVtZW50T3JFbGVtZW50czogRWxlbWVudCB8IEVsZW1lbnRbXVxuKTogRG9jdW1lbnQge1xuICBjb25zdCBbZWxlbWVudF0gPSBub3JtYWxpemVUb0FycmF5KGVsZW1lbnRPckVsZW1lbnRzKTtcblxuICAvLyBFbGVtZW50cyBjcmVhdGVkIHZpYSBhIDx0ZW1wbGF0ZT4gaGF2ZSBhbiBvd25lckRvY3VtZW50IHdpdGggbm8gcmVmZXJlbmNlIHRvIHRoZSBib2R5XG4gIHJldHVybiBlbGVtZW50Py5vd25lckRvY3VtZW50Py5ib2R5ID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogZG9jdW1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0N1cnNvck91dHNpZGVJbnRlcmFjdGl2ZUJvcmRlcihcbiAgcG9wcGVyVHJlZURhdGE6IFBvcHBlclRyZWVEYXRhW10sXG4gIGV2ZW50OiBNb3VzZUV2ZW50XG4pOiBib29sZWFuIHtcbiAgY29uc3Qge2NsaWVudFgsIGNsaWVudFl9ID0gZXZlbnQ7XG5cbiAgcmV0dXJuIHBvcHBlclRyZWVEYXRhLmV2ZXJ5KCh7cG9wcGVyUmVjdCwgcG9wcGVyU3RhdGUsIHByb3BzfSkgPT4ge1xuICAgIGNvbnN0IHtpbnRlcmFjdGl2ZUJvcmRlcn0gPSBwcm9wcztcbiAgICBjb25zdCBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwb3BwZXJTdGF0ZS5wbGFjZW1lbnQpO1xuICAgIGNvbnN0IG9mZnNldERhdGEgPSBwb3BwZXJTdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDtcblxuICAgIGlmICghb2Zmc2V0RGF0YSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgdG9wRGlzdGFuY2UgPSBiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJyA/IG9mZnNldERhdGEudG9wIS55IDogMDtcbiAgICBjb25zdCBib3R0b21EaXN0YW5jZSA9IGJhc2VQbGFjZW1lbnQgPT09ICd0b3AnID8gb2Zmc2V0RGF0YS5ib3R0b20hLnkgOiAwO1xuICAgIGNvbnN0IGxlZnREaXN0YW5jZSA9IGJhc2VQbGFjZW1lbnQgPT09ICdyaWdodCcgPyBvZmZzZXREYXRhLmxlZnQhLnggOiAwO1xuICAgIGNvbnN0IHJpZ2h0RGlzdGFuY2UgPSBiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcgPyBvZmZzZXREYXRhLnJpZ2h0IS54IDogMDtcblxuICAgIGNvbnN0IGV4Y2VlZHNUb3AgPVxuICAgICAgcG9wcGVyUmVjdC50b3AgLSBjbGllbnRZICsgdG9wRGlzdGFuY2UgPiBpbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICBjb25zdCBleGNlZWRzQm90dG9tID1cbiAgICAgIGNsaWVudFkgLSBwb3BwZXJSZWN0LmJvdHRvbSAtIGJvdHRvbURpc3RhbmNlID4gaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgY29uc3QgZXhjZWVkc0xlZnQgPVxuICAgICAgcG9wcGVyUmVjdC5sZWZ0IC0gY2xpZW50WCArIGxlZnREaXN0YW5jZSA+IGludGVyYWN0aXZlQm9yZGVyO1xuICAgIGNvbnN0IGV4Y2VlZHNSaWdodCA9XG4gICAgICBjbGllbnRYIC0gcG9wcGVyUmVjdC5yaWdodCAtIHJpZ2h0RGlzdGFuY2UgPiBpbnRlcmFjdGl2ZUJvcmRlcjtcblxuICAgIHJldHVybiBleGNlZWRzVG9wIHx8IGV4Y2VlZHNCb3R0b20gfHwgZXhjZWVkc0xlZnQgfHwgZXhjZWVkc1JpZ2h0O1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcihcbiAgYm94OiBIVE1MRGl2RWxlbWVudCxcbiAgYWN0aW9uOiAnYWRkJyB8ICdyZW1vdmUnLFxuICBsaXN0ZW5lcjogKGV2ZW50OiBUcmFuc2l0aW9uRXZlbnQpID0+IHZvaWRcbik6IHZvaWQge1xuICBjb25zdCBtZXRob2QgPSBgJHthY3Rpb259RXZlbnRMaXN0ZW5lcmAgYXNcbiAgICB8ICdhZGRFdmVudExpc3RlbmVyJ1xuICAgIHwgJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuXG4gIC8vIHNvbWUgYnJvd3NlcnMgYXBwYXJlbnRseSBzdXBwb3J0IGB0cmFuc2l0aW9uYCAodW5wcmVmaXhlZCkgYnV0IG9ubHkgZmlyZVxuICAvLyBgd2Via2l0VHJhbnNpdGlvbkVuZGAuLi5cbiAgWyd0cmFuc2l0aW9uZW5kJywgJ3dlYmtpdFRyYW5zaXRpb25FbmQnXS5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgIGJveFttZXRob2RdKGV2ZW50LCBsaXN0ZW5lciBhcyBFdmVudExpc3RlbmVyKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29tcGFyZWQgdG8geHh4LmNvbnRhaW5zLCB0aGlzIGZ1bmN0aW9uIHdvcmtzIGZvciBkb20gc3RydWN0dXJlcyB3aXRoIHNoYWRvd1xuICogZG9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhY3R1YWxDb250YWlucyhwYXJlbnQ6IEVsZW1lbnQsIGNoaWxkOiBFbGVtZW50KTogYm9vbGVhbiB7XG4gIGxldCB0YXJnZXQgPSBjaGlsZDtcbiAgd2hpbGUgKHRhcmdldCkge1xuICAgIGlmIChwYXJlbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRhcmdldCA9ICh0YXJnZXQuZ2V0Um9vdE5vZGU/LigpIGFzIGFueSk/Lmhvc3Q7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwgImltcG9ydCB7VE9VQ0hfT1BUSU9OU30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtpc1JlZmVyZW5jZUVsZW1lbnR9IGZyb20gJy4vZG9tLXV0aWxzJztcblxuZXhwb3J0IGNvbnN0IGN1cnJlbnRJbnB1dCA9IHtpc1RvdWNoOiBmYWxzZX07XG5sZXQgbGFzdE1vdXNlTW92ZVRpbWUgPSAwO1xuXG4vKipcbiAqIFdoZW4gYSBgdG91Y2hzdGFydGAgZXZlbnQgaXMgZmlyZWQsIGl0J3MgYXNzdW1lZCB0aGUgdXNlciBpcyB1c2luZyB0b3VjaFxuICogaW5wdXQuIFdlJ2xsIGJpbmQgYSBgbW91c2Vtb3ZlYCBldmVudCBsaXN0ZW5lciB0byBsaXN0ZW4gZm9yIG1vdXNlIGlucHV0IGluXG4gKiB0aGUgZnV0dXJlLiBUaGlzIHdheSwgdGhlIGBpc1RvdWNoYCBwcm9wZXJ0eSBpcyBmdWxseSBkeW5hbWljIGFuZCB3aWxsIGhhbmRsZVxuICogaHlicmlkIGRldmljZXMgdGhhdCB1c2UgYSBtaXggb2YgdG91Y2ggKyBtb3VzZSBpbnB1dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uRG9jdW1lbnRUb3VjaFN0YXJ0KCk6IHZvaWQge1xuICBpZiAoY3VycmVudElucHV0LmlzVG91Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdXJyZW50SW5wdXQuaXNUb3VjaCA9IHRydWU7XG5cbiAgaWYgKHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uRG9jdW1lbnRNb3VzZU1vdmUpO1xuICB9XG59XG5cbi8qKlxuICogV2hlbiB0d28gYG1vdXNlbW92ZWAgZXZlbnQgYXJlIGZpcmVkIGNvbnNlY3V0aXZlbHkgd2l0aGluIDIwbXMsIGl0J3MgYXNzdW1lZFxuICogdGhlIHVzZXIgaXMgdXNpbmcgbW91c2UgaW5wdXQgYWdhaW4uIGBtb3VzZW1vdmVgIGNhbiBmaXJlIG9uIHRvdWNoIGRldmljZXMgYXNcbiAqIHdlbGwsIGJ1dCB2ZXJ5IHJhcmVseSB0aGF0IHF1aWNrbHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbkRvY3VtZW50TW91c2VNb3ZlKCk6IHZvaWQge1xuICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICBpZiAobm93IC0gbGFzdE1vdXNlTW92ZVRpbWUgPCAyMCkge1xuICAgIGN1cnJlbnRJbnB1dC5pc1RvdWNoID0gZmFsc2U7XG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbkRvY3VtZW50TW91c2VNb3ZlKTtcbiAgfVxuXG4gIGxhc3RNb3VzZU1vdmVUaW1lID0gbm93O1xufVxuXG4vKipcbiAqIFdoZW4gYW4gZWxlbWVudCBpcyBpbiBmb2N1cyBhbmQgaGFzIGEgdGlwcHksIGxlYXZpbmcgdGhlIHRhYi93aW5kb3cgYW5kXG4gKiByZXR1cm5pbmcgY2F1c2VzIGl0IHRvIHNob3cgYWdhaW4uIEZvciBtb3VzZSB1c2VycyB0aGlzIGlzIHVuZXhwZWN0ZWQsIGJ1dFxuICogZm9yIGtleWJvYXJkIHVzZSBpdCBtYWtlcyBzZW5zZS5cbiAqIFRPRE86IGZpbmQgYSBiZXR0ZXIgdGVjaG5pcXVlIHRvIHNvbHZlIHRoaXMgcHJvYmxlbVxuICovXG5leHBvcnQgZnVuY3Rpb24gb25XaW5kb3dCbHVyKCk6IHZvaWQge1xuICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCB8IG51bGw7XG5cbiAgaWYgKGlzUmVmZXJlbmNlRWxlbWVudChhY3RpdmVFbGVtZW50KSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gYWN0aXZlRWxlbWVudC5fdGlwcHkhO1xuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQuYmx1ciAmJiAhaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzKCk6IHZvaWQge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Eb2N1bWVudFRvdWNoU3RhcnQsIFRPVUNIX09QVElPTlMpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIG9uV2luZG93Qmx1cik7XG59XG4iLCAiZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9XG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmV4cG9ydCBjb25zdCBpc0lFMTEgPSBpc0Jyb3dzZXJcbiAgPyAvLyBAdHMtaWdub3JlXG4gICAgISF3aW5kb3cubXNDcnlwdG9cbiAgOiBmYWxzZTtcbiIsICJpbXBvcnQge1RhcmdldHN9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcobWV0aG9kOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCB0eHQgPSBtZXRob2QgPT09ICdkZXN0cm95JyA/ICduIGFscmVhZHktJyA6ICcgJztcblxuICByZXR1cm4gW1xuICAgIGAke21ldGhvZH0oKSB3YXMgY2FsbGVkIG9uIGEke3R4dH1kZXN0cm95ZWQgaW5zdGFuY2UuIFRoaXMgaXMgYSBuby1vcCBidXRgLFxuICAgICdpbmRpY2F0ZXMgYSBwb3RlbnRpYWwgbWVtb3J5IGxlYWsuJyxcbiAgXS5qb2luKCcgJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbih2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3Qgc3BhY2VzQW5kVGFicyA9IC9bIFxcdF17Mix9L2c7XG4gIGNvbnN0IGxpbmVTdGFydFdpdGhTcGFjZXMgPSAvXlsgXFx0XSovZ207XG5cbiAgcmV0dXJuIHZhbHVlXG4gICAgLnJlcGxhY2Uoc3BhY2VzQW5kVGFicywgJyAnKVxuICAgIC5yZXBsYWNlKGxpbmVTdGFydFdpdGhTcGFjZXMsICcnKVxuICAgIC50cmltKCk7XG59XG5cbmZ1bmN0aW9uIGdldERldk1lc3NhZ2UobWVzc2FnZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGNsZWFuKGBcbiAgJWN0aXBweS5qc1xuXG4gICVjJHtjbGVhbihtZXNzYWdlKX1cblxuICAlY/CfkbfigI0gVGhpcyBpcyBhIGRldmVsb3BtZW50LW9ubHkgbWVzc2FnZS4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHByb2R1Y3Rpb24uXG4gIGApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9ybWF0dGVkTWVzc2FnZShtZXNzYWdlOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIHJldHVybiBbXG4gICAgZ2V0RGV2TWVzc2FnZShtZXNzYWdlKSxcbiAgICAvLyB0aXRsZVxuICAgICdjb2xvcjogIzAwQzU4NDsgZm9udC1zaXplOiAxLjNlbTsgZm9udC13ZWlnaHQ6IGJvbGQ7JyxcbiAgICAvLyBtZXNzYWdlXG4gICAgJ2xpbmUtaGVpZ2h0OiAxLjUnLFxuICAgIC8vIGZvb3RlclxuICAgICdjb2xvcjogI2E2YTA5NTsnLFxuICBdO1xufVxuXG4vLyBBc3N1bWUgd2FybmluZ3MgYW5kIGVycm9ycyBuZXZlciBoYXZlIHRoZSBzYW1lIG1lc3NhZ2VcbmxldCB2aXNpdGVkTWVzc2FnZXM6IFNldDxzdHJpbmc+O1xuaWYgKF9fREVWX18pIHtcbiAgcmVzZXRWaXNpdGVkTWVzc2FnZXMoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0VmlzaXRlZE1lc3NhZ2VzKCk6IHZvaWQge1xuICB2aXNpdGVkTWVzc2FnZXMgPSBuZXcgU2V0KCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXJuV2hlbihjb25kaXRpb246IGJvb2xlYW4sIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoY29uZGl0aW9uICYmICF2aXNpdGVkTWVzc2FnZXMuaGFzKG1lc3NhZ2UpKSB7XG4gICAgdmlzaXRlZE1lc3NhZ2VzLmFkZChtZXNzYWdlKTtcbiAgICBjb25zb2xlLndhcm4oLi4uZ2V0Rm9ybWF0dGVkTWVzc2FnZShtZXNzYWdlKSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9yV2hlbihjb25kaXRpb246IGJvb2xlYW4sIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoY29uZGl0aW9uICYmICF2aXNpdGVkTWVzc2FnZXMuaGFzKG1lc3NhZ2UpKSB7XG4gICAgdmlzaXRlZE1lc3NhZ2VzLmFkZChtZXNzYWdlKTtcbiAgICBjb25zb2xlLmVycm9yKC4uLmdldEZvcm1hdHRlZE1lc3NhZ2UobWVzc2FnZSkpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVRhcmdldHModGFyZ2V0czogVGFyZ2V0cyk6IHZvaWQge1xuICBjb25zdCBkaWRQYXNzRmFsc3lWYWx1ZSA9ICF0YXJnZXRzO1xuICBjb25zdCBkaWRQYXNzUGxhaW5PYmplY3QgPVxuICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YXJnZXRzKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiZcbiAgICAhKHRhcmdldHMgYXMgYW55KS5hZGRFdmVudExpc3RlbmVyO1xuXG4gIGVycm9yV2hlbihcbiAgICBkaWRQYXNzRmFsc3lWYWx1ZSxcbiAgICBbXG4gICAgICAndGlwcHkoKSB3YXMgcGFzc2VkJyxcbiAgICAgICdgJyArIFN0cmluZyh0YXJnZXRzKSArICdgJyxcbiAgICAgICdhcyBpdHMgdGFyZ2V0cyAoZmlyc3QpIGFyZ3VtZW50LiBWYWxpZCB0eXBlcyBhcmU6IFN0cmluZywgRWxlbWVudCwnLFxuICAgICAgJ0VsZW1lbnRbXSwgb3IgTm9kZUxpc3QuJyxcbiAgICBdLmpvaW4oJyAnKVxuICApO1xuXG4gIGVycm9yV2hlbihcbiAgICBkaWRQYXNzUGxhaW5PYmplY3QsXG4gICAgW1xuICAgICAgJ3RpcHB5KCkgd2FzIHBhc3NlZCBhIHBsYWluIG9iamVjdCB3aGljaCBpcyBub3Qgc3VwcG9ydGVkIGFzIGFuIGFyZ3VtZW50JyxcbiAgICAgICdmb3IgdmlydHVhbCBwb3NpdGlvbmluZy4gVXNlIHByb3BzLmdldFJlZmVyZW5jZUNsaWVudFJlY3QgaW5zdGVhZC4nLFxuICAgIF0uam9pbignICcpXG4gICk7XG59XG4iLCAiaW1wb3J0IHtEZWZhdWx0UHJvcHMsIFBsdWdpbiwgUHJvcHMsIFJlZmVyZW5jZUVsZW1lbnQsIFRpcHB5fSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7XG4gIGhhc093blByb3BlcnR5LFxuICByZW1vdmVQcm9wZXJ0aWVzLFxuICBpbnZva2VXaXRoQXJnc09yUmV0dXJuLFxufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7d2FybldoZW59IGZyb20gJy4vdmFsaWRhdGlvbic7XG5pbXBvcnQge1RJUFBZX0RFRkFVTFRfQVBQRU5EX1RPfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmNvbnN0IHBsdWdpblByb3BzID0ge1xuICBhbmltYXRlRmlsbDogZmFsc2UsXG4gIGZvbGxvd0N1cnNvcjogZmFsc2UsXG4gIGlubGluZVBvc2l0aW9uaW5nOiBmYWxzZSxcbiAgc3RpY2t5OiBmYWxzZSxcbn07XG5cbmNvbnN0IHJlbmRlclByb3BzID0ge1xuICBhbGxvd0hUTUw6IGZhbHNlLFxuICBhbmltYXRpb246ICdmYWRlJyxcbiAgYXJyb3c6IHRydWUsXG4gIGNvbnRlbnQ6ICcnLFxuICBpbmVydGlhOiBmYWxzZSxcbiAgbWF4V2lkdGg6IDM1MCxcbiAgcm9sZTogJ3Rvb2x0aXAnLFxuICB0aGVtZTogJycsXG4gIHpJbmRleDogOTk5OSxcbn07XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0UHJvcHM6IERlZmF1bHRQcm9wcyA9IHtcbiAgYXBwZW5kVG86IFRJUFBZX0RFRkFVTFRfQVBQRU5EX1RPLFxuICBhcmlhOiB7XG4gICAgY29udGVudDogJ2F1dG8nLFxuICAgIGV4cGFuZGVkOiAnYXV0bycsXG4gIH0sXG4gIGRlbGF5OiAwLFxuICBkdXJhdGlvbjogWzMwMCwgMjUwXSxcbiAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogbnVsbCxcbiAgaGlkZU9uQ2xpY2s6IHRydWUsXG4gIGlnbm9yZUF0dHJpYnV0ZXM6IGZhbHNlLFxuICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gIGludGVyYWN0aXZlQm9yZGVyOiAyLFxuICBpbnRlcmFjdGl2ZURlYm91bmNlOiAwLFxuICBtb3ZlVHJhbnNpdGlvbjogJycsXG4gIG9mZnNldDogWzAsIDEwXSxcbiAgb25BZnRlclVwZGF0ZSgpIHt9LFxuICBvbkJlZm9yZVVwZGF0ZSgpIHt9LFxuICBvbkNyZWF0ZSgpIHt9LFxuICBvbkRlc3Ryb3koKSB7fSxcbiAgb25IaWRkZW4oKSB7fSxcbiAgb25IaWRlKCkge30sXG4gIG9uTW91bnQoKSB7fSxcbiAgb25TaG93KCkge30sXG4gIG9uU2hvd24oKSB7fSxcbiAgb25UcmlnZ2VyKCkge30sXG4gIG9uVW50cmlnZ2VyKCkge30sXG4gIG9uQ2xpY2tPdXRzaWRlKCkge30sXG4gIHBsYWNlbWVudDogJ3RvcCcsXG4gIHBsdWdpbnM6IFtdLFxuICBwb3BwZXJPcHRpb25zOiB7fSxcbiAgcmVuZGVyOiBudWxsLFxuICBzaG93T25DcmVhdGU6IGZhbHNlLFxuICB0b3VjaDogdHJ1ZSxcbiAgdHJpZ2dlcjogJ21vdXNlZW50ZXIgZm9jdXMnLFxuICB0cmlnZ2VyVGFyZ2V0OiBudWxsLFxuICAuLi5wbHVnaW5Qcm9wcyxcbiAgLi4ucmVuZGVyUHJvcHMsXG59O1xuXG5jb25zdCBkZWZhdWx0S2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRQcm9wcyk7XG5cbmV4cG9ydCBjb25zdCBzZXREZWZhdWx0UHJvcHM6IFRpcHB5WydzZXREZWZhdWx0UHJvcHMnXSA9IChwYXJ0aWFsUHJvcHMpID0+IHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKF9fREVWX18pIHtcbiAgICB2YWxpZGF0ZVByb3BzKHBhcnRpYWxQcm9wcywgW10pO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHBhcnRpYWxQcm9wcykgYXMgQXJyYXk8a2V5b2YgRGVmYXVsdFByb3BzPjtcbiAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAoZGVmYXVsdFByb3BzIGFzIGFueSlba2V5XSA9IHBhcnRpYWxQcm9wc1trZXldO1xuICB9KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFeHRlbmRlZFBhc3NlZFByb3BzKFxuICBwYXNzZWRQcm9wczogUGFydGlhbDxQcm9wcz4gJiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuKTogUGFydGlhbDxQcm9wcz4ge1xuICBjb25zdCBwbHVnaW5zID0gcGFzc2VkUHJvcHMucGx1Z2lucyB8fCBbXTtcbiAgY29uc3QgcGx1Z2luUHJvcHMgPSBwbHVnaW5zLnJlZHVjZTxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oKGFjYywgcGx1Z2luKSA9PiB7XG4gICAgY29uc3Qge25hbWUsIGRlZmF1bHRWYWx1ZX0gPSBwbHVnaW47XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgYWNjW25hbWVdID1cbiAgICAgICAgcGFzc2VkUHJvcHNbbmFtZV0gIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gcGFzc2VkUHJvcHNbbmFtZV1cbiAgICAgICAgICA6IChkZWZhdWx0UHJvcHMgYXMgYW55KVtuYW1lXSA/PyBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuXG4gIHJldHVybiB7XG4gICAgLi4ucGFzc2VkUHJvcHMsXG4gICAgLi4ucGx1Z2luUHJvcHMsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhQXR0cmlidXRlUHJvcHMoXG4gIHJlZmVyZW5jZTogUmVmZXJlbmNlRWxlbWVudCxcbiAgcGx1Z2luczogUGx1Z2luW11cbik6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgY29uc3QgcHJvcEtleXMgPSBwbHVnaW5zXG4gICAgPyBPYmplY3Qua2V5cyhnZXRFeHRlbmRlZFBhc3NlZFByb3BzKHsuLi5kZWZhdWx0UHJvcHMsIHBsdWdpbnN9KSlcbiAgICA6IGRlZmF1bHRLZXlzO1xuXG4gIGNvbnN0IHByb3BzID0gcHJvcEtleXMucmVkdWNlKFxuICAgIChhY2M6IFBhcnRpYWw8UHJvcHM+ICYgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIGtleSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVBc1N0cmluZyA9IChcbiAgICAgICAgcmVmZXJlbmNlLmdldEF0dHJpYnV0ZShgZGF0YS10aXBweS0ke2tleX1gKSB8fCAnJ1xuICAgICAgKS50cmltKCk7XG5cbiAgICAgIGlmICghdmFsdWVBc1N0cmluZykge1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ID09PSAnY29udGVudCcpIHtcbiAgICAgICAgYWNjW2tleV0gPSB2YWx1ZUFzU3RyaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhY2Nba2V5XSA9IEpTT04ucGFyc2UodmFsdWVBc1N0cmluZyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlQXNTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LFxuICAgIHt9XG4gICk7XG5cbiAgcmV0dXJuIHByb3BzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZhbHVhdGVQcm9wcyhcbiAgcmVmZXJlbmNlOiBSZWZlcmVuY2VFbGVtZW50LFxuICBwcm9wczogUHJvcHNcbik6IFByb3BzIHtcbiAgY29uc3Qgb3V0ID0ge1xuICAgIC4uLnByb3BzLFxuICAgIGNvbnRlbnQ6IGludm9rZVdpdGhBcmdzT3JSZXR1cm4ocHJvcHMuY29udGVudCwgW3JlZmVyZW5jZV0pLFxuICAgIC4uLihwcm9wcy5pZ25vcmVBdHRyaWJ1dGVzXG4gICAgICA/IHt9XG4gICAgICA6IGdldERhdGFBdHRyaWJ1dGVQcm9wcyhyZWZlcmVuY2UsIHByb3BzLnBsdWdpbnMpKSxcbiAgfTtcblxuICBvdXQuYXJpYSA9IHtcbiAgICAuLi5kZWZhdWx0UHJvcHMuYXJpYSxcbiAgICAuLi5vdXQuYXJpYSxcbiAgfTtcblxuICBvdXQuYXJpYSA9IHtcbiAgICBleHBhbmRlZDpcbiAgICAgIG91dC5hcmlhLmV4cGFuZGVkID09PSAnYXV0bycgPyBwcm9wcy5pbnRlcmFjdGl2ZSA6IG91dC5hcmlhLmV4cGFuZGVkLFxuICAgIGNvbnRlbnQ6XG4gICAgICBvdXQuYXJpYS5jb250ZW50ID09PSAnYXV0bydcbiAgICAgICAgPyBwcm9wcy5pbnRlcmFjdGl2ZVxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogJ2Rlc2NyaWJlZGJ5J1xuICAgICAgICA6IG91dC5hcmlhLmNvbnRlbnQsXG4gIH07XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMoXG4gIHBhcnRpYWxQcm9wczogUGFydGlhbDxQcm9wcz4gPSB7fSxcbiAgcGx1Z2luczogUGx1Z2luW10gPSBbXVxuKTogdm9pZCB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwYXJ0aWFsUHJvcHMpIGFzIEFycmF5PGtleW9mIFByb3BzPjtcbiAga2V5cy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgY29uc3Qgbm9uUGx1Z2luUHJvcHMgPSByZW1vdmVQcm9wZXJ0aWVzKFxuICAgICAgZGVmYXVsdFByb3BzLFxuICAgICAgT2JqZWN0LmtleXMocGx1Z2luUHJvcHMpXG4gICAgKTtcblxuICAgIGxldCBkaWRQYXNzVW5rbm93blByb3AgPSAhaGFzT3duUHJvcGVydHkobm9uUGx1Z2luUHJvcHMsIHByb3ApO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHByb3AgZXhpc3RzIGluIGBwbHVnaW5zYFxuICAgIGlmIChkaWRQYXNzVW5rbm93blByb3ApIHtcbiAgICAgIGRpZFBhc3NVbmtub3duUHJvcCA9XG4gICAgICAgIHBsdWdpbnMuZmlsdGVyKChwbHVnaW4pID0+IHBsdWdpbi5uYW1lID09PSBwcm9wKS5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgd2FybldoZW4oXG4gICAgICBkaWRQYXNzVW5rbm93blByb3AsXG4gICAgICBbXG4gICAgICAgIGBcXGAke3Byb3B9XFxgYCxcbiAgICAgICAgXCJpcyBub3QgYSB2YWxpZCBwcm9wLiBZb3UgbWF5IGhhdmUgc3BlbGxlZCBpdCBpbmNvcnJlY3RseSwgb3IgaWYgaXQnc1wiLFxuICAgICAgICAnYSBwbHVnaW4sIGZvcmdvdCB0byBwYXNzIGl0IGluIGFuIGFycmF5IGFzIHByb3BzLnBsdWdpbnMuJyxcbiAgICAgICAgJ1xcblxcbicsXG4gICAgICAgICdBbGwgcHJvcHM6IGh0dHBzOi8vYXRvbWlrcy5naXRodWIuaW8vdGlwcHlqcy92Ni9hbGwtcHJvcHMvXFxuJyxcbiAgICAgICAgJ1BsdWdpbnM6IGh0dHBzOi8vYXRvbWlrcy5naXRodWIuaW8vdGlwcHlqcy92Ni9wbHVnaW5zLycsXG4gICAgICBdLmpvaW4oJyAnKVxuICAgICk7XG4gIH0pO1xufVxuIiwgImltcG9ydCB7XG4gIEFSUk9XX0NMQVNTLFxuICBCQUNLRFJPUF9DTEFTUyxcbiAgQk9YX0NMQVNTLFxuICBDT05URU5UX0NMQVNTLFxuICBTVkdfQVJST1dfQ0xBU1MsXG59IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7ZGl2LCBpc0VsZW1lbnR9IGZyb20gJy4vZG9tLXV0aWxzJztcbmltcG9ydCB7SW5zdGFuY2UsIFBvcHBlckVsZW1lbnQsIFByb3BzfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7UG9wcGVyQ2hpbGRyZW59IGZyb20gJy4vdHlwZXMtaW50ZXJuYWwnO1xuaW1wb3J0IHthcnJheUZyb219IGZyb20gJy4vdXRpbHMnO1xuXG4vLyBGaXJlZm94IGV4dGVuc2lvbnMgZG9uJ3QgYWxsb3cgLmlubmVySFRNTCA9IFwiLi4uXCIgcHJvcGVydHkuIFRoaXMgdHJpY2tzIGl0LlxuY29uc3QgaW5uZXJIVE1MID0gKCk6ICdpbm5lckhUTUwnID0+ICdpbm5lckhUTUwnO1xuXG5mdW5jdGlvbiBkYW5nZXJvdXNseVNldElubmVySFRNTChlbGVtZW50OiBFbGVtZW50LCBodG1sOiBzdHJpbmcpOiB2b2lkIHtcbiAgZWxlbWVudFtpbm5lckhUTUwoKV0gPSBodG1sO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcnJvd0VsZW1lbnQodmFsdWU6IFByb3BzWydhcnJvdyddKTogSFRNTERpdkVsZW1lbnQge1xuICBjb25zdCBhcnJvdyA9IGRpdigpO1xuXG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgIGFycm93LmNsYXNzTmFtZSA9IEFSUk9XX0NMQVNTO1xuICB9IGVsc2Uge1xuICAgIGFycm93LmNsYXNzTmFtZSA9IFNWR19BUlJPV19DTEFTUztcblxuICAgIGlmIChpc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICBhcnJvdy5hcHBlbmRDaGlsZCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKGFycm93LCB2YWx1ZSBhcyBzdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcnJvdztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldENvbnRlbnQoY29udGVudDogSFRNTERpdkVsZW1lbnQsIHByb3BzOiBQcm9wcyk6IHZvaWQge1xuICBpZiAoaXNFbGVtZW50KHByb3BzLmNvbnRlbnQpKSB7XG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwoY29udGVudCwgJycpO1xuICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQocHJvcHMuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzLmNvbnRlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvcHMuYWxsb3dIVE1MKSB7XG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTChjb250ZW50LCBwcm9wcy5jb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudC50ZXh0Q29udGVudCA9IHByb3BzLmNvbnRlbnQ7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGlsZHJlbihwb3BwZXI6IFBvcHBlckVsZW1lbnQpOiBQb3BwZXJDaGlsZHJlbiB7XG4gIGNvbnN0IGJveCA9IHBvcHBlci5maXJzdEVsZW1lbnRDaGlsZCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgY29uc3QgYm94Q2hpbGRyZW4gPSBhcnJheUZyb20oYm94LmNoaWxkcmVuKTtcblxuICByZXR1cm4ge1xuICAgIGJveCxcbiAgICBjb250ZW50OiBib3hDaGlsZHJlbi5maW5kKChub2RlKSA9PiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhDT05URU5UX0NMQVNTKSksXG4gICAgYXJyb3c6IGJveENoaWxkcmVuLmZpbmQoXG4gICAgICAobm9kZSkgPT5cbiAgICAgICAgbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoQVJST1dfQ0xBU1MpIHx8XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKFNWR19BUlJPV19DTEFTUylcbiAgICApLFxuICAgIGJhY2tkcm9wOiBib3hDaGlsZHJlbi5maW5kKChub2RlKSA9PlxuICAgICAgbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoQkFDS0RST1BfQ0xBU1MpXG4gICAgKSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihcbiAgaW5zdGFuY2U6IEluc3RhbmNlXG4pOiB7XG4gIHBvcHBlcjogUG9wcGVyRWxlbWVudDtcbiAgb25VcGRhdGU/OiAocHJldlByb3BzOiBQcm9wcywgbmV4dFByb3BzOiBQcm9wcykgPT4gdm9pZDtcbn0ge1xuICBjb25zdCBwb3BwZXIgPSBkaXYoKTtcblxuICBjb25zdCBib3ggPSBkaXYoKTtcbiAgYm94LmNsYXNzTmFtZSA9IEJPWF9DTEFTUztcbiAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsICdoaWRkZW4nKTtcbiAgYm94LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcblxuICBjb25zdCBjb250ZW50ID0gZGl2KCk7XG4gIGNvbnRlbnQuY2xhc3NOYW1lID0gQ09OVEVOVF9DTEFTUztcbiAgY29udGVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhdGUnLCAnaGlkZGVuJyk7XG5cbiAgc2V0Q29udGVudChjb250ZW50LCBpbnN0YW5jZS5wcm9wcyk7XG5cbiAgcG9wcGVyLmFwcGVuZENoaWxkKGJveCk7XG4gIGJveC5hcHBlbmRDaGlsZChjb250ZW50KTtcblxuICBvblVwZGF0ZShpbnN0YW5jZS5wcm9wcywgaW5zdGFuY2UucHJvcHMpO1xuXG4gIGZ1bmN0aW9uIG9uVXBkYXRlKHByZXZQcm9wczogUHJvcHMsIG5leHRQcm9wczogUHJvcHMpOiB2b2lkIHtcbiAgICBjb25zdCB7Ym94LCBjb250ZW50LCBhcnJvd30gPSBnZXRDaGlsZHJlbihwb3BwZXIpO1xuXG4gICAgaWYgKG5leHRQcm9wcy50aGVtZSkge1xuICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS10aGVtZScsIG5leHRQcm9wcy50aGVtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJveC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtdGhlbWUnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5leHRQcm9wcy5hbmltYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBib3guc2V0QXR0cmlidXRlKCdkYXRhLWFuaW1hdGlvbicsIG5leHRQcm9wcy5hbmltYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3gucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWFuaW1hdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChuZXh0UHJvcHMuaW5lcnRpYSkge1xuICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1pbmVydGlhJywgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3gucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWluZXJ0aWEnKTtcbiAgICB9XG5cbiAgICBib3guc3R5bGUubWF4V2lkdGggPVxuICAgICAgdHlwZW9mIG5leHRQcm9wcy5tYXhXaWR0aCA9PT0gJ251bWJlcidcbiAgICAgICAgPyBgJHtuZXh0UHJvcHMubWF4V2lkdGh9cHhgXG4gICAgICAgIDogbmV4dFByb3BzLm1heFdpZHRoO1xuXG4gICAgaWYgKG5leHRQcm9wcy5yb2xlKSB7XG4gICAgICBib3guc2V0QXR0cmlidXRlKCdyb2xlJywgbmV4dFByb3BzLnJvbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3gucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgcHJldlByb3BzLmNvbnRlbnQgIT09IG5leHRQcm9wcy5jb250ZW50IHx8XG4gICAgICBwcmV2UHJvcHMuYWxsb3dIVE1MICE9PSBuZXh0UHJvcHMuYWxsb3dIVE1MXG4gICAgKSB7XG4gICAgICBzZXRDb250ZW50KGNvbnRlbnQsIGluc3RhbmNlLnByb3BzKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dFByb3BzLmFycm93KSB7XG4gICAgICBpZiAoIWFycm93KSB7XG4gICAgICAgIGJveC5hcHBlbmRDaGlsZChjcmVhdGVBcnJvd0VsZW1lbnQobmV4dFByb3BzLmFycm93KSk7XG4gICAgICB9IGVsc2UgaWYgKHByZXZQcm9wcy5hcnJvdyAhPT0gbmV4dFByb3BzLmFycm93KSB7XG4gICAgICAgIGJveC5yZW1vdmVDaGlsZChhcnJvdyk7XG4gICAgICAgIGJveC5hcHBlbmRDaGlsZChjcmVhdGVBcnJvd0VsZW1lbnQobmV4dFByb3BzLmFycm93KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcnJvdykge1xuICAgICAgYm94LnJlbW92ZUNoaWxkKGFycm93ISk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwb3BwZXIsXG4gICAgb25VcGRhdGUsXG4gIH07XG59XG5cbi8vIFJ1bnRpbWUgY2hlY2sgdG8gaWRlbnRpZnkgaWYgdGhlIHJlbmRlciBmdW5jdGlvbiBpcyB0aGUgZGVmYXVsdCBvbmU7IHRoaXNcbi8vIHdheSB3ZSBjYW4gYXBwbHkgZGVmYXVsdCBDU1MgdHJhbnNpdGlvbnMgbG9naWMgYW5kIGl0IGNhbiBiZSB0cmVlLXNoYWtlbiBhd2F5XG5yZW5kZXIuJCR0aXBweSA9IHRydWU7XG4iLCAiaW1wb3J0IHtjcmVhdGVQb3BwZXIsIFN0cmljdE1vZGlmaWVycywgTW9kaWZpZXJ9IGZyb20gJ0Bwb3BwZXJqcy9jb3JlJztcbmltcG9ydCB7Y3VycmVudElucHV0fSBmcm9tICcuL2JpbmRHbG9iYWxFdmVudExpc3RlbmVycyc7XG5pbXBvcnQge2lzSUUxMX0gZnJvbSAnLi9icm93c2VyJztcbmltcG9ydCB7VElQUFlfREVGQVVMVF9BUFBFTkRfVE8sIFRPVUNIX09QVElPTlN9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7XG4gIGFjdHVhbENvbnRhaW5zLFxuICBkaXYsXG4gIGdldE93bmVyRG9jdW1lbnQsXG4gIGlzQ3Vyc29yT3V0c2lkZUludGVyYWN0aXZlQm9yZGVyLFxuICBpc01vdXNlRXZlbnQsXG4gIHNldFRyYW5zaXRpb25EdXJhdGlvbixcbiAgc2V0VmlzaWJpbGl0eVN0YXRlLFxuICB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIsXG59IGZyb20gJy4vZG9tLXV0aWxzJztcbmltcG9ydCB7ZGVmYXVsdFByb3BzLCBldmFsdWF0ZVByb3BzLCBnZXRFeHRlbmRlZFBhc3NlZFByb3BzfSBmcm9tICcuL3Byb3BzJztcbmltcG9ydCB7Z2V0Q2hpbGRyZW59IGZyb20gJy4vdGVtcGxhdGUnO1xuaW1wb3J0IHtcbiAgQ29udGVudCxcbiAgSW5zdGFuY2UsXG4gIExpZmVjeWNsZUhvb2tzLFxuICBQb3BwZXJFbGVtZW50LFxuICBQcm9wcyxcbiAgUmVmZXJlbmNlRWxlbWVudCxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge0xpc3RlbmVyT2JqZWN0LCBQb3BwZXJUcmVlRGF0YSwgUG9wcGVyQ2hpbGRyZW59IGZyb20gJy4vdHlwZXMtaW50ZXJuYWwnO1xuaW1wb3J0IHtcbiAgYXJyYXlGcm9tLFxuICBkZWJvdW5jZSxcbiAgZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4sXG4gIGludm9rZVdpdGhBcmdzT3JSZXR1cm4sXG4gIG5vcm1hbGl6ZVRvQXJyYXksXG4gIHB1c2hJZlVuaXF1ZSxcbiAgc3BsaXRCeVNwYWNlcyxcbiAgdW5pcXVlLFxuICByZW1vdmVVbmRlZmluZWRQcm9wcyxcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge2NyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nLCBlcnJvcldoZW4sIHdhcm5XaGVufSBmcm9tICcuL3ZhbGlkYXRpb24nO1xuXG5sZXQgaWRDb3VudGVyID0gMTtcbmxldCBtb3VzZU1vdmVMaXN0ZW5lcnM6ICgoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHZvaWQpW10gPSBbXTtcblxuLy8gVXNlZCBieSBgaGlkZUFsbCgpYFxuZXhwb3J0IGxldCBtb3VudGVkSW5zdGFuY2VzOiBJbnN0YW5jZVtdID0gW107XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVRpcHB5KFxuICByZWZlcmVuY2U6IFJlZmVyZW5jZUVsZW1lbnQsXG4gIHBhc3NlZFByb3BzOiBQYXJ0aWFsPFByb3BzPlxuKTogSW5zdGFuY2Uge1xuICBjb25zdCBwcm9wcyA9IGV2YWx1YXRlUHJvcHMocmVmZXJlbmNlLCB7XG4gICAgLi4uZGVmYXVsdFByb3BzLFxuICAgIC4uLmdldEV4dGVuZGVkUGFzc2VkUHJvcHMocmVtb3ZlVW5kZWZpbmVkUHJvcHMocGFzc2VkUHJvcHMpKSxcbiAgfSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIPCflJIgUHJpdmF0ZSBtZW1iZXJzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBsZXQgc2hvd1RpbWVvdXQ6IGFueTtcbiAgbGV0IGhpZGVUaW1lb3V0OiBhbnk7XG4gIGxldCBzY2hlZHVsZUhpZGVBbmltYXRpb25GcmFtZTogbnVtYmVyO1xuICBsZXQgaXNWaXNpYmxlRnJvbUNsaWNrID0gZmFsc2U7XG4gIGxldCBkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93biA9IGZhbHNlO1xuICBsZXQgZGlkVG91Y2hNb3ZlID0gZmFsc2U7XG4gIGxldCBpZ25vcmVPbkZpcnN0VXBkYXRlID0gZmFsc2U7XG4gIGxldCBsYXN0VHJpZ2dlckV2ZW50OiBFdmVudCB8IHVuZGVmaW5lZDtcbiAgbGV0IGN1cnJlbnRUcmFuc2l0aW9uRW5kTGlzdGVuZXI6IChldmVudDogVHJhbnNpdGlvbkV2ZW50KSA9PiB2b2lkO1xuICBsZXQgb25GaXJzdFVwZGF0ZTogKCkgPT4gdm9pZDtcbiAgbGV0IGxpc3RlbmVyczogTGlzdGVuZXJPYmplY3RbXSA9IFtdO1xuICBsZXQgZGVib3VuY2VkT25Nb3VzZU1vdmUgPSBkZWJvdW5jZShvbk1vdXNlTW92ZSwgcHJvcHMuaW50ZXJhY3RpdmVEZWJvdW5jZSk7XG4gIGxldCBjdXJyZW50VGFyZ2V0OiBFbGVtZW50O1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyDwn5SRIFB1YmxpYyBtZW1iZXJzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBjb25zdCBpZCA9IGlkQ291bnRlcisrO1xuICBjb25zdCBwb3BwZXJJbnN0YW5jZSA9IG51bGw7XG4gIGNvbnN0IHBsdWdpbnMgPSB1bmlxdWUocHJvcHMucGx1Z2lucyk7XG5cbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgLy8gSXMgdGhlIGluc3RhbmNlIGN1cnJlbnRseSBlbmFibGVkP1xuICAgIGlzRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyBJcyB0aGUgdGlwcHkgY3VycmVudGx5IHNob3dpbmcgYW5kIG5vdCB0cmFuc2l0aW9uaW5nIG91dD9cbiAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgIC8vIEhhcyB0aGUgaW5zdGFuY2UgYmVlbiBkZXN0cm95ZWQ/XG4gICAgaXNEZXN0cm95ZWQ6IGZhbHNlLFxuICAgIC8vIElzIHRoZSB0aXBweSBjdXJyZW50bHkgbW91bnRlZCB0byB0aGUgRE9NP1xuICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgLy8gSGFzIHRoZSB0aXBweSBmaW5pc2hlZCB0cmFuc2l0aW9uaW5nIGluP1xuICAgIGlzU2hvd246IGZhbHNlLFxuICB9O1xuXG4gIGNvbnN0IGluc3RhbmNlOiBJbnN0YW5jZSA9IHtcbiAgICAvLyBwcm9wZXJ0aWVzXG4gICAgaWQsXG4gICAgcmVmZXJlbmNlLFxuICAgIHBvcHBlcjogZGl2KCksXG4gICAgcG9wcGVySW5zdGFuY2UsXG4gICAgcHJvcHMsXG4gICAgc3RhdGUsXG4gICAgcGx1Z2lucyxcbiAgICAvLyBtZXRob2RzXG4gICAgY2xlYXJEZWxheVRpbWVvdXRzLFxuICAgIHNldFByb3BzLFxuICAgIHNldENvbnRlbnQsXG4gICAgc2hvdyxcbiAgICBoaWRlLFxuICAgIGhpZGVXaXRoSW50ZXJhY3Rpdml0eSxcbiAgICBlbmFibGUsXG4gICAgZGlzYWJsZSxcbiAgICB1bm1vdW50LFxuICAgIGRlc3Ryb3ksXG4gIH07XG5cbiAgLy8gVE9ETzogSW52ZXN0aWdhdGUgd2h5IHRoaXMgZWFybHkgcmV0dXJuIGNhdXNlcyBhIFREWiBlcnJvciBpbiB0aGUgdGVzdHMg4oCUXG4gIC8vIGl0IGRvZXNuJ3Qgc2VlbSB0byBoYXBwZW4gaW4gdGhlIGJyb3dzZXJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghcHJvcHMucmVuZGVyKSB7XG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIGVycm9yV2hlbih0cnVlLCAncmVuZGVyKCkgZnVuY3Rpb24gaGFzIG5vdCBiZWVuIHN1cHBsaWVkLicpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBJbml0aWFsIG11dGF0aW9uc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3Qge3BvcHBlciwgb25VcGRhdGV9ID0gcHJvcHMucmVuZGVyKGluc3RhbmNlKTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCdkYXRhLV9fTkFNRVNQQUNFX1BSRUZJWF9fLXJvb3QnLCAnJyk7XG4gIHBvcHBlci5pZCA9IGBfX05BTUVTUEFDRV9QUkVGSVhfXy0ke2luc3RhbmNlLmlkfWA7XG5cbiAgaW5zdGFuY2UucG9wcGVyID0gcG9wcGVyO1xuICByZWZlcmVuY2UuX3RpcHB5ID0gaW5zdGFuY2U7XG4gIHBvcHBlci5fdGlwcHkgPSBpbnN0YW5jZTtcblxuICBjb25zdCBwbHVnaW5zSG9va3MgPSBwbHVnaW5zLm1hcCgocGx1Z2luKSA9PiBwbHVnaW4uZm4oaW5zdGFuY2UpKTtcbiAgY29uc3QgaGFzQXJpYUV4cGFuZGVkID0gcmVmZXJlbmNlLmhhc0F0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuXG4gIGFkZExpc3RlbmVycygpO1xuICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcbiAgaGFuZGxlU3R5bGVzKCk7XG5cbiAgaW52b2tlSG9vaygnb25DcmVhdGUnLCBbaW5zdGFuY2VdKTtcblxuICBpZiAocHJvcHMuc2hvd09uQ3JlYXRlKSB7XG4gICAgc2NoZWR1bGVTaG93KCk7XG4gIH1cblxuICAvLyBQcmV2ZW50IGEgdGlwcHkgd2l0aCBhIGRlbGF5IGZyb20gaGlkaW5nIGlmIHRoZSBjdXJzb3IgbGVmdCB0aGVuIHJldHVybmVkXG4gIC8vIGJlZm9yZSBpdCBzdGFydGVkIGhpZGluZ1xuICBwb3BwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsICgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHBvcHBlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgKCkgPT4ge1xuICAgIGlmIChcbiAgICAgIGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmXG4gICAgICBpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ21vdXNlZW50ZXInKSA+PSAwXG4gICAgKSB7XG4gICAgICBnZXREb2N1bWVudCgpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGRlYm91bmNlZE9uTW91c2VNb3ZlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8g8J+UkiBQcml2YXRlIG1ldGhvZHNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRUb3VjaFNldHRpbmdzKCk6IFtzdHJpbmcgfCBib29sZWFuLCBudW1iZXJdIHtcbiAgICBjb25zdCB7dG91Y2h9ID0gaW5zdGFuY2UucHJvcHM7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodG91Y2gpID8gdG91Y2ggOiBbdG91Y2gsIDBdO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXNDdXN0b21Ub3VjaEJlaGF2aW9yKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBnZXROb3JtYWxpemVkVG91Y2hTZXR0aW5ncygpWzBdID09PSAnaG9sZCc7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJc0RlZmF1bHRSZW5kZXJGbigpOiBib29sZWFuIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuICEhaW5zdGFuY2UucHJvcHMucmVuZGVyPy4kJHRpcHB5O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudFRhcmdldCgpOiBFbGVtZW50IHtcbiAgICByZXR1cm4gY3VycmVudFRhcmdldCB8fCByZWZlcmVuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREb2N1bWVudCgpOiBEb2N1bWVudCB7XG4gICAgY29uc3QgcGFyZW50ID0gZ2V0Q3VycmVudFRhcmdldCgpLnBhcmVudE5vZGUgYXMgRWxlbWVudDtcbiAgICByZXR1cm4gcGFyZW50ID8gZ2V0T3duZXJEb2N1bWVudChwYXJlbnQpIDogZG9jdW1lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpOiBQb3BwZXJDaGlsZHJlbiB7XG4gICAgcmV0dXJuIGdldENoaWxkcmVuKHBvcHBlcik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREZWxheShpc1Nob3c6IGJvb2xlYW4pOiBudW1iZXIge1xuICAgIC8vIEZvciB0b3VjaCBvciBrZXlib2FyZCBpbnB1dCwgZm9yY2UgYDBgIGRlbGF5IGZvciBVWCByZWFzb25zXG4gICAgLy8gQWxzbyBpZiB0aGUgaW5zdGFuY2UgaXMgbW91bnRlZCBidXQgbm90IHZpc2libGUgKHRyYW5zaXRpb25pbmcgb3V0KSxcbiAgICAvLyBpZ25vcmUgZGVsYXlcbiAgICBpZiAoXG4gICAgICAoaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkICYmICFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHx8XG4gICAgICBjdXJyZW50SW5wdXQuaXNUb3VjaCB8fFxuICAgICAgKGxhc3RUcmlnZ2VyRXZlbnQgJiYgbGFzdFRyaWdnZXJFdmVudC50eXBlID09PSAnZm9jdXMnKVxuICAgICkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFZhbHVlQXRJbmRleE9yUmV0dXJuKFxuICAgICAgaW5zdGFuY2UucHJvcHMuZGVsYXksXG4gICAgICBpc1Nob3cgPyAwIDogMSxcbiAgICAgIGRlZmF1bHRQcm9wcy5kZWxheVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdHlsZXMoZnJvbUhpZGUgPSBmYWxzZSk6IHZvaWQge1xuICAgIHBvcHBlci5zdHlsZS5wb2ludGVyRXZlbnRzID1cbiAgICAgIGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmICFmcm9tSGlkZSA/ICcnIDogJ25vbmUnO1xuICAgIHBvcHBlci5zdHlsZS56SW5kZXggPSBgJHtpbnN0YW5jZS5wcm9wcy56SW5kZXh9YDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUhvb2soXG4gICAgaG9vazoga2V5b2YgTGlmZWN5Y2xlSG9va3MsXG4gICAgYXJnczogW0luc3RhbmNlLCBhbnk/XSxcbiAgICBzaG91bGRJbnZva2VQcm9wc0hvb2sgPSB0cnVlXG4gICk6IHZvaWQge1xuICAgIHBsdWdpbnNIb29rcy5mb3JFYWNoKChwbHVnaW5Ib29rcykgPT4ge1xuICAgICAgaWYgKHBsdWdpbkhvb2tzW2hvb2tdKSB7XG4gICAgICAgIHBsdWdpbkhvb2tzW2hvb2tdISguLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChzaG91bGRJbnZva2VQcm9wc0hvb2spIHtcbiAgICAgIGluc3RhbmNlLnByb3BzW2hvb2tdKC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFyaWFDb250ZW50QXR0cmlidXRlKCk6IHZvaWQge1xuICAgIGNvbnN0IHthcmlhfSA9IGluc3RhbmNlLnByb3BzO1xuXG4gICAgaWYgKCFhcmlhLmNvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhdHRyID0gYGFyaWEtJHthcmlhLmNvbnRlbnR9YDtcbiAgICBjb25zdCBpZCA9IHBvcHBlci5pZDtcbiAgICBjb25zdCBub2RlcyA9IG5vcm1hbGl6ZVRvQXJyYXkoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpO1xuXG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cik7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgY3VycmVudFZhbHVlID8gYCR7Y3VycmVudFZhbHVlfSAke2lkfWAgOiBpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSBjdXJyZW50VmFsdWUgJiYgY3VycmVudFZhbHVlLnJlcGxhY2UoaWQsICcnKS50cmltKCk7XG5cbiAgICAgICAgaWYgKG5leHRWYWx1ZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIG5leHRWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpOiB2b2lkIHtcbiAgICBpZiAoaGFzQXJpYUV4cGFuZGVkIHx8ICFpbnN0YW5jZS5wcm9wcy5hcmlhLmV4cGFuZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZXMgPSBub3JtYWxpemVUb0FycmF5KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKTtcblxuICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAnYXJpYS1leHBhbmRlZCcsXG4gICAgICAgICAgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmIG5vZGUgPT09IGdldEN1cnJlbnRUYXJnZXQoKVxuICAgICAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgICAgIDogJ2ZhbHNlJ1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIGdldERvY3VtZW50KCkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgIG1vdXNlTW92ZUxpc3RlbmVycyA9IG1vdXNlTW92ZUxpc3RlbmVycy5maWx0ZXIoXG4gICAgICAobGlzdGVuZXIpID0+IGxpc3RlbmVyICE9PSBkZWJvdW5jZWRPbk1vdXNlTW92ZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkRvY3VtZW50UHJlc3MoZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KTogdm9pZCB7XG4gICAgLy8gTW92ZWQgZmluZ2VyIHRvIHNjcm9sbCBpbnN0ZWFkIG9mIGFuIGludGVudGlvbmFsIHRhcCBvdXRzaWRlXG4gICAgaWYgKGN1cnJlbnRJbnB1dC5pc1RvdWNoKSB7XG4gICAgICBpZiAoZGlkVG91Y2hNb3ZlIHx8IGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhY3R1YWxUYXJnZXQgPVxuICAgICAgKGV2ZW50LmNvbXBvc2VkUGF0aCAmJiBldmVudC5jb21wb3NlZFBhdGgoKVswXSkgfHwgZXZlbnQudGFyZ2V0O1xuXG4gICAgLy8gQ2xpY2tlZCBvbiBpbnRlcmFjdGl2ZSBwb3BwZXJcbiAgICBpZiAoXG4gICAgICBpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJlxuICAgICAgYWN0dWFsQ29udGFpbnMocG9wcGVyLCBhY3R1YWxUYXJnZXQgYXMgRWxlbWVudClcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDbGlja2VkIG9uIHRoZSBldmVudCBsaXN0ZW5lcnMgdGFyZ2V0XG4gICAgaWYgKFxuICAgICAgbm9ybWFsaXplVG9BcnJheShpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSkuc29tZSgoZWwpID0+XG4gICAgICAgIGFjdHVhbENvbnRhaW5zKGVsLCBhY3R1YWxUYXJnZXQgYXMgRWxlbWVudClcbiAgICAgIClcbiAgICApIHtcbiAgICAgIGlmIChjdXJyZW50SW5wdXQuaXNUb3VjaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmXG4gICAgICAgIGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignY2xpY2snKSA+PSAwXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbnZva2VIb29rKCdvbkNsaWNrT3V0c2lkZScsIFtpbnN0YW5jZSwgZXZlbnRdKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaGlkZU9uQ2xpY2sgPT09IHRydWUpIHtcbiAgICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuXG4gICAgICAvLyBgbW91c2Vkb3duYCBldmVudCBpcyBmaXJlZCByaWdodCBiZWZvcmUgYGZvY3VzYCBpZiBwcmVzc2luZyB0aGVcbiAgICAgIC8vIGN1cnJlbnRUYXJnZXQuIFRoaXMgbGV0cyBhIHRpcHB5IHdpdGggYGZvY3VzYCB0cmlnZ2VyIGtub3cgdGhhdCBpdFxuICAgICAgLy8gc2hvdWxkIG5vdCBzaG93XG4gICAgICBkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93biA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZGlkSGlkZUR1ZVRvRG9jdW1lbnRNb3VzZURvd24gPSBmYWxzZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUaGUgbGlzdGVuZXIgZ2V0cyBhZGRlZCBpbiBgc2NoZWR1bGVTaG93KClgLCBidXQgdGhpcyBtYXkgYmUgaGlkaW5nIGl0XG4gICAgICAvLyBiZWZvcmUgaXQgc2hvd3MsIGFuZCBoaWRlKCkncyBlYXJseSBiYWlsLW91dCBiZWhhdmlvciBjYW4gcHJldmVudCBpdFxuICAgICAgLy8gZnJvbSBiZWluZyBjbGVhbmVkIHVwXG4gICAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICByZW1vdmVEb2N1bWVudFByZXNzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Ub3VjaE1vdmUoKTogdm9pZCB7XG4gICAgZGlkVG91Y2hNb3ZlID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hTdGFydCgpOiB2b2lkIHtcbiAgICBkaWRUb3VjaE1vdmUgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZERvY3VtZW50UHJlc3MoKTogdm9pZCB7XG4gICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQoKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Eb2N1bWVudFByZXNzLCB0cnVlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvbkRvY3VtZW50UHJlc3MsIFRPVUNIX09QVElPTlMpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCBUT1VDSF9PUFRJT05TKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIFRPVUNIX09QVElPTlMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRG9jdW1lbnRQcmVzcygpOiB2b2lkIHtcbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudCgpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbkRvY3VtZW50UHJlc3MsIHRydWUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uRG9jdW1lbnRQcmVzcywgVE9VQ0hfT1BUSU9OUyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIFRPVUNIX09QVElPTlMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgVE9VQ0hfT1BUSU9OUyk7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zaXRpb25lZE91dChkdXJhdGlvbjogbnVtYmVyLCBjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIG9uVHJhbnNpdGlvbkVuZChkdXJhdGlvbiwgKCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAhaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmXG4gICAgICAgIHBvcHBlci5wYXJlbnROb2RlICYmXG4gICAgICAgIHBvcHBlci5wYXJlbnROb2RlLmNvbnRhaW5zKHBvcHBlcilcbiAgICAgICkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc2l0aW9uZWRJbihkdXJhdGlvbjogbnVtYmVyLCBjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIG9uVHJhbnNpdGlvbkVuZChkdXJhdGlvbiwgY2FsbGJhY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kKGR1cmF0aW9uOiBudW1iZXIsIGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgY29uc3QgYm94ID0gZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4oKS5ib3g7XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW5lcihldmVudDogVHJhbnNpdGlvbkV2ZW50KTogdm9pZCB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBib3gpIHtcbiAgICAgICAgdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyKGJveCwgJ3JlbW92ZScsIGxpc3RlbmVyKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlIGNhbGxiYWNrIHN5bmNocm9ub3VzIGlmIGR1cmF0aW9uIGlzIDBcbiAgICAvLyBgdHJhbnNpdGlvbmVuZGAgd29uJ3QgZmlyZSBvdGhlcndpc2VcbiAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcihib3gsICdyZW1vdmUnLCBjdXJyZW50VHJhbnNpdGlvbkVuZExpc3RlbmVyKTtcbiAgICB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIoYm94LCAnYWRkJywgbGlzdGVuZXIpO1xuXG4gICAgY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gb24oXG4gICAgZXZlbnRUeXBlOiBzdHJpbmcsXG4gICAgaGFuZGxlcjogRXZlbnRMaXN0ZW5lcixcbiAgICBvcHRpb25zOiBib29sZWFuIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSBmYWxzZVxuICApOiB2b2lkIHtcbiAgICBjb25zdCBub2RlcyA9IG5vcm1hbGl6ZVRvQXJyYXkoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpO1xuICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgbGlzdGVuZXJzLnB1c2goe25vZGUsIGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9uc30pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIGlmIChnZXRJc0N1c3RvbVRvdWNoQmVoYXZpb3IoKSkge1xuICAgICAgb24oJ3RvdWNoc3RhcnQnLCBvblRyaWdnZXIsIHtwYXNzaXZlOiB0cnVlfSk7XG4gICAgICBvbigndG91Y2hlbmQnLCBvbk1vdXNlTGVhdmUgYXMgRXZlbnRMaXN0ZW5lciwge3Bhc3NpdmU6IHRydWV9KTtcbiAgICB9XG5cbiAgICBzcGxpdEJ5U3BhY2VzKGluc3RhbmNlLnByb3BzLnRyaWdnZXIpLmZvckVhY2goKGV2ZW50VHlwZSkgPT4ge1xuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ21hbnVhbCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvbihldmVudFR5cGUsIG9uVHJpZ2dlcik7XG5cbiAgICAgIHN3aXRjaCAoZXZlbnRUeXBlKSB7XG4gICAgICAgIGNhc2UgJ21vdXNlZW50ZXInOlxuICAgICAgICAgIG9uKCdtb3VzZWxlYXZlJywgb25Nb3VzZUxlYXZlIGFzIEV2ZW50TGlzdGVuZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgb24oaXNJRTExID8gJ2ZvY3Vzb3V0JyA6ICdibHVyJywgb25CbHVyT3JGb2N1c091dCBhcyBFdmVudExpc3RlbmVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZm9jdXNpbic6XG4gICAgICAgICAgb24oJ2ZvY3Vzb3V0Jywgb25CbHVyT3JGb2N1c091dCBhcyBFdmVudExpc3RlbmVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpOiB2b2lkIHtcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaCgoe25vZGUsIGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9uc306IExpc3RlbmVyT2JqZWN0KSA9PiB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICBsaXN0ZW5lcnMgPSBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJpZ2dlcihldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICBsZXQgc2hvdWxkU2NoZWR1bGVDbGlja0hpZGUgPSBmYWxzZTtcblxuICAgIGlmIChcbiAgICAgICFpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQgfHxcbiAgICAgIGlzRXZlbnRMaXN0ZW5lclN0b3BwZWQoZXZlbnQpIHx8XG4gICAgICBkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93blxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHdhc0ZvY3VzZWQgPSBsYXN0VHJpZ2dlckV2ZW50Py50eXBlID09PSAnZm9jdXMnO1xuXG4gICAgbGFzdFRyaWdnZXJFdmVudCA9IGV2ZW50O1xuICAgIGN1cnJlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEVsZW1lbnQ7XG5cbiAgICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcblxuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmIGlzTW91c2VFdmVudChldmVudCkpIHtcbiAgICAgIC8vIElmIHNjcm9sbGluZywgYG1vdXNlZW50ZXJgIGV2ZW50cyBjYW4gYmUgZmlyZWQgaWYgdGhlIGN1cnNvciBsYW5kc1xuICAgICAgLy8gb3ZlciBhIG5ldyB0YXJnZXQsIGJ1dCBgbW91c2Vtb3ZlYCBldmVudHMgZG9uJ3QgZ2V0IGZpcmVkLiBUaGlzXG4gICAgICAvLyBjYXVzZXMgaW50ZXJhY3RpdmUgdG9vbHRpcHMgdG8gZ2V0IHN0dWNrIG9wZW4gdW50aWwgdGhlIGN1cnNvciBpc1xuICAgICAgLy8gbW92ZWRcbiAgICAgIG1vdXNlTW92ZUxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoZXZlbnQpKTtcbiAgICB9XG5cbiAgICAvLyBUb2dnbGUgc2hvdy9oaWRlIHdoZW4gY2xpY2tpbmcgY2xpY2stdHJpZ2dlcmVkIHRvb2x0aXBzXG4gICAgaWYgKFxuICAgICAgZXZlbnQudHlwZSA9PT0gJ2NsaWNrJyAmJlxuICAgICAgKGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignbW91c2VlbnRlcicpIDwgMCB8fFxuICAgICAgICBpc1Zpc2libGVGcm9tQ2xpY2spICYmXG4gICAgICBpbnN0YW5jZS5wcm9wcy5oaWRlT25DbGljayAhPT0gZmFsc2UgJiZcbiAgICAgIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZVxuICAgICkge1xuICAgICAgc2hvdWxkU2NoZWR1bGVDbGlja0hpZGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZVNob3coZXZlbnQpO1xuICAgIH1cblxuICAgIGlmIChldmVudC50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICBpc1Zpc2libGVGcm9tQ2xpY2sgPSAhc2hvdWxkU2NoZWR1bGVDbGlja0hpZGU7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFNjaGVkdWxlQ2xpY2tIaWRlICYmICF3YXNGb2N1c2VkKSB7XG4gICAgICBzY2hlZHVsZUhpZGUoZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIE5vZGU7XG4gICAgY29uc3QgaXNDdXJzb3JPdmVyUmVmZXJlbmNlT3JQb3BwZXIgPVxuICAgICAgZ2V0Q3VycmVudFRhcmdldCgpLmNvbnRhaW5zKHRhcmdldCkgfHwgcG9wcGVyLmNvbnRhaW5zKHRhcmdldCk7XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlbW92ZScgJiYgaXNDdXJzb3JPdmVyUmVmZXJlbmNlT3JQb3BwZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwb3BwZXJUcmVlRGF0YSA9IGdldE5lc3RlZFBvcHBlclRyZWUoKVxuICAgICAgLmNvbmNhdChwb3BwZXIpXG4gICAgICAubWFwKChwb3BwZXIpID0+IHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBwb3BwZXIuX3RpcHB5ITtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZT8uc3RhdGU7XG5cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvcHBlclJlY3Q6IHBvcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIHBvcHBlclN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pIGFzIFBvcHBlclRyZWVEYXRhW107XG5cbiAgICBpZiAoaXNDdXJzb3JPdXRzaWRlSW50ZXJhY3RpdmVCb3JkZXIocG9wcGVyVHJlZURhdGEsIGV2ZW50KSkge1xuICAgICAgY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKTtcbiAgICAgIHNjaGVkdWxlSGlkZShldmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3VzZUxlYXZlKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgY29uc3Qgc2hvdWxkQmFpbCA9XG4gICAgICBpc0V2ZW50TGlzdGVuZXJTdG9wcGVkKGV2ZW50KSB8fFxuICAgICAgKGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignY2xpY2snKSA+PSAwICYmIGlzVmlzaWJsZUZyb21DbGljayk7XG5cbiAgICBpZiAoc2hvdWxkQmFpbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgaW5zdGFuY2UuaGlkZVdpdGhJbnRlcmFjdGl2aXR5KGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlZHVsZUhpZGUoZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25CbHVyT3JGb2N1c091dChldmVudDogRm9jdXNFdmVudCk6IHZvaWQge1xuICAgIGlmIChcbiAgICAgIGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignZm9jdXNpbicpIDwgMCAmJlxuICAgICAgZXZlbnQudGFyZ2V0ICE9PSBnZXRDdXJyZW50VGFyZ2V0KClcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBmb2N1cyB3YXMgbW92ZWQgdG8gd2l0aGluIHRoZSBwb3BwZXJcbiAgICBpZiAoXG4gICAgICBpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSAmJlxuICAgICAgZXZlbnQucmVsYXRlZFRhcmdldCAmJlxuICAgICAgcG9wcGVyLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQgYXMgRWxlbWVudClcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlZHVsZUhpZGUoZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFdmVudExpc3RlbmVyU3RvcHBlZChldmVudDogRXZlbnQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gY3VycmVudElucHV0LmlzVG91Y2hcbiAgICAgID8gZ2V0SXNDdXN0b21Ub3VjaEJlaGF2aW9yKCkgIT09IGV2ZW50LnR5cGUuaW5kZXhPZigndG91Y2gnKSA+PSAwXG4gICAgICA6IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUG9wcGVySW5zdGFuY2UoKTogdm9pZCB7XG4gICAgZGVzdHJveVBvcHBlckluc3RhbmNlKCk7XG5cbiAgICBjb25zdCB7XG4gICAgICBwb3BwZXJPcHRpb25zLFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgb2Zmc2V0LFxuICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICAgIG1vdmVUcmFuc2l0aW9uLFxuICAgIH0gPSBpbnN0YW5jZS5wcm9wcztcblxuICAgIGNvbnN0IGFycm93ID0gZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSA/IGdldENoaWxkcmVuKHBvcHBlcikuYXJyb3cgOiBudWxsO1xuXG4gICAgY29uc3QgY29tcHV0ZWRSZWZlcmVuY2UgPSBnZXRSZWZlcmVuY2VDbGllbnRSZWN0XG4gICAgICA/IHtcbiAgICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IGdldFJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgICAgICAgY29udGV4dEVsZW1lbnQ6XG4gICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0LmNvbnRleHRFbGVtZW50IHx8IGdldEN1cnJlbnRUYXJnZXQoKSxcbiAgICAgICAgfVxuICAgICAgOiByZWZlcmVuY2U7XG5cbiAgICBjb25zdCB0aXBweU1vZGlmaWVyOiBNb2RpZmllcjwnJCR0aXBweScsIFJlY29yZDxzdHJpbmcsIHVua25vd24+PiA9IHtcbiAgICAgIG5hbWU6ICckJHRpcHB5JyxcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBwaGFzZTogJ2JlZm9yZVdyaXRlJyxcbiAgICAgIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXSxcbiAgICAgIGZuKHtzdGF0ZX0pIHtcbiAgICAgICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgICAgICBjb25zdCB7Ym94fSA9IGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCk7XG5cbiAgICAgICAgICBbJ3BsYWNlbWVudCcsICdyZWZlcmVuY2UtaGlkZGVuJywgJ2VzY2FwZWQnXS5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICAgICAgICBpZiAoYXR0ciA9PT0gJ3BsYWNlbWVudCcpIHtcbiAgICAgICAgICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1wbGFjZW1lbnQnLCBzdGF0ZS5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyW2BkYXRhLXBvcHBlci0ke2F0dHJ9YF0pIHtcbiAgICAgICAgICAgICAgICBib3guc2V0QXR0cmlidXRlKGBkYXRhLSR7YXR0cn1gLCAnJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYm94LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS0ke2F0dHJ9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0ge307XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHR5cGUgVGlwcHlNb2RpZmllciA9IE1vZGlmaWVyPCckJHRpcHB5JywgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+O1xuICAgIHR5cGUgRXh0ZW5kZWRNb2RpZmllcnMgPSBTdHJpY3RNb2RpZmllcnMgfCBQYXJ0aWFsPFRpcHB5TW9kaWZpZXI+O1xuXG4gICAgY29uc3QgbW9kaWZpZXJzOiBBcnJheTxFeHRlbmRlZE1vZGlmaWVycz4gPSBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgICB0b3A6IDIsXG4gICAgICAgICAgICBib3R0b206IDIsXG4gICAgICAgICAgICBsZWZ0OiA1LFxuICAgICAgICAgICAgcmlnaHQ6IDUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdmbGlwJyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHBhZGRpbmc6IDUsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBhZGFwdGl2ZTogIW1vdmVUcmFuc2l0aW9uLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHRpcHB5TW9kaWZpZXIsXG4gICAgXTtcblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpICYmIGFycm93KSB7XG4gICAgICBtb2RpZmllcnMucHVzaCh7XG4gICAgICAgIG5hbWU6ICdhcnJvdycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBlbGVtZW50OiBhcnJvdyxcbiAgICAgICAgICBwYWRkaW5nOiAzLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW9kaWZpZXJzLnB1c2goLi4uKHBvcHBlck9wdGlvbnM/Lm1vZGlmaWVycyB8fCBbXSkpO1xuXG4gICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UgPSBjcmVhdGVQb3BwZXI8RXh0ZW5kZWRNb2RpZmllcnM+KFxuICAgICAgY29tcHV0ZWRSZWZlcmVuY2UsXG4gICAgICBwb3BwZXIsXG4gICAgICB7XG4gICAgICAgIC4uLnBvcHBlck9wdGlvbnMsXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgb25GaXJzdFVwZGF0ZSxcbiAgICAgICAgbW9kaWZpZXJzLFxuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95UG9wcGVySW5zdGFuY2UoKTogdm9pZCB7XG4gICAgaWYgKGluc3RhbmNlLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW91bnQoKTogdm9pZCB7XG4gICAgY29uc3Qge2FwcGVuZFRvfSA9IGluc3RhbmNlLnByb3BzO1xuXG4gICAgbGV0IHBhcmVudE5vZGU6IGFueTtcblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlJ2xsIGFwcGVuZCB0aGUgcG9wcGVyIHRvIHRoZSB0cmlnZ2VyVGFyZ2V0cydzIHBhcmVudE5vZGUgc29cbiAgICAvLyBpdCdzIGRpcmVjdGx5IGFmdGVyIHRoZSByZWZlcmVuY2UgZWxlbWVudCBzbyB0aGUgZWxlbWVudHMgaW5zaWRlIHRoZVxuICAgIC8vIHRpcHB5IGNhbiBiZSB0YWJiZWQgdG9cbiAgICAvLyBJZiB0aGVyZSBhcmUgY2xpcHBpbmcgaXNzdWVzLCB0aGUgdXNlciBjYW4gc3BlY2lmeSBhIGRpZmZlcmVudCBhcHBlbmRUb1xuICAgIC8vIGFuZCBlbnN1cmUgZm9jdXMgbWFuYWdlbWVudCBpcyBoYW5kbGVkIGNvcnJlY3RseSBtYW51YWxseVxuICAgIGNvbnN0IG5vZGUgPSBnZXRDdXJyZW50VGFyZ2V0KCk7XG5cbiAgICBpZiAoXG4gICAgICAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgYXBwZW5kVG8gPT09IFRJUFBZX0RFRkFVTFRfQVBQRU5EX1RPKSB8fFxuICAgICAgYXBwZW5kVG8gPT09ICdwYXJlbnQnXG4gICAgKSB7XG4gICAgICBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnROb2RlID0gaW52b2tlV2l0aEFyZ3NPclJldHVybihhcHBlbmRUbywgW25vZGVdKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgcG9wcGVyIGVsZW1lbnQgbmVlZHMgdG8gZXhpc3Qgb24gdGhlIERPTSBiZWZvcmUgaXRzIHBvc2l0aW9uIGNhbiBiZVxuICAgIC8vIHVwZGF0ZWQgYXMgUG9wcGVyIG5lZWRzIHRvIHJlYWQgaXRzIGRpbWVuc2lvbnNcbiAgICBpZiAoIXBhcmVudE5vZGUuY29udGFpbnMocG9wcGVyKSkge1xuICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChwb3BwZXIpO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCA9IHRydWU7XG5cbiAgICBjcmVhdGVQb3BwZXJJbnN0YW5jZSgpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgLy8gQWNjZXNzaWJpbGl0eSBjaGVja1xuICAgICAgd2FybldoZW4oXG4gICAgICAgIGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmXG4gICAgICAgICAgYXBwZW5kVG8gPT09IGRlZmF1bHRQcm9wcy5hcHBlbmRUbyAmJlxuICAgICAgICAgIG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nICE9PSBwb3BwZXIsXG4gICAgICAgIFtcbiAgICAgICAgICAnSW50ZXJhY3RpdmUgdGlwcHkgZWxlbWVudCBtYXkgbm90IGJlIGFjY2Vzc2libGUgdmlhIGtleWJvYXJkJyxcbiAgICAgICAgICAnbmF2aWdhdGlvbiBiZWNhdXNlIGl0IGlzIG5vdCBkaXJlY3RseSBhZnRlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQnLFxuICAgICAgICAgICdpbiB0aGUgRE9NIHNvdXJjZSBvcmRlci4nLFxuICAgICAgICAgICdcXG5cXG4nLFxuICAgICAgICAgICdVc2luZyBhIHdyYXBwZXIgPGRpdj4gb3IgPHNwYW4+IHRhZyBhcm91bmQgdGhlIHJlZmVyZW5jZSBlbGVtZW50JyxcbiAgICAgICAgICAnc29sdmVzIHRoaXMgYnkgY3JlYXRpbmcgYSBuZXcgcGFyZW50Tm9kZSBjb250ZXh0LicsXG4gICAgICAgICAgJ1xcblxcbicsXG4gICAgICAgICAgJ1NwZWNpZnlpbmcgYGFwcGVuZFRvOiBkb2N1bWVudC5ib2R5YCBzaWxlbmNlcyB0aGlzIHdhcm5pbmcsIGJ1dCBpdCcsXG4gICAgICAgICAgJ2Fzc3VtZXMgeW91IGFyZSB1c2luZyBhIGZvY3VzIG1hbmFnZW1lbnQgc29sdXRpb24gdG8gaGFuZGxlJyxcbiAgICAgICAgICAna2V5Ym9hcmQgbmF2aWdhdGlvbi4nLFxuICAgICAgICAgICdcXG5cXG4nLFxuICAgICAgICAgICdTZWU6IGh0dHBzOi8vYXRvbWlrcy5naXRodWIuaW8vdGlwcHlqcy92Ni9hY2Nlc3NpYmlsaXR5LyNpbnRlcmFjdGl2aXR5JyxcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TmVzdGVkUG9wcGVyVHJlZSgpOiBQb3BwZXJFbGVtZW50W10ge1xuICAgIHJldHVybiBhcnJheUZyb20oXG4gICAgICBwb3BwZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtX19OQU1FU1BBQ0VfUFJFRklYX18tcm9vdF0nKVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZVNob3coZXZlbnQ/OiBFdmVudCk6IHZvaWQge1xuICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBpbnZva2VIb29rKCdvblRyaWdnZXInLCBbaW5zdGFuY2UsIGV2ZW50XSk7XG4gICAgfVxuXG4gICAgYWRkRG9jdW1lbnRQcmVzcygpO1xuXG4gICAgbGV0IGRlbGF5ID0gZ2V0RGVsYXkodHJ1ZSk7XG4gICAgY29uc3QgW3RvdWNoVmFsdWUsIHRvdWNoRGVsYXldID0gZ2V0Tm9ybWFsaXplZFRvdWNoU2V0dGluZ3MoKTtcblxuICAgIGlmIChjdXJyZW50SW5wdXQuaXNUb3VjaCAmJiB0b3VjaFZhbHVlID09PSAnaG9sZCcgJiYgdG91Y2hEZWxheSkge1xuICAgICAgZGVsYXkgPSB0b3VjaERlbGF5O1xuICAgIH1cblxuICAgIGlmIChkZWxheSkge1xuICAgICAgc2hvd1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaW5zdGFuY2Uuc2hvdygpO1xuICAgICAgfSwgZGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVIaWRlKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuXG4gICAgaW52b2tlSG9vaygnb25VbnRyaWdnZXInLCBbaW5zdGFuY2UsIGV2ZW50XSk7XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgcmVtb3ZlRG9jdW1lbnRQcmVzcygpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRm9yIGludGVyYWN0aXZlIHRpcHBpZXMsIHNjaGVkdWxlSGlkZSBpcyBhZGRlZCB0byBhIGRvY3VtZW50LmJvZHkgaGFuZGxlclxuICAgIC8vIGZyb20gb25Nb3VzZUxlYXZlIHNvIG11c3QgaW50ZXJjZXB0IHNjaGVkdWxlZCBoaWRlcyBmcm9tIG1vdXNlbW92ZS9sZWF2ZVxuICAgIC8vIGV2ZW50cyB3aGVuIHRyaWdnZXIgY29udGFpbnMgbW91c2VlbnRlciBhbmQgY2xpY2ssIGFuZCB0aGUgdGlwIGlzXG4gICAgLy8gY3VycmVudGx5IHNob3duIGFzIGEgcmVzdWx0IG9mIGEgY2xpY2suXG4gICAgaWYgKFxuICAgICAgaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdtb3VzZWVudGVyJykgPj0gMCAmJlxuICAgICAgaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdjbGljaycpID49IDAgJiZcbiAgICAgIFsnbW91c2VsZWF2ZScsICdtb3VzZW1vdmUnXS5pbmRleE9mKGV2ZW50LnR5cGUpID49IDAgJiZcbiAgICAgIGlzVmlzaWJsZUZyb21DbGlja1xuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbGF5ID0gZ2V0RGVsYXkoZmFsc2UpO1xuXG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBoaWRlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpeGVzIGEgYHRyYW5zaXRpb25lbmRgIHByb2JsZW0gd2hlbiBpdCBmaXJlcyAxIGZyYW1lIHRvb1xuICAgICAgLy8gbGF0ZSBzb21ldGltZXMsIHdlIGRvbid0IHdhbnQgaGlkZSgpIHRvIGJlIGNhbGxlZC5cbiAgICAgIHNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIPCflJEgUHVibGljIG1ldGhvZHNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIGVuYWJsZSgpOiB2b2lkIHtcbiAgICBpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlzYWJsZSgpOiB2b2lkIHtcbiAgICAvLyBEaXNhYmxpbmcgdGhlIGluc3RhbmNlIHNob3VsZCBhbHNvIGhpZGUgaXRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXRvbWlrcy90aXBweS5qcy1yZWFjdC9pc3N1ZXMvMTA2XG4gICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgIGluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZCA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJEZWxheVRpbWVvdXRzKCk6IHZvaWQge1xuICAgIGNsZWFyVGltZW91dChzaG93VGltZW91dCk7XG4gICAgY2xlYXJUaW1lb3V0KGhpZGVUaW1lb3V0KTtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZShzY2hlZHVsZUhpZGVBbmltYXRpb25GcmFtZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRQcm9wcyhwYXJ0aWFsUHJvcHM6IFBhcnRpYWw8UHJvcHM+KTogdm9pZCB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdzZXRQcm9wcycpKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnZva2VIb29rKCdvbkJlZm9yZVVwZGF0ZScsIFtpbnN0YW5jZSwgcGFydGlhbFByb3BzXSk7XG5cbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcblxuICAgIGNvbnN0IHByZXZQcm9wcyA9IGluc3RhbmNlLnByb3BzO1xuICAgIGNvbnN0IG5leHRQcm9wcyA9IGV2YWx1YXRlUHJvcHMocmVmZXJlbmNlLCB7XG4gICAgICAuLi5wcmV2UHJvcHMsXG4gICAgICAuLi5yZW1vdmVVbmRlZmluZWRQcm9wcyhwYXJ0aWFsUHJvcHMpLFxuICAgICAgaWdub3JlQXR0cmlidXRlczogdHJ1ZSxcbiAgICB9KTtcblxuICAgIGluc3RhbmNlLnByb3BzID0gbmV4dFByb3BzO1xuXG4gICAgYWRkTGlzdGVuZXJzKCk7XG5cbiAgICBpZiAocHJldlByb3BzLmludGVyYWN0aXZlRGVib3VuY2UgIT09IG5leHRQcm9wcy5pbnRlcmFjdGl2ZURlYm91bmNlKSB7XG4gICAgICBjbGVhbnVwSW50ZXJhY3RpdmVNb3VzZUxpc3RlbmVycygpO1xuICAgICAgZGVib3VuY2VkT25Nb3VzZU1vdmUgPSBkZWJvdW5jZShcbiAgICAgICAgb25Nb3VzZU1vdmUsXG4gICAgICAgIG5leHRQcm9wcy5pbnRlcmFjdGl2ZURlYm91bmNlXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBzdGFsZSBhcmlhLWV4cGFuZGVkIGF0dHJpYnV0ZXMgYXJlIHJlbW92ZWRcbiAgICBpZiAocHJldlByb3BzLnRyaWdnZXJUYXJnZXQgJiYgIW5leHRQcm9wcy50cmlnZ2VyVGFyZ2V0KSB7XG4gICAgICBub3JtYWxpemVUb0FycmF5KHByZXZQcm9wcy50cmlnZ2VyVGFyZ2V0KS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wcy50cmlnZ2VyVGFyZ2V0KSB7XG4gICAgICByZWZlcmVuY2UucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJyk7XG4gICAgfVxuXG4gICAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG4gICAgaGFuZGxlU3R5bGVzKCk7XG5cbiAgICBpZiAob25VcGRhdGUpIHtcbiAgICAgIG9uVXBkYXRlKHByZXZQcm9wcywgbmV4dFByb3BzKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgIGNyZWF0ZVBvcHBlckluc3RhbmNlKCk7XG5cbiAgICAgIC8vIEZpeGVzIGFuIGlzc3VlIHdpdGggbmVzdGVkIHRpcHBpZXMgaWYgdGhleSBhcmUgYWxsIGdldHRpbmcgcmUtcmVuZGVyZWQsXG4gICAgICAvLyBhbmQgdGhlIG5lc3RlZCBvbmVzIGdldCByZS1yZW5kZXJlZCBmaXJzdC5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hdG9taWtzL3RpcHB5anMtcmVhY3QvaXNzdWVzLzE3N1xuICAgICAgLy8gVE9ETzogZmluZCBhIGNsZWFuZXIgLyBtb3JlIGVmZmljaWVudCBzb2x1dGlvbighKVxuICAgICAgZ2V0TmVzdGVkUG9wcGVyVHJlZSgpLmZvckVhY2goKG5lc3RlZFBvcHBlcikgPT4ge1xuICAgICAgICAvLyBSZWFjdCAoYW5kIG90aGVyIFVJIGxpYnMgbGlrZWx5KSByZXF1aXJlcyBhIHJBRiB3cmFwcGVyIGFzIGl0IGZsdXNoZXNcbiAgICAgICAgLy8gaXRzIHdvcmsgaW4gb25lXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShuZXN0ZWRQb3BwZXIuX3RpcHB5IS5wb3BwZXJJbnN0YW5jZSEuZm9yY2VVcGRhdGUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25BZnRlclVwZGF0ZScsIFtpbnN0YW5jZSwgcGFydGlhbFByb3BzXSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDb250ZW50KGNvbnRlbnQ6IENvbnRlbnQpOiB2b2lkIHtcbiAgICBpbnN0YW5jZS5zZXRQcm9wcyh7Y29udGVudH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdygpOiB2b2lkIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCwgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ3Nob3cnKSk7XG4gICAgfVxuXG4gICAgLy8gRWFybHkgYmFpbC1vdXRcbiAgICBjb25zdCBpc0FscmVhZHlWaXNpYmxlID0gaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlO1xuICAgIGNvbnN0IGlzRGVzdHJveWVkID0gaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQ7XG4gICAgY29uc3QgaXNEaXNhYmxlZCA9ICFpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQ7XG4gICAgY29uc3QgaXNUb3VjaEFuZFRvdWNoRGlzYWJsZWQgPVxuICAgICAgY3VycmVudElucHV0LmlzVG91Y2ggJiYgIWluc3RhbmNlLnByb3BzLnRvdWNoO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4oXG4gICAgICBpbnN0YW5jZS5wcm9wcy5kdXJhdGlvbixcbiAgICAgIDAsXG4gICAgICBkZWZhdWx0UHJvcHMuZHVyYXRpb25cbiAgICApO1xuXG4gICAgaWYgKFxuICAgICAgaXNBbHJlYWR5VmlzaWJsZSB8fFxuICAgICAgaXNEZXN0cm95ZWQgfHxcbiAgICAgIGlzRGlzYWJsZWQgfHxcbiAgICAgIGlzVG91Y2hBbmRUb3VjaERpc2FibGVkXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsaXplIGBkaXNhYmxlZGAgYmVoYXZpb3IgYWNyb3NzIGJyb3dzZXJzLlxuICAgIC8vIEZpcmVmb3ggYWxsb3dzIGV2ZW50cyBvbiBkaXNhYmxlZCBlbGVtZW50cywgYnV0IENocm9tZSBkb2Vzbid0LlxuICAgIC8vIFVzaW5nIGEgd3JhcHBlciBlbGVtZW50IChpLmUuIDxzcGFuPikgaXMgcmVjb21tZW5kZWQuXG4gICAgaWYgKGdldEN1cnJlbnRUYXJnZXQoKS5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnZva2VIb29rKCdvblNob3cnLCBbaW5zdGFuY2VdLCBmYWxzZSk7XG4gICAgaWYgKGluc3RhbmNlLnByb3BzLm9uU2hvdyhpbnN0YW5jZSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlID0gdHJ1ZTtcblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICBwb3BwZXIuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICB9XG5cbiAgICBoYW5kbGVTdHlsZXMoKTtcbiAgICBhZGREb2N1bWVudFByZXNzKCk7XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgcG9wcGVyLnN0eWxlLnRyYW5zaXRpb24gPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgLy8gSWYgZmxpcHBpbmcgdG8gdGhlIG9wcG9zaXRlIHNpZGUgYWZ0ZXIgaGlkaW5nIGF0IGxlYXN0IG9uY2UsIHRoZVxuICAgIC8vIGFuaW1hdGlvbiB3aWxsIHVzZSB0aGUgd3JvbmcgcGxhY2VtZW50IHdpdGhvdXQgcmVzZXR0aW5nIHRoZSBkdXJhdGlvblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICBjb25zdCB7Ym94LCBjb250ZW50fSA9IGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCk7XG4gICAgICBzZXRUcmFuc2l0aW9uRHVyYXRpb24oW2JveCwgY29udGVudF0sIDApO1xuICAgIH1cblxuICAgIG9uRmlyc3RVcGRhdGUgPSAoKTogdm9pZCA9PiB7XG4gICAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSB8fCBpZ25vcmVPbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWdub3JlT25GaXJzdFVwZGF0ZSA9IHRydWU7XG5cbiAgICAgIC8vIHJlZmxvd1xuICAgICAgdm9pZCBwb3BwZXIub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICBwb3BwZXIuc3R5bGUudHJhbnNpdGlvbiA9IGluc3RhbmNlLnByb3BzLm1vdmVUcmFuc2l0aW9uO1xuXG4gICAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSAmJiBpbnN0YW5jZS5wcm9wcy5hbmltYXRpb24pIHtcbiAgICAgICAgY29uc3Qge2JveCwgY29udGVudH0gPSBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpO1xuICAgICAgICBzZXRUcmFuc2l0aW9uRHVyYXRpb24oW2JveCwgY29udGVudF0sIGR1cmF0aW9uKTtcbiAgICAgICAgc2V0VmlzaWJpbGl0eVN0YXRlKFtib3gsIGNvbnRlbnRdLCAndmlzaWJsZScpO1xuICAgICAgfVxuXG4gICAgICBoYW5kbGVBcmlhQ29udGVudEF0dHJpYnV0ZSgpO1xuICAgICAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG5cbiAgICAgIHB1c2hJZlVuaXF1ZShtb3VudGVkSW5zdGFuY2VzLCBpbnN0YW5jZSk7XG5cbiAgICAgIC8vIGNlcnRhaW4gbW9kaWZpZXJzIChlLmcuIGBtYXhTaXplYCkgcmVxdWlyZSBhIHNlY29uZCB1cGRhdGUgYWZ0ZXIgdGhlXG4gICAgICAvLyBwb3BwZXIgaGFzIGJlZW4gcG9zaXRpb25lZCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgIGluc3RhbmNlLnBvcHBlckluc3RhbmNlPy5mb3JjZVVwZGF0ZSgpO1xuXG4gICAgICBpbnZva2VIb29rKCdvbk1vdW50JywgW2luc3RhbmNlXSk7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5hbmltYXRpb24gJiYgZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgICBvblRyYW5zaXRpb25lZEluKGR1cmF0aW9uLCAoKSA9PiB7XG4gICAgICAgICAgaW5zdGFuY2Uuc3RhdGUuaXNTaG93biA9IHRydWU7XG4gICAgICAgICAgaW52b2tlSG9vaygnb25TaG93bicsIFtpbnN0YW5jZV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbW91bnQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZGUoKTogdm9pZCB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCdoaWRlJykpO1xuICAgIH1cblxuICAgIC8vIEVhcmx5IGJhaWwtb3V0XG4gICAgY29uc3QgaXNBbHJlYWR5SGlkZGVuID0gIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZTtcbiAgICBjb25zdCBpc0Rlc3Ryb3llZCA9IGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkO1xuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSAhaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4oXG4gICAgICBpbnN0YW5jZS5wcm9wcy5kdXJhdGlvbixcbiAgICAgIDEsXG4gICAgICBkZWZhdWx0UHJvcHMuZHVyYXRpb25cbiAgICApO1xuXG4gICAgaWYgKGlzQWxyZWFkeUhpZGRlbiB8fCBpc0Rlc3Ryb3llZCB8fCBpc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25IaWRlJywgW2luc3RhbmNlXSwgZmFsc2UpO1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5vbkhpZGUoaW5zdGFuY2UpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgIGluc3RhbmNlLnN0YXRlLmlzU2hvd24gPSBmYWxzZTtcbiAgICBpZ25vcmVPbkZpcnN0VXBkYXRlID0gZmFsc2U7XG4gICAgaXNWaXNpYmxlRnJvbUNsaWNrID0gZmFsc2U7XG5cbiAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgcG9wcGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICB9XG5cbiAgICBjbGVhbnVwSW50ZXJhY3RpdmVNb3VzZUxpc3RlbmVycygpO1xuICAgIHJlbW92ZURvY3VtZW50UHJlc3MoKTtcbiAgICBoYW5kbGVTdHlsZXModHJ1ZSk7XG5cbiAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgY29uc3Qge2JveCwgY29udGVudH0gPSBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpO1xuXG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuYW5pbWF0aW9uKSB7XG4gICAgICAgIHNldFRyYW5zaXRpb25EdXJhdGlvbihbYm94LCBjb250ZW50XSwgZHVyYXRpb24pO1xuICAgICAgICBzZXRWaXNpYmlsaXR5U3RhdGUoW2JveCwgY29udGVudF0sICdoaWRkZW4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVBcmlhQ29udGVudEF0dHJpYnV0ZSgpO1xuICAgIGhhbmRsZUFyaWFFeHBhbmRlZEF0dHJpYnV0ZSgpO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmFuaW1hdGlvbikge1xuICAgICAgaWYgKGdldElzRGVmYXVsdFJlbmRlckZuKCkpIHtcbiAgICAgICAgb25UcmFuc2l0aW9uZWRPdXQoZHVyYXRpb24sIGluc3RhbmNlLnVubW91bnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS51bm1vdW50KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGlkZVdpdGhJbnRlcmFjdGl2aXR5KGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgd2FybldoZW4oXG4gICAgICAgIGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLFxuICAgICAgICBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnaGlkZVdpdGhJbnRlcmFjdGl2aXR5JylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0RG9jdW1lbnQoKS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBkZWJvdW5jZWRPbk1vdXNlTW92ZSk7XG4gICAgcHVzaElmVW5pcXVlKG1vdXNlTW92ZUxpc3RlbmVycywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgIGRlYm91bmNlZE9uTW91c2VNb3ZlKGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVubW91bnQoKTogdm9pZCB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoX19ERVZfXykge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCd1bm1vdW50JykpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIGluc3RhbmNlLmhpZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRlc3Ryb3lQb3BwZXJJbnN0YW5jZSgpO1xuXG4gICAgLy8gSWYgYSBwb3BwZXIgaXMgbm90IGludGVyYWN0aXZlLCBpdCB3aWxsIGJlIGFwcGVuZGVkIG91dHNpZGUgdGhlIHBvcHBlclxuICAgIC8vIHRyZWUgYnkgZGVmYXVsdC4gVGhpcyBzZWVtcyBtYWlubHkgZm9yIGludGVyYWN0aXZlIHRpcHBpZXMsIGJ1dCB3ZSBzaG91bGRcbiAgICAvLyBmaW5kIGEgd29ya2Fyb3VuZCBpZiBwb3NzaWJsZVxuICAgIGdldE5lc3RlZFBvcHBlclRyZWUoKS5mb3JFYWNoKChuZXN0ZWRQb3BwZXIpID0+IHtcbiAgICAgIG5lc3RlZFBvcHBlci5fdGlwcHkhLnVubW91bnQoKTtcbiAgICB9KTtcblxuICAgIGlmIChwb3BwZXIucGFyZW50Tm9kZSkge1xuICAgICAgcG9wcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocG9wcGVyKTtcbiAgICB9XG5cbiAgICBtb3VudGVkSW5zdGFuY2VzID0gbW91bnRlZEluc3RhbmNlcy5maWx0ZXIoKGkpID0+IGkgIT09IGluc3RhbmNlKTtcblxuICAgIGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgIGludm9rZUhvb2soJ29uSGlkZGVuJywgW2luc3RhbmNlXSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCk6IHZvaWQge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnZGVzdHJveScpKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcbiAgICBpbnN0YW5jZS51bm1vdW50KCk7XG5cbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcblxuICAgIGRlbGV0ZSByZWZlcmVuY2UuX3RpcHB5O1xuXG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQgPSB0cnVlO1xuXG4gICAgaW52b2tlSG9vaygnb25EZXN0cm95JywgW2luc3RhbmNlXSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzLCB7XG4gIGN1cnJlbnRJbnB1dCxcbn0gZnJvbSAnLi9iaW5kR2xvYmFsRXZlbnRMaXN0ZW5lcnMnO1xuaW1wb3J0IGNyZWF0ZVRpcHB5LCB7bW91bnRlZEluc3RhbmNlc30gZnJvbSAnLi9jcmVhdGVUaXBweSc7XG5pbXBvcnQge2dldEFycmF5T2ZFbGVtZW50cywgaXNFbGVtZW50LCBpc1JlZmVyZW5jZUVsZW1lbnR9IGZyb20gJy4vZG9tLXV0aWxzJztcbmltcG9ydCB7ZGVmYXVsdFByb3BzLCBzZXREZWZhdWx0UHJvcHMsIHZhbGlkYXRlUHJvcHN9IGZyb20gJy4vcHJvcHMnO1xuaW1wb3J0IHtIaWRlQWxsLCBIaWRlQWxsT3B0aW9ucywgSW5zdGFuY2UsIFByb3BzLCBUYXJnZXRzfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7dmFsaWRhdGVUYXJnZXRzLCB3YXJuV2hlbn0gZnJvbSAnLi92YWxpZGF0aW9uJztcblxuZnVuY3Rpb24gdGlwcHkoXG4gIHRhcmdldHM6IFRhcmdldHMsXG4gIG9wdGlvbmFsUHJvcHM6IFBhcnRpYWw8UHJvcHM+ID0ge31cbik6IEluc3RhbmNlIHwgSW5zdGFuY2VbXSB7XG4gIGNvbnN0IHBsdWdpbnMgPSBkZWZhdWx0UHJvcHMucGx1Z2lucy5jb25jYXQob3B0aW9uYWxQcm9wcy5wbHVnaW5zIHx8IFtdKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoX19ERVZfXykge1xuICAgIHZhbGlkYXRlVGFyZ2V0cyh0YXJnZXRzKTtcbiAgICB2YWxpZGF0ZVByb3BzKG9wdGlvbmFsUHJvcHMsIHBsdWdpbnMpO1xuICB9XG5cbiAgYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgY29uc3QgcGFzc2VkUHJvcHM6IFBhcnRpYWw8UHJvcHM+ID0gey4uLm9wdGlvbmFsUHJvcHMsIHBsdWdpbnN9O1xuXG4gIGNvbnN0IGVsZW1lbnRzID0gZ2V0QXJyYXlPZkVsZW1lbnRzKHRhcmdldHMpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgY29uc3QgaXNTaW5nbGVDb250ZW50RWxlbWVudCA9IGlzRWxlbWVudChwYXNzZWRQcm9wcy5jb250ZW50KTtcbiAgICBjb25zdCBpc01vcmVUaGFuT25lUmVmZXJlbmNlRWxlbWVudCA9IGVsZW1lbnRzLmxlbmd0aCA+IDE7XG4gICAgd2FybldoZW4oXG4gICAgICBpc1NpbmdsZUNvbnRlbnRFbGVtZW50ICYmIGlzTW9yZVRoYW5PbmVSZWZlcmVuY2VFbGVtZW50LFxuICAgICAgW1xuICAgICAgICAndGlwcHkoKSB3YXMgcGFzc2VkIGFuIEVsZW1lbnQgYXMgdGhlIGBjb250ZW50YCBwcm9wLCBidXQgbW9yZSB0aGFuJyxcbiAgICAgICAgJ29uZSB0aXBweSBpbnN0YW5jZSB3YXMgY3JlYXRlZCBieSB0aGlzIGludm9jYXRpb24uIFRoaXMgbWVhbnMgdGhlJyxcbiAgICAgICAgJ2NvbnRlbnQgZWxlbWVudCB3aWxsIG9ubHkgYmUgYXBwZW5kZWQgdG8gdGhlIGxhc3QgdGlwcHkgaW5zdGFuY2UuJyxcbiAgICAgICAgJ1xcblxcbicsXG4gICAgICAgICdJbnN0ZWFkLCBwYXNzIHRoZSAuaW5uZXJIVE1MIG9mIHRoZSBlbGVtZW50LCBvciB1c2UgYSBmdW5jdGlvbiB0aGF0JyxcbiAgICAgICAgJ3JldHVybnMgYSBjbG9uZWQgdmVyc2lvbiBvZiB0aGUgZWxlbWVudCBpbnN0ZWFkLicsXG4gICAgICAgICdcXG5cXG4nLFxuICAgICAgICAnMSkgY29udGVudDogZWxlbWVudC5pbm5lckhUTUxcXG4nLFxuICAgICAgICAnMikgY29udGVudDogKCkgPT4gZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSknLFxuICAgICAgXS5qb2luKCcgJylcbiAgICApO1xuICB9XG5cbiAgY29uc3QgaW5zdGFuY2VzID0gZWxlbWVudHMucmVkdWNlPEluc3RhbmNlW10+KFxuICAgIChhY2MsIHJlZmVyZW5jZSk6IEluc3RhbmNlW10gPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSByZWZlcmVuY2UgJiYgY3JlYXRlVGlwcHkocmVmZXJlbmNlLCBwYXNzZWRQcm9wcyk7XG5cbiAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICBhY2MucHVzaChpbnN0YW5jZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICBbXVxuICApO1xuXG4gIHJldHVybiBpc0VsZW1lbnQodGFyZ2V0cykgPyBpbnN0YW5jZXNbMF0gOiBpbnN0YW5jZXM7XG59XG5cbnRpcHB5LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbnRpcHB5LnNldERlZmF1bHRQcm9wcyA9IHNldERlZmF1bHRQcm9wcztcbnRpcHB5LmN1cnJlbnRJbnB1dCA9IGN1cnJlbnRJbnB1dDtcblxuZXhwb3J0IGRlZmF1bHQgdGlwcHk7XG5cbmV4cG9ydCBjb25zdCBoaWRlQWxsOiBIaWRlQWxsID0gKHtcbiAgZXhjbHVkZTogZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlLFxuICBkdXJhdGlvbixcbn06IEhpZGVBbGxPcHRpb25zID0ge30pID0+IHtcbiAgbW91bnRlZEluc3RhbmNlcy5mb3JFYWNoKChpbnN0YW5jZSkgPT4ge1xuICAgIGxldCBpc0V4Y2x1ZGVkID0gZmFsc2U7XG5cbiAgICBpZiAoZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlKSB7XG4gICAgICBpc0V4Y2x1ZGVkID0gaXNSZWZlcmVuY2VFbGVtZW50KGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSlcbiAgICAgICAgPyBpbnN0YW5jZS5yZWZlcmVuY2UgPT09IGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZVxuICAgICAgICA6IGluc3RhbmNlLnBvcHBlciA9PT0gKGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSBhcyBJbnN0YW5jZSkucG9wcGVyO1xuICAgIH1cblxuICAgIGlmICghaXNFeGNsdWRlZCkge1xuICAgICAgY29uc3Qgb3JpZ2luYWxEdXJhdGlvbiA9IGluc3RhbmNlLnByb3BzLmR1cmF0aW9uO1xuXG4gICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7ZHVyYXRpb259KTtcbiAgICAgIGluc3RhbmNlLmhpZGUoKTtcblxuICAgICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7ZHVyYXRpb246IG9yaWdpbmFsRHVyYXRpb259KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcbiIsICJpbXBvcnQgdGlwcHkgZnJvbSAnLi4nO1xuaW1wb3J0IHtkaXZ9IGZyb20gJy4uL2RvbS11dGlscyc7XG5pbXBvcnQge1xuICBDcmVhdGVTaW5nbGV0b24sXG4gIFBsdWdpbixcbiAgQ3JlYXRlU2luZ2xldG9uUHJvcHMsXG4gIFJlZmVyZW5jZUVsZW1lbnQsXG4gIENyZWF0ZVNpbmdsZXRvbkluc3RhbmNlLFxuICBJbnN0YW5jZSxcbiAgUHJvcHMsXG59IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7bm9ybWFsaXplVG9BcnJheSwgcmVtb3ZlUHJvcGVydGllc30gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHtlcnJvcldoZW59IGZyb20gJy4uL3ZhbGlkYXRpb24nO1xuaW1wb3J0IHthcHBseVN0eWxlcywgTW9kaWZpZXJ9IGZyb20gJ0Bwb3BwZXJqcy9jb3JlJztcblxuLy8gVGhlIGRlZmF1bHQgYGFwcGx5U3R5bGVzYCBtb2RpZmllciBoYXMgYSBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWRcbi8vIGV2ZXJ5IHRpbWUgdGhlIHBvcHBlciBpcyBkZXN0cm95ZWQgKGkuZS4gYSBuZXcgdGFyZ2V0KSwgcmVtb3ZpbmcgdGhlIHN0eWxlc1xuLy8gYW5kIGNhdXNpbmcgdHJhbnNpdGlvbnMgdG8gYnJlYWsgZm9yIHNpbmdsZXRvbnMgd2hlbiB0aGUgY29uc29sZSBpcyBvcGVuLCBidXRcbi8vIG1vc3Qgbm90YWJseSBmb3Igbm9uLXRyYW5zZm9ybSBzdHlsZXMgYmVpbmcgdXNlZCwgYGdwdUFjY2VsZXJhdGlvbjogZmFsc2VgLlxuY29uc3QgYXBwbHlTdHlsZXNNb2RpZmllcjogTW9kaWZpZXI8J2FwcGx5U3R5bGVzJywgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+ID0ge1xuICAuLi5hcHBseVN0eWxlcyxcbiAgZWZmZWN0KHtzdGF0ZX0pIHtcbiAgICBjb25zdCBpbml0aWFsU3R5bGVzID0ge1xuICAgICAgcG9wcGVyOiB7XG4gICAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgICBsZWZ0OiAnMCcsXG4gICAgICAgIHRvcDogJzAnLFxuICAgICAgICBtYXJnaW46ICcwJyxcbiAgICAgIH0sXG4gICAgICBhcnJvdzoge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIH0sXG4gICAgICByZWZlcmVuY2U6IHt9LFxuICAgIH07XG5cbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgaW5pdGlhbFN0eWxlcy5wb3BwZXIpO1xuICAgIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGluaXRpYWxTdHlsZXMuYXJyb3cpO1xuICAgIH1cblxuICAgIC8vIGludGVudGlvbmFsbHkgcmV0dXJuIG5vIGNsZWFudXAgZnVuY3Rpb25cbiAgICAvLyByZXR1cm4gKCkgPT4geyAuLi4gfVxuICB9LFxufTtcblxuY29uc3QgY3JlYXRlU2luZ2xldG9uOiBDcmVhdGVTaW5nbGV0b24gPSAoXG4gIHRpcHB5SW5zdGFuY2VzLFxuICBvcHRpb25hbFByb3BzID0ge31cbikgPT4ge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoX19ERVZfXykge1xuICAgIGVycm9yV2hlbihcbiAgICAgICFBcnJheS5pc0FycmF5KHRpcHB5SW5zdGFuY2VzKSxcbiAgICAgIFtcbiAgICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gY3JlYXRlU2luZ2xldG9uKCkgbXVzdCBiZSBhbiBhcnJheSBvZicsXG4gICAgICAgICd0aXBweSBpbnN0YW5jZXMuIFRoZSBwYXNzZWQgdmFsdWUgd2FzJyxcbiAgICAgICAgU3RyaW5nKHRpcHB5SW5zdGFuY2VzKSxcbiAgICAgIF0uam9pbignICcpXG4gICAgKTtcbiAgfVxuXG4gIGxldCBpbmRpdmlkdWFsSW5zdGFuY2VzID0gdGlwcHlJbnN0YW5jZXM7XG4gIGxldCByZWZlcmVuY2VzOiBBcnJheTxSZWZlcmVuY2VFbGVtZW50PiA9IFtdO1xuICBsZXQgdHJpZ2dlclRhcmdldHM6IEFycmF5PEVsZW1lbnQ+ID0gW107XG4gIGxldCBjdXJyZW50VGFyZ2V0OiBFbGVtZW50IHwgbnVsbDtcbiAgbGV0IG92ZXJyaWRlcyA9IG9wdGlvbmFsUHJvcHMub3ZlcnJpZGVzO1xuICBsZXQgaW50ZXJjZXB0U2V0UHJvcHNDbGVhbnVwczogQXJyYXk8KCkgPT4gdm9pZD4gPSBbXTtcbiAgbGV0IHNob3duT25DcmVhdGUgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBzZXRUcmlnZ2VyVGFyZ2V0cygpOiB2b2lkIHtcbiAgICB0cmlnZ2VyVGFyZ2V0cyA9IGluZGl2aWR1YWxJbnN0YW5jZXNcbiAgICAgIC5tYXAoKGluc3RhbmNlKSA9PlxuICAgICAgICBub3JtYWxpemVUb0FycmF5KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgaW5zdGFuY2UucmVmZXJlbmNlKVxuICAgICAgKVxuICAgICAgLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiBhY2MuY29uY2F0KGl0ZW0pLCBbXSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRSZWZlcmVuY2VzKCk6IHZvaWQge1xuICAgIHJlZmVyZW5jZXMgPSBpbmRpdmlkdWFsSW5zdGFuY2VzLm1hcCgoaW5zdGFuY2UpID0+IGluc3RhbmNlLnJlZmVyZW5jZSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmFibGVJbnN0YW5jZXMoaXNFbmFibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgaW5kaXZpZHVhbEluc3RhbmNlcy5mb3JFYWNoKChpbnN0YW5jZSkgPT4ge1xuICAgICAgaWYgKGlzRW5hYmxlZCkge1xuICAgICAgICBpbnN0YW5jZS5lbmFibGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLmRpc2FibGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVyY2VwdFNldFByb3BzKHNpbmdsZXRvbjogSW5zdGFuY2UpOiBBcnJheTwoKSA9PiB2b2lkPiB7XG4gICAgcmV0dXJuIGluZGl2aWR1YWxJbnN0YW5jZXMubWFwKChpbnN0YW5jZSkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxTZXRQcm9wcyA9IGluc3RhbmNlLnNldFByb3BzO1xuXG4gICAgICBpbnN0YW5jZS5zZXRQcm9wcyA9IChwcm9wcyk6IHZvaWQgPT4ge1xuICAgICAgICBvcmlnaW5hbFNldFByb3BzKHByb3BzKTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UucmVmZXJlbmNlID09PSBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgc2luZ2xldG9uLnNldFByb3BzKHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuICgpOiB2b2lkID0+IHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMgPSBvcmlnaW5hbFNldFByb3BzO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGhhdmUgdG8gcGFzcyBzaW5nbGV0b24sIGFzIGl0IG1heWJlIHVuZGVmaW5lZCBvbiBmaXJzdCBjYWxsXG4gIGZ1bmN0aW9uIHByZXBhcmVJbnN0YW5jZShcbiAgICBzaW5nbGV0b246IEluc3RhbmNlLFxuICAgIHRhcmdldDogUmVmZXJlbmNlRWxlbWVudFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBpbmRleCA9IHRyaWdnZXJUYXJnZXRzLmluZGV4T2YodGFyZ2V0KTtcblxuICAgIC8vIGJhaWwtb3V0XG4gICAgaWYgKHRhcmdldCA9PT0gY3VycmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN1cnJlbnRUYXJnZXQgPSB0YXJnZXQ7XG5cbiAgICBjb25zdCBvdmVycmlkZVByb3BzOiBQYXJ0aWFsPFByb3BzPiA9IChvdmVycmlkZXMgfHwgW10pXG4gICAgICAuY29uY2F0KCdjb250ZW50JylcbiAgICAgIC5yZWR1Y2UoKGFjYywgcHJvcCkgPT4ge1xuICAgICAgICAoYWNjIGFzIGFueSlbcHJvcF0gPSBpbmRpdmlkdWFsSW5zdGFuY2VzW2luZGV4XS5wcm9wc1twcm9wXTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KTtcblxuICAgIHNpbmdsZXRvbi5zZXRQcm9wcyh7XG4gICAgICAuLi5vdmVycmlkZVByb3BzLFxuICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDpcbiAgICAgICAgdHlwZW9mIG92ZXJyaWRlUHJvcHMuZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gb3ZlcnJpZGVQcm9wcy5nZXRSZWZlcmVuY2VDbGllbnRSZWN0XG4gICAgICAgICAgOiAoKTogQ2xpZW50UmVjdCA9PiByZWZlcmVuY2VzW2luZGV4XT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgfSk7XG4gIH1cblxuICBlbmFibGVJbnN0YW5jZXMoZmFsc2UpO1xuICBzZXRSZWZlcmVuY2VzKCk7XG4gIHNldFRyaWdnZXJUYXJnZXRzKCk7XG5cbiAgY29uc3QgcGx1Z2luOiBQbHVnaW4gPSB7XG4gICAgZm4oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgICAgZW5hYmxlSW5zdGFuY2VzKHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBvbkhpZGRlbigpOiB2b2lkIHtcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgb25DbGlja091dHNpZGUoaW5zdGFuY2UpOiB2b2lkIHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMuc2hvd09uQ3JlYXRlICYmICFzaG93bk9uQ3JlYXRlKSB7XG4gICAgICAgICAgICBzaG93bk9uQ3JlYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25TaG93KGluc3RhbmNlKTogdm9pZCB7XG4gICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzLnNob3dPbkNyZWF0ZSAmJiAhc2hvd25PbkNyZWF0ZSkge1xuICAgICAgICAgICAgc2hvd25PbkNyZWF0ZSA9IHRydWU7XG4gICAgICAgICAgICBwcmVwYXJlSW5zdGFuY2UoaW5zdGFuY2UsIHJlZmVyZW5jZXNbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25UcmlnZ2VyKGluc3RhbmNlLCBldmVudCk6IHZvaWQge1xuICAgICAgICAgIHByZXBhcmVJbnN0YW5jZShpbnN0YW5jZSwgZXZlbnQuY3VycmVudFRhcmdldCBhcyBFbGVtZW50KTtcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSxcbiAgfTtcblxuICBjb25zdCBzaW5nbGV0b24gPSB0aXBweShkaXYoKSwge1xuICAgIC4uLnJlbW92ZVByb3BlcnRpZXMob3B0aW9uYWxQcm9wcywgWydvdmVycmlkZXMnXSksXG4gICAgcGx1Z2luczogW3BsdWdpbiwgLi4uKG9wdGlvbmFsUHJvcHMucGx1Z2lucyB8fCBbXSldLFxuICAgIHRyaWdnZXJUYXJnZXQ6IHRyaWdnZXJUYXJnZXRzLFxuICAgIHBvcHBlck9wdGlvbnM6IHtcbiAgICAgIC4uLm9wdGlvbmFsUHJvcHMucG9wcGVyT3B0aW9ucyxcbiAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICAuLi4ob3B0aW9uYWxQcm9wcy5wb3BwZXJPcHRpb25zPy5tb2RpZmllcnMgfHwgW10pLFxuICAgICAgICBhcHBseVN0eWxlc01vZGlmaWVyLFxuICAgICAgXSxcbiAgICB9LFxuICB9KSBhcyBDcmVhdGVTaW5nbGV0b25JbnN0YW5jZTxDcmVhdGVTaW5nbGV0b25Qcm9wcz47XG5cbiAgY29uc3Qgb3JpZ2luYWxTaG93ID0gc2luZ2xldG9uLnNob3c7XG5cbiAgc2luZ2xldG9uLnNob3cgPSAodGFyZ2V0PzogUmVmZXJlbmNlRWxlbWVudCB8IEluc3RhbmNlIHwgbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgb3JpZ2luYWxTaG93KCk7XG5cbiAgICAvLyBmaXJzdCB0aW1lLCBzaG93T25DcmVhdGUgb3IgcHJvZ3JhbW1hdGljIGNhbGwgd2l0aCBubyBwYXJhbXNcbiAgICAvLyBkZWZhdWx0IHRvIHNob3dpbmcgZmlyc3QgaW5zdGFuY2VcbiAgICBpZiAoIWN1cnJlbnRUYXJnZXQgJiYgdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBwcmVwYXJlSW5zdGFuY2Uoc2luZ2xldG9uLCByZWZlcmVuY2VzWzBdKTtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyZWQgZnJvbSBldmVudCAoZG8gbm90aGluZyBhcyBwcmVwYXJlSW5zdGFuY2UgYWxyZWFkeSBjYWxsZWQgYnkgb25UcmlnZ2VyKVxuICAgIC8vIHByb2dyYW1tYXRpYyBjYWxsIHdpdGggbm8gcGFyYW1zIHdoZW4gYWxyZWFkeSB2aXNpYmxlIChkbyBub3RoaW5nIGFnYWluKVxuICAgIGlmIChjdXJyZW50VGFyZ2V0ICYmIHRhcmdldCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdGFyZ2V0IGlzIGluZGV4IG9mIGluc3RhbmNlXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICByZWZlcmVuY2VzW3RhcmdldF0gJiYgcHJlcGFyZUluc3RhbmNlKHNpbmdsZXRvbiwgcmVmZXJlbmNlc1t0YXJnZXRdKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyB0YXJnZXQgaXMgYSBjaGlsZCB0aXBweSBpbnN0YW5jZVxuICAgIGlmIChpbmRpdmlkdWFsSW5zdGFuY2VzLmluZGV4T2YodGFyZ2V0IGFzIEluc3RhbmNlKSA+PSAwKSB7XG4gICAgICBjb25zdCByZWYgPSAodGFyZ2V0IGFzIEluc3RhbmNlKS5yZWZlcmVuY2U7XG4gICAgICByZXR1cm4gcHJlcGFyZUluc3RhbmNlKHNpbmdsZXRvbiwgcmVmKTtcbiAgICB9XG5cbiAgICAvLyB0YXJnZXQgaXMgYSBSZWZlcmVuY2VFbGVtZW50XG4gICAgaWYgKHJlZmVyZW5jZXMuaW5kZXhPZih0YXJnZXQgYXMgUmVmZXJlbmNlRWxlbWVudCkgPj0gMCkge1xuICAgICAgcmV0dXJuIHByZXBhcmVJbnN0YW5jZShzaW5nbGV0b24sIHRhcmdldCBhcyBSZWZlcmVuY2VFbGVtZW50KTtcbiAgICB9XG4gIH07XG5cbiAgc2luZ2xldG9uLnNob3dOZXh0ID0gKCk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IGZpcnN0ID0gcmVmZXJlbmNlc1swXTtcbiAgICBpZiAoIWN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybiBzaW5nbGV0b24uc2hvdygwKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSByZWZlcmVuY2VzLmluZGV4T2YoY3VycmVudFRhcmdldCk7XG4gICAgc2luZ2xldG9uLnNob3cocmVmZXJlbmNlc1tpbmRleCArIDFdIHx8IGZpcnN0KTtcbiAgfTtcblxuICBzaW5nbGV0b24uc2hvd1ByZXZpb3VzID0gKCk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IGxhc3QgPSByZWZlcmVuY2VzW3JlZmVyZW5jZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFjdXJyZW50VGFyZ2V0KSB7XG4gICAgICByZXR1cm4gc2luZ2xldG9uLnNob3cobGFzdCk7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gcmVmZXJlbmNlcy5pbmRleE9mKGN1cnJlbnRUYXJnZXQpO1xuICAgIGNvbnN0IHRhcmdldCA9IHJlZmVyZW5jZXNbaW5kZXggLSAxXSB8fCBsYXN0O1xuICAgIHNpbmdsZXRvbi5zaG93KHRhcmdldCk7XG4gIH07XG5cbiAgY29uc3Qgb3JpZ2luYWxTZXRQcm9wcyA9IHNpbmdsZXRvbi5zZXRQcm9wcztcblxuICBzaW5nbGV0b24uc2V0UHJvcHMgPSAocHJvcHMpOiB2b2lkID0+IHtcbiAgICBvdmVycmlkZXMgPSBwcm9wcy5vdmVycmlkZXMgfHwgb3ZlcnJpZGVzO1xuICAgIG9yaWdpbmFsU2V0UHJvcHMocHJvcHMpO1xuICB9O1xuXG4gIHNpbmdsZXRvbi5zZXRJbnN0YW5jZXMgPSAobmV4dEluc3RhbmNlcyk6IHZvaWQgPT4ge1xuICAgIGVuYWJsZUluc3RhbmNlcyh0cnVlKTtcbiAgICBpbnRlcmNlcHRTZXRQcm9wc0NsZWFudXBzLmZvckVhY2goKGZuKSA9PiBmbigpKTtcblxuICAgIGluZGl2aWR1YWxJbnN0YW5jZXMgPSBuZXh0SW5zdGFuY2VzO1xuXG4gICAgZW5hYmxlSW5zdGFuY2VzKGZhbHNlKTtcbiAgICBzZXRSZWZlcmVuY2VzKCk7XG4gICAgc2V0VHJpZ2dlclRhcmdldHMoKTtcbiAgICBpbnRlcmNlcHRTZXRQcm9wc0NsZWFudXBzID0gaW50ZXJjZXB0U2V0UHJvcHMoc2luZ2xldG9uKTtcblxuICAgIHNpbmdsZXRvbi5zZXRQcm9wcyh7dHJpZ2dlclRhcmdldDogdHJpZ2dlclRhcmdldHN9KTtcbiAgfTtcblxuICBpbnRlcmNlcHRTZXRQcm9wc0NsZWFudXBzID0gaW50ZXJjZXB0U2V0UHJvcHMoc2luZ2xldG9uKTtcblxuICByZXR1cm4gc2luZ2xldG9uO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlU2luZ2xldG9uO1xuIiwgImltcG9ydCB0aXBweSBmcm9tICcuLic7XG5pbXBvcnQge1RPVUNIX09QVElPTlN9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQge2RlZmF1bHRQcm9wc30gZnJvbSAnLi4vcHJvcHMnO1xuaW1wb3J0IHtJbnN0YW5jZSwgUHJvcHMsIFRhcmdldHN9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7TGlzdGVuZXJPYmplY3R9IGZyb20gJy4uL3R5cGVzLWludGVybmFsJztcbmltcG9ydCB7bm9ybWFsaXplVG9BcnJheSwgcmVtb3ZlUHJvcGVydGllc30gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHtlcnJvcldoZW59IGZyb20gJy4uL3ZhbGlkYXRpb24nO1xuXG5jb25zdCBCVUJCTElOR19FVkVOVFNfTUFQID0ge1xuICBtb3VzZW92ZXI6ICdtb3VzZWVudGVyJyxcbiAgZm9jdXNpbjogJ2ZvY3VzJyxcbiAgY2xpY2s6ICdjbGljaycsXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWxlZ2F0ZSBpbnN0YW5jZSB0aGF0IGNvbnRyb2xzIHRoZSBjcmVhdGlvbiBvZiB0aXBweSBpbnN0YW5jZXNcbiAqIGZvciBjaGlsZCBlbGVtZW50cyAoYHRhcmdldGAgQ1NTIHNlbGVjdG9yKS5cbiAqL1xuZnVuY3Rpb24gZGVsZWdhdGUoXG4gIHRhcmdldHM6IFRhcmdldHMsXG4gIHByb3BzOiBQYXJ0aWFsPFByb3BzPiAmIHt0YXJnZXQ6IHN0cmluZ31cbik6IEluc3RhbmNlIHwgSW5zdGFuY2VbXSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgZXJyb3JXaGVuKFxuICAgICAgIShwcm9wcyAmJiBwcm9wcy50YXJnZXQpLFxuICAgICAgW1xuICAgICAgICAnWW91IG11c3Qgc3BlY2l0eSBhIGB0YXJnZXRgIHByb3AgaW5kaWNhdGluZyBhIENTUyBzZWxlY3RvciBzdHJpbmcgbWF0Y2hpbmcnLFxuICAgICAgICAndGhlIHRhcmdldCBlbGVtZW50cyB0aGF0IHNob3VsZCByZWNlaXZlIGEgdGlwcHkuJyxcbiAgICAgIF0uam9pbignICcpXG4gICAgKTtcbiAgfVxuXG4gIGxldCBsaXN0ZW5lcnM6IExpc3RlbmVyT2JqZWN0W10gPSBbXTtcbiAgbGV0IGNoaWxkVGlwcHlJbnN0YW5jZXM6IEluc3RhbmNlW10gPSBbXTtcbiAgbGV0IGRpc2FibGVkID0gZmFsc2U7XG5cbiAgY29uc3Qge3RhcmdldH0gPSBwcm9wcztcblxuICBjb25zdCBuYXRpdmVQcm9wcyA9IHJlbW92ZVByb3BlcnRpZXMocHJvcHMsIFsndGFyZ2V0J10pO1xuICBjb25zdCBwYXJlbnRQcm9wcyA9IHsuLi5uYXRpdmVQcm9wcywgdHJpZ2dlcjogJ21hbnVhbCcsIHRvdWNoOiBmYWxzZX07XG4gIGNvbnN0IGNoaWxkUHJvcHMgPSB7XG4gICAgdG91Y2g6IGRlZmF1bHRQcm9wcy50b3VjaCxcbiAgICAuLi5uYXRpdmVQcm9wcyxcbiAgICBzaG93T25DcmVhdGU6IHRydWUsXG4gIH07XG5cbiAgY29uc3QgcmV0dXJuVmFsdWUgPSB0aXBweSh0YXJnZXRzLCBwYXJlbnRQcm9wcyk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRSZXR1cm5WYWx1ZSA9IG5vcm1hbGl6ZVRvQXJyYXkocmV0dXJuVmFsdWUpO1xuXG4gIGZ1bmN0aW9uIG9uVHJpZ2dlcihldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICBpZiAoIWV2ZW50LnRhcmdldCB8fCBkaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldE5vZGUgPSAoZXZlbnQudGFyZ2V0IGFzIEVsZW1lbnQpLmNsb3Nlc3QodGFyZ2V0KTtcblxuICAgIGlmICghdGFyZ2V0Tm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEdldCByZWxldmFudCB0cmlnZ2VyIHdpdGggZmFsbGJhY2tzOlxuICAgIC8vIDEuIENoZWNrIGBkYXRhLXRpcHB5LXRyaWdnZXJgIGF0dHJpYnV0ZSBvbiB0YXJnZXQgbm9kZVxuICAgIC8vIDIuIEZhbGxiYWNrIHRvIGB0cmlnZ2VyYCBwYXNzZWQgdG8gYGRlbGVnYXRlKClgXG4gICAgLy8gMy4gRmFsbGJhY2sgdG8gYGRlZmF1bHRQcm9wcy50cmlnZ2VyYFxuICAgIGNvbnN0IHRyaWdnZXIgPVxuICAgICAgdGFyZ2V0Tm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGlwcHktdHJpZ2dlcicpIHx8XG4gICAgICBwcm9wcy50cmlnZ2VyIHx8XG4gICAgICBkZWZhdWx0UHJvcHMudHJpZ2dlcjtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodGFyZ2V0Tm9kZS5fdGlwcHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnICYmIHR5cGVvZiBjaGlsZFByb3BzLnRvdWNoID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBldmVudC50eXBlICE9PSAndG91Y2hzdGFydCcgJiZcbiAgICAgIHRyaWdnZXIuaW5kZXhPZigoQlVCQkxJTkdfRVZFTlRTX01BUCBhcyBhbnkpW2V2ZW50LnR5cGVdKSA8IDBcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpbnN0YW5jZSA9IHRpcHB5KHRhcmdldE5vZGUsIGNoaWxkUHJvcHMpO1xuXG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzID0gY2hpbGRUaXBweUluc3RhbmNlcy5jb25jYXQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uKFxuICAgIG5vZGU6IEVsZW1lbnQsXG4gICAgZXZlbnRUeXBlOiBzdHJpbmcsXG4gICAgaGFuZGxlcjogRXZlbnRMaXN0ZW5lcixcbiAgICBvcHRpb25zOiBib29sZWFuIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSBmYWxzZVxuICApOiB2b2lkIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICBsaXN0ZW5lcnMucHVzaCh7bm9kZSwgZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyhpbnN0YW5jZTogSW5zdGFuY2UpOiB2b2lkIHtcbiAgICBjb25zdCB7cmVmZXJlbmNlfSA9IGluc3RhbmNlO1xuXG4gICAgb24ocmVmZXJlbmNlLCAndG91Y2hzdGFydCcsIG9uVHJpZ2dlciwgVE9VQ0hfT1BUSU9OUyk7XG4gICAgb24ocmVmZXJlbmNlLCAnbW91c2VvdmVyJywgb25UcmlnZ2VyKTtcbiAgICBvbihyZWZlcmVuY2UsICdmb2N1c2luJywgb25UcmlnZ2VyKTtcbiAgICBvbihyZWZlcmVuY2UsICdjbGljaycsIG9uVHJpZ2dlcik7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycygpOiB2b2lkIHtcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaCgoe25vZGUsIGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9uc306IExpc3RlbmVyT2JqZWN0KSA9PiB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICBsaXN0ZW5lcnMgPSBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5TXV0YXRpb25zKGluc3RhbmNlOiBJbnN0YW5jZSk6IHZvaWQge1xuICAgIGNvbnN0IG9yaWdpbmFsRGVzdHJveSA9IGluc3RhbmNlLmRlc3Ryb3k7XG4gICAgY29uc3Qgb3JpZ2luYWxFbmFibGUgPSBpbnN0YW5jZS5lbmFibGU7XG4gICAgY29uc3Qgb3JpZ2luYWxEaXNhYmxlID0gaW5zdGFuY2UuZGlzYWJsZTtcblxuICAgIGluc3RhbmNlLmRlc3Ryb3kgPSAoc2hvdWxkRGVzdHJveUNoaWxkSW5zdGFuY2VzID0gdHJ1ZSk6IHZvaWQgPT4ge1xuICAgICAgaWYgKHNob3VsZERlc3Ryb3lDaGlsZEluc3RhbmNlcykge1xuICAgICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzLmZvckVhY2goKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgaW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY2hpbGRUaXBweUluc3RhbmNlcyA9IFtdO1xuXG4gICAgICByZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgICAgb3JpZ2luYWxEZXN0cm95KCk7XG4gICAgfTtcblxuICAgIGluc3RhbmNlLmVuYWJsZSA9ICgpOiB2b2lkID0+IHtcbiAgICAgIG9yaWdpbmFsRW5hYmxlKCk7XG4gICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzLmZvckVhY2goKGluc3RhbmNlKSA9PiBpbnN0YW5jZS5lbmFibGUoKSk7XG4gICAgICBkaXNhYmxlZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBpbnN0YW5jZS5kaXNhYmxlID0gKCk6IHZvaWQgPT4ge1xuICAgICAgb3JpZ2luYWxEaXNhYmxlKCk7XG4gICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzLmZvckVhY2goKGluc3RhbmNlKSA9PiBpbnN0YW5jZS5kaXNhYmxlKCkpO1xuICAgICAgZGlzYWJsZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICBhZGRFdmVudExpc3RlbmVycyhpbnN0YW5jZSk7XG4gIH1cblxuICBub3JtYWxpemVkUmV0dXJuVmFsdWUuZm9yRWFjaChhcHBseU11dGF0aW9ucyk7XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBkZWxlZ2F0ZTtcbiIsICJpbXBvcnQge0JBQ0tEUk9QX0NMQVNTfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHtkaXYsIHNldFZpc2liaWxpdHlTdGF0ZX0gZnJvbSAnLi4vZG9tLXV0aWxzJztcbmltcG9ydCB7Z2V0Q2hpbGRyZW59IGZyb20gJy4uL3RlbXBsYXRlJztcbmltcG9ydCB7QW5pbWF0ZUZpbGx9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7ZXJyb3JXaGVufSBmcm9tICcuLi92YWxpZGF0aW9uJztcblxuY29uc3QgYW5pbWF0ZUZpbGw6IEFuaW1hdGVGaWxsID0ge1xuICBuYW1lOiAnYW5pbWF0ZUZpbGwnLFxuICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICBmbihpbnN0YW5jZSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoIWluc3RhbmNlLnByb3BzLnJlbmRlcj8uJCR0aXBweSkge1xuICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgZXJyb3JXaGVuKFxuICAgICAgICAgIGluc3RhbmNlLnByb3BzLmFuaW1hdGVGaWxsLFxuICAgICAgICAgICdUaGUgYGFuaW1hdGVGaWxsYCBwbHVnaW4gcmVxdWlyZXMgdGhlIGRlZmF1bHQgcmVuZGVyIGZ1bmN0aW9uLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGNvbnN0IHtib3gsIGNvbnRlbnR9ID0gZ2V0Q2hpbGRyZW4oaW5zdGFuY2UucG9wcGVyKTtcblxuICAgIGNvbnN0IGJhY2tkcm9wID0gaW5zdGFuY2UucHJvcHMuYW5pbWF0ZUZpbGxcbiAgICAgID8gY3JlYXRlQmFja2Ryb3BFbGVtZW50KClcbiAgICAgIDogbnVsbDtcblxuICAgIHJldHVybiB7XG4gICAgICBvbkNyZWF0ZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgYm94Lmluc2VydEJlZm9yZShiYWNrZHJvcCwgYm94LmZpcnN0RWxlbWVudENoaWxkISk7XG4gICAgICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRlZmlsbCcsICcnKTtcbiAgICAgICAgICBib3guc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICAgICAgICAgIGluc3RhbmNlLnNldFByb3BzKHthcnJvdzogZmFsc2UsIGFuaW1hdGlvbjogJ3NoaWZ0LWF3YXknfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbk1vdW50KCk6IHZvaWQge1xuICAgICAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgICAgICBjb25zdCB7dHJhbnNpdGlvbkR1cmF0aW9ufSA9IGJveC5zdHlsZTtcbiAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IE51bWJlcih0cmFuc2l0aW9uRHVyYXRpb24ucmVwbGFjZSgnbXMnLCAnJykpO1xuXG4gICAgICAgICAgLy8gVGhlIGNvbnRlbnQgc2hvdWxkIGZhZGUgaW4gYWZ0ZXIgdGhlIGJhY2tkcm9wIGhhcyBtb3N0bHkgZmlsbGVkIHRoZVxuICAgICAgICAgIC8vIHRvb2x0aXAgZWxlbWVudC4gYGNsaXAtcGF0aGAgaXMgdGhlIG90aGVyIGFsdGVybmF0aXZlIGJ1dCBpcyBub3RcbiAgICAgICAgICAvLyB3ZWxsLXN1cHBvcnRlZCBhbmQgaXMgYnVnZ3kgb24gc29tZSBkZXZpY2VzLlxuICAgICAgICAgIGNvbnRlbnQuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gYCR7TWF0aC5yb3VuZChkdXJhdGlvbiAvIDEwKX1tc2A7XG5cbiAgICAgICAgICBiYWNrZHJvcC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb247XG4gICAgICAgICAgc2V0VmlzaWJpbGl0eVN0YXRlKFtiYWNrZHJvcF0sICd2aXNpYmxlJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblNob3coKTogdm9pZCB7XG4gICAgICAgIGlmIChiYWNrZHJvcCkge1xuICAgICAgICAgIGJhY2tkcm9wLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwbXMnO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25IaWRlKCk6IHZvaWQge1xuICAgICAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgICAgICBzZXRWaXNpYmlsaXR5U3RhdGUoW2JhY2tkcm9wXSwgJ2hpZGRlbicpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH07XG4gIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBhbmltYXRlRmlsbDtcblxuZnVuY3Rpb24gY3JlYXRlQmFja2Ryb3BFbGVtZW50KCk6IEhUTUxEaXZFbGVtZW50IHtcbiAgY29uc3QgYmFja2Ryb3AgPSBkaXYoKTtcbiAgYmFja2Ryb3AuY2xhc3NOYW1lID0gQkFDS0RST1BfQ0xBU1M7XG4gIHNldFZpc2liaWxpdHlTdGF0ZShbYmFja2Ryb3BdLCAnaGlkZGVuJyk7XG4gIHJldHVybiBiYWNrZHJvcDtcbn1cbiIsICJpbXBvcnQge2dldE93bmVyRG9jdW1lbnQsIGlzTW91c2VFdmVudH0gZnJvbSAnLi4vZG9tLXV0aWxzJztcbmltcG9ydCB7Rm9sbG93Q3Vyc29yLCBJbnN0YW5jZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5sZXQgbW91c2VDb29yZHMgPSB7Y2xpZW50WDogMCwgY2xpZW50WTogMH07XG5sZXQgYWN0aXZlSW5zdGFuY2VzOiBBcnJheTx7aW5zdGFuY2U6IEluc3RhbmNlOyBkb2M6IERvY3VtZW50fT4gPSBbXTtcblxuZnVuY3Rpb24gc3RvcmVNb3VzZUNvb3Jkcyh7Y2xpZW50WCwgY2xpZW50WX06IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgbW91c2VDb29yZHMgPSB7Y2xpZW50WCwgY2xpZW50WX07XG59XG5cbmZ1bmN0aW9uIGFkZE1vdXNlQ29vcmRzTGlzdGVuZXIoZG9jOiBEb2N1bWVudCk6IHZvaWQge1xuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc3RvcmVNb3VzZUNvb3Jkcyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU1vdXNlQ29vcmRzTGlzdGVuZXIoZG9jOiBEb2N1bWVudCk6IHZvaWQge1xuICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc3RvcmVNb3VzZUNvb3Jkcyk7XG59XG5cbmNvbnN0IGZvbGxvd0N1cnNvcjogRm9sbG93Q3Vyc29yID0ge1xuICBuYW1lOiAnZm9sbG93Q3Vyc29yJyxcbiAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgZm4oaW5zdGFuY2UpIHtcbiAgICBjb25zdCByZWZlcmVuY2UgPSBpbnN0YW5jZS5yZWZlcmVuY2U7XG4gICAgY29uc3QgZG9jID0gZ2V0T3duZXJEb2N1bWVudChpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSk7XG5cbiAgICBsZXQgaXNJbnRlcm5hbFVwZGF0ZSA9IGZhbHNlO1xuICAgIGxldCB3YXNGb2N1c0V2ZW50ID0gZmFsc2U7XG4gICAgbGV0IGlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICBsZXQgcHJldlByb3BzID0gaW5zdGFuY2UucHJvcHM7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0luaXRpYWxCZWhhdmlvcigpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvciA9PT0gJ2luaXRpYWwnICYmIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRMaXN0ZW5lcigpOiB2b2lkIHtcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoKTogdm9pZCB7XG4gICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuc2V0R2V0UmVmZXJlbmNlQ2xpZW50UmVjdCgpOiB2b2lkIHtcbiAgICAgIGlzSW50ZXJuYWxVcGRhdGUgPSB0cnVlO1xuICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe2dldFJlZmVyZW5jZUNsaWVudFJlY3Q6IG51bGx9KTtcbiAgICAgIGlzSW50ZXJuYWxVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgLy8gSWYgdGhlIGluc3RhbmNlIGlzIGludGVyYWN0aXZlLCBhdm9pZCB1cGRhdGluZyB0aGUgcG9zaXRpb24gdW5sZXNzIGl0J3NcbiAgICAgIC8vIG92ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAgICBjb25zdCBpc0N1cnNvck92ZXJSZWZlcmVuY2UgPSBldmVudC50YXJnZXRcbiAgICAgICAgPyByZWZlcmVuY2UuY29udGFpbnMoZXZlbnQudGFyZ2V0IGFzIE5vZGUpXG4gICAgICAgIDogdHJ1ZTtcbiAgICAgIGNvbnN0IHtmb2xsb3dDdXJzb3J9ID0gaW5zdGFuY2UucHJvcHM7XG4gICAgICBjb25zdCB7Y2xpZW50WCwgY2xpZW50WX0gPSBldmVudDtcblxuICAgICAgY29uc3QgcmVjdCA9IHJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHJlbGF0aXZlWCA9IGNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgICBjb25zdCByZWxhdGl2ZVkgPSBjbGllbnRZIC0gcmVjdC50b3A7XG5cbiAgICAgIGlmIChpc0N1cnNvck92ZXJSZWZlcmVuY2UgfHwgIWluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gdW5uZWVkZWQgRE9NUmVjdCBwcm9wZXJ0aWVzXG4gICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSByZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgIGxldCB4ID0gY2xpZW50WDtcbiAgICAgICAgICAgIGxldCB5ID0gY2xpZW50WTtcblxuICAgICAgICAgICAgaWYgKGZvbGxvd0N1cnNvciA9PT0gJ2luaXRpYWwnKSB7XG4gICAgICAgICAgICAgIHggPSByZWN0LmxlZnQgKyByZWxhdGl2ZVg7XG4gICAgICAgICAgICAgIHkgPSByZWN0LnRvcCArIHJlbGF0aXZlWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdG9wID0gZm9sbG93Q3Vyc29yID09PSAnaG9yaXpvbnRhbCcgPyByZWN0LnRvcCA6IHk7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGZvbGxvd0N1cnNvciA9PT0gJ3ZlcnRpY2FsJyA/IHJlY3QucmlnaHQgOiB4O1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gZm9sbG93Q3Vyc29yID09PSAnaG9yaXpvbnRhbCcgPyByZWN0LmJvdHRvbSA6IHk7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gZm9sbG93Q3Vyc29yID09PSAndmVydGljYWwnID8gcmVjdC5sZWZ0IDogeDtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBib3R0b20gLSB0b3AsXG4gICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlKCk6IHZvaWQge1xuICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvcikge1xuICAgICAgICBhY3RpdmVJbnN0YW5jZXMucHVzaCh7aW5zdGFuY2UsIGRvY30pO1xuICAgICAgICBhZGRNb3VzZUNvb3Jkc0xpc3RlbmVyKGRvYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVzdHJveSgpOiB2b2lkIHtcbiAgICAgIGFjdGl2ZUluc3RhbmNlcyA9IGFjdGl2ZUluc3RhbmNlcy5maWx0ZXIoXG4gICAgICAgIChkYXRhKSA9PiBkYXRhLmluc3RhbmNlICE9PSBpbnN0YW5jZVxuICAgICAgKTtcblxuICAgICAgaWYgKGFjdGl2ZUluc3RhbmNlcy5maWx0ZXIoKGRhdGEpID0+IGRhdGEuZG9jID09PSBkb2MpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZW1vdmVNb3VzZUNvb3Jkc0xpc3RlbmVyKGRvYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ3JlYXRlOiBjcmVhdGUsXG4gICAgICBvbkRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICBvbkJlZm9yZVVwZGF0ZSgpOiB2b2lkIHtcbiAgICAgICAgcHJldlByb3BzID0gaW5zdGFuY2UucHJvcHM7XG4gICAgICB9LFxuICAgICAgb25BZnRlclVwZGF0ZShfLCB7Zm9sbG93Q3Vyc29yfSk6IHZvaWQge1xuICAgICAgICBpZiAoaXNJbnRlcm5hbFVwZGF0ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBmb2xsb3dDdXJzb3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgIHByZXZQcm9wcy5mb2xsb3dDdXJzb3IgIT09IGZvbGxvd0N1cnNvclxuICAgICAgICApIHtcbiAgICAgICAgICBkZXN0cm95KCk7XG5cbiAgICAgICAgICBpZiAoZm9sbG93Q3Vyc29yKSB7XG4gICAgICAgICAgICBjcmVhdGUoKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQgJiZcbiAgICAgICAgICAgICAgIXdhc0ZvY3VzRXZlbnQgJiZcbiAgICAgICAgICAgICAgIWdldElzSW5pdGlhbEJlaGF2aW9yKClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBhZGRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgdW5zZXRHZXRSZWZlcmVuY2VDbGllbnRSZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Nb3VudCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvciAmJiAhd2FzRm9jdXNFdmVudCkge1xuICAgICAgICAgIGlmIChpc1VubW91bnRlZCkge1xuICAgICAgICAgICAgb25Nb3VzZU1vdmUobW91c2VDb29yZHMgYXMgTW91c2VFdmVudCk7XG4gICAgICAgICAgICBpc1VubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZ2V0SXNJbml0aWFsQmVoYXZpb3IoKSkge1xuICAgICAgICAgICAgYWRkTGlzdGVuZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblRyaWdnZXIoXywgZXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzTW91c2VFdmVudChldmVudCkpIHtcbiAgICAgICAgICBtb3VzZUNvb3JkcyA9IHtjbGllbnRYOiBldmVudC5jbGllbnRYLCBjbGllbnRZOiBldmVudC5jbGllbnRZfTtcbiAgICAgICAgfVxuICAgICAgICB3YXNGb2N1c0V2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2ZvY3VzJztcbiAgICAgIH0sXG4gICAgICBvbkhpZGRlbigpOiB2b2lkIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvcikge1xuICAgICAgICAgIHVuc2V0R2V0UmVmZXJlbmNlQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgaXNVbm1vdW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH07XG4gIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmb2xsb3dDdXJzb3I7XG4iLCAiaW1wb3J0IHtNb2RpZmllciwgUGxhY2VtZW50fSBmcm9tICdAcG9wcGVyanMvY29yZSc7XG5pbXBvcnQge2lzTW91c2VFdmVudH0gZnJvbSAnLi4vZG9tLXV0aWxzJztcbmltcG9ydCB7QmFzZVBsYWNlbWVudCwgSW5saW5lUG9zaXRpb25pbmcsIFByb3BzfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge2FycmF5RnJvbSwgZ2V0QmFzZVBsYWNlbWVudH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5mdW5jdGlvbiBnZXRQcm9wcyhwcm9wczogUHJvcHMsIG1vZGlmaWVyOiBNb2RpZmllcjxhbnksIGFueT4pOiBQYXJ0aWFsPFByb3BzPiB7XG4gIHJldHVybiB7XG4gICAgcG9wcGVyT3B0aW9uczoge1xuICAgICAgLi4ucHJvcHMucG9wcGVyT3B0aW9ucyxcbiAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICAuLi4ocHJvcHMucG9wcGVyT3B0aW9ucz8ubW9kaWZpZXJzIHx8IFtdKS5maWx0ZXIoXG4gICAgICAgICAgKHtuYW1lfSkgPT4gbmFtZSAhPT0gbW9kaWZpZXIubmFtZVxuICAgICAgICApLFxuICAgICAgICBtb2RpZmllcixcbiAgICAgIF0sXG4gICAgfSxcbiAgfTtcbn1cblxuY29uc3QgaW5saW5lUG9zaXRpb25pbmc6IElubGluZVBvc2l0aW9uaW5nID0ge1xuICBuYW1lOiAnaW5saW5lUG9zaXRpb25pbmcnLFxuICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICBmbihpbnN0YW5jZSkge1xuICAgIGNvbnN0IHtyZWZlcmVuY2V9ID0gaW5zdGFuY2U7XG5cbiAgICBmdW5jdGlvbiBpc0VuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gISFpbnN0YW5jZS5wcm9wcy5pbmxpbmVQb3NpdGlvbmluZztcbiAgICB9XG5cbiAgICBsZXQgcGxhY2VtZW50OiBQbGFjZW1lbnQ7XG4gICAgbGV0IGN1cnNvclJlY3RJbmRleCA9IC0xO1xuICAgIGxldCBpc0ludGVybmFsVXBkYXRlID0gZmFsc2U7XG4gICAgbGV0IHRyaWVkUGxhY2VtZW50czogQXJyYXk8c3RyaW5nPiA9IFtdO1xuXG4gICAgY29uc3QgbW9kaWZpZXI6IE1vZGlmaWVyPFxuICAgICAgJ3RpcHB5SW5saW5lUG9zaXRpb25pbmcnLFxuICAgICAgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgICA+ID0ge1xuICAgICAgbmFtZTogJ3RpcHB5SW5saW5lUG9zaXRpb25pbmcnLFxuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIHBoYXNlOiAnYWZ0ZXJXcml0ZScsXG4gICAgICBmbih7c3RhdGV9KSB7XG4gICAgICAgIGlmIChpc0VuYWJsZWQoKSkge1xuICAgICAgICAgIGlmICh0cmllZFBsYWNlbWVudHMuaW5kZXhPZihzdGF0ZS5wbGFjZW1lbnQpICE9PSAtMSkge1xuICAgICAgICAgICAgdHJpZWRQbGFjZW1lbnRzID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcGxhY2VtZW50ICE9PSBzdGF0ZS5wbGFjZW1lbnQgJiZcbiAgICAgICAgICAgIHRyaWVkUGxhY2VtZW50cy5pbmRleE9mKHN0YXRlLnBsYWNlbWVudCkgPT09IC0xXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0cmllZFBsYWNlbWVudHMucHVzaChzdGF0ZS5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe1xuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gdW5uZWVkZWQgRE9NUmVjdCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6ICgpID0+XG4gICAgICAgICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGxhY2VtZW50ID0gc3RhdGUucGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRSZWZlcmVuY2VDbGllbnRSZWN0KHBsYWNlbWVudDogUGxhY2VtZW50KTogUGFydGlhbDxET01SZWN0PiB7XG4gICAgICByZXR1cm4gZ2V0SW5saW5lQm91bmRpbmdDbGllbnRSZWN0KFxuICAgICAgICBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCksXG4gICAgICAgIHJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgYXJyYXlGcm9tKHJlZmVyZW5jZS5nZXRDbGllbnRSZWN0cygpKSxcbiAgICAgICAgY3Vyc29yUmVjdEluZGV4XG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEludGVybmFsUHJvcHMocGFydGlhbFByb3BzOiBQYXJ0aWFsPFByb3BzPik6IHZvaWQge1xuICAgICAgaXNJbnRlcm5hbFVwZGF0ZSA9IHRydWU7XG4gICAgICBpbnN0YW5jZS5zZXRQcm9wcyhwYXJ0aWFsUHJvcHMpO1xuICAgICAgaXNJbnRlcm5hbFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZE1vZGlmaWVyKCk6IHZvaWQge1xuICAgICAgaWYgKCFpc0ludGVybmFsVXBkYXRlKSB7XG4gICAgICAgIHNldEludGVybmFsUHJvcHMoZ2V0UHJvcHMoaW5zdGFuY2UucHJvcHMsIG1vZGlmaWVyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ3JlYXRlOiBhZGRNb2RpZmllcixcbiAgICAgIG9uQWZ0ZXJVcGRhdGU6IGFkZE1vZGlmaWVyLFxuICAgICAgb25UcmlnZ2VyKF8sIGV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmIChpc01vdXNlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgY29uc3QgcmVjdHMgPSBhcnJheUZyb20oaW5zdGFuY2UucmVmZXJlbmNlLmdldENsaWVudFJlY3RzKCkpO1xuICAgICAgICAgIGNvbnN0IGN1cnNvclJlY3QgPSByZWN0cy5maW5kKFxuICAgICAgICAgICAgKHJlY3QpID0+XG4gICAgICAgICAgICAgIHJlY3QubGVmdCAtIDIgPD0gZXZlbnQuY2xpZW50WCAmJlxuICAgICAgICAgICAgICByZWN0LnJpZ2h0ICsgMiA+PSBldmVudC5jbGllbnRYICYmXG4gICAgICAgICAgICAgIHJlY3QudG9wIC0gMiA8PSBldmVudC5jbGllbnRZICYmXG4gICAgICAgICAgICAgIHJlY3QuYm90dG9tICsgMiA+PSBldmVudC5jbGllbnRZXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHJlY3RzLmluZGV4T2YoY3Vyc29yUmVjdCk7XG4gICAgICAgICAgY3Vyc29yUmVjdEluZGV4ID0gaW5kZXggPiAtMSA/IGluZGV4IDogY3Vyc29yUmVjdEluZGV4O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25IaWRkZW4oKTogdm9pZCB7XG4gICAgICAgIGN1cnNvclJlY3RJbmRleCA9IC0xO1xuICAgICAgfSxcbiAgICB9O1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgaW5saW5lUG9zaXRpb25pbmc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmxpbmVCb3VuZGluZ0NsaWVudFJlY3QoXG4gIGN1cnJlbnRCYXNlUGxhY2VtZW50OiBCYXNlUGxhY2VtZW50IHwgbnVsbCxcbiAgYm91bmRpbmdSZWN0OiBET01SZWN0LFxuICBjbGllbnRSZWN0czogRE9NUmVjdFtdLFxuICBjdXJzb3JSZWN0SW5kZXg6IG51bWJlclxuKToge1xuICB0b3A6IG51bWJlcjtcbiAgYm90dG9tOiBudW1iZXI7XG4gIGxlZnQ6IG51bWJlcjtcbiAgcmlnaHQ6IG51bWJlcjtcbiAgd2lkdGg6IG51bWJlcjtcbiAgaGVpZ2h0OiBudW1iZXI7XG59IHtcbiAgLy8gTm90IGFuIGlubGluZSBlbGVtZW50LCBvciBwbGFjZW1lbnQgaXMgbm90IHlldCBrbm93blxuICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoIDwgMiB8fCBjdXJyZW50QmFzZVBsYWNlbWVudCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBib3VuZGluZ1JlY3Q7XG4gIH1cblxuICAvLyBUaGVyZSBhcmUgdHdvIHJlY3RzIGFuZCB0aGV5IGFyZSBkaXNqb2luZWRcbiAgaWYgKFxuICAgIGNsaWVudFJlY3RzLmxlbmd0aCA9PT0gMiAmJlxuICAgIGN1cnNvclJlY3RJbmRleCA+PSAwICYmXG4gICAgY2xpZW50UmVjdHNbMF0ubGVmdCA+IGNsaWVudFJlY3RzWzFdLnJpZ2h0XG4gICkge1xuICAgIHJldHVybiBjbGllbnRSZWN0c1tjdXJzb3JSZWN0SW5kZXhdIHx8IGJvdW5kaW5nUmVjdDtcbiAgfVxuXG4gIHN3aXRjaCAoY3VycmVudEJhc2VQbGFjZW1lbnQpIHtcbiAgICBjYXNlICd0b3AnOlxuICAgIGNhc2UgJ2JvdHRvbSc6IHtcbiAgICAgIGNvbnN0IGZpcnN0UmVjdCA9IGNsaWVudFJlY3RzWzBdO1xuICAgICAgY29uc3QgbGFzdFJlY3QgPSBjbGllbnRSZWN0c1tjbGllbnRSZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGlzVG9wID0gY3VycmVudEJhc2VQbGFjZW1lbnQgPT09ICd0b3AnO1xuXG4gICAgICBjb25zdCB0b3AgPSBmaXJzdFJlY3QudG9wO1xuICAgICAgY29uc3QgYm90dG9tID0gbGFzdFJlY3QuYm90dG9tO1xuICAgICAgY29uc3QgbGVmdCA9IGlzVG9wID8gZmlyc3RSZWN0LmxlZnQgOiBsYXN0UmVjdC5sZWZ0O1xuICAgICAgY29uc3QgcmlnaHQgPSBpc1RvcCA/IGZpcnN0UmVjdC5yaWdodCA6IGxhc3RSZWN0LnJpZ2h0O1xuICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG5cbiAgICAgIHJldHVybiB7dG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0LCB3aWR0aCwgaGVpZ2h0fTtcbiAgICB9XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgY2FzZSAncmlnaHQnOiB7XG4gICAgICBjb25zdCBtaW5MZWZ0ID0gTWF0aC5taW4oLi4uY2xpZW50UmVjdHMubWFwKChyZWN0cykgPT4gcmVjdHMubGVmdCkpO1xuICAgICAgY29uc3QgbWF4UmlnaHQgPSBNYXRoLm1heCguLi5jbGllbnRSZWN0cy5tYXAoKHJlY3RzKSA9PiByZWN0cy5yaWdodCkpO1xuICAgICAgY29uc3QgbWVhc3VyZVJlY3RzID0gY2xpZW50UmVjdHMuZmlsdGVyKChyZWN0KSA9PlxuICAgICAgICBjdXJyZW50QmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnXG4gICAgICAgICAgPyByZWN0LmxlZnQgPT09IG1pbkxlZnRcbiAgICAgICAgICA6IHJlY3QucmlnaHQgPT09IG1heFJpZ2h0XG4gICAgICApO1xuXG4gICAgICBjb25zdCB0b3AgPSBtZWFzdXJlUmVjdHNbMF0udG9wO1xuICAgICAgY29uc3QgYm90dG9tID0gbWVhc3VyZVJlY3RzW21lYXN1cmVSZWN0cy5sZW5ndGggLSAxXS5ib3R0b207XG4gICAgICBjb25zdCBsZWZ0ID0gbWluTGVmdDtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gbWF4UmlnaHQ7XG4gICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcblxuICAgICAgcmV0dXJuIHt0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQsIHdpZHRoLCBoZWlnaHR9O1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gYm91bmRpbmdSZWN0O1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7VmlydHVhbEVsZW1lbnR9IGZyb20gJ0Bwb3BwZXJqcy9jb3JlJztcbmltcG9ydCB7UmVmZXJlbmNlRWxlbWVudCwgU3RpY2t5fSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IHN0aWNreTogU3RpY2t5ID0ge1xuICBuYW1lOiAnc3RpY2t5JyxcbiAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgZm4oaW5zdGFuY2UpIHtcbiAgICBjb25zdCB7cmVmZXJlbmNlLCBwb3BwZXJ9ID0gaW5zdGFuY2U7XG5cbiAgICBmdW5jdGlvbiBnZXRSZWZlcmVuY2UoKTogUmVmZXJlbmNlRWxlbWVudCB8IFZpcnR1YWxFbGVtZW50IHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZVxuICAgICAgICA/IGluc3RhbmNlLnBvcHBlckluc3RhbmNlLnN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZVxuICAgICAgICA6IHJlZmVyZW5jZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG91bGRDaGVjayh2YWx1ZTogJ3JlZmVyZW5jZScgfCAncG9wcGVyJyk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnByb3BzLnN0aWNreSA9PT0gdHJ1ZSB8fCBpbnN0YW5jZS5wcm9wcy5zdGlja3kgPT09IHZhbHVlO1xuICAgIH1cblxuICAgIGxldCBwcmV2UmVmUmVjdDogQ2xpZW50UmVjdCB8IG51bGwgPSBudWxsO1xuICAgIGxldCBwcmV2UG9wUmVjdDogQ2xpZW50UmVjdCB8IG51bGwgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oKTogdm9pZCB7XG4gICAgICBjb25zdCBjdXJyZW50UmVmUmVjdCA9IHNob3VsZENoZWNrKCdyZWZlcmVuY2UnKVxuICAgICAgICA/IGdldFJlZmVyZW5jZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIDogbnVsbDtcbiAgICAgIGNvbnN0IGN1cnJlbnRQb3BSZWN0ID0gc2hvdWxkQ2hlY2soJ3BvcHBlcicpXG4gICAgICAgID8gcG9wcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIDogbnVsbDtcblxuICAgICAgaWYgKFxuICAgICAgICAoY3VycmVudFJlZlJlY3QgJiYgYXJlUmVjdHNEaWZmZXJlbnQocHJldlJlZlJlY3QsIGN1cnJlbnRSZWZSZWN0KSkgfHxcbiAgICAgICAgKGN1cnJlbnRQb3BSZWN0ICYmIGFyZVJlY3RzRGlmZmVyZW50KHByZXZQb3BSZWN0LCBjdXJyZW50UG9wUmVjdCkpXG4gICAgICApIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICAgICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldlJlZlJlY3QgPSBjdXJyZW50UmVmUmVjdDtcbiAgICAgIHByZXZQb3BSZWN0ID0gY3VycmVudFBvcFJlY3Q7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZVBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb25Nb3VudCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzLnN0aWNreSkge1xuICAgICAgICAgIHVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHN0aWNreTtcblxuZnVuY3Rpb24gYXJlUmVjdHNEaWZmZXJlbnQoXG4gIHJlY3RBOiBDbGllbnRSZWN0IHwgbnVsbCxcbiAgcmVjdEI6IENsaWVudFJlY3QgfCBudWxsXG4pOiBib29sZWFuIHtcbiAgaWYgKHJlY3RBICYmIHJlY3RCKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHJlY3RBLnRvcCAhPT0gcmVjdEIudG9wIHx8XG4gICAgICByZWN0QS5yaWdodCAhPT0gcmVjdEIucmlnaHQgfHxcbiAgICAgIHJlY3RBLmJvdHRvbSAhPT0gcmVjdEIuYm90dG9tIHx8XG4gICAgICByZWN0QS5sZWZ0ICE9PSByZWN0Qi5sZWZ0XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuIiwgImltcG9ydCB0aXBweSBmcm9tICcuLi9zcmMnO1xuaW1wb3J0IHtyZW5kZXJ9IGZyb20gJy4uL3NyYy90ZW1wbGF0ZSc7XG5cbnRpcHB5LnNldERlZmF1bHRQcm9wcyh7cmVuZGVyfSk7XG5cbmV4cG9ydCB7ZGVmYXVsdCwgaGlkZUFsbH0gZnJvbSAnLi4vc3JjJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjcmVhdGVTaW5nbGV0b259IGZyb20gJy4uL3NyYy9hZGRvbnMvY3JlYXRlU2luZ2xldG9uJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBkZWxlZ2F0ZX0gZnJvbSAnLi4vc3JjL2FkZG9ucy9kZWxlZ2F0ZSc7XG5leHBvcnQge2RlZmF1bHQgYXMgYW5pbWF0ZUZpbGx9IGZyb20gJy4uL3NyYy9wbHVnaW5zL2FuaW1hdGVGaWxsJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBmb2xsb3dDdXJzb3J9IGZyb20gJy4uL3NyYy9wbHVnaW5zL2ZvbGxvd0N1cnNvcic7XG5leHBvcnQge2RlZmF1bHQgYXMgaW5saW5lUG9zaXRpb25pbmd9IGZyb20gJy4uL3NyYy9wbHVnaW5zL2lubGluZVBvc2l0aW9uaW5nJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdGlja3l9IGZyb20gJy4uL3NyYy9wbHVnaW5zL3N0aWNreSc7XG5leHBvcnQge1JPVU5EX0FSUk9XIGFzIHJvdW5kQXJyb3d9IGZyb20gJy4uL3NyYy9jb25zdGFudHMnO1xuIiwgImltcG9ydCB7XG4gIEVkaXRvciwgaXNOb2RlU2VsZWN0aW9uLCBpc1RleHRTZWxlY3Rpb24sIHBvc1RvRE9NUmVjdCxcbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHsgRWRpdG9yU3RhdGUsIFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnXG5pbXBvcnQgdGlwcHksIHsgSW5zdGFuY2UsIFByb3BzIH0gZnJvbSAndGlwcHkuanMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQnViYmxlTWVudVBsdWdpblByb3BzIHtcbiAgcGx1Z2luS2V5OiBQbHVnaW5LZXkgfCBzdHJpbmdcbiAgZWRpdG9yOiBFZGl0b3JcbiAgZWxlbWVudDogSFRNTEVsZW1lbnRcbiAgdGlwcHlPcHRpb25zPzogUGFydGlhbDxQcm9wcz5cbiAgdXBkYXRlRGVsYXk/OiBudW1iZXJcbiAgc2hvdWxkU2hvdz86XG4gICAgfCAoKHByb3BzOiB7XG4gICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgIHZpZXc6IEVkaXRvclZpZXdcbiAgICAgICAgc3RhdGU6IEVkaXRvclN0YXRlXG4gICAgICAgIG9sZFN0YXRlPzogRWRpdG9yU3RhdGVcbiAgICAgICAgZnJvbTogbnVtYmVyXG4gICAgICAgIHRvOiBudW1iZXJcbiAgICAgIH0pID0+IGJvb2xlYW4pXG4gICAgfCBudWxsXG59XG5cbmV4cG9ydCB0eXBlIEJ1YmJsZU1lbnVWaWV3UHJvcHMgPSBCdWJibGVNZW51UGx1Z2luUHJvcHMgJiB7XG4gIHZpZXc6IEVkaXRvclZpZXdcbn1cblxuZXhwb3J0IGNsYXNzIEJ1YmJsZU1lbnVWaWV3IHtcbiAgcHVibGljIGVkaXRvcjogRWRpdG9yXG5cbiAgcHVibGljIGVsZW1lbnQ6IEhUTUxFbGVtZW50XG5cbiAgcHVibGljIHZpZXc6IEVkaXRvclZpZXdcblxuICBwdWJsaWMgcHJldmVudEhpZGUgPSBmYWxzZVxuXG4gIHB1YmxpYyB0aXBweTogSW5zdGFuY2UgfCB1bmRlZmluZWRcblxuICBwdWJsaWMgdGlwcHlPcHRpb25zPzogUGFydGlhbDxQcm9wcz5cblxuICBwdWJsaWMgdXBkYXRlRGVsYXk6IG51bWJlclxuXG4gIHByaXZhdGUgdXBkYXRlRGVib3VuY2VUaW1lcjogbnVtYmVyIHwgdW5kZWZpbmVkXG5cbiAgcHVibGljIHNob3VsZFNob3c6IEV4Y2x1ZGU8QnViYmxlTWVudVBsdWdpblByb3BzWydzaG91bGRTaG93J10sIG51bGw+ID0gKHtcbiAgICB2aWV3LFxuICAgIHN0YXRlLFxuICAgIGZyb20sXG4gICAgdG8sXG4gIH0pID0+IHtcbiAgICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHsgZW1wdHkgfSA9IHNlbGVjdGlvblxuXG4gICAgLy8gU29tZXRpbWUgY2hlY2sgZm9yIGBlbXB0eWAgaXMgbm90IGVub3VnaC5cbiAgICAvLyBEb3VibGVjbGljayBhbiBlbXB0eSBwYXJhZ3JhcGggcmV0dXJucyBhIG5vZGUgc2l6ZSBvZiAyLlxuICAgIC8vIFNvIHdlIGNoZWNrIGFsc28gZm9yIGFuIGVtcHR5IHRleHQgc2l6ZS5cbiAgICBjb25zdCBpc0VtcHR5VGV4dEJsb2NrID0gIWRvYy50ZXh0QmV0d2Vlbihmcm9tLCB0bykubGVuZ3RoICYmIGlzVGV4dFNlbGVjdGlvbihzdGF0ZS5zZWxlY3Rpb24pXG5cbiAgICAvLyBXaGVuIGNsaWNraW5nIG9uIGEgZWxlbWVudCBpbnNpZGUgdGhlIGJ1YmJsZSBtZW51IHRoZSBlZGl0b3IgXCJibHVyXCIgZXZlbnRcbiAgICAvLyBpcyBjYWxsZWQgYW5kIHRoZSBidWJibGUgbWVudSBpdGVtIGlzIGZvY3Vzc2VkLiBJbiB0aGlzIGNhc2Ugd2Ugc2hvdWxkXG4gICAgLy8gY29uc2lkZXIgdGhlIG1lbnUgYXMgcGFydCBvZiB0aGUgZWRpdG9yIGFuZCBrZWVwIHNob3dpbmcgdGhlIG1lbnVcbiAgICBjb25zdCBpc0NoaWxkT2ZNZW51ID0gdGhpcy5lbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpXG5cbiAgICBjb25zdCBoYXNFZGl0b3JGb2N1cyA9IHZpZXcuaGFzRm9jdXMoKSB8fCBpc0NoaWxkT2ZNZW51XG5cbiAgICBpZiAoIWhhc0VkaXRvckZvY3VzIHx8IGVtcHR5IHx8IGlzRW1wdHlUZXh0QmxvY2sgfHwgIXRoaXMuZWRpdG9yLmlzRWRpdGFibGUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgZWRpdG9yLFxuICAgIGVsZW1lbnQsXG4gICAgdmlldyxcbiAgICB0aXBweU9wdGlvbnMgPSB7fSxcbiAgICB1cGRhdGVEZWxheSA9IDI1MCxcbiAgICBzaG91bGRTaG93LFxuICB9OiBCdWJibGVNZW51Vmlld1Byb3BzKSB7XG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50XG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMudXBkYXRlRGVsYXkgPSB1cGRhdGVEZWxheVxuXG4gICAgaWYgKHNob3VsZFNob3cpIHtcbiAgICAgIHRoaXMuc2hvdWxkU2hvdyA9IHNob3VsZFNob3dcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZWRvd25IYW5kbGVyLCB7IGNhcHR1cmU6IHRydWUgfSlcbiAgICB0aGlzLnZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuZHJhZ3N0YXJ0SGFuZGxlcilcbiAgICB0aGlzLmVkaXRvci5vbignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcilcbiAgICB0aGlzLmVkaXRvci5vbignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXIpXG4gICAgdGhpcy50aXBweU9wdGlvbnMgPSB0aXBweU9wdGlvbnNcbiAgICAvLyBEZXRhY2hlcyBtZW51IGNvbnRlbnQgZnJvbSBpdHMgY3VycmVudCBwYXJlbnRcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlKClcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJ1xuICB9XG5cbiAgbW91c2Vkb3duSGFuZGxlciA9ICgpID0+IHtcbiAgICB0aGlzLnByZXZlbnRIaWRlID0gdHJ1ZVxuICB9XG5cbiAgZHJhZ3N0YXJ0SGFuZGxlciA9ICgpID0+IHtcbiAgICB0aGlzLmhpZGUoKVxuICB9XG5cbiAgZm9jdXNIYW5kbGVyID0gKCkgPT4ge1xuICAgIC8vIHdlIHVzZSBgc2V0VGltZW91dGAgdG8gbWFrZSBzdXJlIGBzZWxlY3Rpb25gIGlzIGFscmVhZHkgdXBkYXRlZFxuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGUodGhpcy5lZGl0b3IudmlldykpXG4gIH1cblxuICBibHVySGFuZGxlciA9ICh7IGV2ZW50IH06IHsgZXZlbnQ6IEZvY3VzRXZlbnQgfSkgPT4ge1xuICAgIGlmICh0aGlzLnByZXZlbnRIaWRlKSB7XG4gICAgICB0aGlzLnByZXZlbnRIaWRlID0gZmFsc2VcblxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50Py5yZWxhdGVkVGFyZ2V0ICYmIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlPy5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0IGFzIE5vZGUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmhpZGUoKVxuICB9XG5cbiAgdGlwcHlCbHVySGFuZGxlciA9IChldmVudDogRm9jdXNFdmVudCkgPT4ge1xuICAgIHRoaXMuYmx1ckhhbmRsZXIoeyBldmVudCB9KVxuICB9XG5cbiAgY3JlYXRlVG9vbHRpcCgpIHtcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGVkaXRvckVsZW1lbnQgfSA9IHRoaXMuZWRpdG9yLm9wdGlvbnNcbiAgICBjb25zdCBlZGl0b3JJc0F0dGFjaGVkID0gISFlZGl0b3JFbGVtZW50LnBhcmVudEVsZW1lbnRcblxuICAgIGlmICh0aGlzLnRpcHB5IHx8ICFlZGl0b3JJc0F0dGFjaGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnRpcHB5ID0gdGlwcHkoZWRpdG9yRWxlbWVudCwge1xuICAgICAgZHVyYXRpb246IDAsXG4gICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiBudWxsLFxuICAgICAgY29udGVudDogdGhpcy5lbGVtZW50LFxuICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXG4gICAgICB0cmlnZ2VyOiAnbWFudWFsJyxcbiAgICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgICBoaWRlT25DbGljazogJ3RvZ2dsZScsXG4gICAgICAuLi50aGlzLnRpcHB5T3B0aW9ucyxcbiAgICB9KVxuXG4gICAgLy8gbWF5YmUgd2UgaGF2ZSB0byBoaWRlIHRpcHB5IG9uIGl0cyBvd24gYmx1ciBldmVudCBhcyB3ZWxsXG4gICAgaWYgKHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICh0aGlzLnRpcHB5LnBvcHBlci5maXJzdENoaWxkIGFzIEhUTUxFbGVtZW50KS5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy50aXBweUJsdXJIYW5kbGVyKVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSh2aWV3OiBFZGl0b3JWaWV3LCBvbGRTdGF0ZT86IEVkaXRvclN0YXRlKSB7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gdmlld1xuICAgIGNvbnN0IGhhc1ZhbGlkU2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBvcyAhPT0gc3RhdGUuc2VsZWN0aW9uLiR0by5wb3NcblxuICAgIGlmICh0aGlzLnVwZGF0ZURlbGF5ID4gMCAmJiBoYXNWYWxpZFNlbGVjdGlvbikge1xuICAgICAgdGhpcy5oYW5kbGVEZWJvdW5jZWRVcGRhdGUodmlldywgb2xkU3RhdGUpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3Rpb25DaGFuZ2VkID0gIW9sZFN0YXRlPy5zZWxlY3Rpb24uZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pXG4gICAgY29uc3QgZG9jQ2hhbmdlZCA9ICFvbGRTdGF0ZT8uZG9jLmVxKHZpZXcuc3RhdGUuZG9jKVxuXG4gICAgdGhpcy51cGRhdGVIYW5kbGVyKHZpZXcsIHNlbGVjdGlvbkNoYW5nZWQsIGRvY0NoYW5nZWQsIG9sZFN0YXRlKVxuICB9XG5cbiAgaGFuZGxlRGVib3VuY2VkVXBkYXRlID0gKHZpZXc6IEVkaXRvclZpZXcsIG9sZFN0YXRlPzogRWRpdG9yU3RhdGUpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb25DaGFuZ2VkID0gIW9sZFN0YXRlPy5zZWxlY3Rpb24uZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pXG4gICAgY29uc3QgZG9jQ2hhbmdlZCA9ICFvbGRTdGF0ZT8uZG9jLmVxKHZpZXcuc3RhdGUuZG9jKVxuXG4gICAgaWYgKCFzZWxlY3Rpb25DaGFuZ2VkICYmICFkb2NDaGFuZ2VkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy51cGRhdGVEZWJvdW5jZVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy51cGRhdGVEZWJvdW5jZVRpbWVyKVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlRGVib3VuY2VUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlSGFuZGxlcih2aWV3LCBzZWxlY3Rpb25DaGFuZ2VkLCBkb2NDaGFuZ2VkLCBvbGRTdGF0ZSlcbiAgICB9LCB0aGlzLnVwZGF0ZURlbGF5KVxuICB9XG5cbiAgdXBkYXRlSGFuZGxlciA9ICh2aWV3OiBFZGl0b3JWaWV3LCBzZWxlY3Rpb25DaGFuZ2VkOiBib29sZWFuLCBkb2NDaGFuZ2VkOiBib29sZWFuLCBvbGRTdGF0ZT86IEVkaXRvclN0YXRlKSA9PiB7XG4gICAgY29uc3QgeyBzdGF0ZSwgY29tcG9zaW5nIH0gPSB2aWV3XG4gICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlXG5cbiAgICBjb25zdCBpc1NhbWUgPSAhc2VsZWN0aW9uQ2hhbmdlZCAmJiAhZG9jQ2hhbmdlZFxuXG4gICAgaWYgKGNvbXBvc2luZyB8fCBpc1NhbWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY3JlYXRlVG9vbHRpcCgpXG5cbiAgICAvLyBzdXBwb3J0IGZvciBDZWxsU2VsZWN0aW9uc1xuICAgIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb25cbiAgICBjb25zdCBmcm9tID0gTWF0aC5taW4oLi4ucmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS4kZnJvbS5wb3MpKVxuICAgIGNvbnN0IHRvID0gTWF0aC5tYXgoLi4ucmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS4kdG8ucG9zKSlcblxuICAgIGNvbnN0IHNob3VsZFNob3cgPSB0aGlzLnNob3VsZFNob3c/Lih7XG4gICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgdmlldyxcbiAgICAgIHN0YXRlLFxuICAgICAgb2xkU3RhdGUsXG4gICAgICBmcm9tLFxuICAgICAgdG8sXG4gICAgfSlcblxuICAgIGlmICghc2hvdWxkU2hvdykge1xuICAgICAgdGhpcy5oaWRlKClcblxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy50aXBweT8uc2V0UHJvcHMoe1xuICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDpcbiAgICAgICAgdGhpcy50aXBweU9wdGlvbnM/LmdldFJlZmVyZW5jZUNsaWVudFJlY3RcbiAgICAgICAgfHwgKCgpID0+IHtcbiAgICAgICAgICBpZiAoaXNOb2RlU2VsZWN0aW9uKHN0YXRlLnNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gdmlldy5ub2RlRE9NKGZyb20pIGFzIEhUTUxFbGVtZW50XG5cbiAgICAgICAgICAgIGNvbnN0IG5vZGVWaWV3V3JhcHBlciA9IG5vZGUuZGF0YXNldC5ub2RlVmlld1dyYXBwZXIgPyBub2RlIDogbm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1ub2RlLXZpZXctd3JhcHBlcl0nKVxuXG4gICAgICAgICAgICBpZiAobm9kZVZpZXdXcmFwcGVyKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBub2RlVmlld1dyYXBwZXIuZmlyc3RDaGlsZCBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBwb3NUb0RPTVJlY3QodmlldywgZnJvbSwgdG8pXG4gICAgICAgIH0pLFxuICAgIH0pXG5cbiAgICB0aGlzLnNob3coKVxuICB9XG5cbiAgc2hvdygpIHtcbiAgICB0aGlzLnRpcHB5Py5zaG93KClcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgdGhpcy50aXBweT8uaGlkZSgpXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnRpcHB5Py5wb3BwZXIuZmlyc3RDaGlsZCkge1xuICAgICAgKHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQgYXMgSFRNTEVsZW1lbnQpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICdibHVyJyxcbiAgICAgICAgdGhpcy50aXBweUJsdXJIYW5kbGVyLFxuICAgICAgKVxuICAgIH1cbiAgICB0aGlzLnRpcHB5Py5kZXN0cm95KClcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZWRvd25IYW5kbGVyLCB7IGNhcHR1cmU6IHRydWUgfSlcbiAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuZHJhZ3N0YXJ0SGFuZGxlcilcbiAgICB0aGlzLmVkaXRvci5vZmYoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpXG4gICAgdGhpcy5lZGl0b3Iub2ZmKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQnViYmxlTWVudVBsdWdpbiA9IChvcHRpb25zOiBCdWJibGVNZW51UGx1Z2luUHJvcHMpID0+IHtcbiAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgIGtleTpcbiAgICAgIHR5cGVvZiBvcHRpb25zLnBsdWdpbktleSA9PT0gJ3N0cmluZycgPyBuZXcgUGx1Z2luS2V5KG9wdGlvbnMucGx1Z2luS2V5KSA6IG9wdGlvbnMucGx1Z2luS2V5LFxuICAgIHZpZXc6IHZpZXcgPT4gbmV3IEJ1YmJsZU1lbnVWaWV3KHsgdmlldywgLi4ub3B0aW9ucyB9KSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmltcG9ydCB7IEJ1YmJsZU1lbnVQbHVnaW4sIEJ1YmJsZU1lbnVQbHVnaW5Qcm9wcyB9IGZyb20gJy4vYnViYmxlLW1lbnUtcGx1Z2luLmpzJ1xuXG5leHBvcnQgdHlwZSBCdWJibGVNZW51T3B0aW9ucyA9IE9taXQ8QnViYmxlTWVudVBsdWdpblByb3BzLCAnZWRpdG9yJyB8ICdlbGVtZW50Jz4gJiB7XG4gIGVsZW1lbnQ6IEhUTUxFbGVtZW50IHwgbnVsbCxcbn1cblxuZXhwb3J0IGNvbnN0IEJ1YmJsZU1lbnUgPSBFeHRlbnNpb24uY3JlYXRlPEJ1YmJsZU1lbnVPcHRpb25zPih7XG4gIG5hbWU6ICdidWJibGVNZW51JyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50OiBudWxsLFxuICAgICAgdGlwcHlPcHRpb25zOiB7fSxcbiAgICAgIHBsdWdpbktleTogJ2J1YmJsZU1lbnUnLFxuICAgICAgdXBkYXRlRGVsYXk6IHVuZGVmaW5lZCxcbiAgICAgIHNob3VsZFNob3c6IG51bGwsXG4gICAgfVxuICB9LFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5lbGVtZW50KSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgQnViYmxlTWVudVBsdWdpbih7XG4gICAgICAgIHBsdWdpbktleTogdGhpcy5vcHRpb25zLnBsdWdpbktleSxcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgZWxlbWVudDogdGhpcy5vcHRpb25zLmVsZW1lbnQsXG4gICAgICAgIHRpcHB5T3B0aW9uczogdGhpcy5vcHRpb25zLnRpcHB5T3B0aW9ucyxcbiAgICAgICAgdXBkYXRlRGVsYXk6IHRoaXMub3B0aW9ucy51cGRhdGVEZWxheSxcbiAgICAgICAgc2hvdWxkU2hvdzogdGhpcy5vcHRpb25zLnNob3VsZFNob3csXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7RXh0ZW5zaW9ufSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBkZWZhdWx0IEV4dGVuc2lvbi5jcmVhdGUoe1xuICAgIG5hbWU6ICdjbGFzc0V4dGVuc2lvbicsXG5cbiAgICBhZGRHbG9iYWxBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGVzOiBbXG4gICAgICAgICAgICAgICAgICAgICdoZWFkaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ3BhcmFncmFwaCcsXG4gICAgICAgICAgICAgICAgICAgICdsaW5rJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2xpc3RJdGVtJyxcbiAgICAgICAgICAgICAgICAgICAgJ2J1bGxldExpc3QnLFxuICAgICAgICAgICAgICAgICAgICAnb3JkZXJlZExpc3QnLFxuICAgICAgICAgICAgICAgICAgICAndGFibGUnLFxuICAgICAgICAgICAgICAgICAgICAndGFibGVIZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICAndGFibGVSb3cnLFxuICAgICAgICAgICAgICAgICAgICAndGFibGVDZWxsJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHRTdHlsZScsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpID8/IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJIVE1MOiBhdHRyaWJ1dGVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXMuY2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBhdHRyaWJ1dGVzLmNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXVxuICAgIH1cbn0pXG4iLCAiaW1wb3J0IHtFeHRlbnNpb259IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGRlZmF1bHQgRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2NvbW1hbmRzRXh0ZW5zaW9uJyxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vdmVUb0VuZDogKCkgPT4gKHtjaGFpbiwgc3RhdGUsIGRpc3BhdGNofSkgID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW4oKS5zZXRUZXh0U2VsZWN0aW9uKHN0YXRlLnNlbGVjdGlvbi4kdG8ucG9zKS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pXG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbHVtbihjb2xUeXBlLCBjb2xTcGFuLCBjb2xDb250ZW50ID0gbnVsbCkge1xuICBpZiAoY29sQ29udGVudCkge1xuICAgIHJldHVybiBjb2xUeXBlLmNyZWF0ZUNoZWNrZWQoeydkYXRhLWNvbC1zcGFuJzogY29sU3Bhbn0sIGNvbENvbnRlbnQpO1xuICB9XG5cbiAgcmV0dXJuIGNvbFR5cGUuY3JlYXRlQW5kRmlsbCh7J2RhdGEtY29sLXNwYW4nOiBjb2xTcGFufSk7XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGdldEdyaWROb2RlVHlwZXMoc2NoZW1hKSB7XG4gIGlmIChzY2hlbWEuY2FjaGVkLmdyaWROb2RlVHlwZXMpIHtcbiAgICByZXR1cm4gc2NoZW1hLmNhY2hlZC5ncmlkTm9kZVR5cGVzO1xuICB9XG5cbiAgY29uc3Qgcm9sZXMgPSB7fTtcblxuICBPYmplY3Qua2V5cyhzY2hlbWEubm9kZXMpLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICBjb25zdCBub2RlVHlwZSA9IHNjaGVtYS5ub2Rlc1t0eXBlXTtcblxuICAgIGlmIChub2RlVHlwZS5zcGVjLmdyaWRSb2xlKSB7XG4gICAgICByb2xlc1tub2RlVHlwZS5zcGVjLmdyaWRSb2xlXSA9IG5vZGVUeXBlO1xuICAgIH1cbiAgfSk7XG5cbiAgc2NoZW1hLmNhY2hlZC5ncmlkTm9kZVR5cGVzID0gcm9sZXM7XG5cbiAgcmV0dXJuIHJvbGVzO1xufVxuIiwgImltcG9ydCB7IGNyZWF0ZUNvbHVtbiB9IGZyb20gXCIuL2NyZWF0ZUNvbHVtbi5qc1wiO1xuaW1wb3J0IHsgZ2V0R3JpZE5vZGVUeXBlcyB9IGZyb20gXCIuL2dldEdyaWROb2RlVHlwZXMuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUdyaWQoc2NoZW1hLCBjb2xzQ291bnQsIHN0YWNrQXQsIGFzeW1tZXRyaWMsIGxlZnRTcGFuID0gbnVsbCwgcmlnaHRTcGFuID0gbnVsbCwgY29sQ29udGVudCA9IG51bGwpIHtcbiAgY29uc3QgeyBncmlkLCBjb2x1bW4gfSA9IGdldEdyaWROb2RlVHlwZXMoc2NoZW1hKTtcbiAgY29uc3QgY29scyA9IFtdO1xuXG4gIGlmIChhc3ltbWV0cmljKSB7XG4gICAgY29scy5wdXNoKGNyZWF0ZUNvbHVtbihjb2x1bW4sIGxlZnRTcGFuLCBjb2xDb250ZW50KSk7XG4gICAgY29scy5wdXNoKGNyZWF0ZUNvbHVtbihjb2x1bW4sIHJpZ2h0U3BhbiwgY29sQ29udGVudCkpO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBjb2xzQ291bnQ7IGluZGV4ICs9IDEpIHtcbiAgICAgIGNvbnN0IGNvbCA9IGNyZWF0ZUNvbHVtbihjb2x1bW4sIDEsIGNvbENvbnRlbnQpO1xuXG4gICAgICBpZiAoY29sKSB7XG4gICAgICAgIGNvbHMucHVzaChjb2wpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBncmlkLmNyZWF0ZUNoZWNrZWQoeyAnZGF0YS1jb2x1bW5zJzogY29sc0NvdW50LCAnZGF0YS10eXBlJzogYXN5bW1ldHJpYyA/PyAncmVzcG9uc2l2ZScsICdkYXRhLXN0YWNrLWF0Jzogc3RhY2tBdCB9LCBjb2xzKTtcbn1cbiIsICJpbXBvcnQgeyBjYWxsT3JSZXR1cm4sIGdldEV4dGVuc2lvbkZpZWxkLCBOb2RlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IGNyZWF0ZUdyaWQgfSBmcm9tICcuL3V0aWxzL2NyZWF0ZUdyaWQuanMnXG5cbmV4cG9ydCBkZWZhdWx0IE5vZGUuY3JlYXRlKHtcbiAgICBuYW1lOiAnZ3JpZCcsXG4gICAgZ3JvdXA6ICdibG9jaycsXG4gICAgZGVmaW5pbmc6IHRydWUsXG4gICAgaXNvbGF0aW5nOiB0cnVlLFxuICAgIGFsbG93R2FwQ3Vyc29yOiBmYWxzZSxcbiAgICBjb250ZW50OiAnZ3JpZENvbHVtbisnLFxuICAgIGdyaWRSb2xlOiAnZ3JpZCcsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6ICdzY3JpYmJsZS1ncmlkJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnZGF0YS10eXBlJzoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICdyZXNwb25zaXZlJyxcbiAgICAgICAgICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10eXBlJyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2RhdGEtY29sdW1ucyc6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAyLFxuICAgICAgICAgICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbHVtbnMnKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZGF0YS1zdGFjay1hdCc6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAnbWQnLFxuICAgICAgICAgICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXN0YWNrLWF0JyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3N0eWxlJzoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyc2VIVE1MOiAoZWxlbWVudCkgPT4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyksXG4gICAgICAgICAgICAgICAgcmVuZGVySFRNTDogKGF0dHJpYnV0ZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoJHthdHRyaWJ1dGVzWydkYXRhLWNvbHVtbnMnXX0sIDFmcik7YCxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgfSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnZGl2JyxcbiAgICAgICAgICAgICAgICBnZXRBdHRyczogKG5vZGUpID0+IChub2RlLmNsYXNzTGlzdC5jb250YWlucyhcInNjcmliYmxlLWdyaWRcIikgJiYgISBub2RlLmNsYXNzTGlzdC5jb250YWlucyhcIi1jb2x1bW5cIikpICYmIG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdXG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWydkaXYnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluc2VydEdyaWQ6XG4gICAgICAgICAgICAgICAgKHsgY29sdW1ucyA9IDIsIHN0YWNrX2F0LCBhc3ltbWV0cmljLCBsZWZ0X3NwYW4gPSBudWxsLCByaWdodF9zcGFuID0gbnVsbCB9ID0ge30pID0+XG4gICAgICAgICAgICAgICAgICAgICh7IHRyLCBkaXNwYXRjaCwgZWRpdG9yIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjcmVhdGVHcmlkKGVkaXRvci5zY2hlbWEsIGNvbHVtbnMsIHN0YWNrX2F0LCBhc3ltbWV0cmljLCBsZWZ0X3NwYW4sIHJpZ2h0X3NwYW4pXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRyLnNlbGVjdGlvbi5hbmNob3IgKyAxXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5yZXBsYWNlU2VsZWN0aW9uV2l0aChub2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShvZmZzZXQpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZXh0ZW5kTm9kZVNjaGVtYShleHRlbnNpb24pIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncmlkUm9sZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2dyaWRSb2xlJywgY29udGV4dCkpLFxuICAgICAgICB9XG4gICAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBOb2RlLmNyZWF0ZSh7XG4gIG5hbWU6IFwiZ3JpZENvbHVtblwiLFxuICBjb250ZW50OiBcImJsb2NrK1wiLFxuICBncmlkUm9sZTogXCJjb2x1bW5cIixcbiAgaXNvbGF0aW5nOiB0cnVlLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge1xuICAgICAgICBjbGFzczogXCJzY3JpYmJsZS1ncmlkLWNvbHVtblwiLFxuICAgICAgfSxcbiAgICB9O1xuICB9LFxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnZGF0YS1jb2wtc3Bhbic6IHtcbiAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgcGFyc2VIVE1MOiAoZWxlbWVudCkgPT4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbC1zcGFuXCIpLFxuICAgICAgICByZW5kZXJIVE1MOiAoYXR0cmlidXRlcykgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnZGF0YS1jb2wtc3Bhbic6IGF0dHJpYnV0ZXNbJ2RhdGEtY29sLXNwYW4nXSA/PyAxLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdzdHlsZSc6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgcGFyc2VIVE1MOiAoZWxlbWVudCkgPT4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSxcbiAgICAgICAgcmVuZGVySFRNTDogKGF0dHJpYnV0ZXMpID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3R5bGU6IGBncmlkLWNvbHVtbjogc3BhbiAke2F0dHJpYnV0ZXNbJ2RhdGEtY29sLXNwYW4nXSA/PyAxfTtgXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJkaXZcIixcbiAgICAgICAgZ2V0QXR0cnM6IChub2RlKSA9PiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhcInNjcmliYmxlLWdyaWQtY29sdW1uXCIpICYmIG51bGwsXG4gICAgICB9LFxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcImRpdlwiLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICB9LFxufSk7XG4iLCAiaW1wb3J0IHsgZmluZFBhcmVudE5vZGUsIGZpbmRDaGlsZHJlbiwgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgZGVmYXVsdCBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2RldGFpbHMnLFxuXG4gICAgY29udGVudDogJ2RldGFpbHNTdW1tYXJ5IGRldGFpbHNDb250ZW50JyxcblxuICAgIGdyb3VwOiAnYmxvY2snLFxuXG4gICAgZGVmaW5pbmc6IHRydWUsXG5cbiAgICBpc29sYXRpbmc6IHRydWUsXG5cbiAgICBhbGxvd0dhcEN1cnNvcjogZmFsc2UsXG5cbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7fVxuICAgIH0sXG5cbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnZGV0YWlscycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdXG4gICAgfSxcblxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBbJ2RldGFpbHMnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gICAgfSxcblxuICAgIGFkZE5vZGVWaWV3KCkge1xuICAgICAgICByZXR1cm4gKHsgSFRNTEF0dHJpYnV0ZXMgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICAgICAgICAnZGF0YS10eXBlJzogdGhpcy5uYW1lLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4gZG9tLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKSlcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkb20sXG4gICAgICAgICAgICAgICAgY29udGVudERPTTogZG9tLFxuICAgICAgICAgICAgICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnc2VsZWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFkb20uY29udGFpbnMobXV0YXRpb24udGFyZ2V0KSB8fCBkb20gPT09IG11dGF0aW9uLnRhcmdldFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdXBkYXRlOiAodXBkYXRlZE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWROb2RlLnR5cGUgPT09IHRoaXMudHlwZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXREZXRhaWxzOlxuICAgICAgICAgICAgICAgICgpID0+XG4gICAgICAgICAgICAgICAgICAgICh7IHN0YXRlLCBjaGFpbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX2FcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hLCBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gc3RhdGUuZG9jLnNsaWNlKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHNjaGVtYS5ub2Rlcy5kZXRhaWxzQ29udGVudC5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChzbGljZS5jb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gKChfYSA9IHNsaWNlLnRvSlNPTigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGVudCkgfHwgW11cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYWluKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0Q29udGVudEF0KHsgZnJvbTogcmFuZ2Uuc3RhcnQsIHRvOiByYW5nZS5lbmQgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6ICdkZXRhaWxzU3VtbWFyeScgfSwgeyB0eXBlOiAnZGV0YWlsc0NvbnRlbnQnLCBjb250ZW50IH1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldFRleHRTZWxlY3Rpb24ocmFuZ2Uuc3RhcnQgKyAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5ydW4oKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zZXREZXRhaWxzOlxuICAgICAgICAgICAgICAgICgpID0+XG4gICAgICAgICAgICAgICAgICAgICh7IHN0YXRlLCBjaGFpbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgc2NoZW1hIH0gPSBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGV0YWlscyA9IGZpbmRQYXJlbnROb2RlKChub2RlKSA9PiBub2RlLnR5cGUgPT09IHRoaXMudHlwZSkoc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXRhaWxzU3VtbWFyaWVzID0gZmluZENoaWxkcmVuKGRldGFpbHMubm9kZSwgKG5vZGUpID0+IG5vZGUudHlwZSA9PT0gc2NoZW1hLm5vZGVzLmRldGFpbHNTdW1tYXJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGV0YWlsc0NvbnRlbnRzID0gZmluZENoaWxkcmVuKGRldGFpbHMubm9kZSwgKG5vZGUpID0+IG5vZGUudHlwZSA9PT0gc2NoZW1hLm5vZGVzLmRldGFpbHNDb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZXRhaWxzU3VtbWFyaWVzLmxlbmd0aCB8fCAhZGV0YWlsc0NvbnRlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGV0YWlsc1N1bW1hcnkgPSBkZXRhaWxzU3VtbWFyaWVzWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXRhaWxzQ29udGVudCA9IGRldGFpbHNDb250ZW50c1swXVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJvbSA9IGRldGFpbHMucG9zXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCAkZnJvbSA9IHN0YXRlLmRvYy5yZXNvbHZlKGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyBkZXRhaWxzLm5vZGUubm9kZVNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0geyBmcm9tLCB0byB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gZGV0YWlsc0NvbnRlbnQubm9kZS5jb250ZW50LnRvSlNPTigpIHx8IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0VHlwZUZvclN1bW1hcnkgPSAkZnJvbS5wYXJlbnQudHlwZS5jb250ZW50TWF0Y2guZGVmYXVsdFR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgbWF5IGJyZWFrIGZvciBzb21lIGN1c3RvbSBzY2hlbWFzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdW1tYXJ5Q29udGVudCA9IGRlZmF1bHRUeXBlRm9yU3VtbWFyeSA9PT0gbnVsbCB8fCBkZWZhdWx0VHlwZUZvclN1bW1hcnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlZmF1bHRUeXBlRm9yU3VtbWFyeS5jcmVhdGUobnVsbCwgZGV0YWlsc1N1bW1hcnkubm9kZS5jb250ZW50KS50b0pTT04oKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVyZ2VkQ29udGVudCA9IFtzdW1tYXJ5Q29udGVudCwgLi4uY29udGVudF1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmluc2VydENvbnRlbnRBdChyYW5nZSwgbWVyZ2VkQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0VGV4dFNlbGVjdGlvbihmcm9tICsgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucnVuKClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEJhY2tzcGFjZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hLCBzZWxlY3Rpb24gfSA9IHRoaXMuZWRpdG9yLnN0YXRlXG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbXB0eSwgJGFuY2hvciB9ID0gc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKCFlbXB0eSB8fCAkYW5jaG9yLnBhcmVudC50eXBlICE9PSBzY2hlbWEubm9kZXMuZGV0YWlsc1N1bW1hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBzYWZhcmkgcmVtb3ZlcyB0aGUgd2hvbGUgdGV4dCBjb250ZW50IHdpdGhpbiBhIGA8c3VtbWFyeT5gdGFnIG9uIGJhY2tzcGFjZVxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSB0ZXh0IG1hbnVhbGx5XG4gICAgICAgICAgICAgICAgLy8gc2VlOiBodHRwczovL2Rpc2N1c3MucHJvc2VtaXJyb3IubmV0L3Qvc2FmYXJpLWJhY2tzcGFjZS1idWctd2l0aC1kZXRhaWxzLXRhZy80MjIzXG4gICAgICAgICAgICAgICAgaWYgKCRhbmNob3IucGFyZW50T2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvci5jb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb20gPSAkYW5jaG9yLnBvcyAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gJGFuY2hvci5wb3NcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZShmcm9tLCB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvci5jb21tYW5kcy51bnNldERldGFpbHMoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgIH0sXG59KVxuIiwgImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGRlZmF1bHQgTm9kZS5jcmVhdGUoe1xuICAgIG5hbWU6ICdkZXRhaWxzU3VtbWFyeScsXG4gICAgY29udGVudDogJ3RleHQqJyxcbiAgICBkZWZpbmluZzogdHJ1ZSxcbiAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICBpc29sYXRpbmc6IHRydWUsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhZzogJ3N1bW1hcnknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXVxuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAgICAgcmV0dXJuIFsnc3VtbWFyeScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgICB9LFxufSlcbiIsICJpbXBvcnQgeyBOb2RlLCBtZXJnZUF0dHJpYnV0ZXMsIGZpbmRQYXJlbnROb2RlLCBkZWZhdWx0QmxvY2tBdCB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJ1xuXG5leHBvcnQgZGVmYXVsdCBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2RldGFpbHNDb250ZW50JyxcblxuICAgIGNvbnRlbnQ6ICdibG9jaysnLFxuXG4gICAgZGVmaW5pbmc6IHRydWUsXG5cbiAgICBzZWxlY3RhYmxlOiBmYWxzZSxcblxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhZzogYGRpdltkYXRhLXR5cGU9XCJkZXRhaWxzLWNvbnRlbnRcIl1gLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXVxuICAgIH0sXG5cbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWydkaXYnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcywgeyAnZGF0YS10eXBlJzogJ2RldGFpbHMtY29udGVudCcgfSksIDBdXG4gICAgfSxcblxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gYWxsb3dzIGRvdWJsZSBlbnRlciB0byBleGl0IGNvbnRlbnQgbm9kZVxuICAgICAgICAgICAgRW50ZXI6ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSwgdmlldyB9ID0gZWRpdG9yXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gICAgICAgICAgICAgICAgY29uc3QgeyAkZnJvbSwgZW1wdHkgfSA9IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IGRldGFpbHNDb250ZW50ID0gZmluZFBhcmVudE5vZGUoKG5vZGUpID0+IG5vZGUudHlwZSA9PT0gdGhpcy50eXBlKShzZWxlY3Rpb24pXG5cbiAgICAgICAgICAgICAgICBpZiAoIWVtcHR5IHx8ICFkZXRhaWxzQ29udGVudCB8fCAhZGV0YWlsc0NvbnRlbnQubm9kZS5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGZyb21JbmRleCA9ICRmcm9tLmluZGV4KGRldGFpbHNDb250ZW50LmRlcHRoKVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2hpbGRDb3VudCB9ID0gZGV0YWlsc0NvbnRlbnQubm9kZVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXRFbmQgPSBjaGlsZENvdW50ID09PSBmcm9tSW5kZXggKyAxXG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzQXRFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdENoaWxkVHlwZSA9IGRldGFpbHNDb250ZW50Lm5vZGUudHlwZS5jb250ZW50TWF0Y2guZGVmYXVsdFR5cGVcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0Q2hpbGROb2RlID0gZGVmYXVsdENoaWxkVHlwZSA9PT0gbnVsbCB8fCBkZWZhdWx0Q2hpbGRUeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWZhdWx0Q2hpbGRUeXBlLmNyZWF0ZUFuZEZpbGwoKVxuXG4gICAgICAgICAgICAgICAgaWYgKCFkZWZhdWx0Q2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0ICRjaGlsZFBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKGRldGFpbHNDb250ZW50LnBvcyArIDEpXG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdENoaWxkSW5kZXggPSBjaGlsZENvdW50IC0gMVxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RDaGlsZE5vZGUgPSBkZXRhaWxzQ29udGVudC5ub2RlLmNoaWxkKGxhc3RDaGlsZEluZGV4KVxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RDaGlsZFBvcyA9ICRjaGlsZFBvcy5wb3NBdEluZGV4KGxhc3RDaGlsZEluZGV4LCBkZXRhaWxzQ29udGVudC5kZXB0aClcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0Q2hpbGROb2RlSXNFbXB0eSA9IGxhc3RDaGlsZE5vZGUuZXEoZGVmYXVsdENoaWxkTm9kZSlcblxuICAgICAgICAgICAgICAgIGlmICghbGFzdENoaWxkTm9kZUlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgYWJvdmUgPSAkZnJvbS5ub2RlKC0zKVxuICAgICAgICAgICAgICAgIGlmICghYWJvdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgYWZ0ZXIgPSAkZnJvbS5pbmRleEFmdGVyKC0zKVxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBkZWZhdWx0QmxvY2tBdChhYm92ZS5jb250ZW50TWF0Y2hBdChhZnRlcikpXG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlIHx8ICFhYm92ZS5jYW5SZXBsYWNlV2l0aChhZnRlciwgYWZ0ZXIsIHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0eXBlLmNyZWF0ZUFuZEZpbGwoKVxuXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlXG4gICAgICAgICAgICAgICAgY29uc3QgcG9zID0gJGZyb20uYWZ0ZXIoLTIpXG4gICAgICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgocG9zLCBwb3MsIG5vZGUpXG4gICAgICAgICAgICAgICAgY29uc3QgJHBvcyA9IHRyLmRvYy5yZXNvbHZlKHBvcylcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSBTZWxlY3Rpb24ubmVhcigkcG9zLCAxKVxuICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlRnJvbSA9IGxhc3RDaGlsZFBvc1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVRvID0gbGFzdENoaWxkUG9zICsgbGFzdENoaWxkTm9kZS5ub2RlU2l6ZVxuICAgICAgICAgICAgICAgIHRyLmRlbGV0ZShkZWxldGVGcm9tLCBkZWxldGVUbylcbiAgICAgICAgICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgIH0sXG59KVxuIiwgImltcG9ydCB7RXh0ZW5zaW9ufSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBkZWZhdWx0IEV4dGVuc2lvbi5jcmVhdGUoe1xuICAgIG5hbWU6ICdpZEV4dGVuc2lvbicsXG5cbiAgICBhZGRHbG9iYWxBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGVzOiBbXG4gICAgICAgICAgICAgICAgICAgICdoZWFkaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmsnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSFRNTDogZWxlbWVudCA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKSA/PyBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVySFRNTDogYXR0cmlidXRlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogYXR0cmlidXRlcy5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF1cbiAgICB9XG59KVxuIiwgImltcG9ydCB7XG4gIG1lcmdlQXR0cmlidXRlcyxcbiAgTm9kZSxcbiAgbm9kZUlucHV0UnVsZSxcbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlT3B0aW9ucyB7XG4gIGlubGluZTogYm9vbGVhbixcbiAgYWxsb3dCYXNlNjQ6IGJvb2xlYW4sXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgaW1hZ2U6IHtcbiAgICAgIC8qKlxuICAgICAgICogQWRkIGFuIGltYWdlXG4gICAgICAgKi9cbiAgICAgIHNldEltYWdlOiAob3B0aW9uczogeyBzcmM6IHN0cmluZywgYWx0Pzogc3RyaW5nLCB0aXRsZT86IHN0cmluZyB9KSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgaW5wdXRSZWdleCA9IC8oPzpefFxccykoIVxcWyguK3w6PyldXFwoKFxcUyspKD86KD86XFxzKylbXCInXShcXFMrKVtcIiddKT9cXCkpJC9cblxuZXhwb3J0IGNvbnN0IEltYWdlID0gTm9kZS5jcmVhdGU8SW1hZ2VPcHRpb25zPih7XG4gIG5hbWU6ICdpbWFnZScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5saW5lOiBmYWxzZSxcbiAgICAgIGFsbG93QmFzZTY0OiBmYWxzZSxcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgaW5saW5lKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW5saW5lXG4gIH0sXG5cbiAgZ3JvdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbmxpbmUgPyAnaW5saW5lJyA6ICdibG9jaydcbiAgfSxcblxuICBkcmFnZ2FibGU6IHRydWUsXG5cbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3JjOiB7XG4gICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICB9LFxuICAgICAgYWx0OiB7XG4gICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICB9LFxuICAgICAgdGl0bGU6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IHRoaXMub3B0aW9ucy5hbGxvd0Jhc2U2NFxuICAgICAgICAgID8gJ2ltZ1tzcmNdJ1xuICAgICAgICAgIDogJ2ltZ1tzcmNdOm5vdChbc3JjXj1cImRhdGE6XCJdKScsXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ2ltZycsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKV1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0SW1hZ2U6IG9wdGlvbnMgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuaW5zZXJ0Q29udGVudCh7XG4gICAgICAgICAgdHlwZTogdGhpcy5uYW1lLFxuICAgICAgICAgIGF0dHJzOiBvcHRpb25zLFxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbm9kZUlucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4ge1xuICAgICAgICAgIGNvbnN0IFssLCBhbHQsIHNyYywgdGl0bGVdID0gbWF0Y2hcblxuICAgICAgICAgIHJldHVybiB7IHNyYywgYWx0LCB0aXRsZSB9XG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImNsYXNzIFN2ZWx0ZVJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnQsIHsgZWxlbWVudCB9KSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLmRvbSA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoJ3N2ZWx0ZS1yZW5kZXJlcicpO1xuICAgIH1cbiAgICB1cGRhdGVQcm9wcyhwcm9wcykge1xuICAgICAgICB0aGlzLmNvbXBvbmVudC4kc2V0KHByb3BzKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuJGRlc3Ryb3koKTtcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBTdmVsdGVSZW5kZXJlcjtcbiIsICJleHBvcnQgY29uc3QgVElQVEFQX05PREVfVklFVyA9ICdUaXBUYXBOb2RlVmlldyc7XG4iLCAiaW1wb3J0IHsgTm9kZVZpZXcsIEVkaXRvciB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgU3ZlbHRlUmVuZGVyZXIgZnJvbSAnLi9TdmVsdGVSZW5kZXJlcic7XG5pbXBvcnQgeyBUSVBUQVBfTk9ERV9WSUVXIH0gZnJvbSAnLi9jb250ZXh0JztcbmNsYXNzIFN2ZWx0ZU5vZGVWaWV3IGV4dGVuZHMgTm9kZVZpZXcge1xuICAgIG1vdW50KCkge1xuICAgICAgICBjb25zdCBDb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgbm9kZTogdGhpcy5ub2RlLFxuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IHRoaXMuZGVjb3JhdGlvbnMsXG4gICAgICAgICAgICBzZWxlY3RlZDogZmFsc2UsXG4gICAgICAgICAgICBleHRlbnNpb246IHRoaXMuZXh0ZW5zaW9uLFxuICAgICAgICAgICAgZ2V0UG9zOiAoKSA9PiB0aGlzLmdldFBvcygpLFxuICAgICAgICAgICAgdXBkYXRlQXR0cmlidXRlczogKGF0dHJpYnV0ZXMgPSB7fSkgPT4gdGhpcy51cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpLFxuICAgICAgICAgICAgZGVsZXRlTm9kZTogKCkgPT4gdGhpcy5kZWxldGVOb2RlKCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQgPSB0aGlzLm5vZGUuaXNMZWFmID8gbnVsbCA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5ub2RlLmlzSW5saW5lID8gJ3NwYW4nIDogJ2RpdicpO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uIHRoZSB3aGl0ZVNwYWNlIHByb3AgaXMgbm90IGluaGVyaXRlZCBwcm9wZXJseSBpbiBDaHJvbWUgYW5kIFNhZmFyaVxuICAgICAgICAgICAgLy8gV2l0aCB0aGlzIGZpeCBpdCBzZWVtcyB0byB3b3JrIGZpbmVcbiAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8xMTk3XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50LnN0eWxlLndoaXRlU3BhY2UgPSAnaW5oZXJpdCc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGV4dCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29udGV4dC5zZXQoVElQVEFQX05PREVfVklFVywge1xuICAgICAgICAgICAgb25EcmFnU3RhcnQ6IHRoaXMub25EcmFnU3RhcnQuYmluZCh0aGlzKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFzID0gdGhpcy5vcHRpb25zLmFzID8/ICh0aGlzLm5vZGUuaXNJbmxpbmUgPyAnc3BhbicgOiAnZGl2Jyk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoYXMpO1xuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZChgbm9kZS0ke3RoaXMubm9kZS50eXBlLm5hbWV9YCk7XG4gICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0aW9uVXBkYXRlID0gdGhpcy5oYW5kbGVTZWxlY3Rpb25VcGRhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3NlbGVjdGlvblVwZGF0ZScsIHRoaXMuaGFuZGxlU2VsZWN0aW9uVXBkYXRlKTtcbiAgICAgICAgY29uc3Qgc3ZlbHRlQ29tcG9uZW50ID0gbmV3IENvbXBvbmVudCh7XG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFN2ZWx0ZVJlbmRlcmVyKHN2ZWx0ZUNvbXBvbmVudCwge1xuICAgICAgICAgICAgZWxlbWVudDogdGFyZ2V0LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcHBlbmRDb250ZW5kRG9tKCk7XG4gICAgfVxuICAgIGFwcGVuZENvbnRlbmREb20oKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRFbGVtZW50ID0gdGhpcy5kb20ucXVlcnlTZWxlY3RvcignW2RhdGEtbm9kZS12aWV3LWNvbnRlbnRdJyk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET01FbGVtZW50ICYmIGNvbnRlbnRFbGVtZW50ICYmICFjb250ZW50RWxlbWVudC5jb250YWlucyh0aGlzLmNvbnRlbnRET01FbGVtZW50KSkge1xuICAgICAgICAgICAgY29udGVudEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RE9NRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRvbSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVyLmRvbS5maXJzdEVsZW1lbnRDaGlsZD8uaGFzQXR0cmlidXRlKCdkYXRhLW5vZGUtdmlldy13cmFwcGVyJykpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdQbGVhc2UgdXNlIHRoZSBOb2RlVmlld1dyYXBwZXIgY29tcG9uZW50IGZvciB5b3VyIG5vZGUgdmlldy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5kb207XG4gICAgfVxuICAgIGdldCBjb250ZW50RE9NKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlLmlzTGVhZikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudERPTUVsZW1lbnQ7XG4gICAgfVxuICAgIGhhbmRsZVNlbGVjdGlvblVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gdGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoZnJvbSA8PSB0aGlzLmdldFBvcygpICYmIHRvID49IHRoaXMuZ2V0UG9zKCkgKyB0aGlzLm5vZGUubm9kZVNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Tm9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdE5vZGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUobm9kZSwgZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlUHJvcHMgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZVByb3BzKHsgbm9kZSwgZGVjb3JhdGlvbnMgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3Qgb2xkTm9kZSA9IHRoaXMubm9kZTtcbiAgICAgICAgICAgIGNvbnN0IG9sZERlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0aW9ucztcbiAgICAgICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gZGVjb3JhdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgb2xkTm9kZSxcbiAgICAgICAgICAgICAgICBvbGREZWNvcmF0aW9ucyxcbiAgICAgICAgICAgICAgICBuZXdOb2RlOiBub2RlLFxuICAgICAgICAgICAgICAgIG5ld0RlY29yYXRpb25zOiBkZWNvcmF0aW9ucyxcbiAgICAgICAgICAgICAgICB1cGRhdGVQcm9wczogKCkgPT4gdXBkYXRlUHJvcHMoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09IHRoaXMubm9kZS50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMubm9kZSAmJiB0aGlzLmRlY29yYXRpb25zID09PSBkZWNvcmF0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zO1xuICAgICAgICB1cGRhdGVQcm9wcygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVQcm9wcyh7IHNlbGVjdGVkOiB0cnVlIH0pO1xuICAgIH1cbiAgICBkZXNlbGVjdE5vZGUoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlUHJvcHMoeyBzZWxlY3RlZDogZmFsc2UgfSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ3NlbGVjdGlvblVwZGF0ZScsIHRoaXMuaGFuZGxlU2VsZWN0aW9uVXBkYXRlKTtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NRWxlbWVudCA9IG51bGw7XG4gICAgfVxufVxuY29uc3QgU3ZlbHRlTm9kZVZpZXdSZW5kZXJlciA9IChjb21wb25lbnQsIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gKHByb3BzKSA9PiBuZXcgU3ZlbHRlTm9kZVZpZXcoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucyk7XG59O1xuZXhwb3J0IGRlZmF1bHQgU3ZlbHRlTm9kZVZpZXdSZW5kZXJlcjtcbiIsICI8c2NyaXB0PmltcG9ydCB7IGdldENvbnRleHQsIG9uTW91bnQsIHRpY2sgfSBmcm9tIFwic3ZlbHRlXCI7XG5pbXBvcnQgeyBUSVBUQVBfTk9ERV9WSUVXIH0gZnJvbSBcIi4vY29udGV4dFwiO1xuY29uc3QgeyBvbkRyYWdTdGFydCB9ID0gZ2V0Q29udGV4dChUSVBUQVBfTk9ERV9WSUVXKTtcbmxldCBlbGVtZW50O1xuZXhwb3J0IGxldCBhcyA9IFwiZGl2XCI7XG5vbk1vdW50KGFzeW5jICgpID0+IHtcbiAgYXdhaXQgdGljaygpO1xuICBlbGVtZW50LnN0eWxlLndoaXRlU3BhY2UgPSBcIm5vcm1hbFwiO1xufSk7XG48L3NjcmlwdD5cblxuPHN2ZWx0ZTplbGVtZW50XG4gIHRoaXM9e2FzfVxuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIGRhdGEtbm9kZS12aWV3LXdyYXBwZXI9XCJcIlxuICBvbjpkcmFnc3RhcnQ9e29uRHJhZ1N0YXJ0fVxuICByb2xlPVwibm9uZVwiXG4gIHsuLi4kJHJlc3RQcm9wc31cbj5cbiAgPHNsb3QgLz5cbjwvc3ZlbHRlOmVsZW1lbnQ+XG4iLCAiPGRpdiBjbGFzcz1cInNjcmliYmxlLWJsb2NrLWFjdGlvbnNcIiBjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiPlxuICAgIDxzbG90IC8+XG48L2Rpdj5cbiIsICI8c2NyaXB0PlxuICAgIGV4cG9ydCBsZXQgaGFuZGxlTWVudU9wZW47XG48L3NjcmlwdD5cblxuPGJ1dHRvbiBvbjpjbGlja3xwcmV2ZW50RGVmYXVsdHxzdG9wUHJvcGFnYXRpb249e2hhbmRsZU1lbnVPcGVufSAgZGF0YS1kcmFnLWhhbmRsZSB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJzY3JpYmJsZS1ibG9jay1hY3Rpb24gYmxvY2stZHJhZ1wiPlxuICAgIDxzdmcgZmlsbD1cImN1cnJlbnRDb2xvclwiIHdpZHRoPVwiODAwcHhcIiBoZWlnaHQ9XCI4MDBweFwiIHZpZXdCb3g9XCIwIDAgMTYgMTZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG4gICAgICAgIDxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTcuMzc1IDMuNjdjMC0uNjQ1LS41Ni0xLjE3LTEuMjUtMS4xN3MtMS4yNS41MjUtMS4yNSAxLjE3YzAgLjY0Ni41NiAxLjE3IDEuMjUgMS4xN3MxLjI1LS41MjQgMS4yNS0xLjE3em0wIDguNjZjMC0uNjQ2LS41Ni0xLjE3LTEuMjUtMS4xN3MtMS4yNS41MjQtMS4yNSAxLjE3YzAgLjY0NS41NiAxLjE3IDEuMjUgMS4xN3MxLjI1LS41MjUgMS4yNS0xLjE3em0tMS4yNS01LjVjLjY5IDAgMS4yNS41MjUgMS4yNSAxLjE3IDAgLjY0NS0uNTYgMS4xNy0xLjI1IDEuMTdTNC44NzUgOC42NDUgNC44NzUgOGMwLS42NDUuNTYtMS4xNyAxLjI1LTEuMTd6bTUtMy4xNmMwLS42NDUtLjU2LTEuMTctMS4yNS0xLjE3cy0xLjI1LjUyNS0xLjI1IDEuMTdjMCAuNjQ2LjU2IDEuMTcgMS4yNSAxLjE3czEuMjUtLjUyNCAxLjI1LTEuMTd6bS0xLjI1IDcuNDljLjY5IDAgMS4yNS41MjQgMS4yNSAxLjE3IDAgLjY0NS0uNTYgMS4xNy0xLjI1IDEuMTdzLTEuMjUtLjUyNS0xLjI1LTEuMTdjMC0uNjQ2LjU2LTEuMTcgMS4yNS0xLjE3ek0xMS4xMjUgOGMwLS42NDUtLjU2LTEuMTctMS4yNS0xLjE3cy0xLjI1LjUyNS0xLjI1IDEuMTdjMCAuNjQ1LjU2IDEuMTcgMS4yNSAxLjE3czEuMjUtLjUyNSAxLjI1LTEuMTd6XCIvPlxuICAgIDwvc3ZnPlxuPC9idXR0b24+XG4iLCAiaW1wb3J0IHRpcHB5IGZyb20gJ3RpcHB5LmpzJ1xuXG5leHBvcnQgY29uc3QgdXVpZCA9ICgpID0+IHtcbiAgICByZXR1cm4gKFsxZTddKy0xZTMrLTRlMystOGUzKy0xZTExKS5yZXBsYWNlKC9bMDE4XS9nLCBjID0+XG4gICAgICAgIChjIF4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgxKSlbMF0gJiAxNSA+PiBjIC8gNCkudG9TdHJpbmcoMTYpXG4gICAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IG9wZW5TY3JpYmJsZU1vZGFsID0gKGNvbXBvbmVudCwgYXJncykgPT4ge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzY3JpYmJsZS1lZGl0b3ItbG9hZGluZy1pbmRpY2F0b3InKS5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc2NyaWJibGUtZWRpdG9yLWxvYWRpbmctaW5kaWNhdG9yIC5sb2FkZXInKS5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICB3aW5kb3cuTGl2ZXdpcmUuZGlzcGF0Y2goJ29wZW5TY3JpYmJsZU1vZGFsJywgeyBjb21wb25lbnQ6IGNvbXBvbmVudCwgYXJndW1lbnRzOiBhcmdzIH0pXG59XG5cbmV4cG9ydCBjb25zdCBoaWRlTG9hZGluZ0luZGljYXRvciA9IChoaWRlX2xvYWRlciA9IGZhbHNlKSA9PiB7XG4gICAgaWYgKCBoaWRlX2xvYWRlciApXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzY3JpYmJsZS1lZGl0b3ItbG9hZGluZy1pbmRpY2F0b3IgLmxvYWRlcicpLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgIGVsc2VcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjcmliYmxlLWVkaXRvci1sb2FkaW5nLWluZGljYXRvcicpLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xufVxuXG5leHBvcnQgY29uc3QgY29tbWFuZFJ1bm5lciA9IChlZGl0b3IsIGNvbW1hbmRzLCBhcmdzID0gW10pID0+IHtcbiAgICBjb21tYW5kcy5mb3JFYWNoKGNvbW1hbmQgPT4ge1xuICAgICAgICBlZGl0b3IuY2hhaW4oKS5mb2N1cygpW2NvbW1hbmQuY29tbWFuZF0oT2JqZWN0LmtleXMoY29tbWFuZD8uYXJndW1lbnRzKS5sZW5ndGggPiAwID8gY29tbWFuZC5hcmd1bWVudHMgOiBhcmdzKS5ydW4oKVxuICAgIH0pXG59XG5cbmV4cG9ydCBjb25zdCByZXBsYWNlU3RhdGVQYXRoID0gKGRhdGEsIHN0YXRlUGF0aCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZGF0YSAhPSBcIm9iamVjdFwiKSByZXR1cm47XG4gICAgaWYgKCFkYXRhKSByZXR1cm47IC8vIG51bGwgb2JqZWN0XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChbJ3N0YXRlUGF0aCddLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IHN0YXRlUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcGxhY2VTdGF0ZVBhdGgoZGF0YVtrZXldLCBzdGF0ZVBhdGgpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwgIjxzY3JpcHQ+XG4gICAgZXhwb3J0IGxldCBoYW5kbGVPcGVuO1xuPC9zY3JpcHQ+XG5cbjxidXR0b24gb246Y2xpY2t8cHJldmVudERlZmF1bHR8c3RvcFByb3BhZ2F0aW9uPXtoYW5kbGVPcGVufSB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJzY3JpYmJsZS1ibG9jay1hY3Rpb24gYmxvY2stc2V0dGluZ3NcIj5cbiAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNiBoLTZcIj5cbiAgICAgICAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk05LjU5NCAzLjk0Yy4wOS0uNTQyLjU2LS45NCAxLjExLS45NGgyLjU5M2MuNTUgMCAxLjAyLjM5OCAxLjExLjk0bC4yMTMgMS4yODFjLjA2My4zNzQuMzEzLjY4Ni42NDUuODcuMDc0LjA0LjE0Ny4wODMuMjIuMTI3LjMyNS4xOTYuNzIuMjU3IDEuMDc1LjEyNGwxLjIxNy0uNDU2YTEuMTI1IDEuMTI1IDAgMCAxIDEuMzcuNDlsMS4yOTYgMi4yNDdhMS4xMjUgMS4xMjUgMCAwIDEtLjI2IDEuNDMxbC0xLjAwMy44MjdjLS4yOTMuMjQxLS40MzguNjEzLS40My45OTJhNy43MjMgNy43MjMgMCAwIDEgMCAuMjU1Yy0uMDA4LjM3OC4xMzcuNzUuNDMuOTkxbDEuMDA0LjgyN2MuNDI0LjM1LjUzNC45NTUuMjYgMS40M2wtMS4yOTggMi4yNDdhMS4xMjUgMS4xMjUgMCAwIDEtMS4zNjkuNDkxbC0xLjIxNy0uNDU2Yy0uMzU1LS4xMzMtLjc1LS4wNzItMS4wNzYuMTI0YTYuNDcgNi40NyAwIDAgMS0uMjIuMTI4Yy0uMzMxLjE4My0uNTgxLjQ5NS0uNjQ0Ljg2OWwtLjIxMyAxLjI4MWMtLjA5LjU0My0uNTYuOTQtMS4xMS45NGgtMi41OTRjLS41NSAwLTEuMDE5LS4zOTgtMS4xMS0uOTRsLS4yMTMtMS4yODFjLS4wNjItLjM3NC0uMzEyLS42ODYtLjY0NC0uODdhNi41MiA2LjUyIDAgMCAxLS4yMi0uMTI3Yy0uMzI1LS4xOTYtLjcyLS4yNTctMS4wNzYtLjEyNGwtMS4yMTcuNDU2YTEuMTI1IDEuMTI1IDAgMCAxLTEuMzY5LS40OWwtMS4yOTctMi4yNDdhMS4xMjUgMS4xMjUgMCAwIDEgLjI2LTEuNDMxbDEuMDA0LS44MjdjLjI5Mi0uMjQuNDM3LS42MTMuNDMtLjk5MWE2LjkzMiA2LjkzMiAwIDAgMSAwLS4yNTVjLjAwNy0uMzgtLjEzOC0uNzUxLS40My0uOTkybC0xLjAwNC0uODI3YTEuMTI1IDEuMTI1IDAgMCAxLS4yNi0xLjQzbDEuMjk3LTIuMjQ3YTEuMTI1IDEuMTI1IDAgMCAxIDEuMzctLjQ5MWwxLjIxNi40NTZjLjM1Ni4xMzMuNzUxLjA3MiAxLjA3Ni0uMTI0LjA3Mi0uMDQ0LjE0Ni0uMDg2LjIyLS4xMjguMzMyLS4xODMuNTgyLS40OTUuNjQ0LS44NjlsLjIxNC0xLjI4WlwiIC8+XG4gICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTUgMTJhMyAzIDAgMSAxLTYgMCAzIDMgMCAwIDEgNiAwWlwiIC8+XG4gICAgPC9zdmc+XG4gICAgPHNwYW4gY2xhc3M9XCJncm93XCI+SW1wb3N0YXppb25pPC9zcGFuPlxuPC9idXR0b24+XG4iLCAiPHNjcmlwdD5cbiAgICBleHBvcnQgbGV0IGhhbmRsZVJlbW92ZTtcbjwvc2NyaXB0PlxuXG48YnV0dG9uIG9uOmNsaWNrfHByZXZlbnREZWZhdWx0fHN0b3BQcm9wYWdhdGlvbj17aGFuZGxlUmVtb3ZlfSB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgY2xhc3M9XCJzY3JpYmJsZS1ibG9jay1hY3Rpb24gYmxvY2stcmVtb3ZlIGRlbGV0ZVwiPlxuICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNiBoLTZcIj5cbiAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJtMTQuNzQgOS0uMzQ2IDltLTQuNzg4IDBMOS4yNiA5bTkuOTY4LTMuMjFjLjM0Mi4wNTIuNjgyLjEwNyAxLjAyMi4xNjZtLTEuMDIyLS4xNjVMMTguMTYgMTkuNjczYTIuMjUgMi4yNSAwIDAgMS0yLjI0NCAyLjA3N0g4LjA4NGEyLjI1IDIuMjUgMCAwIDEtMi4yNDQtMi4wNzdMNC43NzIgNS43OW0xNC40NTYgMGE0OC4xMDggNDguMTA4IDAgMCAwLTMuNDc4LS4zOTdtLTEyIC41NjJjLjM0LS4wNTkuNjgtLjExNCAxLjAyMi0uMTY1bTAgMGE0OC4xMSA0OC4xMSAwIDAgMSAzLjQ3OC0uMzk3bTcuNSAwdi0uOTE2YzAtMS4xOC0uOTEtMi4xNjQtMi4wOS0yLjIwMWE1MS45NjQgNTEuOTY0IDAgMCAwLTMuMzIgMGMtMS4xOC4wMzctMi4wOSAxLjAyMi0yLjA5IDIuMjAxdi45MTZtNy41IDBhNDguNjY3IDQ4LjY2NyAwIDAgMC03LjUgMFwiIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImdyb3dcIj5DYW5jZWxsYTwvc3Bhbj5cbjwvYnV0dG9uPlxuIiwgIjxzY3JpcHQ+XG4gICAgZXhwb3J0IGxldCBoYW5kbGVEdXBsaWNhdGU7XG48L3NjcmlwdD5cblxuPGJ1dHRvbiBvbjpjbGlja3xwcmV2ZW50RGVmYXVsdHxzdG9wUHJvcGFnYXRpb249e2hhbmRsZUR1cGxpY2F0ZX0gdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzPVwic2NyaWJibGUtYmxvY2stYWN0aW9uIGJsb2NrLXJlbW92ZVwiPlxuICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNiBoLTZcIj5cbiAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMTUuNzUgMTcuMjV2My4zNzVjMCAuNjIxLS41MDQgMS4xMjUtMS4xMjUgMS4xMjVoLTkuNzVhMS4xMjUgMS4xMjUgMCAwIDEtMS4xMjUtMS4xMjVWNy44NzVjMC0uNjIxLjUwNC0xLjEyNSAxLjEyNS0xLjEyNUg2Ljc1YTkuMDYgOS4wNiAwIDAgMSAxLjUuMTI0bTcuNSAxMC4zNzZoMy4zNzVjLjYyMSAwIDEuMTI1LS41MDQgMS4xMjUtMS4xMjVWMTEuMjVjMC00LjQ2LTMuMjQzLTguMTYxLTcuNS04Ljg3NmE5LjA2IDkuMDYgMCAwIDAtMS41LS4xMjRIOS4zNzVjLS42MjEgMC0xLjEyNS41MDQtMS4xMjUgMS4xMjV2My41bTcuNSAxMC4zNzVIOS4zNzVhMS4xMjUgMS4xMjUgMCAwIDEtMS4xMjUtMS4xMjV2LTkuMjVtMTIgNi42MjV2LTEuODc1YTMuMzc1IDMuMzc1IDAgMCAwLTMuMzc1LTMuMzc1aC0xLjVhMS4xMjUgMS4xMjUgMCAwIDEtMS4xMjUtMS4xMjV2LTEuNWEzLjM3NSAzLjM3NSAwIDAgMC0zLjM3NS0zLjM3NUg5Ljc1XCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiZ3Jvd1wiPkR1cGxpY2E8L3NwYW4+XG48L2J1dHRvbj5cbiIsICI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9wZW5TY3JpYmJsZU1vZGFsLCB1dWlkIH0gZnJvbSAnLi4vdXRpbHMuanMnXG4gICAgaW1wb3J0IEJsb2NrU2V0dGluZ3MgZnJvbSAnLi9CbG9ja1NldHRpbmdzLnN2ZWx0ZSdcbiAgICBpbXBvcnQgUmVtb3ZlQmxvY2sgZnJvbSAnLi9SZW1vdmVCbG9jay5zdmVsdGUnXG4gICAgaW1wb3J0IER1cGxpY2F0ZUJsb2NrIGZyb20gJy4vRHVwbGljYXRlQmxvY2suc3ZlbHRlJztcblxuICAgIGV4cG9ydCBsZXQgbm9kZVxuICAgIGV4cG9ydCBsZXQgZWRpdG9yXG4gICAgZXhwb3J0IGxldCBvbkNsb3NlO1xuXG4gICAgLy8gQXR0cmlidXRpIGJvb2xlYW5pIHBlciByZW5kZXJlIG9wemlvbmFsaSBpIHRhc3RpXG4gICAgZXhwb3J0IGxldCBzaG93U2V0dGluZ3MgPSB0cnVlO1xuICAgIGV4cG9ydCBsZXQgc2hvd0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgZXhwb3J0IGxldCBzaG93UmVtb3ZlID0gdHJ1ZTtcblxuICAgIGNvbnN0IGhhbmRsZUR1cGxpY2F0ZSA9ICgpID0+IHtcblxuICAgICAgICBjb25zdCB7IHRyLCBkb2MgfSA9IGVkaXRvci5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xuICAgICAgICAvLyBWZXJpZmljYSBzZSBjJ8OoIHVuIG5vZG8gc2VsZXppb25hdG8gZSBvdHRpZW5pIGxhIHBvc2l6aW9uZSBkaSBxdWVsIG5vZG8uXG4gICAgICAgIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc2VsZWN0aW9uO1xuICAgICAgICBjb25zdCBub2RlUG9zID0gJGZyb20ucG9zO1xuICAgICAgICBjb25zdCBub2RlU2l6ZSA9ICR0by5wb3MgLSAkZnJvbS5wb3M7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSAkZnJvbS5ub2RlQWZ0ZXI7XG5cbiAgICAgICAgLy8gTGEgbnVvdmEgcG9zaXppb25lIMOoIGxhIHBvc2l6aW9uZSBhdHR1YWxlIGRlbCBub2RvIHBpw7kgbGEgc3VhIGx1bmdoZXp6YSAobm9kZVNpemUpLlxuICAgICAgICBjb25zdCBuZXdQb3MgPSBub2RlUG9zICsgbm9kZVNpemU7XG5cbiAgICAgICAgLy8gQ3JlYSB1bmEgY29waWEgZGVsIG5vZG8gc2VsZXppb25hdG8uXG4gICAgICAgIGNvbnN0IG5vZGVDb3B5ID0gbm9kZS50eXBlLmNyZWF0ZSh7Li4ubm9kZS5hdHRycywgaWQ6IHV1aWQoKX0sIG5vZGUuY29udGVudCwgbm9kZS5tYXJrcyk7XG5cbiAgICAgICAgLy8gVmVyaWZpY2Egc2UgbGEgbnVvdmEgcG9zaXppb25lIG5vbiDDqCBvbHRyZSBsJ3VsdGltbyBub2RvIGRlbCBkb2N1bWVudG8uXG4gICAgICAgIGlmIChuZXdQb3MgPD0gZG9jLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgLy8gQWdnaXVuZ2kgaWwgbm9kbyBjb3BpYXRvIGFsbGEgbnVvdmEgcG9zaXppb25lLlxuICAgICAgICAgICAgdHIuaW5zZXJ0KG5ld1Bvcywgbm9kZUNvcHkpO1xuICAgICAgICAgICAgZWRpdG9yLnZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IGR1cGxpY2F0ZSBhZnRlciB0aGUgbGFzdCBub2RlIG9mIHRoZSBkb2N1bWVudC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvbkNsb3NlKSB7XG4gICAgICAgICAgICBvbkNsb3NlKCk7IC8vIENoaWFtYSBsYSBmdW56aW9uZSBkaSBjaGl1c3VyYSBzZSBwcmVzZW50ZS5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZU9wZW4gPSAoKSA9PiB7XG5cbiAgICAgICAgaWYgKG9uQ2xvc2UpIHtcbiAgICAgICAgICAgIG9uQ2xvc2UoKTsgLy8gQ2hpYW1hIGxhIGZ1bnppb25lIGRpIGNoaXVzdXJhIHBhc3NhdGEgY29tZSBwcm9wXG4gICAgICAgIH1cblxuICAgICAgICBvcGVuU2NyaWJibGVNb2RhbChub2RlLmF0dHJzLmlkZW50aWZpZXIsIHtcbiAgICAgICAgICAgIHVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIHN0YXRlUGF0aDogZWRpdG9yLnN0b3JhZ2U/LnN0YXRlUGF0aEV4dGVuc2lvbi5zdGF0ZVBhdGggPz8gbnVsbCxcbiAgICAgICAgICAgIGJsb2NrSWQ6IG5vZGUuYXR0cnMuaWQsXG4gICAgICAgICAgICBkYXRhOiBub2RlLmF0dHJzLnZhbHVlc1xuICAgICAgICB9KVxuICAgIH1cbiAgICBjb25zdCBoYW5kbGVSZW1vdmUgPSAoKSA9PiB7XG5cbiAgICAgICAgaWYgKG9uQ2xvc2UpIHtcbiAgICAgICAgICAgIG9uQ2xvc2UoKTsgLy8gQ2hpYW1hIGxhIGZ1bnppb25lIGRpIGNoaXVzdXJhIHBhc3NhdGEgY29tZSBwcm9wXG4gICAgICAgIH1cblxuICAgICAgICBlZGl0b3IuY29tbWFuZHMuZGVsZXRlU2VsZWN0aW9uKClcbiAgICB9XG5cbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwic3ZlbHRlLW9wdGlvbnMtbWVudVwiPlxuICAgIHsjaWYgc2hvd1NldHRpbmdzfVxuICAgICAgICA8QmxvY2tTZXR0aW5ncyB7aGFuZGxlT3Blbn0gLz5cbiAgICB7L2lmfVxuICAgIHsjaWYgc2hvd0R1cGxpY2F0ZX1cbiAgICAgICAgPER1cGxpY2F0ZUJsb2NrIHtoYW5kbGVEdXBsaWNhdGV9IC8+XG4gICAgey9pZn1cbiAgICB7I2lmIHNob3dSZW1vdmV9XG4gICAgICAgIDxSZW1vdmVCbG9jayB7aGFuZGxlUmVtb3ZlfSAvPlxuICAgIHsvaWZ9XG48L2Rpdj5cbiIsICI8c2NyaXB0PlxuICAgIGltcG9ydCB7IE5vZGVWaWV3V3JhcHBlciB9IGZyb20gJ3N2ZWx0ZS10aXB0YXAnXG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgQmxvY2tBY3Rpb25zIGZyb20gJy4vQmxvY2tBY3Rpb25zLnN2ZWx0ZSdcbiAgICBpbXBvcnQgRHJhZ0hhbmRsZSBmcm9tICcuL0RyYWdIYW5kbGUuc3ZlbHRlJ1xuICAgIGltcG9ydCB0aXBweSBmcm9tICd0aXBweS5qcydcbiAgICBpbXBvcnQgT3B0aW9uc01lbnUgZnJvbSAnLi4vY29tcG9uZW50cy9PcHRpb25zTWVudS5zdmVsdGUnXG5cbiAgICBleHBvcnQgbGV0IGVkaXRvcjtcbiAgICBleHBvcnQgbGV0IG5vZGU7XG4gICAgZXhwb3J0IGxldCBzZWxlY3RlZCA9IGZhbHNlO1xuICAgIGV4cG9ydCBsZXQgdXBkYXRlQXR0cmlidXRlcztcblxuICAgIGxldCBjb21wb25lbnQ7XG4gICAgbGV0IHBvcHVwSW5zdGFuY2U7XG5cbiAgICBjb25zdCBoYW5kbGVNZW51T3BlbiA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBjbGllbnRSZWN0ID0gZXZlbnQuY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAvLyBJbml6aWFsaXp6YSBwcmltYSBpbCBjb21wb25lbnRlIHNlbnphIHBvcHVwSW5zdGFuY2VcbiAgICAgICAgY29tcG9uZW50ID0gbmV3IE9wdGlvbnNNZW51KHtcbiAgICAgICAgICAgIHRhcmdldDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIC8vIENyZWEgdW4gZWxlbWVudG8gZGl2IHBlciBtb250YXJlIGlsIGNvbXBvbmVudGUgU3ZlbHRlXG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgc2hvd1NldHRpbmdzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgb25DbG9zZTogKCkgPT4gY2xvc2VPcHRpb25zKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcG9wdXBJbnN0YW5jZSA9IHRpcHB5KCdib2R5Jywge1xuICAgICAgICAgICAgY29udGVudDogY29tcG9uZW50LiQkLnJvb3QsXG4gICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiAoKSA9PiBjbGllbnRSZWN0LFxuICAgICAgICAgICAgYWxsb3dIVE1MOiB0cnVlLFxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICB0cmlnZ2VyOiAnbWFudWFsJyxcbiAgICAgICAgICAgIHBsYWNlbWVudDogJ2xlZnQnLFxuICAgICAgICAgICAgc2hvd09uQ3JlYXRlOiB0cnVlLFxuICAgICAgICAgICAgaGlkZU9uQ2xpY2s6IHRydWUsXG4gICAgICAgICAgICB0aGVtZTogJ3NjcmliYmxlLW9wdGlvbnMnLFxuICAgICAgICAgICAgYXJyb3c6IHRydWUsXG4gICAgICAgICAgICB6SW5kZXg6IDk5OTksXG4gICAgICAgICAgICBvbkhpZGRlbihpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGNsb3NlT3B0aW9ucyA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb3B1cEluc3RhbmNlKSkge1xuICAgICAgICAgICAgcG9wdXBJbnN0YW5jZS5mb3JFYWNoKGluc3RhbmNlID0+IGluc3RhbmNlLmhpZGUoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3B1cEluc3RhbmNlLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlZEJsb2NrJywgKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBlLmRldGFpbC50eXBlID09PSBub2RlLmF0dHJzLnR5cGVcbiAgICAgICAgICAgICAgICAmJiBlLmRldGFpbC5zdGF0ZVBhdGggPT09IGVkaXRvci5zdG9yYWdlPy5zdGF0ZVBhdGhFeHRlbnNpb24uc3RhdGVQYXRoXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVBdHRyaWJ1dGVzKHsgdmFsdWVzOiBlLmRldGFpbC52YWx1ZXMgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KVxuPC9zY3JpcHQ+XG5cbjxOb2RlVmlld1dyYXBwZXI+XG4gICAgPGRpdiBjbGFzcz1cInNjcmliYmxlLWJsb2NrXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzY3JpYmJsZS1ibG9jay1jb250ZW50IHtzZWxlY3RlZCA/ICdQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGUnIDogJyd9XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicC04XCI+XG4gICAgICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICAgICAgICBzcmM9e25vZGUuYXR0cnMuc3JjfVxuICAgICAgICAgICAgICAgICAgICBhbHQ9e25vZGUuYXR0cnMuYWx0fVxuICAgICAgICAgICAgICAgICAgICB0aXRsZT17bm9kZS5hdHRycz8udGl0bGUgPz8gbnVsbH1cbiAgICAgICAgICAgICAgICAgICAgd2lkdGg9e25vZGUuYXR0cnMud2lkdGh9XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodD17bm9kZS5hdHRycy5oZWlnaHR9XG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmc9e25vZGUuYXR0cnMubG9hZGluZ31cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8QmxvY2tBY3Rpb25zPlxuICAgICAgICAgICAgPERyYWdIYW5kbGUge2hhbmRsZU1lbnVPcGVufSAvPlxuICAgICAgICA8L0Jsb2NrQWN0aW9ucz5cbiAgICA8L2Rpdj5cbjwvTm9kZVZpZXdXcmFwcGVyPlxuIiwgImltcG9ydCBJbWFnZSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24taW1hZ2VcIjtcbmltcG9ydCB7IFN2ZWx0ZU5vZGVWaWV3UmVuZGVyZXIgfSBmcm9tICdzdmVsdGUtdGlwdGFwJ1xuaW1wb3J0IE1lZGlhVmlldyBmcm9tICcuLi9jb21wb25lbnRzL01lZGlhVmlldy5zdmVsdGUnXG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlLmV4dGVuZCh7XG4gICAgc2VsZWN0YWJsZTogdHJ1ZSxcblxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcmM6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsdDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvYWRpbmc6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpemVzOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzcmNzZXQ6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldE1lZGlhOiBvcHRpb25zID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcmMgPSBvcHRpb25zPy51cmwgfHwgb3B0aW9ucz8uc3JjO1xuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlVHlwZXMgPSBbJ2pwZycsICdqcGVnJywgJ3N2ZycsICdwbmcnLCAnd2VicCddO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSAvLipcXC4oW2EtekEtWl0qKVxcPz8vO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyhzcmMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsICYmIGltYWdlVHlwZXMuaW5jbHVkZXMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzLnNldEltYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogc3JjLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWx0OiBvcHRpb25zPy5hbHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogb3B0aW9ucz8udGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogb3B0aW9ucz8ud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG9wdGlvbnM/LmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhenk6IG9wdGlvbnM/LmxhenksXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZHMuc2V0RG9jdW1lbnQob3B0aW9ucylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0RG9jdW1lbnQ6IG9wdGlvbnMgPT4gKHsgY2hhaW4gfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbigpLmZvY3VzKCkuZXh0ZW5kTWFya1JhbmdlKCdsaW5rJykuc2V0TGluayh7IGhyZWY6IG9wdGlvbnMuc3JjIH0pLmluc2VydENvbnRlbnQob3B0aW9ucz8ubGlua190ZXh0KS5ydW4oKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldEltYWdlOiBvcHRpb25zID0+ICh7IGNoYWluIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW4oKS5mb2N1cygpLmluc2VydENvbnRlbnQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgIH0pLmNyZWF0ZVBhcmFncmFwaE5lYXIoKS5ydW4oKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGROb2RlVmlldygpIHtcbiAgICAgICAgcmV0dXJuIFN2ZWx0ZU5vZGVWaWV3UmVuZGVyZXIoTWVkaWFWaWV3KVxuICAgIH1cbn0pO1xuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGRlZmF1bHQgTm9kZS5jcmVhdGUoe1xuICAgIG5hbWU6ICdtZXJnZVRhZycsXG5cbiAgICBncm91cDogJ2lubGluZScsXG5cbiAgICBpbmxpbmU6IHRydWUsXG5cbiAgICBzZWxlY3RhYmxlOiBmYWxzZSxcblxuICAgIGF0b206IHRydWUsXG5cbiAgICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgICAgIHBhcnNlSFRNTDogZWxlbWVudCA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1pZCcpLFxuICAgICAgICAgICAgICAgIHJlbmRlckhUTUw6IGF0dHJpYnV0ZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXMuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7fVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWlkJzogYXR0cmlidXRlcy5pZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiBgc3BhbltkYXRhLXR5cGU9JyR7dGhpcy5uYW1lfSddYFxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcblxuICAgIHJlbmRlckhUTUwoeyBub2RlLCBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICBtZXJnZUF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgeyAnZGF0YS10eXBlJzogdGhpcy5uYW1lIH0sXG4gICAgICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBge3sgJHtub2RlLmF0dHJzLmlkfSB9fWAsXG4gICAgICAgIF1cbiAgICB9LFxuXG4gICAgcmVuZGVyVGV4dCh7IG5vZGUgfSkge1xuICAgICAgICByZXR1cm4gYHt7ICR7bm9kZS5hdHRycy5pZH0gfX1gXG4gICAgfSxcblxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgQmFja3NwYWNlOiAoKSA9PlxuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmNvbW1hbmQoKHsgdHIsIHN0YXRlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzTWVyZ2VUYWcgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBlbXB0eSwgYW5jaG9yIH0gPSBzZWxlY3Rpb25cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oYW5jaG9yIC0gMSwgYW5jaG9yLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlLm5hbWUgPT09IHRoaXMubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTWVyZ2VUYWcgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuaW5zZXJ0VGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3t7JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgKyBub2RlLm5vZGVTaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTWVyZ2VUYWdcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5zZXJ0TWVyZ2VUYWc6IChhdHRyaWJ1dGVzKSA9PiAoeyBjaGFpbiwgc3RhdGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDaGFpbiA9IGNoYWluKClcblxuICAgICAgICAgICAgICAgIGlmICghIFtudWxsLCB1bmRlZmluZWRdLmluY2x1ZGVzKGF0dHJpYnV0ZXMuY29vcmRpbmF0ZXM/LnBvcykpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYWluLmluc2VydENvbnRlbnRBdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgZnJvbTogYXR0cmlidXRlcy5jb29yZGluYXRlcy5wb3MsIHRvOiBhdHRyaWJ1dGVzLmNvb3JkaW5hdGVzLnBvcyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogdGhpcy5uYW1lLCBhdHRyczogeyBpZDogYXR0cmlidXRlcy50YWcgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCB0ZXh0OiAnICcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudENoYWluXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgIH0sXG59KVxuIiwgImltcG9ydCB7IGVzY2FwZUZvclJlZ0V4LCBSYW5nZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IFJlc29sdmVkUG9zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGludGVyZmFjZSBUcmlnZ2VyIHtcbiAgY2hhcjogc3RyaW5nXG4gIGFsbG93U3BhY2VzOiBib29sZWFuXG4gIGFsbG93ZWRQcmVmaXhlczogc3RyaW5nW10gfCBudWxsXG4gIHN0YXJ0T2ZMaW5lOiBib29sZWFuXG4gICRwb3NpdGlvbjogUmVzb2x2ZWRQb3Ncbn1cblxuZXhwb3J0IHR5cGUgU3VnZ2VzdGlvbk1hdGNoID0ge1xuICByYW5nZTogUmFuZ2VcbiAgcXVlcnk6IHN0cmluZ1xuICB0ZXh0OiBzdHJpbmdcbn0gfCBudWxsXG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kU3VnZ2VzdGlvbk1hdGNoKGNvbmZpZzogVHJpZ2dlcik6IFN1Z2dlc3Rpb25NYXRjaCB7XG4gIGNvbnN0IHtcbiAgICBjaGFyLCBhbGxvd1NwYWNlcywgYWxsb3dlZFByZWZpeGVzLCBzdGFydE9mTGluZSwgJHBvc2l0aW9uLFxuICB9ID0gY29uZmlnXG5cbiAgY29uc3QgZXNjYXBlZENoYXIgPSBlc2NhcGVGb3JSZWdFeChjaGFyKVxuICBjb25zdCBzdWZmaXggPSBuZXcgUmVnRXhwKGBcXFxccyR7ZXNjYXBlZENoYXJ9JGApXG4gIGNvbnN0IHByZWZpeCA9IHN0YXJ0T2ZMaW5lID8gJ14nIDogJydcbiAgY29uc3QgcmVnZXhwID0gYWxsb3dTcGFjZXNcbiAgICA/IG5ldyBSZWdFeHAoYCR7cHJlZml4fSR7ZXNjYXBlZENoYXJ9Lio/KD89XFxcXHMke2VzY2FwZWRDaGFyfXwkKWAsICdnbScpXG4gICAgOiBuZXcgUmVnRXhwKGAke3ByZWZpeH0oPzpeKT8ke2VzY2FwZWRDaGFyfVteXFxcXHMke2VzY2FwZWRDaGFyfV0qYCwgJ2dtJylcblxuICBjb25zdCB0ZXh0ID0gJHBvc2l0aW9uLm5vZGVCZWZvcmU/LmlzVGV4dCAmJiAkcG9zaXRpb24ubm9kZUJlZm9yZS50ZXh0XG5cbiAgaWYgKCF0ZXh0KSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHRleHRGcm9tID0gJHBvc2l0aW9uLnBvcyAtIHRleHQubGVuZ3RoXG4gIGNvbnN0IG1hdGNoID0gQXJyYXkuZnJvbSh0ZXh0Lm1hdGNoQWxsKHJlZ2V4cCkpLnBvcCgpXG5cbiAgaWYgKCFtYXRjaCB8fCBtYXRjaC5pbnB1dCA9PT0gdW5kZWZpbmVkIHx8IG1hdGNoLmluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gSmF2YVNjcmlwdCBkb2Vzbid0IGhhdmUgbG9va2JlaGluZHMuIFRoaXMgaGFja3MgYSBjaGVjayB0aGF0IGZpcnN0IGNoYXJhY3RlclxuICAvLyBpcyBhIHNwYWNlIG9yIHRoZSBzdGFydCBvZiB0aGUgbGluZVxuICBjb25zdCBtYXRjaFByZWZpeCA9IG1hdGNoLmlucHV0LnNsaWNlKE1hdGgubWF4KDAsIG1hdGNoLmluZGV4IC0gMSksIG1hdGNoLmluZGV4KVxuICBjb25zdCBtYXRjaFByZWZpeElzQWxsb3dlZCA9IG5ldyBSZWdFeHAoYF5bJHthbGxvd2VkUHJlZml4ZXM/LmpvaW4oJycpfVxcMF0/JGApLnRlc3QobWF0Y2hQcmVmaXgpXG5cbiAgaWYgKGFsbG93ZWRQcmVmaXhlcyAhPT0gbnVsbCAmJiAhbWF0Y2hQcmVmaXhJc0FsbG93ZWQpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBtYXRjaCBpbiB0aGUgZG9jdW1lbnRcbiAgY29uc3QgZnJvbSA9IHRleHRGcm9tICsgbWF0Y2guaW5kZXhcbiAgbGV0IHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aFxuXG4gIC8vIEVkZ2UgY2FzZSBoYW5kbGluZzsgaWYgc3BhY2VzIGFyZSBhbGxvd2VkIGFuZCB3ZSdyZSBkaXJlY3RseSBpbiBiZXR3ZWVuXG4gIC8vIHR3byB0cmlnZ2Vyc1xuICBpZiAoYWxsb3dTcGFjZXMgJiYgc3VmZml4LnRlc3QodGV4dC5zbGljZSh0byAtIDEsIHRvICsgMSkpKSB7XG4gICAgbWF0Y2hbMF0gKz0gJyAnXG4gICAgdG8gKz0gMVxuICB9XG5cbiAgLy8gSWYgdGhlICRwb3NpdGlvbiBpcyBsb2NhdGVkIHdpdGhpbiB0aGUgbWF0Y2hlZCBzdWJzdHJpbmcsIHJldHVybiB0aGF0IHJhbmdlXG4gIGlmIChmcm9tIDwgJHBvc2l0aW9uLnBvcyAmJiB0byA+PSAkcG9zaXRpb24ucG9zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhbmdlOiB7XG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgICAgfSxcbiAgICAgIHF1ZXJ5OiBtYXRjaFswXS5zbGljZShjaGFyLmxlbmd0aCksXG4gICAgICB0ZXh0OiBtYXRjaFswXSxcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuIiwgImltcG9ydCB7IEVkaXRvciwgUmFuZ2UgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSwgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldCwgRWRpdG9yVmlldyB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldydcblxuaW1wb3J0IHsgZmluZFN1Z2dlc3Rpb25NYXRjaCBhcyBkZWZhdWx0RmluZFN1Z2dlc3Rpb25NYXRjaCB9IGZyb20gJy4vZmluZFN1Z2dlc3Rpb25NYXRjaC5qcydcblxuZXhwb3J0IGludGVyZmFjZSBTdWdnZXN0aW9uT3B0aW9uczxJID0gYW55PiB7XG4gIHBsdWdpbktleT86IFBsdWdpbktleVxuICBlZGl0b3I6IEVkaXRvclxuICBjaGFyPzogc3RyaW5nXG4gIGFsbG93U3BhY2VzPzogYm9vbGVhblxuICBhbGxvd2VkUHJlZml4ZXM/OiBzdHJpbmdbXSB8IG51bGxcbiAgc3RhcnRPZkxpbmU/OiBib29sZWFuXG4gIGRlY29yYXRpb25UYWc/OiBzdHJpbmdcbiAgZGVjb3JhdGlvbkNsYXNzPzogc3RyaW5nXG4gIGNvbW1hbmQ/OiAocHJvcHM6IHsgZWRpdG9yOiBFZGl0b3I7IHJhbmdlOiBSYW5nZTsgcHJvcHM6IEkgfSkgPT4gdm9pZFxuICBpdGVtcz86IChwcm9wczogeyBxdWVyeTogc3RyaW5nOyBlZGl0b3I6IEVkaXRvciB9KSA9PiBJW10gfCBQcm9taXNlPElbXT5cbiAgcmVuZGVyPzogKCkgPT4ge1xuICAgIG9uQmVmb3JlU3RhcnQ/OiAocHJvcHM6IFN1Z2dlc3Rpb25Qcm9wczxJPikgPT4gdm9pZFxuICAgIG9uU3RhcnQ/OiAocHJvcHM6IFN1Z2dlc3Rpb25Qcm9wczxJPikgPT4gdm9pZFxuICAgIG9uQmVmb3JlVXBkYXRlPzogKHByb3BzOiBTdWdnZXN0aW9uUHJvcHM8ST4pID0+IHZvaWRcbiAgICBvblVwZGF0ZT86IChwcm9wczogU3VnZ2VzdGlvblByb3BzPEk+KSA9PiB2b2lkXG4gICAgb25FeGl0PzogKHByb3BzOiBTdWdnZXN0aW9uUHJvcHM8ST4pID0+IHZvaWRcbiAgICBvbktleURvd24/OiAocHJvcHM6IFN1Z2dlc3Rpb25LZXlEb3duUHJvcHMpID0+IGJvb2xlYW5cbiAgfVxuICBhbGxvdz86IChwcm9wczogeyBlZGl0b3I6IEVkaXRvcjsgc3RhdGU6IEVkaXRvclN0YXRlOyByYW5nZTogUmFuZ2UgfSkgPT4gYm9vbGVhblxuICBmaW5kU3VnZ2VzdGlvbk1hdGNoPzogdHlwZW9mIGRlZmF1bHRGaW5kU3VnZ2VzdGlvbk1hdGNoXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3VnZ2VzdGlvblByb3BzPEkgPSBhbnk+IHtcbiAgZWRpdG9yOiBFZGl0b3JcbiAgcmFuZ2U6IFJhbmdlXG4gIHF1ZXJ5OiBzdHJpbmdcbiAgdGV4dDogc3RyaW5nXG4gIGl0ZW1zOiBJW11cbiAgY29tbWFuZDogKHByb3BzOiBJKSA9PiB2b2lkXG4gIGRlY29yYXRpb25Ob2RlOiBFbGVtZW50IHwgbnVsbFxuICBjbGllbnRSZWN0PzogKCgpID0+IERPTVJlY3QgfCBudWxsKSB8IG51bGxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdWdnZXN0aW9uS2V5RG93blByb3BzIHtcbiAgdmlldzogRWRpdG9yVmlld1xuICBldmVudDogS2V5Ym9hcmRFdmVudFxuICByYW5nZTogUmFuZ2Vcbn1cblxuZXhwb3J0IGNvbnN0IFN1Z2dlc3Rpb25QbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5KCdzdWdnZXN0aW9uJylcblxuZXhwb3J0IGZ1bmN0aW9uIFN1Z2dlc3Rpb248SSA9IGFueT4oe1xuICBwbHVnaW5LZXkgPSBTdWdnZXN0aW9uUGx1Z2luS2V5LFxuICBlZGl0b3IsXG4gIGNoYXIgPSAnQCcsXG4gIGFsbG93U3BhY2VzID0gZmFsc2UsXG4gIGFsbG93ZWRQcmVmaXhlcyA9IFsnICddLFxuICBzdGFydE9mTGluZSA9IGZhbHNlLFxuICBkZWNvcmF0aW9uVGFnID0gJ3NwYW4nLFxuICBkZWNvcmF0aW9uQ2xhc3MgPSAnc3VnZ2VzdGlvbicsXG4gIGNvbW1hbmQgPSAoKSA9PiBudWxsLFxuICBpdGVtcyA9ICgpID0+IFtdLFxuICByZW5kZXIgPSAoKSA9PiAoe30pLFxuICBhbGxvdyA9ICgpID0+IHRydWUsXG4gIGZpbmRTdWdnZXN0aW9uTWF0Y2ggPSBkZWZhdWx0RmluZFN1Z2dlc3Rpb25NYXRjaCxcbn06IFN1Z2dlc3Rpb25PcHRpb25zPEk+KSB7XG4gIGxldCBwcm9wczogU3VnZ2VzdGlvblByb3BzPEk+IHwgdW5kZWZpbmVkXG4gIGNvbnN0IHJlbmRlcmVyID0gcmVuZGVyPy4oKVxuXG4gIGNvbnN0IHBsdWdpbjogUGx1Z2luPGFueT4gPSBuZXcgUGx1Z2luKHtcbiAgICBrZXk6IHBsdWdpbktleSxcblxuICAgIHZpZXcoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGU6IGFzeW5jICh2aWV3LCBwcmV2U3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5rZXk/LmdldFN0YXRlKHByZXZTdGF0ZSlcbiAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5rZXk/LmdldFN0YXRlKHZpZXcuc3RhdGUpXG5cbiAgICAgICAgICAvLyBTZWUgaG93IHRoZSBzdGF0ZSBjaGFuZ2VkXG4gICAgICAgICAgY29uc3QgbW92ZWQgPSBwcmV2LmFjdGl2ZSAmJiBuZXh0LmFjdGl2ZSAmJiBwcmV2LnJhbmdlLmZyb20gIT09IG5leHQucmFuZ2UuZnJvbVxuICAgICAgICAgIGNvbnN0IHN0YXJ0ZWQgPSAhcHJldi5hY3RpdmUgJiYgbmV4dC5hY3RpdmVcbiAgICAgICAgICBjb25zdCBzdG9wcGVkID0gcHJldi5hY3RpdmUgJiYgIW5leHQuYWN0aXZlXG4gICAgICAgICAgY29uc3QgY2hhbmdlZCA9ICFzdGFydGVkICYmICFzdG9wcGVkICYmIHByZXYucXVlcnkgIT09IG5leHQucXVlcnlcbiAgICAgICAgICBjb25zdCBoYW5kbGVTdGFydCA9IHN0YXJ0ZWQgfHwgbW92ZWRcbiAgICAgICAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSBjaGFuZ2VkICYmICFtb3ZlZFxuICAgICAgICAgIGNvbnN0IGhhbmRsZUV4aXQgPSBzdG9wcGVkIHx8IG1vdmVkXG5cbiAgICAgICAgICAvLyBDYW5jZWwgd2hlbiBzdWdnZXN0aW9uIGlzbid0IGFjdGl2ZVxuICAgICAgICAgIGlmICghaGFuZGxlU3RhcnQgJiYgIWhhbmRsZUNoYW5nZSAmJiAhaGFuZGxlRXhpdCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBoYW5kbGVFeGl0ICYmICFoYW5kbGVTdGFydCA/IHByZXYgOiBuZXh0XG4gICAgICAgICAgY29uc3QgZGVjb3JhdGlvbk5vZGUgPSB2aWV3LmRvbS5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgYFtkYXRhLWRlY29yYXRpb24taWQ9XCIke3N0YXRlLmRlY29yYXRpb25JZH1cIl1gLFxuICAgICAgICAgIClcblxuICAgICAgICAgIHByb3BzID0ge1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgcmFuZ2U6IHN0YXRlLnJhbmdlLFxuICAgICAgICAgICAgcXVlcnk6IHN0YXRlLnF1ZXJ5LFxuICAgICAgICAgICAgdGV4dDogc3RhdGUudGV4dCxcbiAgICAgICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgICAgIGNvbW1hbmQ6IGNvbW1hbmRQcm9wcyA9PiB7XG4gICAgICAgICAgICAgIGNvbW1hbmQoe1xuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICByYW5nZTogc3RhdGUucmFuZ2UsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGNvbW1hbmRQcm9wcyxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvcmF0aW9uTm9kZSxcbiAgICAgICAgICAgIC8vIHZpcnR1YWwgbm9kZSBmb3IgcG9wcGVyLmpzIG9yIHRpcHB5LmpzXG4gICAgICAgICAgICAvLyB0aGlzIGNhbiBiZSB1c2VkIGZvciBidWlsZGluZyBwb3B1cHMgd2l0aG91dCBhIERPTSBub2RlXG4gICAgICAgICAgICBjbGllbnRSZWN0OiBkZWNvcmF0aW9uTm9kZVxuICAgICAgICAgICAgICA/ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIG9mIGBpdGVtc2AgY2FuIGJlIGFzeW5jaHJvdW5vdXMgd2XigJlsbCBzZWFyY2ggZm9yIHRoZSBjdXJyZW50IGRlY29yYXRpb24gbm9kZVxuICAgICAgICAgICAgICAgICAgY29uc3QgeyBkZWNvcmF0aW9uSWQgfSA9IHRoaXMua2V5Py5nZXRTdGF0ZShlZGl0b3Iuc3RhdGUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RGVjb3JhdGlvbk5vZGUgPSB2aWV3LmRvbS5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgICAgICAgYFtkYXRhLWRlY29yYXRpb24taWQ9XCIke2RlY29yYXRpb25JZH1cIl1gLFxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGVjb3JhdGlvbk5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHx8IG51bGxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhbmRsZVN0YXJ0KSB7XG4gICAgICAgICAgICByZW5kZXJlcj8ub25CZWZvcmVTdGFydD8uKHByb3BzKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYW5kbGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyPy5vbkJlZm9yZVVwZGF0ZT8uKHByb3BzKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYW5kbGVDaGFuZ2UgfHwgaGFuZGxlU3RhcnQpIHtcbiAgICAgICAgICAgIHByb3BzLml0ZW1zID0gYXdhaXQgaXRlbXMoe1xuICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgIHF1ZXJ5OiBzdGF0ZS5xdWVyeSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhbmRsZUV4aXQpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyPy5vbkV4aXQ/Lihwcm9wcylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFuZGxlQ2hhbmdlKSB7XG4gICAgICAgICAgICByZW5kZXJlcj8ub25VcGRhdGU/Lihwcm9wcylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFuZGxlU3RhcnQpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyPy5vblN0YXJ0Py4ocHJvcHMpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW5kZXJlcj8ub25FeGl0Py4ocHJvcHMpXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0YXRlOiB7XG4gICAgICAvLyBJbml0aWFsaXplIHRoZSBwbHVnaW4ncyBpbnRlcm5hbCBzdGF0ZS5cbiAgICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlOiB7XG4gICAgICAgICAgYWN0aXZlOiBib29sZWFuXG4gICAgICAgICAgcmFuZ2U6IFJhbmdlXG4gICAgICAgICAgcXVlcnk6IG51bGwgfCBzdHJpbmdcbiAgICAgICAgICB0ZXh0OiBudWxsIHwgc3RyaW5nXG4gICAgICAgICAgY29tcG9zaW5nOiBib29sZWFuXG4gICAgICAgICAgZGVjb3JhdGlvbklkPzogc3RyaW5nIHwgbnVsbFxuICAgICAgICB9ID0ge1xuICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgIGZyb206IDAsXG4gICAgICAgICAgICB0bzogMCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHF1ZXJ5OiBudWxsLFxuICAgICAgICAgIHRleHQ6IG51bGwsXG4gICAgICAgICAgY29tcG9zaW5nOiBmYWxzZSxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGF0ZVxuICAgICAgfSxcblxuICAgICAgLy8gQXBwbHkgY2hhbmdlcyB0byB0aGUgcGx1Z2luIHN0YXRlIGZyb20gYSB2aWV3IHRyYW5zYWN0aW9uLlxuICAgICAgYXBwbHkodHJhbnNhY3Rpb24sIHByZXYsIG9sZFN0YXRlLCBzdGF0ZSkge1xuICAgICAgICBjb25zdCB7IGlzRWRpdGFibGUgfSA9IGVkaXRvclxuICAgICAgICBjb25zdCB7IGNvbXBvc2luZyB9ID0gZWRpdG9yLnZpZXdcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyYW5zYWN0aW9uXG4gICAgICAgIGNvbnN0IHsgZW1wdHksIGZyb20gfSA9IHNlbGVjdGlvblxuICAgICAgICBjb25zdCBuZXh0ID0geyAuLi5wcmV2IH1cblxuICAgICAgICBuZXh0LmNvbXBvc2luZyA9IGNvbXBvc2luZ1xuXG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IGJlIHN1Z2dlc3RpbmcgaWYgdGhlIHZpZXcgaXMgZWRpdGFibGUsIGFuZDpcbiAgICAgICAgLy8gICAqIHRoZXJlIGlzIG5vIHNlbGVjdGlvbiwgb3JcbiAgICAgICAgLy8gICAqIGEgY29tcG9zaXRpb24gaXMgYWN0aXZlIChzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMTQ0OSlcbiAgICAgICAgaWYgKGlzRWRpdGFibGUgJiYgKGVtcHR5IHx8IGVkaXRvci52aWV3LmNvbXBvc2luZykpIHtcbiAgICAgICAgICAvLyBSZXNldCBhY3RpdmUgc3RhdGUgaWYgd2UganVzdCBsZWZ0IHRoZSBwcmV2aW91cyBzdWdnZXN0aW9uIHJhbmdlXG4gICAgICAgICAgaWYgKChmcm9tIDwgcHJldi5yYW5nZS5mcm9tIHx8IGZyb20gPiBwcmV2LnJhbmdlLnRvKSAmJiAhY29tcG9zaW5nICYmICFwcmV2LmNvbXBvc2luZykge1xuICAgICAgICAgICAgbmV4dC5hY3RpdmUgPSBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRyeSB0byBtYXRjaCBhZ2FpbnN0IHdoZXJlIG91ciBjdXJzb3IgY3VycmVudGx5IGlzXG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSBmaW5kU3VnZ2VzdGlvbk1hdGNoKHtcbiAgICAgICAgICAgIGNoYXIsXG4gICAgICAgICAgICBhbGxvd1NwYWNlcyxcbiAgICAgICAgICAgIGFsbG93ZWRQcmVmaXhlcyxcbiAgICAgICAgICAgIHN0YXJ0T2ZMaW5lLFxuICAgICAgICAgICAgJHBvc2l0aW9uOiBzZWxlY3Rpb24uJGZyb20sXG4gICAgICAgICAgfSlcbiAgICAgICAgICBjb25zdCBkZWNvcmF0aW9uSWQgPSBgaWRfJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmKX1gXG5cbiAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIG1hdGNoLCB1cGRhdGUgdGhlIGN1cnJlbnQgc3RhdGUgdG8gc2hvdyBpdFxuICAgICAgICAgIGlmIChtYXRjaCAmJiBhbGxvdyh7IGVkaXRvciwgc3RhdGUsIHJhbmdlOiBtYXRjaC5yYW5nZSB9KSkge1xuICAgICAgICAgICAgbmV4dC5hY3RpdmUgPSB0cnVlXG4gICAgICAgICAgICBuZXh0LmRlY29yYXRpb25JZCA9IHByZXYuZGVjb3JhdGlvbklkID8gcHJldi5kZWNvcmF0aW9uSWQgOiBkZWNvcmF0aW9uSWRcbiAgICAgICAgICAgIG5leHQucmFuZ2UgPSBtYXRjaC5yYW5nZVxuICAgICAgICAgICAgbmV4dC5xdWVyeSA9IG1hdGNoLnF1ZXJ5XG4gICAgICAgICAgICBuZXh0LnRleHQgPSBtYXRjaC50ZXh0XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHQuYWN0aXZlID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dC5hY3RpdmUgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRvIGVtcHR5IHRoZSByYW5nZSBpZiBzdWdnZXN0aW9uIGlzIGluYWN0aXZlXG4gICAgICAgIGlmICghbmV4dC5hY3RpdmUpIHtcbiAgICAgICAgICBuZXh0LmRlY29yYXRpb25JZCA9IG51bGxcbiAgICAgICAgICBuZXh0LnJhbmdlID0geyBmcm9tOiAwLCB0bzogMCB9XG4gICAgICAgICAgbmV4dC5xdWVyeSA9IG51bGxcbiAgICAgICAgICBuZXh0LnRleHQgPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV4dFxuICAgICAgfSxcbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcbiAgICAgIC8vIENhbGwgdGhlIGtleWRvd24gaG9vayBpZiBzdWdnZXN0aW9uIGlzIGFjdGl2ZS5cbiAgICAgIGhhbmRsZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyBhY3RpdmUsIHJhbmdlIH0gPSBwbHVnaW4uZ2V0U3RhdGUodmlldy5zdGF0ZSlcblxuICAgICAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyPy5vbktleURvd24/Lih7IHZpZXcsIGV2ZW50LCByYW5nZSB9KSB8fCBmYWxzZVxuICAgICAgfSxcblxuICAgICAgLy8gU2V0dXAgZGVjb3JhdG9yIG9uIHRoZSBjdXJyZW50bHkgYWN0aXZlIHN1Z2dlc3Rpb24uXG4gICAgICBkZWNvcmF0aW9ucyhzdGF0ZSkge1xuICAgICAgICBjb25zdCB7IGFjdGl2ZSwgcmFuZ2UsIGRlY29yYXRpb25JZCB9ID0gcGx1Z2luLmdldFN0YXRlKHN0YXRlKVxuXG4gICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIFtcbiAgICAgICAgICBEZWNvcmF0aW9uLmlubGluZShyYW5nZS5mcm9tLCByYW5nZS50bywge1xuICAgICAgICAgICAgbm9kZU5hbWU6IGRlY29yYXRpb25UYWcsXG4gICAgICAgICAgICBjbGFzczogZGVjb3JhdGlvbkNsYXNzLFxuICAgICAgICAgICAgJ2RhdGEtZGVjb3JhdGlvbi1pZCc6IGRlY29yYXRpb25JZCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgXSlcbiAgICAgIH0sXG4gICAgfSxcbiAgfSlcblxuICByZXR1cm4gcGx1Z2luXG59XG4iLCAiPHNjcmlwdD5cbiAgICBleHBvcnQgbGV0IGl0ZW1zXG4gICAgZXhwb3J0IGxldCBlZGl0b3JcbiAgICBleHBvcnQgbGV0IHJhbmdlXG5cbiAgICBsZXQgc2VsZWN0ZWRJbmRleCA9IDBcbiAgICBsZXQgZHJvcGRvd25cblxuICAgIGV4cG9ydCBjb25zdCByZXNldEluZGV4ID0gKCkgPT4gc2VsZWN0ZWRJbmRleCA9IDBcblxuICAgIGV4cG9ydCBjb25zdCBvbktleURvd24gPSAoeyBldmVudCB9KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5rZXkgPT09ICdBcnJvd1VwJykge1xuICAgICAgICAgICAgdXBIYW5kbGVyKClcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnQXJyb3dEb3duJykge1xuICAgICAgICAgICAgZG93bkhhbmRsZXIoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgICAgICAgIGVudGVySGFuZGxlcigpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgdXBIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBzZWxlY3RlZEluZGV4ID0gKChzZWxlY3RlZEluZGV4ICsgaXRlbXMubGVuZ3RoKSAtIDEpICUgaXRlbXMubGVuZ3RoXG4gICAgICAgIHNjcm9sbFRvU2VsZWN0KClcbiAgICB9XG5cbiAgICBjb25zdCBkb3duSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgc2VsZWN0ZWRJbmRleCA9IChzZWxlY3RlZEluZGV4ICsgMSkgJSBpdGVtcy5sZW5ndGhcbiAgICAgICAgc2Nyb2xsVG9TZWxlY3QoKVxuICAgIH1cblxuICAgIGNvbnN0IGVudGVySGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgc2VsZWN0SXRlbShzZWxlY3RlZEluZGV4KVxuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdEl0ZW0gPSBpbmRleCA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpbmRleF1cblxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUFmdGVyID0gZWRpdG9yLnZpZXcuc3RhdGUuc2VsZWN0aW9uLiR0by5ub2RlQWZ0ZXJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJyaWRlU3BhY2UgPSBub2RlQWZ0ZXI/LnRleHQ/LnN0YXJ0c1dpdGgoJyAnKVxuXG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVTcGFjZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnRvICs9IDFcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgICAgICAgLmNoYWluKClcbiAgICAgICAgICAgICAgICAuZm9jdXMoKVxuICAgICAgICAgICAgICAgIC5pbnNlcnRDb250ZW50QXQocmFuZ2UsIFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ21lcmdlVGFnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7aWQ6IGl0ZW19XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICcgJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgLnJ1bigpXG5cbiAgICAgICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKT8uY29sbGFwc2VUb0VuZCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzY3JvbGxUb1NlbGVjdCA9ICgpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBkcm9wZG93bi5xdWVyeVNlbGVjdG9yKCcuYWN0aXZlLW9wdGlvbicpLnNjcm9sbEludG9WaWV3KHtcbiAgICAgICAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCcsXG4gICAgICAgICAgICAgICAgYmxvY2s6ICduZWFyZXN0JyxcbiAgICAgICAgICAgICAgICBpbmxpbmU6ICdlbmQnLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgMClcbiAgICB9XG48L3NjcmlwdD5cblxuPGRpdlxuICAgIGNsYXNzPVwic2NyaWJibGUtbWVyZ2UtdGFnc1wiXG4gICAgYmluZDp0aGlzPXtkcm9wZG93bn1cbj5cbiAgICA8ZGl2IGNsYXNzPVwiZ3JvdXBcIj5cbiAgICAgICAgeyNpZiBpdGVtcy5sZW5ndGh9XG4gICAgICAgICAgICB7I2VhY2ggaXRlbXMgYXMgaXRlbSwgaX1cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIG9uOmNsaWNrPXsoKSA9PiBzZWxlY3RJdGVtKGkpfVxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cIiB7IGkgPT09XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPyAnYWN0aXZlLW9wdGlvbicgOiAnJyB9XCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGV4dFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAge2l0ZW19XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgey9pZn1cblxuICAgICAgICB7I2lmICFpdGVtcy5sZW5ndGh9XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibm8tYmxvY2tzXCI+Tm8gbWVyZ2UgdGFncyBzZXQ8L2Rpdj5cbiAgICAgICAgey9pZn1cbiAgICA8L2Rpdj5cbjwvZGl2PlxuIiwgImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCBTdWdnZXN0aW9uIGZyb20gJ0B0aXB0YXAvc3VnZ2VzdGlvbidcbmltcG9ydCBNZXJnZVRhZ3NMaXN0IGZyb20gJy4uL2NvbXBvbmVudHMvTWVyZ2VUYWdzTGlzdC5zdmVsdGUnXG5pbXBvcnQgdGlwcHkgZnJvbSAndGlwcHkuanMnXG5pbXBvcnQgeyBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgZGVmYXVsdCBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnbWVyZ2VUYWdzRXh0ZW5zaW9uJyxcblxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YWdzOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogW10sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhdGVQYXRoOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBTdWdnZXN0aW9uKHtcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICAgIGNoYXI6ICd7eycsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogKHsgZWRpdG9yLCByYW5nZSwgcHJvcHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5jb21tYW5kKHsgZWRpdG9yLCByYW5nZSB9KVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RhcnRPZkxpbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBsdWdpbktleTogbmV3IFBsdWdpbktleSgnbWVyZ2VUYWdzRXh0ZW5zaW9uJyksXG4gICAgICAgICAgICAgICAgaXRlbXM6ICh7IHF1ZXJ5IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy50YWdzLmZpbHRlcihpdGVtID0+IGl0ZW0udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbmRlcjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3B1cFxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblN0YXJ0OiBwcm9wcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wcy5jbGllbnRSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gbmV3IE1lcmdlVGFnc0xpc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogcHJvcHMuaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IHByb3BzLmVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBwcm9wcy5yYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlUGF0aDogdGhpcy5vcHRpb25zLnN0YXRlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3B1cCA9IHRpcHB5KCdib2R5Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiBwcm9wcy5jbGllbnRSZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRUbzogKCkgPT4gZG9jdW1lbnQuYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29tcG9uZW50LiQkLnJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dPbkNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20tc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVtZTogJ3NjcmliYmxlLXBhbmVsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3c6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IDQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25VcGRhdGUocHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuJHNldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBwcm9wcy5pdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiBwcm9wcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBwcm9wcy5yYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnJlc2V0SW5kZXgoKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wcy5jbGllbnRSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVwWzBdLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogcHJvcHMuY2xpZW50UmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25LZXlEb3duKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLmV2ZW50LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wdXBbMF0uaGlkZSgpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50Lm9uS2V5RG93bihwcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkV4aXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wdXBbMF0uZGVzdHJveSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LiRkZXN0cm95KClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdXG4gICAgfVxufSlcbiIsICJpbXBvcnQgeyBFZGl0b3IsIEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IE5vZGUgYXMgUHJvc2VtaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IERlY29yYXRpb24sIERlY29yYXRpb25TZXQgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGxhY2Vob2xkZXJPcHRpb25zIHtcbiAgLyoqXG4gICAqICoqVGhlIGNsYXNzIG5hbWUgZm9yIHRoZSBlbXB0eSBlZGl0b3IqKlxuICAgKiBAZGVmYXVsdCAnaXMtZWRpdG9yLWVtcHR5J1xuICAgKi9cbiAgZW1wdHlFZGl0b3JDbGFzczogc3RyaW5nXG5cbiAgLyoqXG4gICAqICoqVGhlIGNsYXNzIG5hbWUgZm9yIGVtcHR5IG5vZGVzKipcbiAgICogQGRlZmF1bHQgJ2lzLWVtcHR5J1xuICAgKi9cbiAgZW1wdHlOb2RlQ2xhc3M6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiAqKlRoZSBwbGFjZWhvbGRlciBjb250ZW50KipcbiAgICpcbiAgICogWW91IGNhbiB1c2UgYSBmdW5jdGlvbiB0byByZXR1cm4gYSBkeW5hbWljIHBsYWNlaG9sZGVyIG9yIGEgc3RyaW5nLlxuICAgKiBAZGVmYXVsdCAnV3JpdGUgc29tZXRoaW5nIOKApidcbiAgICovXG4gIHBsYWNlaG9sZGVyOlxuICAgIHwgKChQbGFjZWhvbGRlclByb3BzOiB7XG4gICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgIG5vZGU6IFByb3NlbWlycm9yTm9kZVxuICAgICAgICBwb3M6IG51bWJlclxuICAgICAgICBoYXNBbmNob3I6IGJvb2xlYW5cbiAgICAgIH0pID0+IHN0cmluZylcbiAgICB8IHN0cmluZ1xuXG4gIC8qKlxuICAgKiAqKlVzZWQgZm9yIGVtcHR5IGNoZWNrIG9uIHRoZSBkb2N1bWVudC4qKlxuICAgKlxuICAgKiBJZiB0cnVlLCBhbnkgbm9kZSB0aGF0IGlzIG5vdCBhIGxlYWYgb3IgYXRvbSB3aWxsIGJlIGNvbnNpZGVyZWQgZm9yIGVtcHR5IGNoZWNrLlxuICAgKiBJZiBmYWxzZSwgb25seSBkZWZhdWx0IG5vZGVzIChwYXJhZ3JhcGhzKSB3aWxsIGJlIGNvbnNpZGVyZWQgZm9yIGVtcHR5IGNoZWNrLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgY29uc2lkZXJBbnlBc0VtcHR5OiBib29sZWFuXG5cbiAgLyoqXG4gICAqICoqQ2hlY2tzIGlmIHRoZSBwbGFjZWhvbGRlciBzaG91bGQgYmUgb25seSBzaG93biB3aGVuIHRoZSBlZGl0b3IgaXMgZWRpdGFibGUuKipcbiAgICpcbiAgICogSWYgdHJ1ZSwgdGhlIHBsYWNlaG9sZGVyIHdpbGwgb25seSBiZSBzaG93biB3aGVuIHRoZSBlZGl0b3IgaXMgZWRpdGFibGUuXG4gICAqIElmIGZhbHNlLCB0aGUgcGxhY2Vob2xkZXIgd2lsbCBhbHdheXMgYmUgc2hvd24uXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHNob3dPbmx5V2hlbkVkaXRhYmxlOiBib29sZWFuXG5cbiAgLyoqXG4gICAqICoqQ2hlY2tzIGlmIHRoZSBwbGFjZWhvbGRlciBzaG91bGQgYmUgb25seSBzaG93biB3aGVuIHRoZSBjdXJyZW50IG5vZGUgaXMgZW1wdHkuKipcbiAgICpcbiAgICogSWYgdHJ1ZSwgdGhlIHBsYWNlaG9sZGVyIHdpbGwgb25seSBiZSBzaG93biB3aGVuIHRoZSBjdXJyZW50IG5vZGUgaXMgZW1wdHkuXG4gICAqIElmIGZhbHNlLCB0aGUgcGxhY2Vob2xkZXIgd2lsbCBiZSBzaG93biB3aGVuIGFueSBub2RlIGlzIGVtcHR5LlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBzaG93T25seUN1cnJlbnQ6IGJvb2xlYW5cblxuICAvKipcbiAgICogKipDb250cm9scyBpZiB0aGUgcGxhY2Vob2xkZXIgc2hvdWxkIGJlIHNob3duIGZvciBhbGwgZGVzY2VuZGVudHMuKipcbiAgICpcbiAgICogSWYgdHJ1ZSwgdGhlIHBsYWNlaG9sZGVyIHdpbGwgYmUgc2hvd24gZm9yIGFsbCBkZXNjZW5kZW50cy5cbiAgICogSWYgZmFsc2UsIHRoZSBwbGFjZWhvbGRlciB3aWxsIG9ubHkgYmUgc2hvd24gZm9yIHRoZSBjdXJyZW50IG5vZGUuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBpbmNsdWRlQ2hpbGRyZW46IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNvbnN0IFBsYWNlaG9sZGVyID0gRXh0ZW5zaW9uLmNyZWF0ZTxQbGFjZWhvbGRlck9wdGlvbnM+KHtcbiAgbmFtZTogJ3BsYWNlaG9sZGVyJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlbXB0eUVkaXRvckNsYXNzOiAnaXMtZWRpdG9yLWVtcHR5JyxcbiAgICAgIGVtcHR5Tm9kZUNsYXNzOiAnaXMtZW1wdHknLFxuICAgICAgcGxhY2Vob2xkZXI6ICdXcml0ZSBzb21ldGhpbmcg4oCmJyxcbiAgICAgIHNob3dPbmx5V2hlbkVkaXRhYmxlOiB0cnVlLFxuICAgICAgY29uc2lkZXJBbnlBc0VtcHR5OiBmYWxzZSxcbiAgICAgIHNob3dPbmx5Q3VycmVudDogdHJ1ZSxcbiAgICAgIGluY2x1ZGVDaGlsZHJlbjogZmFsc2UsXG4gICAgfVxuICB9LFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgncGxhY2Vob2xkZXInKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBkZWNvcmF0aW9uczogKHsgZG9jLCBzZWxlY3Rpb24gfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSB8fCAhdGhpcy5vcHRpb25zLnNob3dPbmx5V2hlbkVkaXRhYmxlXG4gICAgICAgICAgICBjb25zdCB7IGFuY2hvciB9ID0gc2VsZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBkZWNvcmF0aW9uczogRGVjb3JhdGlvbltdID0gW11cblxuICAgICAgICAgICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb25seSBjYWxjdWxhdGUgaXNFbXB0eSBvbmNlIGR1ZSB0byBpdHMgcGVyZm9ybWFuY2UgaW1wYWN0cyAoc2VlIGlzc3VlICMzMzYwKVxuICAgICAgICAgICAgY29uc3QgeyBmaXJzdENoaWxkIH0gPSBkb2MuY29udGVudFxuICAgICAgICAgICAgY29uc3QgaXNMZWFmID0gZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkLnR5cGUuaXNMZWFmXG4gICAgICAgICAgICBjb25zdCBpc0F0b20gPSBmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQuaXNBdG9tXG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkTm9kZSA9IHRoaXMub3B0aW9ucy5jb25zaWRlckFueUFzRW1wdHlcbiAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgIDogZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkLnR5cGUubmFtZSA9PT0gZG9jLnR5cGUuY29udGVudE1hdGNoLmRlZmF1bHRUeXBlPy5uYW1lXG4gICAgICAgICAgICBjb25zdCBpc0VtcHR5RG9jID0gZG9jLmNvbnRlbnQuY2hpbGRDb3VudCA8PSAxXG4gICAgICAgICAgICAgICYmIGZpcnN0Q2hpbGRcbiAgICAgICAgICAgICAgJiYgaXNWYWxpZE5vZGVcbiAgICAgICAgICAgICAgJiYgKGZpcnN0Q2hpbGQubm9kZVNpemUgPD0gMiAmJiAoIWlzTGVhZiB8fCAhaXNBdG9tKSlcblxuICAgICAgICAgICAgZG9jLmRlc2NlbmRhbnRzKChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgaGFzQW5jaG9yID0gYW5jaG9yID49IHBvcyAmJiBhbmNob3IgPD0gcG9zICsgbm9kZS5ub2RlU2l6ZVxuICAgICAgICAgICAgICBjb25zdCBpc0VtcHR5ID0gIW5vZGUuaXNMZWFmICYmICFub2RlLmNoaWxkQ291bnRcblxuICAgICAgICAgICAgICBpZiAoKGhhc0FuY2hvciB8fCAhdGhpcy5vcHRpb25zLnNob3dPbmx5Q3VycmVudCkgJiYgaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSBbdGhpcy5vcHRpb25zLmVtcHR5Tm9kZUNsYXNzXVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHlEb2MpIHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCh0aGlzLm9wdGlvbnMuZW1wdHlFZGl0b3JDbGFzcylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBkZWNvcmF0aW9uID0gRGVjb3JhdGlvbi5ub2RlKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwge1xuICAgICAgICAgICAgICAgICAgY2xhc3M6IGNsYXNzZXMuam9pbignICcpLFxuICAgICAgICAgICAgICAgICAgJ2RhdGEtcGxhY2Vob2xkZXInOlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNBbmNob3IsXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaChkZWNvcmF0aW9uKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbmNsdWRlQ2hpbGRyZW5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKVxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSwgd3JhcHBpbmdJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQmxvY2txdW90ZU9wdGlvbnMge1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGJsb2NrUXVvdGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgYmxvY2txdW90ZSBub2RlXG4gICAgICAgKi9cbiAgICAgIHNldEJsb2NrcXVvdGU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIGJsb2NrcXVvdGUgbm9kZVxuICAgICAgICovXG4gICAgICB0b2dnbGVCbG9ja3F1b3RlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBVbnNldCBhIGJsb2NrcXVvdGUgbm9kZVxuICAgICAgICovXG4gICAgICB1bnNldEJsb2NrcXVvdGU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbnB1dFJlZ2V4ID0gL15cXHMqPlxccyQvXG5cbmV4cG9ydCBjb25zdCBCbG9ja3F1b3RlID0gTm9kZS5jcmVhdGU8QmxvY2txdW90ZU9wdGlvbnM+KHtcblxuICBuYW1lOiAnYmxvY2txdW90ZScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBjb250ZW50OiAnYmxvY2srJyxcblxuICBncm91cDogJ2Jsb2NrJyxcblxuICBkZWZpbmluZzogdHJ1ZSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHsgdGFnOiAnYmxvY2txdW90ZScgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydibG9ja3F1b3RlJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRCbG9ja3F1b3RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy53cmFwSW4odGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZUJsb2NrcXVvdGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZVdyYXAodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHVuc2V0QmxvY2txdW90ZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMubGlmdCh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC1TaGlmdC1iJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQmxvY2txdW90ZSgpLFxuICAgIH1cbiAgfSxcblxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICB3cmFwcGluZ0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHtcbiAgTWFyayxcbiAgbWFya0lucHV0UnVsZSxcbiAgbWFya1Bhc3RlUnVsZSxcbiAgbWVyZ2VBdHRyaWJ1dGVzLFxufSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQm9sZE9wdGlvbnMge1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGJvbGQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgYm9sZCBtYXJrXG4gICAgICAgKi9cbiAgICAgIHNldEJvbGQ6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIGJvbGQgbWFya1xuICAgICAgICovXG4gICAgICB0b2dnbGVCb2xkOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBVbnNldCBhIGJvbGQgbWFya1xuICAgICAgICovXG4gICAgICB1bnNldEJvbGQ6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzdGFySW5wdXRSZWdleCA9IC8oPzpefFxccykoKD86XFwqXFwqKSgoPzpbXipdKykpKD86XFwqXFwqKSkkL1xuZXhwb3J0IGNvbnN0IHN0YXJQYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKSgoPzpcXCpcXCopKCg/OlteKl0rKSkoPzpcXCpcXCopKS9nXG5leHBvcnQgY29uc3QgdW5kZXJzY29yZUlucHV0UmVnZXggPSAvKD86XnxcXHMpKCg/Ol9fKSgoPzpbXl9fXSspKSg/Ol9fKSkkL1xuZXhwb3J0IGNvbnN0IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKSgoPzpfXykoKD86W15fX10rKSkoPzpfXykpL2dcblxuZXhwb3J0IGNvbnN0IEJvbGQgPSBNYXJrLmNyZWF0ZTxCb2xkT3B0aW9ucz4oe1xuICBuYW1lOiAnYm9sZCcsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnc3Ryb25nJyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRhZzogJ2InLFxuICAgICAgICBnZXRBdHRyczogbm9kZSA9PiAobm9kZSBhcyBIVE1MRWxlbWVudCkuc3R5bGUuZm9udFdlaWdodCAhPT0gJ25vcm1hbCcgJiYgbnVsbCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiAnZm9udC13ZWlnaHQnLFxuICAgICAgICBnZXRBdHRyczogdmFsdWUgPT4gL14oYm9sZChlcik/fFs1LTldXFxkezIsfSkkLy50ZXN0KHZhbHVlIGFzIHN0cmluZykgJiYgbnVsbCxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnc3Ryb25nJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRCb2xkOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgICB0b2dnbGVCb2xkOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgICB1bnNldEJvbGQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC1iJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQm9sZCgpLFxuICAgICAgJ01vZC1CJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQm9sZCgpLFxuICAgIH1cbiAgfSxcblxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogc3RhcklucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IHVuZGVyc2NvcmVJbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG5cbiAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IHN0YXJQYXN0ZVJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiB1bmRlcnNjb3JlUGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdEl0ZW1PcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIGJ1bGxldExpc3RUeXBlTmFtZTogc3RyaW5nXG4gIG9yZGVyZWRMaXN0VHlwZU5hbWU6IHN0cmluZ1xufVxuXG5leHBvcnQgY29uc3QgTGlzdEl0ZW0gPSBOb2RlLmNyZWF0ZTxMaXN0SXRlbU9wdGlvbnM+KHtcbiAgbmFtZTogJ2xpc3RJdGVtJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICBidWxsZXRMaXN0VHlwZU5hbWU6ICdidWxsZXRMaXN0JyxcbiAgICAgIG9yZGVyZWRMaXN0VHlwZU5hbWU6ICdvcmRlcmVkTGlzdCcsXG4gICAgfVxuICB9LFxuXG4gIGNvbnRlbnQ6ICdwYXJhZ3JhcGggYmxvY2sqJyxcblxuICBkZWZpbmluZzogdHJ1ZSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnbGknLFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydsaScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgRW50ZXI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNwbGl0TGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgIFRhYjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2lua0xpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICAnU2hpZnQtVGFiJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMubGlmdExpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgfVxuICB9LFxufSlcbiIsICJpbXBvcnQge1xuICBnZXRNYXJrQXR0cmlidXRlcyxcbiAgTWFyayxcbiAgbWVyZ2VBdHRyaWJ1dGVzLFxufSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dFN0eWxlT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdGV4dFN0eWxlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBzcGFucyB3aXRob3V0IGlubGluZSBzdHlsZSBhdHRyaWJ1dGVzLlxuICAgICAgICovXG4gICAgICByZW1vdmVFbXB0eVRleHRTdHlsZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFRleHRTdHlsZSA9IE1hcmsuY3JlYXRlPFRleHRTdHlsZU9wdGlvbnM+KHtcbiAgbmFtZTogJ3RleHRTdHlsZScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnc3BhbicsXG4gICAgICAgIGdldEF0dHJzOiBlbGVtZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBoYXNTdHlsZXMgPSAoZWxlbWVudCBhcyBIVE1MRWxlbWVudCkuaGFzQXR0cmlidXRlKCdzdHlsZScpXG5cbiAgICAgICAgICBpZiAoIWhhc1N0eWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHt9XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ3NwYW4nLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbW92ZUVtcHR5VGV4dFN0eWxlOiAoKSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHRoaXMudHlwZSlcbiAgICAgICAgY29uc3QgaGFzU3R5bGVzID0gT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykuc29tZSgoWywgdmFsdWVdKSA9PiAhIXZhbHVlKVxuXG4gICAgICAgIGlmIChoYXNTdHlsZXMpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxufSlcbiIsICJpbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUsIHdyYXBwaW5nSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5pbXBvcnQgTGlzdEl0ZW0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9uLWxpc3QtaXRlbS9zcmMvaW5kZXguanMnXG5pbXBvcnQgVGV4dFN0eWxlIGZyb20gJy4uLy4uL2V4dGVuc2lvbi10ZXh0LXN0eWxlL3NyYy9pbmRleC5qcydcblxuZXhwb3J0IGludGVyZmFjZSBCdWxsZXRMaXN0T3B0aW9ucyB7XG4gIGl0ZW1UeXBlTmFtZTogc3RyaW5nLFxuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PixcbiAga2VlcE1hcmtzOiBib29sZWFuLFxuICBrZWVwQXR0cmlidXRlczogYm9vbGVhbixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGJ1bGxldExpc3Q6IHtcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGEgYnVsbGV0IGxpc3RcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlQnVsbGV0TGlzdDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGlucHV0UmVnZXggPSAvXlxccyooWy0rKl0pXFxzJC9cblxuZXhwb3J0IGNvbnN0IEJ1bGxldExpc3QgPSBOb2RlLmNyZWF0ZTxCdWxsZXRMaXN0T3B0aW9ucz4oe1xuICBuYW1lOiAnYnVsbGV0TGlzdCcsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbVR5cGVOYW1lOiAnbGlzdEl0ZW0nLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAga2VlcE1hcmtzOiBmYWxzZSxcbiAgICAgIGtlZXBBdHRyaWJ1dGVzOiBmYWxzZSxcbiAgICB9XG4gIH0sXG5cbiAgZ3JvdXA6ICdibG9jayBsaXN0JyxcblxuICBjb250ZW50KCkge1xuICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lfStgXG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7IHRhZzogJ3VsJyB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ3VsJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2dnbGVCdWxsZXRMaXN0OiAoKSA9PiAoeyBjb21tYW5kcywgY2hhaW4gfSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgcmV0dXJuIGNoYWluKCkudG9nZ2xlTGlzdCh0aGlzLm5hbWUsIHRoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWUsIHRoaXMub3B0aW9ucy5rZWVwTWFya3MpLnVwZGF0ZUF0dHJpYnV0ZXMoTGlzdEl0ZW0ubmFtZSwgdGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGUubmFtZSkpLnJ1bigpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtU2hpZnQtOCc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUJ1bGxldExpc3QoKSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICBsZXQgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwTWFya3MgfHwgdGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAga2VlcE1hcmtzOiB0aGlzLm9wdGlvbnMua2VlcE1hcmtzLFxuICAgICAgICBrZWVwQXR0cmlidXRlczogdGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzLFxuICAgICAgICBnZXRBdHRyaWJ1dGVzOiAoKSA9PiB7IHJldHVybiB0aGlzLmVkaXRvci5nZXRBdHRyaWJ1dGVzKFRleHRTdHlsZS5uYW1lKSB9LFxuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIGlucHV0UnVsZSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7XG4gIE1hcmssXG4gIG1hcmtJbnB1dFJ1bGUsXG4gIG1hcmtQYXN0ZVJ1bGUsXG4gIG1lcmdlQXR0cmlidXRlcyxcbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIENvZGVPcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBjb2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBhIGNvZGUgbWFya1xuICAgICAgICovXG4gICAgICBzZXRDb2RlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgaW5saW5lIGNvZGVcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlQ29kZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVW5zZXQgYSBjb2RlIG1hcmtcbiAgICAgICAqL1xuICAgICAgdW5zZXRDb2RlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgaW5wdXRSZWdleCA9IC8oPzpefFxccykoKD86YCkoKD86W15gXSspKSg/OmApKSQvXG5leHBvcnQgY29uc3QgcGFzdGVSZWdleCA9IC8oPzpefFxccykoKD86YCkoKD86W15gXSspKSg/OmApKS9nXG5cbmV4cG9ydCBjb25zdCBDb2RlID0gTWFyay5jcmVhdGU8Q29kZU9wdGlvbnM+KHtcbiAgbmFtZTogJ2NvZGUnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgZXhjbHVkZXM6ICdfJyxcblxuICBjb2RlOiB0cnVlLFxuXG4gIGV4aXRhYmxlOiB0cnVlLFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB0YWc6ICdjb2RlJyB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ2NvZGUnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldENvZGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZUNvZGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHVuc2V0Q29kZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLWUnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVDb2RlKCksXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG5cbiAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IHBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXksIFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIENvZGVCbG9ja09wdGlvbnMge1xuICAvKipcbiAgICogQWRkcyBhIHByZWZpeCB0byBsYW5ndWFnZSBjbGFzc2VzIHRoYXQgYXJlIGFwcGxpZWQgdG8gY29kZSB0YWdzLlxuICAgKiBEZWZhdWx0cyB0byBgJ2xhbmd1YWdlLSdgLlxuICAgKi9cbiAgbGFuZ3VhZ2VDbGFzc1ByZWZpeDogc3RyaW5nXG4gIC8qKlxuICAgKiBEZWZpbmUgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgZXhpdGVkIG9uIHRyaXBsZSBlbnRlci5cbiAgICogRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKi9cbiAgZXhpdE9uVHJpcGxlRW50ZXI6IGJvb2xlYW5cbiAgLyoqXG4gICAqIERlZmluZSB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBleGl0ZWQgb24gYXJyb3cgZG93biBpZiB0aGVyZSBpcyBubyBub2RlIGFmdGVyIGl0LlxuICAgKiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqL1xuICBleGl0T25BcnJvd0Rvd246IGJvb2xlYW5cbiAgLyoqXG4gICAqIEN1c3RvbSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIHJlbmRlcmVkIEhUTUwgdGFnLlxuICAgKi9cbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGNvZGVCbG9jazoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYSBjb2RlIGJsb2NrXG4gICAgICAgKi9cbiAgICAgIHNldENvZGVCbG9jazogKGF0dHJpYnV0ZXM/OiB7IGxhbmd1YWdlOiBzdHJpbmcgfSkgPT4gUmV0dXJuVHlwZVxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBjb2RlIGJsb2NrXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUNvZGVCbG9jazogKGF0dHJpYnV0ZXM/OiB7IGxhbmd1YWdlOiBzdHJpbmcgfSkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgYmFja3RpY2tJbnB1dFJlZ2V4ID0gL15gYGAoW2Etel0rKT9bXFxzXFxuXSQvXG5leHBvcnQgY29uc3QgdGlsZGVJbnB1dFJlZ2V4ID0gL15+fn4oW2Etel0rKT9bXFxzXFxuXSQvXG5cbmV4cG9ydCBjb25zdCBDb2RlQmxvY2sgPSBOb2RlLmNyZWF0ZTxDb2RlQmxvY2tPcHRpb25zPih7XG4gIG5hbWU6ICdjb2RlQmxvY2snLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhbmd1YWdlQ2xhc3NQcmVmaXg6ICdsYW5ndWFnZS0nLFxuICAgICAgZXhpdE9uVHJpcGxlRW50ZXI6IHRydWUsXG4gICAgICBleGl0T25BcnJvd0Rvd246IHRydWUsXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIGNvbnRlbnQ6ICd0ZXh0KicsXG5cbiAgbWFya3M6ICcnLFxuXG4gIGdyb3VwOiAnYmxvY2snLFxuXG4gIGNvZGU6IHRydWUsXG5cbiAgZGVmaW5pbmc6IHRydWUsXG5cbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGFuZ3VhZ2U6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IHtcbiAgICAgICAgICBjb25zdCB7IGxhbmd1YWdlQ2xhc3NQcmVmaXggfSA9IHRoaXMub3B0aW9uc1xuICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBbLi4uKGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ/LmNsYXNzTGlzdCB8fCBbXSldXG4gICAgICAgICAgY29uc3QgbGFuZ3VhZ2VzID0gY2xhc3NOYW1lc1xuICAgICAgICAgICAgLmZpbHRlcihjbGFzc05hbWUgPT4gY2xhc3NOYW1lLnN0YXJ0c1dpdGgobGFuZ3VhZ2VDbGFzc1ByZWZpeCkpXG4gICAgICAgICAgICAubWFwKGNsYXNzTmFtZSA9PiBjbGFzc05hbWUucmVwbGFjZShsYW5ndWFnZUNsYXNzUHJlZml4LCAnJykpXG4gICAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBsYW5ndWFnZXNbMF1cblxuICAgICAgICAgIGlmICghbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGxhbmd1YWdlXG4gICAgICAgIH0sXG4gICAgICAgIHJlbmRlcmVkOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdwcmUnLFxuICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICdmdWxsJyxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBub2RlLCBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICdwcmUnLFxuICAgICAgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLFxuICAgICAgW1xuICAgICAgICAnY29kZScsXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzczogbm9kZS5hdHRycy5sYW5ndWFnZVxuICAgICAgICAgICAgPyB0aGlzLm9wdGlvbnMubGFuZ3VhZ2VDbGFzc1ByZWZpeCArIG5vZGUuYXR0cnMubGFuZ3VhZ2VcbiAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgfSxcbiAgICAgICAgMCxcbiAgICAgIF0sXG4gICAgXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRDb2RlQmxvY2s6XG4gICAgICAgIGF0dHJpYnV0ZXMgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRoaXMubmFtZSwgYXR0cmlidXRlcylcbiAgICAgICAgfSxcbiAgICAgIHRvZ2dsZUNvZGVCbG9jazpcbiAgICAgICAgYXR0cmlidXRlcyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU5vZGUodGhpcy5uYW1lLCAncGFyYWdyYXBoJywgYXR0cmlidXRlcylcbiAgICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtQWx0LWMnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVDb2RlQmxvY2soKSxcblxuICAgICAgLy8gcmVtb3ZlIGNvZGUgYmxvY2sgd2hlbiBhdCBzdGFydCBvZiBkb2N1bWVudCBvciBjb2RlIGJsb2NrIGlzIGVtcHR5XG4gICAgICBCYWNrc3BhY2U6ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBlbXB0eSwgJGFuY2hvciB9ID0gdGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IGlzQXRTdGFydCA9ICRhbmNob3IucG9zID09PSAxXG5cbiAgICAgICAgaWYgKCFlbXB0eSB8fCAkYW5jaG9yLnBhcmVudC50eXBlLm5hbWUgIT09IHRoaXMubmFtZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQXRTdGFydCB8fCAhJGFuY2hvci5wYXJlbnQudGV4dENvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmNsZWFyTm9kZXMoKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9LFxuXG4gICAgICAvLyBleGl0IG5vZGUgb24gdHJpcGxlIGVudGVyXG4gICAgICBFbnRlcjogKHsgZWRpdG9yIH0pID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZXhpdE9uVHJpcGxlRW50ZXIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvclxuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgICAgICAgY29uc3QgeyAkZnJvbSwgZW1wdHkgfSA9IHNlbGVjdGlvblxuXG4gICAgICAgIGlmICghZW1wdHkgfHwgJGZyb20ucGFyZW50LnR5cGUgIT09IHRoaXMudHlwZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNBdEVuZCA9ICRmcm9tLnBhcmVudE9mZnNldCA9PT0gJGZyb20ucGFyZW50Lm5vZGVTaXplIC0gMlxuICAgICAgICBjb25zdCBlbmRzV2l0aERvdWJsZU5ld2xpbmUgPSAkZnJvbS5wYXJlbnQudGV4dENvbnRlbnQuZW5kc1dpdGgoJ1xcblxcbicpXG5cbiAgICAgICAgaWYgKCFpc0F0RW5kIHx8ICFlbmRzV2l0aERvdWJsZU5ld2xpbmUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlZGl0b3JcbiAgICAgICAgICAuY2hhaW4oKVxuICAgICAgICAgIC5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgICAgIHRyLmRlbGV0ZSgkZnJvbS5wb3MgLSAyLCAkZnJvbS5wb3MpXG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZXhpdENvZGUoKVxuICAgICAgICAgIC5ydW4oKVxuICAgICAgfSxcblxuICAgICAgLy8gZXhpdCBub2RlIG9uIGFycm93IGRvd25cbiAgICAgIEFycm93RG93bjogKHsgZWRpdG9yIH0pID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZXhpdE9uQXJyb3dEb3duKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSBlZGl0b3JcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gc3RhdGVcbiAgICAgICAgY29uc3QgeyAkZnJvbSwgZW1wdHkgfSA9IHNlbGVjdGlvblxuXG4gICAgICAgIGlmICghZW1wdHkgfHwgJGZyb20ucGFyZW50LnR5cGUgIT09IHRoaXMudHlwZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNBdEVuZCA9ICRmcm9tLnBhcmVudE9mZnNldCA9PT0gJGZyb20ucGFyZW50Lm5vZGVTaXplIC0gMlxuXG4gICAgICAgIGlmICghaXNBdEVuZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWZ0ZXIgPSAkZnJvbS5hZnRlcigpXG5cbiAgICAgICAgaWYgKGFmdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vZGVBZnRlciA9IGRvYy5ub2RlQXQoYWZ0ZXIpXG5cbiAgICAgICAgaWYgKG5vZGVBZnRlcikge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVkaXRvci5jb21tYW5kcy5leGl0Q29kZSgpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogYmFja3RpY2tJbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+ICh7XG4gICAgICAgICAgbGFuZ3VhZ2U6IG1hdGNoWzFdLFxuICAgICAgICB9KSxcbiAgICAgIH0pLFxuICAgICAgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IHRpbGRlSW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBnZXRBdHRyaWJ1dGVzOiBtYXRjaCA9PiAoe1xuICAgICAgICAgIGxhbmd1YWdlOiBtYXRjaFsxXSxcbiAgICAgICAgfSksXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICAvLyB0aGlzIHBsdWdpbiBjcmVhdGVzIGEgY29kZSBibG9jayBmb3IgcGFzdGVkIGNvbnRlbnQgZnJvbSBWUyBDb2RlXG4gICAgICAvLyB3ZSBjYW4gYWxzbyBkZXRlY3QgdGhlIGNvcGllZCBjb2RlIGxhbmd1YWdlXG4gICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdjb2RlQmxvY2tWU0NvZGVIYW5kbGVyJyksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgaGFuZGxlUGFzdGU6ICh2aWV3LCBldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFldmVudC5jbGlwYm9hcmREYXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkb27igJl0IGNyZWF0ZSBhIG5ldyBjb2RlIGJsb2NrIHdpdGhpbiBjb2RlIGJsb2Nrc1xuICAgICAgICAgICAgaWYgKHRoaXMuZWRpdG9yLmlzQWN0aXZlKHRoaXMudHlwZS5uYW1lKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpXG4gICAgICAgICAgICBjb25zdCB2c2NvZGUgPSBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3ZzY29kZS1lZGl0b3ItZGF0YScpXG4gICAgICAgICAgICBjb25zdCB2c2NvZGVEYXRhID0gdnNjb2RlID8gSlNPTi5wYXJzZSh2c2NvZGUpIDogdW5kZWZpbmVkXG4gICAgICAgICAgICBjb25zdCBsYW5ndWFnZSA9IHZzY29kZURhdGE/Lm1vZGVcblxuICAgICAgICAgICAgaWYgKCF0ZXh0IHx8ICFsYW5ndWFnZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgeyB0ciB9ID0gdmlldy5zdGF0ZVxuXG4gICAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgY29kZSBibG9ja1xuICAgICAgICAgICAgdHIucmVwbGFjZVNlbGVjdGlvbldpdGgodGhpcy50eXBlLmNyZWF0ZSh7IGxhbmd1YWdlIH0pKVxuXG4gICAgICAgICAgICAvLyBwdXQgY3Vyc29yIGluc2lkZSB0aGUgbmV3bHkgY3JlYXRlZCBjb2RlIGJsb2NrXG4gICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKE1hdGgubWF4KDAsIHRyLnNlbGVjdGlvbi5mcm9tIC0gMikpKSlcblxuICAgICAgICAgICAgLy8gYWRkIHRleHQgdG8gY29kZSBibG9ja1xuICAgICAgICAgICAgLy8gc3RyaXAgY2FycmlhZ2UgcmV0dXJuIGNoYXJzIGZyb20gdGV4dCBwYXN0ZWQgYXMgY29kZVxuICAgICAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3Itdmlldy9jb21taXQvYTUwYTZiY2NlYjRjZTUyYWM4ZmNjNjE2MjQ4OGQ4ODc1NjEzYWFjZFxuICAgICAgICAgICAgdHIuaW5zZXJ0VGV4dCh0ZXh0LnJlcGxhY2UoL1xcclxcbj8vZywgJ1xcbicpKVxuXG4gICAgICAgICAgICAvLyBzdG9yZSBtZXRhIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHVzZWZ1bCBmb3Igb3RoZXIgcGx1Z2lucyB0aGF0IGRlcGVuZHMgb24gdGhlIHBhc3RlIGV2ZW50XG4gICAgICAgICAgICAvLyBsaWtlIHRoZSBwYXN0ZSBydWxlIHBsdWdpblxuICAgICAgICAgICAgdHIuc2V0TWV0YSgncGFzdGUnLCB0cnVlKVxuXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IE5vZGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBjb25zdCBEb2N1bWVudCA9IE5vZGUuY3JlYXRlKHtcbiAgbmFtZTogJ2RvYycsXG4gIHRvcE5vZGU6IHRydWUsXG4gIGNvbnRlbnQ6ICdibG9jaysnLFxufSlcbiIsICJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBkcm9wUG9pbnQgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuXG4vKipcbkNyZWF0ZSBhIHBsdWdpbiB0aGF0LCB3aGVuIGFkZGVkIHRvIGEgUHJvc2VNaXJyb3IgaW5zdGFuY2UsXG5jYXVzZXMgYSBkZWNvcmF0aW9uIHRvIHNob3cgdXAgYXQgdGhlIGRyb3AgcG9zaXRpb24gd2hlbiBzb21ldGhpbmdcbmlzIGRyYWdnZWQgb3ZlciB0aGUgZWRpdG9yLlxuXG5Ob2RlcyBtYXkgYWRkIGEgYGRpc2FibGVEcm9wQ3Vyc29yYCBwcm9wZXJ0eSB0byB0aGVpciBzcGVjIHRvXG5jb250cm9sIHRoZSBzaG93aW5nIG9mIGEgZHJvcCBjdXJzb3IgaW5zaWRlIHRoZW0uIFRoaXMgbWF5IGJlIGFcbmJvb2xlYW4gb3IgYSBmdW5jdGlvbiwgd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHZpZXcgYW5kIGFcbnBvc2l0aW9uLCBhbmQgc2hvdWxkIHJldHVybiBhIGJvb2xlYW4uXG4qL1xuZnVuY3Rpb24gZHJvcEN1cnNvcihvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIHZpZXcoZWRpdG9yVmlldykgeyByZXR1cm4gbmV3IERyb3BDdXJzb3JWaWV3KGVkaXRvclZpZXcsIG9wdGlvbnMpOyB9XG4gICAgfSk7XG59XG5jbGFzcyBEcm9wQ3Vyc29yVmlldyB7XG4gICAgY29uc3RydWN0b3IoZWRpdG9yVmlldywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZWRpdG9yVmlldyA9IGVkaXRvclZpZXc7XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMud2lkdGggPSAoX2EgPSBvcHRpb25zLndpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxO1xuICAgICAgICB0aGlzLmNvbG9yID0gb3B0aW9ucy5jb2xvciA9PT0gZmFsc2UgPyB1bmRlZmluZWQgOiAob3B0aW9ucy5jb2xvciB8fCBcImJsYWNrXCIpO1xuICAgICAgICB0aGlzLmNsYXNzID0gb3B0aW9ucy5jbGFzcztcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtcImRyYWdvdmVyXCIsIFwiZHJhZ2VuZFwiLCBcImRyb3BcIiwgXCJkcmFnbGVhdmVcIl0ubWFwKG5hbWUgPT4ge1xuICAgICAgICAgICAgbGV0IGhhbmRsZXIgPSAoZSkgPT4geyB0aGlzW25hbWVdKGUpOyB9O1xuICAgICAgICAgICAgZWRpdG9yVmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWUsIGhhbmRsZXIgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMuZm9yRWFjaCgoeyBuYW1lLCBoYW5kbGVyIH0pID0+IHRoaXMuZWRpdG9yVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKSk7XG4gICAgfVxuICAgIHVwZGF0ZShlZGl0b3JWaWV3LCBwcmV2U3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yUG9zICE9IG51bGwgJiYgcHJldlN0YXRlLmRvYyAhPSBlZGl0b3JWaWV3LnN0YXRlLmRvYykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3Vyc29yUG9zID4gZWRpdG9yVmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKG51bGwpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlT3ZlcmxheSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEN1cnNvcihwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA9PSB0aGlzLmN1cnNvclBvcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jdXJzb3JQb3MgPSBwb3M7XG4gICAgICAgIGlmIChwb3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU92ZXJsYXkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVPdmVybGF5KCkge1xuICAgICAgICBsZXQgJHBvcyA9IHRoaXMuZWRpdG9yVmlldy5zdGF0ZS5kb2MucmVzb2x2ZSh0aGlzLmN1cnNvclBvcyk7XG4gICAgICAgIGxldCBpc0Jsb2NrID0gISRwb3MucGFyZW50LmlubGluZUNvbnRlbnQsIHJlY3Q7XG4gICAgICAgIGlmIChpc0Jsb2NrKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlLCBhZnRlciA9ICRwb3Mubm9kZUFmdGVyO1xuICAgICAgICAgICAgaWYgKGJlZm9yZSB8fCBhZnRlcikge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5lZGl0b3JWaWV3Lm5vZGVET00odGhpcy5jdXJzb3JQb3MgLSAoYmVmb3JlID8gYmVmb3JlLm5vZGVTaXplIDogMCkpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub2RlUmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3AgPSBiZWZvcmUgPyBub2RlUmVjdC5ib3R0b20gOiBub2RlUmVjdC50b3A7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUgJiYgYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSAodG9wICsgdGhpcy5lZGl0b3JWaWV3Lm5vZGVET00odGhpcy5jdXJzb3JQb3MpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0geyBsZWZ0OiBub2RlUmVjdC5sZWZ0LCByaWdodDogbm9kZVJlY3QucmlnaHQsIHRvcDogdG9wIC0gdGhpcy53aWR0aCAvIDIsIGJvdHRvbTogdG9wICsgdGhpcy53aWR0aCAvIDIgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWN0KSB7XG4gICAgICAgICAgICBsZXQgY29vcmRzID0gdGhpcy5lZGl0b3JWaWV3LmNvb3Jkc0F0UG9zKHRoaXMuY3Vyc29yUG9zKTtcbiAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IGNvb3Jkcy5sZWZ0IC0gdGhpcy53aWR0aCAvIDIsIHJpZ2h0OiBjb29yZHMubGVmdCArIHRoaXMud2lkdGggLyAyLCB0b3A6IGNvb3Jkcy50b3AsIGJvdHRvbTogY29vcmRzLmJvdHRvbSB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmVkaXRvclZpZXcuZG9tLm9mZnNldFBhcmVudDtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsYXNzKVxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSB0aGlzLmNsYXNzO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgei1pbmRleDogNTA7IHBvaW50ZXItZXZlbnRzOiBub25lO1wiO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5jb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcInByb3NlbWlycm9yLWRyb3BjdXJzb3ItYmxvY2tcIiwgaXNCbG9jayk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKFwicHJvc2VtaXJyb3ItZHJvcGN1cnNvci1pbmxpbmVcIiwgIWlzQmxvY2spO1xuICAgICAgICBsZXQgcGFyZW50TGVmdCwgcGFyZW50VG9wO1xuICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT0gZG9jdW1lbnQuYm9keSAmJiBnZXRDb21wdXRlZFN0eWxlKHBhcmVudCkucG9zaXRpb24gPT0gXCJzdGF0aWNcIikge1xuICAgICAgICAgICAgcGFyZW50TGVmdCA9IC1wYWdlWE9mZnNldDtcbiAgICAgICAgICAgIHBhcmVudFRvcCA9IC1wYWdlWU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgcGFyZW50TGVmdCA9IHJlY3QubGVmdCAtIHBhcmVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgcGFyZW50VG9wID0gcmVjdC50b3AgLSBwYXJlbnQuc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5sZWZ0ID0gKHJlY3QubGVmdCAtIHBhcmVudExlZnQpICsgXCJweFwiO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUudG9wID0gKHJlY3QudG9wIC0gcGFyZW50VG9wKSArIFwicHhcIjtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpICsgXCJweFwiO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKHJlY3QuYm90dG9tIC0gcmVjdC50b3ApICsgXCJweFwiO1xuICAgIH1cbiAgICBzY2hlZHVsZVJlbW92YWwodGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnNldEN1cnNvcihudWxsKSwgdGltZW91dCk7XG4gICAgfVxuICAgIGRyYWdvdmVyKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5lZGl0b3JWaWV3LmVkaXRhYmxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5lZGl0b3JWaWV3LnBvc0F0Q29vcmRzKHsgbGVmdDogZXZlbnQuY2xpZW50WCwgdG9wOiBldmVudC5jbGllbnRZIH0pO1xuICAgICAgICBsZXQgbm9kZSA9IHBvcyAmJiBwb3MuaW5zaWRlID49IDAgJiYgdGhpcy5lZGl0b3JWaWV3LnN0YXRlLmRvYy5ub2RlQXQocG9zLmluc2lkZSk7XG4gICAgICAgIGxldCBkaXNhYmxlRHJvcEN1cnNvciA9IG5vZGUgJiYgbm9kZS50eXBlLnNwZWMuZGlzYWJsZURyb3BDdXJzb3I7XG4gICAgICAgIGxldCBkaXNhYmxlZCA9IHR5cGVvZiBkaXNhYmxlRHJvcEN1cnNvciA9PSBcImZ1bmN0aW9uXCIgPyBkaXNhYmxlRHJvcEN1cnNvcih0aGlzLmVkaXRvclZpZXcsIHBvcywgZXZlbnQpIDogZGlzYWJsZURyb3BDdXJzb3I7XG4gICAgICAgIGlmIChwb3MgJiYgIWRpc2FibGVkKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gcG9zLnBvcztcbiAgICAgICAgICAgIGlmICh0aGlzLmVkaXRvclZpZXcuZHJhZ2dpbmcgJiYgdGhpcy5lZGl0b3JWaWV3LmRyYWdnaW5nLnNsaWNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ID0gZHJvcFBvaW50KHRoaXMuZWRpdG9yVmlldy5zdGF0ZS5kb2MsIHRhcmdldCwgdGhpcy5lZGl0b3JWaWV3LmRyYWdnaW5nLnNsaWNlKTtcbiAgICAgICAgICAgICAgICBpZiAocG9pbnQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gcG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcih0YXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbW92YWwoNTAwMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhZ2VuZCgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbW92YWwoMjApO1xuICAgIH1cbiAgICBkcm9wKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVtb3ZhbCgyMCk7XG4gICAgfVxuICAgIGRyYWdsZWF2ZShldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09IHRoaXMuZWRpdG9yVmlldy5kb20gfHwgIXRoaXMuZWRpdG9yVmlldy5kb20uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpXG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihudWxsKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGRyb3BDdXJzb3IgfTtcbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBkcm9wQ3Vyc29yIH0gZnJvbSAnQHRpcHRhcC9wbS9kcm9wY3Vyc29yJ1xuXG5leHBvcnQgaW50ZXJmYWNlIERyb3BjdXJzb3JPcHRpb25zIHtcbiAgY29sb3I6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgd2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgY2xhc3M6IHN0cmluZyB8IHVuZGVmaW5lZCxcbn1cblxuZXhwb3J0IGNvbnN0IERyb3BjdXJzb3IgPSBFeHRlbnNpb24uY3JlYXRlPERyb3BjdXJzb3JPcHRpb25zPih7XG4gIG5hbWU6ICdkcm9wQ3Vyc29yJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogJ2N1cnJlbnRDb2xvcicsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIGNsYXNzOiB1bmRlZmluZWQsXG4gICAgfVxuICB9LFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgZHJvcEN1cnNvcih0aGlzLm9wdGlvbnMpLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsga2V5ZG93bkhhbmRsZXIgfSBmcm9tICdwcm9zZW1pcnJvci1rZXltYXAnO1xuaW1wb3J0IHsgU2VsZWN0aW9uLCBOb2RlU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uLCBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBTbGljZSwgRnJhZ21lbnQgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBEZWNvcmF0aW9uU2V0LCBEZWNvcmF0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itdmlldyc7XG5cbi8qKlxuR2FwIGN1cnNvciBzZWxlY3Rpb25zIGFyZSByZXByZXNlbnRlZCB1c2luZyB0aGlzIGNsYXNzLiBJdHNcbmAkYW5jaG9yYCBhbmQgYCRoZWFkYCBwcm9wZXJ0aWVzIGJvdGggcG9pbnQgYXQgdGhlIGN1cnNvciBwb3NpdGlvbi5cbiovXG5jbGFzcyBHYXBDdXJzb3IgZXh0ZW5kcyBTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIGdhcCBjdXJzb3IuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigkcG9zKSB7XG4gICAgICAgIHN1cGVyKCRwb3MsICRwb3MpO1xuICAgIH1cbiAgICBtYXAoZG9jLCBtYXBwaW5nKSB7XG4gICAgICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAodGhpcy5oZWFkKSk7XG4gICAgICAgIHJldHVybiBHYXBDdXJzb3IudmFsaWQoJHBvcykgPyBuZXcgR2FwQ3Vyc29yKCRwb3MpIDogU2VsZWN0aW9uLm5lYXIoJHBvcyk7XG4gICAgfVxuICAgIGNvbnRlbnQoKSB7IHJldHVybiBTbGljZS5lbXB0eTsgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEdhcEN1cnNvciAmJiBvdGhlci5oZWFkID09IHRoaXMuaGVhZDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImdhcGN1cnNvclwiLCBwb3M6IHRoaXMuaGVhZCB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBHYXBDdXJzb3IuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgR2FwQ3Vyc29yKGRvYy5yZXNvbHZlKGpzb24ucG9zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0Qm9va21hcmsoKSB7IHJldHVybiBuZXcgR2FwQm9va21hcmsodGhpcy5hbmNob3IpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgdmFsaWQoJHBvcykge1xuICAgICAgICBsZXQgcGFyZW50ID0gJHBvcy5wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQuaXNUZXh0YmxvY2sgfHwgIWNsb3NlZEJlZm9yZSgkcG9zKSB8fCAhY2xvc2VkQWZ0ZXIoJHBvcykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBvdmVycmlkZSA9IHBhcmVudC50eXBlLnNwZWMuYWxsb3dHYXBDdXJzb3I7XG4gICAgICAgIGlmIChvdmVycmlkZSAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG92ZXJyaWRlO1xuICAgICAgICBsZXQgZGVmbHQgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoJHBvcy5pbmRleCgpKS5kZWZhdWx0VHlwZTtcbiAgICAgICAgcmV0dXJuIGRlZmx0ICYmIGRlZmx0LmlzVGV4dGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmaW5kR2FwQ3Vyc29yRnJvbSgkcG9zLCBkaXIsIG11c3RNb3ZlID0gZmFsc2UpIHtcbiAgICAgICAgc2VhcmNoOiBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoIW11c3RNb3ZlICYmIEdhcEN1cnNvci52YWxpZCgkcG9zKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcztcbiAgICAgICAgICAgIGxldCBwb3MgPSAkcG9zLnBvcywgbmV4dCA9IG51bGw7XG4gICAgICAgICAgICAvLyBTY2FuIHVwIGZyb20gdGhpcyBwb3NpdGlvblxuICAgICAgICAgICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7OyBkLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gJHBvcy5ub2RlKGQpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwID8gJHBvcy5pbmRleEFmdGVyKGQpIDwgcGFyZW50LmNoaWxkQ291bnQgOiAkcG9zLmluZGV4KGQpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcGFyZW50LmNoaWxkKGRpciA+IDAgPyAkcG9zLmluZGV4QWZ0ZXIoZCkgOiAkcG9zLmluZGV4KGQpIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyArPSBkaXI7XG4gICAgICAgICAgICAgICAgbGV0ICRjdXIgPSAkcG9zLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKEdhcEN1cnNvci52YWxpZCgkY3VyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRjdXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBbmQgdGhlbiBkb3duIGludG8gdGhlIG5leHQgbm9kZVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGxldCBpbnNpZGUgPSBkaXIgPiAwID8gbmV4dC5maXJzdENoaWxkIDogbmV4dC5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQuaXNBdG9tICYmICFuZXh0LmlzVGV4dCAmJiAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRwb3MgPSAkcG9zLmRvYy5yZXNvbHZlKHBvcyArIG5leHQubm9kZVNpemUgKiBkaXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVzdE1vdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHNlYXJjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCA9IGluc2lkZTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gZGlyO1xuICAgICAgICAgICAgICAgIGxldCAkY3VyID0gJHBvcy5kb2MucmVzb2x2ZShwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChHYXBDdXJzb3IudmFsaWQoJGN1cikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkY3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5HYXBDdXJzb3IucHJvdG90eXBlLnZpc2libGUgPSBmYWxzZTtcbkdhcEN1cnNvci5maW5kRnJvbSA9IEdhcEN1cnNvci5maW5kR2FwQ3Vyc29yRnJvbTtcblNlbGVjdGlvbi5qc29uSUQoXCJnYXBjdXJzb3JcIiwgR2FwQ3Vyc29yKTtcbmNsYXNzIEdhcEJvb2ttYXJrIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3MpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2FwQm9va21hcmsobWFwcGluZy5tYXAodGhpcy5wb3MpKTtcbiAgICB9XG4gICAgcmVzb2x2ZShkb2MpIHtcbiAgICAgICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZSh0aGlzLnBvcyk7XG4gICAgICAgIHJldHVybiBHYXBDdXJzb3IudmFsaWQoJHBvcykgPyBuZXcgR2FwQ3Vyc29yKCRwb3MpIDogU2VsZWN0aW9uLm5lYXIoJHBvcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xvc2VkQmVmb3JlKCRwb3MpIHtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleChkKSwgcGFyZW50ID0gJHBvcy5ub2RlKGQpO1xuICAgICAgICAvLyBBdCB0aGUgc3RhcnQgb2YgdGhpcyBwYXJlbnQsIGxvb2sgYXQgbmV4dCBvbmVcbiAgICAgICAgaWYgKGluZGV4ID09IDApIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBpZiB0aGUgbm9kZSBiZWZvcmUgKG9yIGl0cyBmaXJzdCBhbmNlc3RvcikgaXMgY2xvc2VkXG4gICAgICAgIGZvciAobGV0IGJlZm9yZSA9IHBhcmVudC5jaGlsZChpbmRleCAtIDEpOzsgYmVmb3JlID0gYmVmb3JlLmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgaWYgKChiZWZvcmUuY2hpbGRDb3VudCA9PSAwICYmICFiZWZvcmUuaW5saW5lQ29udGVudCkgfHwgYmVmb3JlLmlzQXRvbSB8fCBiZWZvcmUudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChiZWZvcmUuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGl0IHN0YXJ0IG9mIGRvY3VtZW50XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjbG9zZWRBZnRlcigkcG9zKSB7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXhBZnRlcihkKSwgcGFyZW50ID0gJHBvcy5ub2RlKGQpO1xuICAgICAgICBpZiAoaW5kZXggPT0gcGFyZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGFmdGVyID0gcGFyZW50LmNoaWxkKGluZGV4KTs7IGFmdGVyID0gYWZ0ZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgaWYgKChhZnRlci5jaGlsZENvdW50ID09IDAgJiYgIWFmdGVyLmlubGluZUNvbnRlbnQpIHx8IGFmdGVyLmlzQXRvbSB8fCBhZnRlci50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGFmdGVyLmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbkNyZWF0ZSBhIGdhcCBjdXJzb3IgcGx1Z2luLiBXaGVuIGVuYWJsZWQsIHRoaXMgd2lsbCBjYXB0dXJlIGNsaWNrc1xubmVhciBhbmQgYXJyb3cta2V5LW1vdGlvbiBwYXN0IHBsYWNlcyB0aGF0IGRvbid0IGhhdmUgYSBub3JtYWxseVxuc2VsZWN0YWJsZSBwb3NpdGlvbiBuZWFyYnksIGFuZCBjcmVhdGUgYSBnYXAgY3Vyc29yIHNlbGVjdGlvbiBmb3JcbnRoZW0uIFRoZSBjdXJzb3IgaXMgZHJhd24gYXMgYW4gZWxlbWVudCB3aXRoIGNsYXNzXG5gUHJvc2VNaXJyb3ItZ2FwY3Vyc29yYC4gWW91IGNhbiBlaXRoZXIgaW5jbHVkZVxuYHN0eWxlL2dhcGN1cnNvci5jc3NgIGZyb20gdGhlIHBhY2thZ2UncyBkaXJlY3Rvcnkgb3IgYWRkIHlvdXIgb3duXG5zdHlsZXMgdG8gbWFrZSBpdCB2aXNpYmxlLlxuKi9cbmZ1bmN0aW9uIGdhcEN1cnNvcigpIHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBkZWNvcmF0aW9uczogZHJhd0dhcEN1cnNvcixcbiAgICAgICAgICAgIGNyZWF0ZVNlbGVjdGlvbkJldHdlZW4oX3ZpZXcsICRhbmNob3IsICRoZWFkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRhbmNob3IucG9zID09ICRoZWFkLnBvcyAmJiBHYXBDdXJzb3IudmFsaWQoJGhlYWQpID8gbmV3IEdhcEN1cnNvcigkaGVhZCkgOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZUNsaWNrLFxuICAgICAgICAgICAgaGFuZGxlS2V5RG93bixcbiAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czogeyBiZWZvcmVpbnB1dDogYmVmb3JlaW5wdXQgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBoYW5kbGVLZXlEb3duID0ga2V5ZG93bkhhbmRsZXIoe1xuICAgIFwiQXJyb3dMZWZ0XCI6IGFycm93KFwiaG9yaXpcIiwgLTEpLFxuICAgIFwiQXJyb3dSaWdodFwiOiBhcnJvdyhcImhvcml6XCIsIDEpLFxuICAgIFwiQXJyb3dVcFwiOiBhcnJvdyhcInZlcnRcIiwgLTEpLFxuICAgIFwiQXJyb3dEb3duXCI6IGFycm93KFwidmVydFwiLCAxKVxufSk7XG5mdW5jdGlvbiBhcnJvdyhheGlzLCBkaXIpIHtcbiAgICBjb25zdCBkaXJTdHIgPSBheGlzID09IFwidmVydFwiID8gKGRpciA+IDAgPyBcImRvd25cIiA6IFwidXBcIikgOiAoZGlyID4gMCA/IFwicmlnaHRcIiA6IFwibGVmdFwiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgICAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgJHN0YXJ0ID0gZGlyID4gMCA/IHNlbC4kdG8gOiBzZWwuJGZyb20sIG11c3RNb3ZlID0gc2VsLmVtcHR5O1xuICAgICAgICBpZiAoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikge1xuICAgICAgICAgICAgaWYgKCF2aWV3LmVuZE9mVGV4dGJsb2NrKGRpclN0cikgfHwgJHN0YXJ0LmRlcHRoID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbXVzdE1vdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICRzdGFydCA9IHN0YXRlLmRvYy5yZXNvbHZlKGRpciA+IDAgPyAkc3RhcnQuYWZ0ZXIoKSA6ICRzdGFydC5iZWZvcmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0ICRmb3VuZCA9IEdhcEN1cnNvci5maW5kR2FwQ3Vyc29yRnJvbSgkc3RhcnQsIGRpciwgbXVzdE1vdmUpO1xuICAgICAgICBpZiAoISRmb3VuZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBHYXBDdXJzb3IoJGZvdW5kKSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlQ2xpY2sodmlldywgcG9zLCBldmVudCkge1xuICAgIGlmICghdmlldyB8fCAhdmlldy5lZGl0YWJsZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmICghR2FwQ3Vyc29yLnZhbGlkKCRwb3MpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNsaWNrUG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IGxlZnQ6IGV2ZW50LmNsaWVudFgsIHRvcDogZXZlbnQuY2xpZW50WSB9KTtcbiAgICBpZiAoY2xpY2tQb3MgJiYgY2xpY2tQb3MuaW5zaWRlID4gLTEgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUodmlldy5zdGF0ZS5kb2Mubm9kZUF0KGNsaWNrUG9zLmluc2lkZSkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgR2FwQ3Vyc29yKCRwb3MpKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBUaGlzIGlzIGEgaGFjayB0aGF0LCB3aGVuIGEgY29tcG9zaXRpb24gc3RhcnRzIHdoaWxlIGEgZ2FwIGN1cnNvclxuLy8gaXMgYWN0aXZlLCBxdWlja2x5IGNyZWF0ZXMgYW4gaW5saW5lIGNvbnRleHQgZm9yIHRoZSBjb21wb3NpdGlvbiB0b1xuLy8gaGFwcGVuIGluLCB0byBhdm9pZCBpdCBiZWluZyBhYm9ydGVkIGJ5IHRoZSBET00gc2VsZWN0aW9uIGJlaW5nXG4vLyBtb3ZlZCBpbnRvIGEgdmFsaWQgcG9zaXRpb24uXG5mdW5jdGlvbiBiZWZvcmVpbnB1dCh2aWV3LCBldmVudCkge1xuICAgIGlmIChldmVudC5pbnB1dFR5cGUgIT0gXCJpbnNlcnRDb21wb3NpdGlvblRleHRcIiB8fCAhKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgR2FwQ3Vyc29yKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7ICRmcm9tIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgaW5zZXJ0ID0gJGZyb20ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4KCkpLmZpbmRXcmFwcGluZyh2aWV3LnN0YXRlLnNjaGVtYS5ub2Rlcy50ZXh0KTtcbiAgICBpZiAoIWluc2VydClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBmcmFnID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgZm9yIChsZXQgaSA9IGluc2VydC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgZnJhZyA9IEZyYWdtZW50LmZyb20oaW5zZXJ0W2ldLmNyZWF0ZUFuZEZpbGwobnVsbCwgZnJhZykpO1xuICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHIucmVwbGFjZSgkZnJvbS5wb3MsICRmcm9tLnBvcywgbmV3IFNsaWNlKGZyYWcsIDAsIDApKTtcbiAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKCRmcm9tLnBvcyArIDEpKSk7XG4gICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZHJhd0dhcEN1cnNvcihzdGF0ZSkge1xuICAgIGlmICghKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEdhcEN1cnNvcikpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBub2RlLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3ItZ2FwY3Vyc29yXCI7XG4gICAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKHN0YXRlLmRvYywgW0RlY29yYXRpb24ud2lkZ2V0KHN0YXRlLnNlbGVjdGlvbi5oZWFkLCBub2RlLCB7IGtleTogXCJnYXBjdXJzb3JcIiB9KV0pO1xufVxuXG5leHBvcnQgeyBHYXBDdXJzb3IsIGdhcEN1cnNvciB9O1xuIiwgImltcG9ydCB7XG4gIGNhbGxPclJldHVybixcbiAgRXh0ZW5zaW9uLFxuICBnZXRFeHRlbnNpb25GaWVsZCxcbiAgUGFyZW50Q29uZmlnLFxufSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBnYXBDdXJzb3IgfSBmcm9tICdAdGlwdGFwL3BtL2dhcGN1cnNvcidcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgTm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPiB7XG4gICAgLyoqXG4gICAgICogQWxsb3cgZ2FwIGN1cnNvclxuICAgICAqL1xuICAgIGFsbG93R2FwQ3Vyc29yPzpcbiAgICAgIHwgYm9vbGVhblxuICAgICAgfCBudWxsXG4gICAgICB8ICgodGhpczoge1xuICAgICAgICBuYW1lOiBzdHJpbmcsXG4gICAgICAgIG9wdGlvbnM6IE9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2UsXG4gICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucz4+WydhbGxvd0dhcEN1cnNvciddLFxuICAgICAgfSkgPT4gYm9vbGVhbiB8IG51bGwpLFxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBHYXBjdXJzb3IgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogJ2dhcEN1cnNvcicsXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBnYXBDdXJzb3IoKSxcbiAgICBdXG4gIH0sXG5cbiAgZXh0ZW5kTm9kZVNjaGVtYShleHRlbnNpb24pIHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhbGxvd0dhcEN1cnNvcjogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FsbG93R2FwQ3Vyc29yJywgY29udGV4dCkpID8/IG51bGwsXG4gICAgfVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgSGFyZEJyZWFrT3B0aW9ucyB7XG4gIGtlZXBNYXJrczogYm9vbGVhbixcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBoYXJkQnJlYWs6IHtcbiAgICAgIC8qKlxuICAgICAgICogQWRkIGEgaGFyZCBicmVha1xuICAgICAgICovXG4gICAgICBzZXRIYXJkQnJlYWs6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBIYXJkQnJlYWsgPSBOb2RlLmNyZWF0ZTxIYXJkQnJlYWtPcHRpb25zPih7XG4gIG5hbWU6ICdoYXJkQnJlYWsnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtlZXBNYXJrczogdHJ1ZSxcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgaW5saW5lOiB0cnVlLFxuXG4gIGdyb3VwOiAnaW5saW5lJyxcblxuICBzZWxlY3RhYmxlOiBmYWxzZSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHsgdGFnOiAnYnInIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnYnInLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyldXG4gIH0sXG5cbiAgcmVuZGVyVGV4dCgpIHtcbiAgICByZXR1cm4gJ1xcbidcbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0SGFyZEJyZWFrOiAoKSA9PiAoe1xuICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgY2hhaW4sXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBlZGl0b3IsXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5maXJzdChbXG4gICAgICAgICAgKCkgPT4gY29tbWFuZHMuZXhpdENvZGUoKSxcbiAgICAgICAgICAoKSA9PiBjb21tYW5kcy5jb21tYW5kKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGVcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi4kZnJvbS5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgeyBrZWVwTWFya3MgfSA9IHRoaXMub3B0aW9uc1xuICAgICAgICAgICAgY29uc3QgeyBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyXG4gICAgICAgICAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzXG4gICAgICAgICAgICAgIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSlcblxuICAgICAgICAgICAgcmV0dXJuIGNoYWluKClcbiAgICAgICAgICAgICAgLmluc2VydENvbnRlbnQoeyB0eXBlOiB0aGlzLm5hbWUgfSlcbiAgICAgICAgICAgICAgLmNvbW1hbmQoKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzcGF0Y2ggJiYgbWFya3MgJiYga2VlcE1hcmtzKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3NcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpXG5cbiAgICAgICAgICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLnJ1bigpXG4gICAgICAgICAgfSksXG4gICAgICAgIF0pXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC1FbnRlcic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldEhhcmRCcmVhaygpLFxuICAgICAgJ1NoaWZ0LUVudGVyJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0SGFyZEJyZWFrKCksXG4gICAgfVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUsIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCB0eXBlIExldmVsID0gMSB8IDIgfCAzIHwgNCB8IDUgfCA2XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGVhZGluZ09wdGlvbnMge1xuICBsZXZlbHM6IExldmVsW10sXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgaGVhZGluZzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYSBoZWFkaW5nIG5vZGVcbiAgICAgICAqL1xuICAgICAgc2V0SGVhZGluZzogKGF0dHJpYnV0ZXM6IHsgbGV2ZWw6IExldmVsIH0pID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIGhlYWRpbmcgbm9kZVxuICAgICAgICovXG4gICAgICB0b2dnbGVIZWFkaW5nOiAoYXR0cmlidXRlczogeyBsZXZlbDogTGV2ZWwgfSkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEhlYWRpbmcgPSBOb2RlLmNyZWF0ZTxIZWFkaW5nT3B0aW9ucz4oe1xuICBuYW1lOiAnaGVhZGluZycsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWxzOiBbMSwgMiwgMywgNCwgNSwgNl0sXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIGNvbnRlbnQ6ICdpbmxpbmUqJyxcblxuICBncm91cDogJ2Jsb2NrJyxcblxuICBkZWZpbmluZzogdHJ1ZSxcblxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbDoge1xuICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICByZW5kZXJlZDogZmFsc2UsXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sZXZlbHNcbiAgICAgIC5tYXAoKGxldmVsOiBMZXZlbCkgPT4gKHtcbiAgICAgICAgdGFnOiBgaCR7bGV2ZWx9YCxcbiAgICAgICAgYXR0cnM6IHsgbGV2ZWwgfSxcbiAgICAgIH0pKVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBub2RlLCBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgY29uc3QgaGFzTGV2ZWwgPSB0aGlzLm9wdGlvbnMubGV2ZWxzLmluY2x1ZGVzKG5vZGUuYXR0cnMubGV2ZWwpXG4gICAgY29uc3QgbGV2ZWwgPSBoYXNMZXZlbFxuICAgICAgPyBub2RlLmF0dHJzLmxldmVsXG4gICAgICA6IHRoaXMub3B0aW9ucy5sZXZlbHNbMF1cblxuICAgIHJldHVybiBbYGgke2xldmVsfWAsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0SGVhZGluZzogYXR0cmlidXRlcyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmxldmVscy5pbmNsdWRlcyhhdHRyaWJ1dGVzLmxldmVsKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodGhpcy5uYW1lLCBhdHRyaWJ1dGVzKVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZUhlYWRpbmc6IGF0dHJpYnV0ZXMgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5sZXZlbHMuaW5jbHVkZXMoYXR0cmlidXRlcy5sZXZlbCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVOb2RlKHRoaXMubmFtZSwgJ3BhcmFncmFwaCcsIGF0dHJpYnV0ZXMpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxldmVscy5yZWR1Y2UoKGl0ZW1zLCBsZXZlbCkgPT4gKHtcbiAgICAgIC4uLml0ZW1zLFxuICAgICAgLi4ue1xuICAgICAgICBbYE1vZC1BbHQtJHtsZXZlbH1gXTogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlSGVhZGluZyh7IGxldmVsIH0pLFxuICAgICAgfSxcbiAgICB9KSwge30pXG4gIH0sXG5cbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxldmVscy5tYXAobGV2ZWwgPT4ge1xuICAgICAgcmV0dXJuIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBuZXcgUmVnRXhwKGBeKCN7MSwke2xldmVsfX0pXFxcXHMkYCksXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczoge1xuICAgICAgICAgIGxldmVsLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9KVxuICB9LFxufSlcbiIsICJ2YXIgR09PRF9MRUFGX1NJWkUgPSAyMDA7XG5cbi8vIDo6IGNsYXNzPFQ+IEEgcm9wZSBzZXF1ZW5jZSBpcyBhIHBlcnNpc3RlbnQgc2VxdWVuY2UgZGF0YSBzdHJ1Y3R1cmVcbi8vIHRoYXQgc3VwcG9ydHMgYXBwZW5kaW5nLCBwcmVwZW5kaW5nLCBhbmQgc2xpY2luZyB3aXRob3V0IGRvaW5nIGFcbi8vIGZ1bGwgY29weS4gSXQgaXMgcmVwcmVzZW50ZWQgYXMgYSBtb3N0bHktYmFsYW5jZWQgdHJlZS5cbnZhciBSb3BlU2VxdWVuY2UgPSBmdW5jdGlvbiBSb3BlU2VxdWVuY2UgKCkge307XG5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kIChvdGhlcikge1xuICBpZiAoIW90aGVyLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gIG90aGVyID0gUm9wZVNlcXVlbmNlLmZyb20ob3RoZXIpO1xuXG4gIHJldHVybiAoIXRoaXMubGVuZ3RoICYmIG90aGVyKSB8fFxuICAgIChvdGhlci5sZW5ndGggPCBHT09EX0xFQUZfU0laRSAmJiB0aGlzLmxlYWZBcHBlbmQob3RoZXIpKSB8fFxuICAgICh0aGlzLmxlbmd0aCA8IEdPT0RfTEVBRl9TSVpFICYmIG90aGVyLmxlYWZQcmVwZW5kKHRoaXMpKSB8fFxuICAgIHRoaXMuYXBwZW5kSW5uZXIob3RoZXIpXG59O1xuXG4vLyA6OiAodW5pb248W1RdLCBSb3BlU2VxdWVuY2U8VD4+KSBcdTIxOTIgUm9wZVNlcXVlbmNlPFQ+XG4vLyBQcmVwZW5kIGFuIGFycmF5IG9yIG90aGVyIHJvcGUgdG8gdGhpcyBvbmUsIHJldHVybmluZyBhIG5ldyByb3BlLlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gcHJlcGVuZCAob3RoZXIpIHtcbiAgaWYgKCFvdGhlci5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICByZXR1cm4gUm9wZVNlcXVlbmNlLmZyb20ob3RoZXIpLmFwcGVuZCh0aGlzKVxufTtcblxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5hcHBlbmRJbm5lciA9IGZ1bmN0aW9uIGFwcGVuZElubmVyIChvdGhlcikge1xuICByZXR1cm4gbmV3IEFwcGVuZCh0aGlzLCBvdGhlcilcbn07XG5cbi8vIDo6ICg/bnVtYmVyLCA/bnVtYmVyKSBcdTIxOTIgUm9wZVNlcXVlbmNlPFQ+XG4vLyBDcmVhdGUgYSByb3BlIHJlcGVzZW50aW5nIGEgc3ViLXNlcXVlbmNlIG9mIHRoaXMgcm9wZS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoZnJvbSwgdG8pIHtcbiAgICBpZiAoIGZyb20gPT09IHZvaWQgMCApIGZyb20gPSAwO1xuICAgIGlmICggdG8gPT09IHZvaWQgMCApIHRvID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKGZyb20gPj0gdG8pIHsgcmV0dXJuIFJvcGVTZXF1ZW5jZS5lbXB0eSB9XG4gIHJldHVybiB0aGlzLnNsaWNlSW5uZXIoTWF0aC5tYXgoMCwgZnJvbSksIE1hdGgubWluKHRoaXMubGVuZ3RoLCB0bykpXG59O1xuXG4vLyA6OiAobnVtYmVyKSBcdTIxOTIgVFxuLy8gUmV0cmlldmUgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGZyb20gdGhpcyByb3BlLlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGkpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIHVuZGVmaW5lZCB9XG4gIHJldHVybiB0aGlzLmdldElubmVyKGkpXG59O1xuXG4vLyA6OiAoKGVsZW1lbnQ6IFQsIGluZGV4OiBudW1iZXIpIFx1MjE5MiA/Ym9vbCwgP251bWJlciwgP251bWJlcilcbi8vIENhbGwgdGhlIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIGVsZW1lbnQgYmV0d2VlbiB0aGUgZ2l2ZW5cbi8vIGluZGljZXMuIFRoaXMgdGVuZHMgdG8gYmUgbW9yZSBlZmZpY2llbnQgdGhhbiBsb29waW5nIG92ZXIgdGhlXG4vLyBpbmRpY2VzIGFuZCBjYWxsaW5nIGBnZXRgLCBiZWNhdXNlIGl0IGRvZXNuJ3QgaGF2ZSB0byBkZXNjZW5kIHRoZVxuLy8gdHJlZSBmb3IgZXZlcnkgZWxlbWVudC5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2ggKGYsIGZyb20sIHRvKSB7XG4gICAgaWYgKCBmcm9tID09PSB2b2lkIDAgKSBmcm9tID0gMDtcbiAgICBpZiAoIHRvID09PSB2b2lkIDAgKSB0byA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChmcm9tIDw9IHRvKVxuICAgIHsgdGhpcy5mb3JFYWNoSW5uZXIoZiwgZnJvbSwgdG8sIDApOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuZm9yRWFjaEludmVydGVkSW5uZXIoZiwgZnJvbSwgdG8sIDApOyB9XG59O1xuXG4vLyA6OiAoKGVsZW1lbnQ6IFQsIGluZGV4OiBudW1iZXIpIFx1MjE5MiBVLCA/bnVtYmVyLCA/bnVtYmVyKSBcdTIxOTIgW1VdXG4vLyBNYXAgdGhlIGdpdmVuIGZ1bmN0aW9ucyBvdmVyIHRoZSBlbGVtZW50cyBvZiB0aGUgcm9wZSwgcHJvZHVjaW5nXG4vLyBhIGZsYXQgYXJyYXkuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAoZiwgZnJvbSwgdG8pIHtcbiAgICBpZiAoIGZyb20gPT09IHZvaWQgMCApIGZyb20gPSAwO1xuICAgIGlmICggdG8gPT09IHZvaWQgMCApIHRvID0gdGhpcy5sZW5ndGg7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsdCwgaSkgeyByZXR1cm4gcmVzdWx0LnB1c2goZihlbHQsIGkpKTsgfSwgZnJvbSwgdG8pO1xuICByZXR1cm4gcmVzdWx0XG59O1xuXG4vLyA6OiAoP3VuaW9uPFtUXSwgUm9wZVNlcXVlbmNlPFQ+PikgXHUyMTkyIFJvcGVTZXF1ZW5jZTxUPlxuLy8gQ3JlYXRlIGEgcm9wZSByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGFycmF5LCBvciByZXR1cm4gdGhlIHJvcGVcbi8vIGl0c2VsZiBpZiBhIHJvcGUgd2FzIGdpdmVuLlxuUm9wZVNlcXVlbmNlLmZyb20gPSBmdW5jdGlvbiBmcm9tICh2YWx1ZXMpIHtcbiAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFJvcGVTZXF1ZW5jZSkgeyByZXR1cm4gdmFsdWVzIH1cbiAgcmV0dXJuIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoID8gbmV3IExlYWYodmFsdWVzKSA6IFJvcGVTZXF1ZW5jZS5lbXB0eVxufTtcblxudmFyIExlYWYgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChSb3BlU2VxdWVuY2UpIHtcbiAgZnVuY3Rpb24gTGVhZih2YWx1ZXMpIHtcbiAgICBSb3BlU2VxdWVuY2UuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgfVxuXG4gIGlmICggUm9wZVNlcXVlbmNlICkgTGVhZi5fX3Byb3RvX18gPSBSb3BlU2VxdWVuY2U7XG4gIExlYWYucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUm9wZVNlcXVlbmNlICYmIFJvcGVTZXF1ZW5jZS5wcm90b3R5cGUgKTtcbiAgTGVhZi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZWFmO1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGxlbmd0aDogeyBjb25maWd1cmFibGU6IHRydWUgfSxkZXB0aDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIExlYWYucHJvdG90eXBlLmZsYXR0ZW4gPSBmdW5jdGlvbiBmbGF0dGVuICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNcbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5zbGljZUlubmVyID0gZnVuY3Rpb24gc2xpY2VJbm5lciAoZnJvbSwgdG8pIHtcbiAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgICByZXR1cm4gbmV3IExlYWYodGhpcy52YWx1ZXMuc2xpY2UoZnJvbSwgdG8pKVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmdldElubmVyID0gZnVuY3Rpb24gZ2V0SW5uZXIgKGkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbaV1cbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5mb3JFYWNoSW5uZXIgPSBmdW5jdGlvbiBmb3JFYWNoSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgdG87IGkrKylcbiAgICAgIHsgaWYgKGYodGhpcy52YWx1ZXNbaV0sIHN0YXJ0ICsgaSkgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9IH1cbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5mb3JFYWNoSW52ZXJ0ZWRJbm5lciA9IGZ1bmN0aW9uIGZvckVhY2hJbnZlcnRlZElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICBmb3IgKHZhciBpID0gZnJvbSAtIDE7IGkgPj0gdG87IGktLSlcbiAgICAgIHsgaWYgKGYodGhpcy52YWx1ZXNbaV0sIHN0YXJ0ICsgaSkgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9IH1cbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5sZWFmQXBwZW5kID0gZnVuY3Rpb24gbGVhZkFwcGVuZCAob3RoZXIpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggKyBvdGhlci5sZW5ndGggPD0gR09PRF9MRUFGX1NJWkUpXG4gICAgICB7IHJldHVybiBuZXcgTGVhZih0aGlzLnZhbHVlcy5jb25jYXQob3RoZXIuZmxhdHRlbigpKSkgfVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmxlYWZQcmVwZW5kID0gZnVuY3Rpb24gbGVhZlByZXBlbmQgKG90aGVyKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoICsgb3RoZXIubGVuZ3RoIDw9IEdPT0RfTEVBRl9TSVpFKVxuICAgICAgeyByZXR1cm4gbmV3IExlYWYob3RoZXIuZmxhdHRlbigpLmNvbmNhdCh0aGlzLnZhbHVlcykpIH1cbiAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMubGVuZ3RoLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudmFsdWVzLmxlbmd0aCB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5kZXB0aC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIExlYWYucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gTGVhZjtcbn0oUm9wZVNlcXVlbmNlKSk7XG5cbi8vIDo6IFJvcGVTZXF1ZW5jZVxuLy8gVGhlIGVtcHR5IHJvcGUgc2VxdWVuY2UuXG5Sb3BlU2VxdWVuY2UuZW1wdHkgPSBuZXcgTGVhZihbXSk7XG5cbnZhciBBcHBlbmQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChSb3BlU2VxdWVuY2UpIHtcbiAgZnVuY3Rpb24gQXBwZW5kKGxlZnQsIHJpZ2h0KSB7XG4gICAgUm9wZVNlcXVlbmNlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgdGhpcy5sZW5ndGggPSBsZWZ0Lmxlbmd0aCArIHJpZ2h0Lmxlbmd0aDtcbiAgICB0aGlzLmRlcHRoID0gTWF0aC5tYXgobGVmdC5kZXB0aCwgcmlnaHQuZGVwdGgpICsgMTtcbiAgfVxuXG4gIGlmICggUm9wZVNlcXVlbmNlICkgQXBwZW5kLl9fcHJvdG9fXyA9IFJvcGVTZXF1ZW5jZTtcbiAgQXBwZW5kLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFJvcGVTZXF1ZW5jZSAmJiBSb3BlU2VxdWVuY2UucHJvdG90eXBlICk7XG4gIEFwcGVuZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcHBlbmQ7XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5mbGF0dGVuID0gZnVuY3Rpb24gZmxhdHRlbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVmdC5mbGF0dGVuKCkuY29uY2F0KHRoaXMucmlnaHQuZmxhdHRlbigpKVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuZ2V0SW5uZXIgPSBmdW5jdGlvbiBnZXRJbm5lciAoaSkge1xuICAgIHJldHVybiBpIDwgdGhpcy5sZWZ0Lmxlbmd0aCA/IHRoaXMubGVmdC5nZXQoaSkgOiB0aGlzLnJpZ2h0LmdldChpIC0gdGhpcy5sZWZ0Lmxlbmd0aClcbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmZvckVhY2hJbm5lciA9IGZ1bmN0aW9uIGZvckVhY2hJbm5lciAoZiwgZnJvbSwgdG8sIHN0YXJ0KSB7XG4gICAgdmFyIGxlZnRMZW4gPSB0aGlzLmxlZnQubGVuZ3RoO1xuICAgIGlmIChmcm9tIDwgbGVmdExlbiAmJlxuICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaElubmVyKGYsIGZyb20sIE1hdGgubWluKHRvLCBsZWZ0TGVuKSwgc3RhcnQpID09PSBmYWxzZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAodG8gPiBsZWZ0TGVuICYmXG4gICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaElubmVyKGYsIE1hdGgubWF4KGZyb20gLSBsZWZ0TGVuLCAwKSwgTWF0aC5taW4odGhpcy5sZW5ndGgsIHRvKSAtIGxlZnRMZW4sIHN0YXJ0ICsgbGVmdExlbikgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuZm9yRWFjaEludmVydGVkSW5uZXIgPSBmdW5jdGlvbiBmb3JFYWNoSW52ZXJ0ZWRJbm5lciAoZiwgZnJvbSwgdG8sIHN0YXJ0KSB7XG4gICAgdmFyIGxlZnRMZW4gPSB0aGlzLmxlZnQubGVuZ3RoO1xuICAgIGlmIChmcm9tID4gbGVmdExlbiAmJlxuICAgICAgICB0aGlzLnJpZ2h0LmZvckVhY2hJbnZlcnRlZElubmVyKGYsIGZyb20gLSBsZWZ0TGVuLCBNYXRoLm1heCh0bywgbGVmdExlbikgLSBsZWZ0TGVuLCBzdGFydCArIGxlZnRMZW4pID09PSBmYWxzZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAodG8gPCBsZWZ0TGVuICYmXG4gICAgICAgIHRoaXMubGVmdC5mb3JFYWNoSW52ZXJ0ZWRJbm5lcihmLCBNYXRoLm1pbihmcm9tLCBsZWZ0TGVuKSwgdG8sIHN0YXJ0KSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5zbGljZUlubmVyID0gZnVuY3Rpb24gc2xpY2VJbm5lciAoZnJvbSwgdG8pIHtcbiAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgICB2YXIgbGVmdExlbiA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgaWYgKHRvIDw9IGxlZnRMZW4pIHsgcmV0dXJuIHRoaXMubGVmdC5zbGljZShmcm9tLCB0bykgfVxuICAgIGlmIChmcm9tID49IGxlZnRMZW4pIHsgcmV0dXJuIHRoaXMucmlnaHQuc2xpY2UoZnJvbSAtIGxlZnRMZW4sIHRvIC0gbGVmdExlbikgfVxuICAgIHJldHVybiB0aGlzLmxlZnQuc2xpY2UoZnJvbSwgbGVmdExlbikuYXBwZW5kKHRoaXMucmlnaHQuc2xpY2UoMCwgdG8gLSBsZWZ0TGVuKSlcbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmxlYWZBcHBlbmQgPSBmdW5jdGlvbiBsZWFmQXBwZW5kIChvdGhlcikge1xuICAgIHZhciBpbm5lciA9IHRoaXMucmlnaHQubGVhZkFwcGVuZChvdGhlcik7XG4gICAgaWYgKGlubmVyKSB7IHJldHVybiBuZXcgQXBwZW5kKHRoaXMubGVmdCwgaW5uZXIpIH1cbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmxlYWZQcmVwZW5kID0gZnVuY3Rpb24gbGVhZlByZXBlbmQgKG90aGVyKSB7XG4gICAgdmFyIGlubmVyID0gdGhpcy5sZWZ0LmxlYWZQcmVwZW5kKG90aGVyKTtcbiAgICBpZiAoaW5uZXIpIHsgcmV0dXJuIG5ldyBBcHBlbmQoaW5uZXIsIHRoaXMucmlnaHQpIH1cbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmFwcGVuZElubmVyID0gZnVuY3Rpb24gYXBwZW5kSW5uZXIgKG90aGVyKSB7XG4gICAgaWYgKHRoaXMubGVmdC5kZXB0aCA+PSBNYXRoLm1heCh0aGlzLnJpZ2h0LmRlcHRoLCBvdGhlci5kZXB0aCkgKyAxKVxuICAgICAgeyByZXR1cm4gbmV3IEFwcGVuZCh0aGlzLmxlZnQsIG5ldyBBcHBlbmQodGhpcy5yaWdodCwgb3RoZXIpKSB9XG4gICAgcmV0dXJuIG5ldyBBcHBlbmQodGhpcywgb3RoZXIpXG4gIH07XG5cbiAgcmV0dXJuIEFwcGVuZDtcbn0oUm9wZVNlcXVlbmNlKSk7XG5cbmV4cG9ydCBkZWZhdWx0IFJvcGVTZXF1ZW5jZTtcbiIsICJpbXBvcnQgUm9wZVNlcXVlbmNlIGZyb20gJ3JvcGUtc2VxdWVuY2UnO1xuaW1wb3J0IHsgTWFwcGluZyB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBQbHVnaW5LZXksIFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxuLy8gUHJvc2VNaXJyb3IncyBoaXN0b3J5IGlzbid0IHNpbXBseSBhIHdheSB0byByb2xsIGJhY2sgdG8gYSBwcmV2aW91c1xuLy8gc3RhdGUsIGJlY2F1c2UgUHJvc2VNaXJyb3Igc3VwcG9ydHMgYXBwbHlpbmcgY2hhbmdlcyB3aXRob3V0IGFkZGluZ1xuLy8gdGhlbSB0byB0aGUgaGlzdG9yeSAoZm9yIGV4YW1wbGUgZHVyaW5nIGNvbGxhYm9yYXRpb24pLlxuLy9cbi8vIFRvIHRoaXMgZW5kLCBlYWNoICdCcmFuY2gnIChvbmUgZm9yIHRoZSB1bmRvIGhpc3RvcnkgYW5kIG9uZSBmb3Jcbi8vIHRoZSByZWRvIGhpc3RvcnkpIGtlZXBzIGFuIGFycmF5IG9mICdJdGVtcycsIHdoaWNoIGNhbiBvcHRpb25hbGx5XG4vLyBob2xkIGEgc3RlcCAoYW4gYWN0dWFsIHVuZG9hYmxlIGNoYW5nZSksIGFuZCBhbHdheXMgaG9sZCBhIHBvc2l0aW9uXG4vLyBtYXAgKHdoaWNoIGlzIG5lZWRlZCB0byBtb3ZlIGNoYW5nZXMgYmVsb3cgdGhlbSB0byBhcHBseSB0byB0aGVcbi8vIGN1cnJlbnQgZG9jdW1lbnQpLlxuLy9cbi8vIEFuIGl0ZW0gdGhhdCBoYXMgYm90aCBhIHN0ZXAgYW5kIGEgc2VsZWN0aW9uIGJvb2ttYXJrIGlzIHRoZSBzdGFydFxuLy8gb2YgYW4gJ2V2ZW50JyBcdTIwMTQgYSBncm91cCBvZiBjaGFuZ2VzIHRoYXQgd2lsbCBiZSB1bmRvbmUgb3IgcmVkb25lIGF0XG4vLyBvbmNlLiAoSXQgc3RvcmVzIG9ubHkgdGhlIGJvb2ttYXJrLCBzaW5jZSB0aGF0IHdheSB3ZSBkb24ndCBoYXZlIHRvXG4vLyBwcm92aWRlIGEgZG9jdW1lbnQgdW50aWwgdGhlIHNlbGVjdGlvbiBpcyBhY3R1YWxseSBhcHBsaWVkLCB3aGljaFxuLy8gaXMgdXNlZnVsIHdoZW4gY29tcHJlc3NpbmcuKVxuLy8gVXNlZCB0byBzY2hlZHVsZSBoaXN0b3J5IGNvbXByZXNzaW9uXG5jb25zdCBtYXhfZW1wdHlfaXRlbXMgPSA1MDA7XG5jbGFzcyBCcmFuY2gge1xuICAgIGNvbnN0cnVjdG9yKGl0ZW1zLCBldmVudENvdW50KSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICAgICAgdGhpcy5ldmVudENvdW50ID0gZXZlbnRDb3VudDtcbiAgICB9XG4gICAgLy8gUG9wIHRoZSBsYXRlc3QgZXZlbnQgb2ZmIHRoZSBicmFuY2gncyBoaXN0b3J5IGFuZCBhcHBseSBpdFxuICAgIC8vIHRvIGEgZG9jdW1lbnQgdHJhbnNmb3JtLlxuICAgIHBvcEV2ZW50KHN0YXRlLCBwcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50Q291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICAgIGZvciAoOzsgZW5kLS0pIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5pdGVtcy5nZXQoZW5kIC0gMSk7XG4gICAgICAgICAgICBpZiAobmV4dC5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAtLWVuZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVtYXAsIG1hcEZyb207XG4gICAgICAgIGlmIChwcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgICAgICAgICByZW1hcCA9IHRoaXMucmVtYXBwaW5nKGVuZCwgdGhpcy5pdGVtcy5sZW5ndGgpO1xuICAgICAgICAgICAgbWFwRnJvbSA9IHJlbWFwLm1hcHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0cmFuc2Zvcm0gPSBzdGF0ZS50cjtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiwgcmVtYWluaW5nO1xuICAgICAgICBsZXQgYWRkQWZ0ZXIgPSBbXSwgYWRkQmVmb3JlID0gW107XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpdGVtLnN0ZXApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFwID0gdGhpcy5yZW1hcHBpbmcoZW5kLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIG1hcEZyb20gPSByZW1hcC5tYXBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwRnJvbS0tO1xuICAgICAgICAgICAgICAgIGFkZEJlZm9yZS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZW1hcCkge1xuICAgICAgICAgICAgICAgIGFkZEJlZm9yZS5wdXNoKG5ldyBJdGVtKGl0ZW0ubWFwKSk7XG4gICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSBpdGVtLnN0ZXAubWFwKHJlbWFwLnNsaWNlKG1hcEZyb20pKSwgbWFwO1xuICAgICAgICAgICAgICAgIGlmIChzdGVwICYmIHRyYW5zZm9ybS5tYXliZVN0ZXAoc3RlcCkuZG9jKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcCA9IHRyYW5zZm9ybS5tYXBwaW5nLm1hcHNbdHJhbnNmb3JtLm1hcHBpbmcubWFwcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQWZ0ZXIucHVzaChuZXcgSXRlbShtYXAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhZGRBZnRlci5sZW5ndGggKyBhZGRCZWZvcmUubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcEZyb20tLTtcbiAgICAgICAgICAgICAgICBpZiAobWFwKVxuICAgICAgICAgICAgICAgICAgICByZW1hcC5hcHBlbmRNYXAobWFwLCBtYXBGcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5tYXliZVN0ZXAoaXRlbS5zdGVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHJlbWFwID8gaXRlbS5zZWxlY3Rpb24ubWFwKHJlbWFwLnNsaWNlKG1hcEZyb20pKSA6IGl0ZW0uc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IG5ldyBCcmFuY2godGhpcy5pdGVtcy5zbGljZSgwLCBlbmQpLmFwcGVuZChhZGRCZWZvcmUucmV2ZXJzZSgpLmNvbmNhdChhZGRBZnRlcikpLCB0aGlzLmV2ZW50Q291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuaXRlbXMubGVuZ3RoLCAwKTtcbiAgICAgICAgcmV0dXJuIHsgcmVtYWluaW5nOiByZW1haW5pbmcsIHRyYW5zZm9ybSwgc2VsZWN0aW9uOiBzZWxlY3Rpb24gfTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgbmV3IGJyYW5jaCB3aXRoIHRoZSBnaXZlbiB0cmFuc2Zvcm0gYWRkZWQuXG4gICAgYWRkVHJhbnNmb3JtKHRyYW5zZm9ybSwgc2VsZWN0aW9uLCBoaXN0T3B0aW9ucywgcHJlc2VydmVJdGVtcykge1xuICAgICAgICBsZXQgbmV3SXRlbXMgPSBbXSwgZXZlbnRDb3VudCA9IHRoaXMuZXZlbnRDb3VudDtcbiAgICAgICAgbGV0IG9sZEl0ZW1zID0gdGhpcy5pdGVtcywgbGFzdEl0ZW0gPSAhcHJlc2VydmVJdGVtcyAmJiBvbGRJdGVtcy5sZW5ndGggPyBvbGRJdGVtcy5nZXQob2xkSXRlbXMubGVuZ3RoIC0gMSkgOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYW5zZm9ybS5zdGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0ZXAgPSB0cmFuc2Zvcm0uc3RlcHNbaV0uaW52ZXJ0KHRyYW5zZm9ybS5kb2NzW2ldKTtcbiAgICAgICAgICAgIGxldCBpdGVtID0gbmV3IEl0ZW0odHJhbnNmb3JtLm1hcHBpbmcubWFwc1tpXSwgc3RlcCwgc2VsZWN0aW9uKSwgbWVyZ2VkO1xuICAgICAgICAgICAgaWYgKG1lcmdlZCA9IGxhc3RJdGVtICYmIGxhc3RJdGVtLm1lcmdlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IG1lcmdlZDtcbiAgICAgICAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgICAgICAgICAgbmV3SXRlbXMucG9wKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvbGRJdGVtcyA9IG9sZEl0ZW1zLnNsaWNlKDAsIG9sZEl0ZW1zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3SXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBldmVudENvdW50Kys7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcmVzZXJ2ZUl0ZW1zKVxuICAgICAgICAgICAgICAgIGxhc3RJdGVtID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3ZlcmZsb3cgPSBldmVudENvdW50IC0gaGlzdE9wdGlvbnMuZGVwdGg7XG4gICAgICAgIGlmIChvdmVyZmxvdyA+IERFUFRIX09WRVJGTE9XKSB7XG4gICAgICAgICAgICBvbGRJdGVtcyA9IGN1dE9mZkV2ZW50cyhvbGRJdGVtcywgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgZXZlbnRDb3VudCAtPSBvdmVyZmxvdztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJyYW5jaChvbGRJdGVtcy5hcHBlbmQobmV3SXRlbXMpLCBldmVudENvdW50KTtcbiAgICB9XG4gICAgcmVtYXBwaW5nKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBtYXBzID0gbmV3IE1hcHBpbmc7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IG1pcnJvclBvcyA9IGl0ZW0ubWlycm9yT2Zmc2V0ICE9IG51bGwgJiYgaSAtIGl0ZW0ubWlycm9yT2Zmc2V0ID49IGZyb21cbiAgICAgICAgICAgICAgICA/IG1hcHMubWFwcy5sZW5ndGggLSBpdGVtLm1pcnJvck9mZnNldCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG1hcHMuYXBwZW5kTWFwKGl0ZW0ubWFwLCBtaXJyb3JQb3MpO1xuICAgICAgICB9LCBmcm9tLCB0byk7XG4gICAgICAgIHJldHVybiBtYXBzO1xuICAgIH1cbiAgICBhZGRNYXBzKGFycmF5KSB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50Q291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEJyYW5jaCh0aGlzLml0ZW1zLmFwcGVuZChhcnJheS5tYXAobWFwID0+IG5ldyBJdGVtKG1hcCkpKSwgdGhpcy5ldmVudENvdW50KTtcbiAgICB9XG4gICAgLy8gV2hlbiB0aGUgY29sbGFiIG1vZHVsZSByZWNlaXZlcyByZW1vdGUgY2hhbmdlcywgdGhlIGhpc3RvcnkgaGFzXG4gICAgLy8gdG8ga25vdyBhYm91dCB0aG9zZSwgc28gdGhhdCBpdCBjYW4gYWRqdXN0IHRoZSBzdGVwcyB0aGF0IHdlcmVcbiAgICAvLyByZWJhc2VkIG9uIHRvcCBvZiB0aGUgcmVtb3RlIGNoYW5nZXMsIGFuZCBpbmNsdWRlIHRoZSBwb3NpdGlvblxuICAgIC8vIG1hcHMgZm9yIHRoZSByZW1vdGUgY2hhbmdlcyBpbiBpdHMgYXJyYXkgb2YgaXRlbXMuXG4gICAgcmViYXNlZChyZWJhc2VkVHJhbnNmb3JtLCByZWJhc2VkQ291bnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmV2ZW50Q291bnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IHJlYmFzZWRJdGVtcyA9IFtdLCBzdGFydCA9IE1hdGgubWF4KDAsIHRoaXMuaXRlbXMubGVuZ3RoIC0gcmViYXNlZENvdW50KTtcbiAgICAgICAgbGV0IG1hcHBpbmcgPSByZWJhc2VkVHJhbnNmb3JtLm1hcHBpbmc7XG4gICAgICAgIGxldCBuZXdVbnRpbCA9IHJlYmFzZWRUcmFuc2Zvcm0uc3RlcHMubGVuZ3RoO1xuICAgICAgICBsZXQgZXZlbnRDb3VudCA9IHRoaXMuZXZlbnRDb3VudDtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4geyBpZiAoaXRlbS5zZWxlY3Rpb24pXG4gICAgICAgICAgICBldmVudENvdW50LS07IH0sIHN0YXJ0KTtcbiAgICAgICAgbGV0IGlSZWJhc2VkID0gcmViYXNlZENvdW50O1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBsZXQgcG9zID0gbWFwcGluZy5nZXRNaXJyb3IoLS1pUmViYXNlZCk7XG4gICAgICAgICAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbmV3VW50aWwgPSBNYXRoLm1pbihuZXdVbnRpbCwgcG9zKTtcbiAgICAgICAgICAgIGxldCBtYXAgPSBtYXBwaW5nLm1hcHNbcG9zXTtcbiAgICAgICAgICAgIGlmIChpdGVtLnN0ZXApIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IHJlYmFzZWRUcmFuc2Zvcm0uc3RlcHNbcG9zXS5pbnZlcnQocmViYXNlZFRyYW5zZm9ybS5kb2NzW3Bvc10pO1xuICAgICAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSBpdGVtLnNlbGVjdGlvbiAmJiBpdGVtLnNlbGVjdGlvbi5tYXAobWFwcGluZy5zbGljZShpUmViYXNlZCArIDEsIHBvcykpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Q291bnQrKztcbiAgICAgICAgICAgICAgICByZWJhc2VkSXRlbXMucHVzaChuZXcgSXRlbShtYXAsIHN0ZXAsIHNlbGVjdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmViYXNlZEl0ZW1zLnB1c2gobmV3IEl0ZW0obWFwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHN0YXJ0KTtcbiAgICAgICAgbGV0IG5ld01hcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHJlYmFzZWRDb3VudDsgaSA8IG5ld1VudGlsOyBpKyspXG4gICAgICAgICAgICBuZXdNYXBzLnB1c2gobmV3IEl0ZW0obWFwcGluZy5tYXBzW2ldKSk7XG4gICAgICAgIGxldCBpdGVtcyA9IHRoaXMuaXRlbXMuc2xpY2UoMCwgc3RhcnQpLmFwcGVuZChuZXdNYXBzKS5hcHBlbmQocmViYXNlZEl0ZW1zKTtcbiAgICAgICAgbGV0IGJyYW5jaCA9IG5ldyBCcmFuY2goaXRlbXMsIGV2ZW50Q291bnQpO1xuICAgICAgICBpZiAoYnJhbmNoLmVtcHR5SXRlbUNvdW50KCkgPiBtYXhfZW1wdHlfaXRlbXMpXG4gICAgICAgICAgICBicmFuY2ggPSBicmFuY2guY29tcHJlc3ModGhpcy5pdGVtcy5sZW5ndGggLSByZWJhc2VkSXRlbXMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICB9XG4gICAgZW1wdHlJdGVtQ291bnQoKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChpdGVtID0+IHsgaWYgKCFpdGVtLnN0ZXApXG4gICAgICAgICAgICBjb3VudCsrOyB9KTtcbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgICAvLyBDb21wcmVzc2luZyBhIGJyYW5jaCBtZWFucyByZXdyaXRpbmcgaXQgdG8gcHVzaCB0aGUgYWlyIChtYXAtb25seVxuICAgIC8vIGl0ZW1zKSBvdXQuIER1cmluZyBjb2xsYWJvcmF0aW9uLCB0aGVzZSBuYXR1cmFsbHkgYWNjdW11bGF0ZVxuICAgIC8vIGJlY2F1c2UgZWFjaCByZW1vdGUgY2hhbmdlIGFkZHMgb25lLiBUaGUgYHVwdG9gIGFyZ3VtZW50IGlzIHVzZWRcbiAgICAvLyB0byBlbnN1cmUgdGhhdCBvbmx5IHRoZSBpdGVtcyBiZWxvdyBhIGdpdmVuIGxldmVsIGFyZSBjb21wcmVzc2VkLFxuICAgIC8vIGJlY2F1c2UgYHJlYmFzZWRgIHJlbGllcyBvbiBhIGNsZWFuLCB1bnRvdWNoZWQgc2V0IG9mIGl0ZW1zIGluXG4gICAgLy8gb3JkZXIgdG8gYXNzb2NpYXRlIG9sZCBpdGVtcyB3aXRoIHJlYmFzZWQgc3RlcHMuXG4gICAgY29tcHJlc3ModXB0byA9IHRoaXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGxldCByZW1hcCA9IHRoaXMucmVtYXBwaW5nKDAsIHVwdG8pLCBtYXBGcm9tID0gcmVtYXAubWFwcy5sZW5ndGg7XG4gICAgICAgIGxldCBpdGVtcyA9IFtdLCBldmVudHMgPSAwO1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChpID49IHVwdG8pIHtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLnN0ZXApIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IGl0ZW0uc3RlcC5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpLCBtYXAgPSBzdGVwICYmIHN0ZXAuZ2V0TWFwKCk7XG4gICAgICAgICAgICAgICAgbWFwRnJvbS0tO1xuICAgICAgICAgICAgICAgIGlmIChtYXApXG4gICAgICAgICAgICAgICAgICAgIHJlbWFwLmFwcGVuZE1hcChtYXAsIG1hcEZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSBpdGVtLnNlbGVjdGlvbiAmJiBpdGVtLnNlbGVjdGlvbi5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzKys7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdJdGVtID0gbmV3IEl0ZW0obWFwLmludmVydCgpLCBzdGVwLCBzZWxlY3Rpb24pLCBtZXJnZWQsIGxhc3QgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVyZ2VkID0gaXRlbXMubGVuZ3RoICYmIGl0ZW1zW2xhc3RdLm1lcmdlKG5ld0l0ZW0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNbbGFzdF0gPSBtZXJnZWQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2gobmV3SXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5tYXApIHtcbiAgICAgICAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuaXRlbXMubGVuZ3RoLCAwKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCcmFuY2goUm9wZVNlcXVlbmNlLmZyb20oaXRlbXMucmV2ZXJzZSgpKSwgZXZlbnRzKTtcbiAgICB9XG59XG5CcmFuY2guZW1wdHkgPSBuZXcgQnJhbmNoKFJvcGVTZXF1ZW5jZS5lbXB0eSwgMCk7XG5mdW5jdGlvbiBjdXRPZmZFdmVudHMoaXRlbXMsIG4pIHtcbiAgICBsZXQgY3V0UG9pbnQ7XG4gICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICBpZiAoaXRlbS5zZWxlY3Rpb24gJiYgKG4tLSA9PSAwKSkge1xuICAgICAgICAgICAgY3V0UG9pbnQgPSBpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZW1zLnNsaWNlKGN1dFBvaW50KTtcbn1cbmNsYXNzIEl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIFRoZSAoZm9yd2FyZCkgc3RlcCBtYXAgZm9yIHRoaXMgaXRlbS5cbiAgICBtYXAsIFxuICAgIC8vIFRoZSBpbnZlcnRlZCBzdGVwXG4gICAgc3RlcCwgXG4gICAgLy8gSWYgdGhpcyBpcyBub24tbnVsbCwgdGhpcyBpdGVtIGlzIHRoZSBzdGFydCBvZiBhIGdyb3VwLCBhbmRcbiAgICAvLyB0aGlzIHNlbGVjdGlvbiBpcyB0aGUgc3RhcnRpbmcgc2VsZWN0aW9uIGZvciB0aGUgZ3JvdXAgKHRoZSBvbmVcbiAgICAvLyB0aGF0IHdhcyBhY3RpdmUgYmVmb3JlIHRoZSBmaXJzdCBzdGVwIHdhcyBhcHBsaWVkKVxuICAgIHNlbGVjdGlvbiwgXG4gICAgLy8gSWYgdGhpcyBpdGVtIGlzIHRoZSBpbnZlcnNlIG9mIGEgcHJldmlvdXMgbWFwcGluZyBvbiB0aGUgc3RhY2ssXG4gICAgLy8gdGhpcyBwb2ludHMgYXQgdGhlIGludmVyc2UncyBvZmZzZXRcbiAgICBtaXJyb3JPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgIHRoaXMuc3RlcCA9IHN0ZXA7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLm1pcnJvck9mZnNldCA9IG1pcnJvck9mZnNldDtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RlcCAmJiBvdGhlci5zdGVwICYmICFvdGhlci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBzdGVwID0gb3RoZXIuc3RlcC5tZXJnZSh0aGlzLnN0ZXApO1xuICAgICAgICAgICAgaWYgKHN0ZXApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJdGVtKHN0ZXAuZ2V0TWFwKCkuaW52ZXJ0KCksIHN0ZXAsIHRoaXMuc2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFRoZSB2YWx1ZSBvZiB0aGUgc3RhdGUgZmllbGQgdGhhdCB0cmFja3MgdW5kby9yZWRvIGhpc3RvcnkgZm9yIHRoYXRcbi8vIHN0YXRlLiBXaWxsIGJlIHN0b3JlZCBpbiB0aGUgcGx1Z2luIHN0YXRlIHdoZW4gdGhlIGhpc3RvcnkgcGx1Z2luXG4vLyBpcyBhY3RpdmUuXG5jbGFzcyBIaXN0b3J5U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGRvbmUsIHVuZG9uZSwgcHJldlJhbmdlcywgcHJldlRpbWUsIHByZXZDb21wb3NpdGlvbikge1xuICAgICAgICB0aGlzLmRvbmUgPSBkb25lO1xuICAgICAgICB0aGlzLnVuZG9uZSA9IHVuZG9uZTtcbiAgICAgICAgdGhpcy5wcmV2UmFuZ2VzID0gcHJldlJhbmdlcztcbiAgICAgICAgdGhpcy5wcmV2VGltZSA9IHByZXZUaW1lO1xuICAgICAgICB0aGlzLnByZXZDb21wb3NpdGlvbiA9IHByZXZDb21wb3NpdGlvbjtcbiAgICB9XG59XG5jb25zdCBERVBUSF9PVkVSRkxPVyA9IDIwO1xuLy8gUmVjb3JkIGEgdHJhbnNmb3JtYXRpb24gaW4gdW5kbyBoaXN0b3J5LlxuZnVuY3Rpb24gYXBwbHlUcmFuc2FjdGlvbihoaXN0b3J5LCBzdGF0ZSwgdHIsIG9wdGlvbnMpIHtcbiAgICBsZXQgaGlzdG9yeVRyID0gdHIuZ2V0TWV0YShoaXN0b3J5S2V5KSwgcmViYXNlZDtcbiAgICBpZiAoaGlzdG9yeVRyKVxuICAgICAgICByZXR1cm4gaGlzdG9yeVRyLmhpc3RvcnlTdGF0ZTtcbiAgICBpZiAodHIuZ2V0TWV0YShjbG9zZUhpc3RvcnlLZXkpKVxuICAgICAgICBoaXN0b3J5ID0gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUsIGhpc3RvcnkudW5kb25lLCBudWxsLCAwLCAtMSk7XG4gICAgbGV0IGFwcGVuZGVkID0gdHIuZ2V0TWV0YShcImFwcGVuZGVkVHJhbnNhY3Rpb25cIik7XG4gICAgaWYgKHRyLnN0ZXBzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiBoaXN0b3J5O1xuICAgIH1cbiAgICBlbHNlIGlmIChhcHBlbmRlZCAmJiBhcHBlbmRlZC5nZXRNZXRhKGhpc3RvcnlLZXkpKSB7XG4gICAgICAgIGlmIChhcHBlbmRlZC5nZXRNZXRhKGhpc3RvcnlLZXkpLnJlZG8pXG4gICAgICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUuYWRkVHJhbnNmb3JtKHRyLCB1bmRlZmluZWQsIG9wdGlvbnMsIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSksIGhpc3RvcnkudW5kb25lLCByYW5nZXNGb3IodHIubWFwcGluZy5tYXBzW3RyLnN0ZXBzLmxlbmd0aCAtIDFdKSwgaGlzdG9yeS5wcmV2VGltZSwgaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUsIGhpc3RvcnkudW5kb25lLmFkZFRyYW5zZm9ybSh0ciwgdW5kZWZpbmVkLCBvcHRpb25zLCBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkpLCBudWxsLCBoaXN0b3J5LnByZXZUaW1lLCBoaXN0b3J5LnByZXZDb21wb3NpdGlvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyLmdldE1ldGEoXCJhZGRUb0hpc3RvcnlcIikgIT09IGZhbHNlICYmICEoYXBwZW5kZWQgJiYgYXBwZW5kZWQuZ2V0TWV0YShcImFkZFRvSGlzdG9yeVwiKSA9PT0gZmFsc2UpKSB7XG4gICAgICAgIC8vIEdyb3VwIHRyYW5zZm9ybXMgdGhhdCBvY2N1ciBpbiBxdWljayBzdWNjZXNzaW9uIGludG8gb25lIGV2ZW50LlxuICAgICAgICBsZXQgY29tcG9zaXRpb24gPSB0ci5nZXRNZXRhKFwiY29tcG9zaXRpb25cIik7XG4gICAgICAgIGxldCBuZXdHcm91cCA9IGhpc3RvcnkucHJldlRpbWUgPT0gMCB8fFxuICAgICAgICAgICAgKCFhcHBlbmRlZCAmJiBoaXN0b3J5LnByZXZDb21wb3NpdGlvbiAhPSBjb21wb3NpdGlvbiAmJlxuICAgICAgICAgICAgICAgIChoaXN0b3J5LnByZXZUaW1lIDwgKHRyLnRpbWUgfHwgMCkgLSBvcHRpb25zLm5ld0dyb3VwRGVsYXkgfHwgIWlzQWRqYWNlbnRUbyh0ciwgaGlzdG9yeS5wcmV2UmFuZ2VzKSkpO1xuICAgICAgICBsZXQgcHJldlJhbmdlcyA9IGFwcGVuZGVkID8gbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZykgOiByYW5nZXNGb3IodHIubWFwcGluZy5tYXBzW3RyLnN0ZXBzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLmFkZFRyYW5zZm9ybSh0ciwgbmV3R3JvdXAgPyBzdGF0ZS5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKSA6IHVuZGVmaW5lZCwgb3B0aW9ucywgbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpKSwgQnJhbmNoLmVtcHR5LCBwcmV2UmFuZ2VzLCB0ci50aW1lLCBjb21wb3NpdGlvbiA9PSBudWxsID8gaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24gOiBjb21wb3NpdGlvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlYmFzZWQgPSB0ci5nZXRNZXRhKFwicmViYXNlZFwiKSkge1xuICAgICAgICAvLyBVc2VkIGJ5IHRoZSBjb2xsYWIgbW9kdWxlIHRvIHRlbGwgdGhlIGhpc3RvcnkgdGhhdCBzb21lIG9mIGl0c1xuICAgICAgICAvLyBjb250ZW50IGhhcyBiZWVuIHJlYmFzZWQuXG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5yZWJhc2VkKHRyLCByZWJhc2VkKSwgaGlzdG9yeS51bmRvbmUucmViYXNlZCh0ciwgcmViYXNlZCksIG1hcFJhbmdlcyhoaXN0b3J5LnByZXZSYW5nZXMsIHRyLm1hcHBpbmcpLCBoaXN0b3J5LnByZXZUaW1lLCBoaXN0b3J5LnByZXZDb21wb3NpdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUuYWRkTWFwcyh0ci5tYXBwaW5nLm1hcHMpLCBoaXN0b3J5LnVuZG9uZS5hZGRNYXBzKHRyLm1hcHBpbmcubWFwcyksIG1hcFJhbmdlcyhoaXN0b3J5LnByZXZSYW5nZXMsIHRyLm1hcHBpbmcpLCBoaXN0b3J5LnByZXZUaW1lLCBoaXN0b3J5LnByZXZDb21wb3NpdGlvbik7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNBZGphY2VudFRvKHRyYW5zZm9ybSwgcHJldlJhbmdlcykge1xuICAgIGlmICghcHJldlJhbmdlcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghdHJhbnNmb3JtLmRvY0NoYW5nZWQpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBhZGphY2VudCA9IGZhbHNlO1xuICAgIHRyYW5zZm9ybS5tYXBwaW5nLm1hcHNbMF0uZm9yRWFjaCgoc3RhcnQsIGVuZCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZSYW5nZXMubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgICAgICBpZiAoc3RhcnQgPD0gcHJldlJhbmdlc1tpICsgMV0gJiYgZW5kID49IHByZXZSYW5nZXNbaV0pXG4gICAgICAgICAgICAgICAgYWRqYWNlbnQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBhZGphY2VudDtcbn1cbmZ1bmN0aW9uIHJhbmdlc0ZvcihtYXApIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgbWFwLmZvckVhY2goKF9mcm9tLCBfdG8sIGZyb20sIHRvKSA9PiByZXN1bHQucHVzaChmcm9tLCB0bykpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtYXBSYW5nZXMocmFuZ2VzLCBtYXBwaW5nKSB7XG4gICAgaWYgKCFyYW5nZXMpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwKHJhbmdlc1tpXSwgMSksIHRvID0gbWFwcGluZy5tYXAocmFuZ2VzW2kgKyAxXSwgLTEpO1xuICAgICAgICBpZiAoZnJvbSA8PSB0bylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyb20sIHRvKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIEFwcGx5IHRoZSBsYXRlc3QgZXZlbnQgZnJvbSBvbmUgYnJhbmNoIHRvIHRoZSBkb2N1bWVudCBhbmQgc2hpZnQgdGhlIGV2ZW50XG4vLyBvbnRvIHRoZSBvdGhlciBicmFuY2guXG5mdW5jdGlvbiBoaXN0VHJhbnNhY3Rpb24oaGlzdG9yeSwgc3RhdGUsIGRpc3BhdGNoLCByZWRvKSB7XG4gICAgbGV0IHByZXNlcnZlSXRlbXMgPSBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSk7XG4gICAgbGV0IGhpc3RPcHRpb25zID0gaGlzdG9yeUtleS5nZXQoc3RhdGUpLnNwZWMuY29uZmlnO1xuICAgIGxldCBwb3AgPSAocmVkbyA/IGhpc3RvcnkudW5kb25lIDogaGlzdG9yeS5kb25lKS5wb3BFdmVudChzdGF0ZSwgcHJlc2VydmVJdGVtcyk7XG4gICAgaWYgKCFwb3ApXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgc2VsZWN0aW9uID0gcG9wLnNlbGVjdGlvbi5yZXNvbHZlKHBvcC50cmFuc2Zvcm0uZG9jKTtcbiAgICBsZXQgYWRkZWQgPSAocmVkbyA/IGhpc3RvcnkuZG9uZSA6IGhpc3RvcnkudW5kb25lKS5hZGRUcmFuc2Zvcm0ocG9wLnRyYW5zZm9ybSwgc3RhdGUuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCksIGhpc3RPcHRpb25zLCBwcmVzZXJ2ZUl0ZW1zKTtcbiAgICBsZXQgbmV3SGlzdCA9IG5ldyBIaXN0b3J5U3RhdGUocmVkbyA/IGFkZGVkIDogcG9wLnJlbWFpbmluZywgcmVkbyA/IHBvcC5yZW1haW5pbmcgOiBhZGRlZCwgbnVsbCwgMCwgLTEpO1xuICAgIGRpc3BhdGNoKHBvcC50cmFuc2Zvcm0uc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikuc2V0TWV0YShoaXN0b3J5S2V5LCB7IHJlZG8sIGhpc3RvcnlTdGF0ZTogbmV3SGlzdCB9KS5zY3JvbGxJbnRvVmlldygpKTtcbn1cbmxldCBjYWNoZWRQcmVzZXJ2ZUl0ZW1zID0gZmFsc2UsIGNhY2hlZFByZXNlcnZlSXRlbXNQbHVnaW5zID0gbnVsbDtcbi8vIENoZWNrIHdoZXRoZXIgYW55IHBsdWdpbiBpbiB0aGUgZ2l2ZW4gc3RhdGUgaGFzIGFcbi8vIGBoaXN0b3J5UHJlc2VydmVJdGVtc2AgcHJvcGVydHkgaW4gaXRzIHNwZWMsIGluIHdoaWNoIGNhc2Ugd2UgbXVzdFxuLy8gcHJlc2VydmUgc3RlcHMgZXhhY3RseSBhcyB0aGV5IGNhbWUgaW4sIHNvIHRoYXQgdGhleSBjYW4gYmVcbi8vIHJlYmFzZWQuXG5mdW5jdGlvbiBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkge1xuICAgIGxldCBwbHVnaW5zID0gc3RhdGUucGx1Z2lucztcbiAgICBpZiAoY2FjaGVkUHJlc2VydmVJdGVtc1BsdWdpbnMgIT0gcGx1Z2lucykge1xuICAgICAgICBjYWNoZWRQcmVzZXJ2ZUl0ZW1zID0gZmFsc2U7XG4gICAgICAgIGNhY2hlZFByZXNlcnZlSXRlbXNQbHVnaW5zID0gcGx1Z2lucztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHBsdWdpbnNbaV0uc3BlYy5oaXN0b3J5UHJlc2VydmVJdGVtcykge1xuICAgICAgICAgICAgICAgIGNhY2hlZFByZXNlcnZlSXRlbXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkUHJlc2VydmVJdGVtcztcbn1cbi8qKlxuU2V0IGEgZmxhZyBvbiB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24gdGhhdCB3aWxsIHByZXZlbnQgZnVydGhlciBzdGVwc1xuZnJvbSBiZWluZyBhcHBlbmRlZCB0byBhbiBleGlzdGluZyBoaXN0b3J5IGV2ZW50IChzbyB0aGF0IHRoZXlcbnJlcXVpcmUgYSBzZXBhcmF0ZSB1bmRvIGNvbW1hbmQgdG8gdW5kbykuXG4qL1xuZnVuY3Rpb24gY2xvc2VIaXN0b3J5KHRyKSB7XG4gICAgcmV0dXJuIHRyLnNldE1ldGEoY2xvc2VIaXN0b3J5S2V5LCB0cnVlKTtcbn1cbmNvbnN0IGhpc3RvcnlLZXkgPSBuZXcgUGx1Z2luS2V5KFwiaGlzdG9yeVwiKTtcbmNvbnN0IGNsb3NlSGlzdG9yeUtleSA9IG5ldyBQbHVnaW5LZXkoXCJjbG9zZUhpc3RvcnlcIik7XG4vKipcblJldHVybnMgYSBwbHVnaW4gdGhhdCBlbmFibGVzIHRoZSB1bmRvIGhpc3RvcnkgZm9yIGFuIGVkaXRvci4gVGhlXG5wbHVnaW4gd2lsbCB0cmFjayB1bmRvIGFuZCByZWRvIHN0YWNrcywgd2hpY2ggY2FuIGJlIHVzZWQgd2l0aCB0aGVcbltgdW5kb2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNoaXN0b3J5LnVuZG8pIGFuZCBbYHJlZG9gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jaGlzdG9yeS5yZWRvKSBjb21tYW5kcy5cblxuWW91IGNhbiBzZXQgYW4gYFwiYWRkVG9IaXN0b3J5XCJgIFttZXRhZGF0YVxucHJvcGVydHldKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zZXRNZXRhKSBvZiBgZmFsc2VgIG9uIGEgdHJhbnNhY3Rpb25cbnRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyByb2xsZWQgYmFjayBieSB1bmRvLlxuKi9cbmZ1bmN0aW9uIGhpc3RvcnkoY29uZmlnID0ge30pIHtcbiAgICBjb25maWcgPSB7IGRlcHRoOiBjb25maWcuZGVwdGggfHwgMTAwLFxuICAgICAgICBuZXdHcm91cERlbGF5OiBjb25maWcubmV3R3JvdXBEZWxheSB8fCA1MDAgfTtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogaGlzdG9yeUtleSxcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgIGluaXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoQnJhbmNoLmVtcHR5LCBCcmFuY2guZW1wdHksIG51bGwsIDAsIC0xKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcHBseSh0ciwgaGlzdCwgc3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHlUcmFuc2FjdGlvbihoaXN0LCBzdGF0ZSwgdHIsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgIGJlZm9yZWlucHV0KHZpZXcsIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlucHV0VHlwZSA9IGUuaW5wdXRUeXBlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29tbWFuZCA9IGlucHV0VHlwZSA9PSBcImhpc3RvcnlVbmRvXCIgPyB1bmRvIDogaW5wdXRUeXBlID09IFwiaGlzdG9yeVJlZG9cIiA/IHJlZG8gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbW1hbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmQodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbkEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHVuZG9lcyB0aGUgbGFzdCBjaGFuZ2UsIGlmIGFueS5cbiovXG5jb25zdCB1bmRvID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gICAgaWYgKCFoaXN0IHx8IGhpc3QuZG9uZS5ldmVudENvdW50ID09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGhpc3RUcmFuc2FjdGlvbihoaXN0LCBzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHJlZG9lcyB0aGUgbGFzdCB1bmRvbmUgY2hhbmdlLCBpZiBhbnkuXG4qL1xuY29uc3QgcmVkbyA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICAgIGlmICghaGlzdCB8fCBoaXN0LnVuZG9uZS5ldmVudENvdW50ID09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGhpc3RUcmFuc2FjdGlvbihoaXN0LCBzdGF0ZSwgZGlzcGF0Y2gsIHRydWUpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuVGhlIGFtb3VudCBvZiB1bmRvYWJsZSBldmVudHMgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gc3RhdGUuXG4qL1xuZnVuY3Rpb24gdW5kb0RlcHRoKHN0YXRlKSB7XG4gICAgbGV0IGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gaGlzdCA/IGhpc3QuZG9uZS5ldmVudENvdW50IDogMDtcbn1cbi8qKlxuVGhlIGFtb3VudCBvZiByZWRvYWJsZSBldmVudHMgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gZWRpdG9yIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIHJlZG9EZXB0aChzdGF0ZSkge1xuICAgIGxldCBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIGhpc3QgPyBoaXN0LnVuZG9uZS5ldmVudENvdW50IDogMDtcbn1cblxuZXhwb3J0IHsgY2xvc2VIaXN0b3J5LCBoaXN0b3J5LCByZWRvLCByZWRvRGVwdGgsIHVuZG8sIHVuZG9EZXB0aCB9O1xuIiwgImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IGhpc3RvcnksIHJlZG8sIHVuZG8gfSBmcm9tICdAdGlwdGFwL3BtL2hpc3RvcnknXG5cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeU9wdGlvbnMge1xuICBkZXB0aDogbnVtYmVyLFxuICBuZXdHcm91cERlbGF5OiBudW1iZXIsXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBoaXN0b3J5OiB7XG4gICAgICAvKipcbiAgICAgICAqIFVuZG8gcmVjZW50IGNoYW5nZXNcbiAgICAgICAqL1xuICAgICAgdW5kbzogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogUmVhcHBseSByZXZlcnRlZCBjaGFuZ2VzXG4gICAgICAgKi9cbiAgICAgIHJlZG86ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBIaXN0b3J5ID0gRXh0ZW5zaW9uLmNyZWF0ZTxIaXN0b3J5T3B0aW9ucz4oe1xuICBuYW1lOiAnaGlzdG9yeScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVwdGg6IDEwMCxcbiAgICAgIG5ld0dyb3VwRGVsYXk6IDUwMCxcbiAgICB9XG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuZG86ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgIHJldHVybiB1bmRvKHN0YXRlLCBkaXNwYXRjaClcbiAgICAgIH0sXG4gICAgICByZWRvOiAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICByZXR1cm4gcmVkbyhzdGF0ZSwgZGlzcGF0Y2gpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGhpc3RvcnkodGhpcy5vcHRpb25zKSxcbiAgICBdXG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2Qteic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnVuZG8oKSxcbiAgICAgICdTaGlmdC1Nb2Qteic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnJlZG8oKSxcbiAgICAgICdNb2QteSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnJlZG8oKSxcblxuICAgICAgLy8gUnVzc2lhbiBrZXlib2FyZCBsYXlvdXRzXG4gICAgICAnTW9kLdGPJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudW5kbygpLFxuICAgICAgJ1NoaWZ0LU1vZC3Rjyc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnJlZG8oKSxcbiAgICB9XG4gIH0sXG59KVxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSwgbm9kZUlucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IE5vZGVTZWxlY3Rpb24sIFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEhvcml6b250YWxSdWxlT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBob3Jpem9udGFsUnVsZToge1xuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYSBob3Jpem9udGFsIHJ1bGVcbiAgICAgICAqL1xuICAgICAgc2V0SG9yaXpvbnRhbFJ1bGU6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEhvcml6b250YWxSdWxlID0gTm9kZS5jcmVhdGU8SG9yaXpvbnRhbFJ1bGVPcHRpb25zPih7XG4gIG5hbWU6ICdob3Jpem9udGFsUnVsZScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBncm91cDogJ2Jsb2NrJyxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFt7IHRhZzogJ2hyJyB9XVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnaHInLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyldXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEhvcml6b250YWxSdWxlOlxuICAgICAgICAoKSA9PiAoeyBjaGFpbiwgc3RhdGUgfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgJHRvOiAkb3JpZ2luVG8gfSA9IHN0YXRlLnNlbGVjdGlvblxuXG4gICAgICAgICAgY29uc3QgY3VycmVudENoYWluID0gY2hhaW4oKVxuXG4gICAgICAgICAgaWYgKCRvcmlnaW5Uby5wYXJlbnRPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnRDaGFpbi5pbnNlcnRDb250ZW50QXQoTWF0aC5tYXgoJG9yaWdpblRvLnBvcyAtIDIsIDApLCB7IHR5cGU6IHRoaXMubmFtZSB9KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50Q2hhaW4uaW5zZXJ0Q29udGVudCh7IHR5cGU6IHRoaXMubmFtZSB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjdXJyZW50Q2hhaW5cbiAgICAgICAgICAgICAgLy8gc2V0IGN1cnNvciBhZnRlciBob3Jpem9udGFsIHJ1bGVcbiAgICAgICAgICAgICAgLmNvbW1hbmQoKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHsgJHRvIH0gPSB0ci5zZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc0FmdGVyID0gJHRvLmVuZCgpXG5cbiAgICAgICAgICAgICAgICAgIGlmICgkdG8ubm9kZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkdG8ubm9kZUFmdGVyLmlzVGV4dGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJHRvLnBvcyArIDEpKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCR0by5ub2RlQWZ0ZXIuaXNCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICR0by5wb3MpKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICR0by5wb3MpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgbm9kZSBhZnRlciBob3Jpem9udGFsIHJ1bGUgaWYgaXTigJlzIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSAkdG8ucGFyZW50LnR5cGUuY29udGVudE1hdGNoLmRlZmF1bHRUeXBlPy5jcmVhdGUoKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHIuaW5zZXJ0KHBvc0FmdGVyLCBub2RlKVxuICAgICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHBvc0FmdGVyICsgMSkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5ydW4oKVxuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbm9kZUlucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IC9eKD86LS0tfOKAlC18X19fXFxzfFxcKlxcKlxcKlxccykkLyxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQge1xuICBNYXJrLFxuICBtYXJrSW5wdXRSdWxlLFxuICBtYXJrUGFzdGVSdWxlLFxuICBtZXJnZUF0dHJpYnV0ZXMsXG59IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBJdGFsaWNPcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBpdGFsaWM6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGFuIGl0YWxpYyBtYXJrXG4gICAgICAgKi9cbiAgICAgIHNldEl0YWxpYzogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGFuIGl0YWxpYyBtYXJrXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUl0YWxpYzogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVW5zZXQgYW4gaXRhbGljIG1hcmtcbiAgICAgICAqL1xuICAgICAgdW5zZXRJdGFsaWM6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzdGFySW5wdXRSZWdleCA9IC8oPzpefFxccykoKD86XFwqKSgoPzpbXipdKykpKD86XFwqKSkkL1xuZXhwb3J0IGNvbnN0IHN0YXJQYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKSgoPzpcXCopKCg/OlteKl0rKSkoPzpcXCopKS9nXG5leHBvcnQgY29uc3QgdW5kZXJzY29yZUlucHV0UmVnZXggPSAvKD86XnxcXHMpKCg/Ol8pKCg/OlteX10rKSkoPzpfKSkkL1xuZXhwb3J0IGNvbnN0IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKSgoPzpfKSgoPzpbXl9dKykpKD86XykpL2dcblxuZXhwb3J0IGNvbnN0IEl0YWxpYyA9IE1hcmsuY3JlYXRlPEl0YWxpY09wdGlvbnM+KHtcbiAgbmFtZTogJ2l0YWxpYycsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnZW0nLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnaScsXG4gICAgICAgIGdldEF0dHJzOiBub2RlID0+IChub2RlIGFzIEhUTUxFbGVtZW50KS5zdHlsZS5mb250U3R5bGUgIT09ICdub3JtYWwnICYmIG51bGwsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogJ2ZvbnQtc3R5bGU9aXRhbGljJyxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnZW0nLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEl0YWxpYzogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdG9nZ2xlSXRhbGljOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgICB1bnNldEl0YWxpYzogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLWknOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVJdGFsaWMoKSxcbiAgICAgICdNb2QtSSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUl0YWxpYygpLFxuICAgIH1cbiAgfSxcblxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogc3RhcklucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IHVuZGVyc2NvcmVJbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG5cbiAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IHN0YXJQYXN0ZVJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiB1bmRlcnNjb3JlUGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdEl0ZW1PcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIGJ1bGxldExpc3RUeXBlTmFtZTogc3RyaW5nXG4gIG9yZGVyZWRMaXN0VHlwZU5hbWU6IHN0cmluZ1xufVxuXG5leHBvcnQgY29uc3QgTGlzdEl0ZW0gPSBOb2RlLmNyZWF0ZTxMaXN0SXRlbU9wdGlvbnM+KHtcbiAgbmFtZTogJ2xpc3RJdGVtJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICBidWxsZXRMaXN0VHlwZU5hbWU6ICdidWxsZXRMaXN0JyxcbiAgICAgIG9yZGVyZWRMaXN0VHlwZU5hbWU6ICdvcmRlcmVkTGlzdCcsXG4gICAgfVxuICB9LFxuXG4gIGNvbnRlbnQ6ICdwYXJhZ3JhcGggYmxvY2sqJyxcblxuICBkZWZpbmluZzogdHJ1ZSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnbGknLFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydsaScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgRW50ZXI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNwbGl0TGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgIFRhYjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2lua0xpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICAnU2hpZnQtVGFiJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMubGlmdExpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgfVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdEl0ZW1PcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIGJ1bGxldExpc3RUeXBlTmFtZTogc3RyaW5nXG4gIG9yZGVyZWRMaXN0VHlwZU5hbWU6IHN0cmluZ1xufVxuXG5leHBvcnQgY29uc3QgTGlzdEl0ZW0gPSBOb2RlLmNyZWF0ZTxMaXN0SXRlbU9wdGlvbnM+KHtcbiAgbmFtZTogJ2xpc3RJdGVtJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICBidWxsZXRMaXN0VHlwZU5hbWU6ICdidWxsZXRMaXN0JyxcbiAgICAgIG9yZGVyZWRMaXN0VHlwZU5hbWU6ICdvcmRlcmVkTGlzdCcsXG4gICAgfVxuICB9LFxuXG4gIGNvbnRlbnQ6ICdwYXJhZ3JhcGggYmxvY2sqJyxcblxuICBkZWZpbmluZzogdHJ1ZSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnbGknLFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydsaScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgRW50ZXI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNwbGl0TGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgIFRhYjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2lua0xpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICAnU2hpZnQtVGFiJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMubGlmdExpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgfVxuICB9LFxufSlcbiIsICJpbXBvcnQge1xuICBnZXRNYXJrQXR0cmlidXRlcyxcbiAgTWFyayxcbiAgbWVyZ2VBdHRyaWJ1dGVzLFxufSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dFN0eWxlT3B0aW9ucyB7XG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdGV4dFN0eWxlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBzcGFucyB3aXRob3V0IGlubGluZSBzdHlsZSBhdHRyaWJ1dGVzLlxuICAgICAgICovXG4gICAgICByZW1vdmVFbXB0eVRleHRTdHlsZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFRleHRTdHlsZSA9IE1hcmsuY3JlYXRlPFRleHRTdHlsZU9wdGlvbnM+KHtcbiAgbmFtZTogJ3RleHRTdHlsZScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnc3BhbicsXG4gICAgICAgIGdldEF0dHJzOiBlbGVtZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBoYXNTdHlsZXMgPSAoZWxlbWVudCBhcyBIVE1MRWxlbWVudCkuaGFzQXR0cmlidXRlKCdzdHlsZScpXG5cbiAgICAgICAgICBpZiAoIWhhc1N0eWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHt9XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ3NwYW4nLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbW92ZUVtcHR5VGV4dFN0eWxlOiAoKSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHRoaXMudHlwZSlcbiAgICAgICAgY29uc3QgaGFzU3R5bGVzID0gT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykuc29tZSgoWywgdmFsdWVdKSA9PiAhIXZhbHVlKVxuXG4gICAgICAgIGlmIChoYXNTdHlsZXMpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxufSlcbiIsICJpbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUsIHdyYXBwaW5nSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5pbXBvcnQgTGlzdEl0ZW0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9uLWxpc3QtaXRlbS9zcmMvaW5kZXguanMnXG5pbXBvcnQgVGV4dFN0eWxlIGZyb20gJy4uLy4uL2V4dGVuc2lvbi10ZXh0LXN0eWxlL3NyYy9pbmRleC5qcydcblxuZXhwb3J0IGludGVyZmFjZSBPcmRlcmVkTGlzdE9wdGlvbnMge1xuICBpdGVtVHlwZU5hbWU6IHN0cmluZyxcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIGtlZXBNYXJrczogYm9vbGVhbixcbiAga2VlcEF0dHJpYnV0ZXM6IGJvb2xlYW4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBvcmRlcmVkTGlzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYW4gb3JkZXJlZCBsaXN0XG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZU9yZGVyZWRMaXN0OiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgaW5wdXRSZWdleCA9IC9eKFxcZCspXFwuXFxzJC9cblxuZXhwb3J0IGNvbnN0IE9yZGVyZWRMaXN0ID0gTm9kZS5jcmVhdGU8T3JkZXJlZExpc3RPcHRpb25zPih7XG4gIG5hbWU6ICdvcmRlcmVkTGlzdCcsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbVR5cGVOYW1lOiAnbGlzdEl0ZW0nLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAga2VlcE1hcmtzOiBmYWxzZSxcbiAgICAgIGtlZXBBdHRyaWJ1dGVzOiBmYWxzZSxcbiAgICB9XG4gIH0sXG5cbiAgZ3JvdXA6ICdibG9jayBsaXN0JyxcblxuICBjb250ZW50KCkge1xuICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lfStgXG4gIH0sXG5cbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3N0YXJ0JylcbiAgICAgICAgICAgID8gcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0YXJ0JykgfHwgJycsIDEwKVxuICAgICAgICAgICAgOiAxXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnb2wnLFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICBjb25zdCB7IHN0YXJ0LCAuLi5hdHRyaWJ1dGVzV2l0aG91dFN0YXJ0IH0gPSBIVE1MQXR0cmlidXRlc1xuXG4gICAgcmV0dXJuIHN0YXJ0ID09PSAxXG4gICAgICA/IFsnb2wnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzV2l0aG91dFN0YXJ0KSwgMF1cbiAgICAgIDogWydvbCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9nZ2xlT3JkZXJlZExpc3Q6ICgpID0+ICh7IGNvbW1hbmRzLCBjaGFpbiB9KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICByZXR1cm4gY2hhaW4oKS50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcykudXBkYXRlQXR0cmlidXRlcyhMaXN0SXRlbS5uYW1lLCB0aGlzLmVkaXRvci5nZXRBdHRyaWJ1dGVzKFRleHRTdHlsZS5uYW1lKSkucnVuKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTGlzdCh0aGlzLm5hbWUsIHRoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWUsIHRoaXMub3B0aW9ucy5rZWVwTWFya3MpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC1TaGlmdC03JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlT3JkZXJlZExpc3QoKSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICBsZXQgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+ICh7IHN0YXJ0OiArbWF0Y2hbMV0gfSksXG4gICAgICBqb2luUHJlZGljYXRlOiAobWF0Y2gsIG5vZGUpID0+IG5vZGUuY2hpbGRDb3VudCArIG5vZGUuYXR0cnMuc3RhcnQgPT09ICttYXRjaFsxXSxcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwTWFya3MgfHwgdGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAga2VlcE1hcmtzOiB0aGlzLm9wdGlvbnMua2VlcE1hcmtzLFxuICAgICAgICBrZWVwQXR0cmlidXRlczogdGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzLFxuICAgICAgICBnZXRBdHRyaWJ1dGVzOiBtYXRjaCA9PiAoeyBzdGFydDogK21hdGNoWzFdLCAuLi50aGlzLmVkaXRvci5nZXRBdHRyaWJ1dGVzKFRleHRTdHlsZS5uYW1lKSB9KSxcbiAgICAgICAgam9pblByZWRpY2F0ZTogKG1hdGNoLCBub2RlKSA9PiBub2RlLmNoaWxkQ291bnQgKyBub2RlLmF0dHJzLnN0YXJ0ID09PSArbWF0Y2hbMV0sXG4gICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgaW5wdXRSdWxlLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFBhcmFncmFwaE9wdGlvbnMge1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHBhcmFncmFwaDoge1xuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBwYXJhZ3JhcGhcbiAgICAgICAqL1xuICAgICAgc2V0UGFyYWdyYXBoOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgUGFyYWdyYXBoID0gTm9kZS5jcmVhdGU8UGFyYWdyYXBoT3B0aW9ucz4oe1xuICBuYW1lOiAncGFyYWdyYXBoJyxcblxuICBwcmlvcml0eTogMTAwMCxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIGdyb3VwOiAnYmxvY2snLFxuXG4gIGNvbnRlbnQ6ICdpbmxpbmUqJyxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHsgdGFnOiAncCcgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydwJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRQYXJhZ3JhcGg6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtQWx0LTAnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRQYXJhZ3JhcGgoKSxcbiAgICB9XG4gIH0sXG59KVxuIiwgImltcG9ydCB7XG4gIGlzTWFjT1MsXG4gIE1hcmssXG4gIG1hcmtJbnB1dFJ1bGUsXG4gIG1hcmtQYXN0ZVJ1bGUsXG4gIG1lcmdlQXR0cmlidXRlcyxcbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0cmlrZU9wdGlvbnMge1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHN0cmlrZToge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYSBzdHJpa2UgbWFya1xuICAgICAgICovXG4gICAgICBzZXRTdHJpa2U6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIHN0cmlrZSBtYXJrXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZVN0cmlrZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVW5zZXQgYSBzdHJpa2UgbWFya1xuICAgICAgICovXG4gICAgICB1bnNldFN0cmlrZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGlucHV0UmVnZXggPSAvKD86XnxcXHMpKCg/On5+KSgoPzpbXn5dKykpKD86fn4pKSQvXG5leHBvcnQgY29uc3QgcGFzdGVSZWdleCA9IC8oPzpefFxccykoKD86fn4pKCg/Oltefl0rKSkoPzp+fikpL2dcblxuZXhwb3J0IGNvbnN0IFN0cmlrZSA9IE1hcmsuY3JlYXRlPFN0cmlrZU9wdGlvbnM+KHtcbiAgbmFtZTogJ3N0cmlrZScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAncycsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0YWc6ICdkZWwnLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnc3RyaWtlJyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiAndGV4dC1kZWNvcmF0aW9uJyxcbiAgICAgICAgY29uc3VtaW5nOiBmYWxzZSxcbiAgICAgICAgZ2V0QXR0cnM6IHN0eWxlID0+ICgoc3R5bGUgYXMgc3RyaW5nKS5pbmNsdWRlcygnbGluZS10aHJvdWdoJykgPyB7fSA6IGZhbHNlKSxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsncycsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0U3RyaWtlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgICB0b2dnbGVTdHJpa2U6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHVuc2V0U3RyaWtlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgY29uc3Qgc2hvcnRjdXRzOiBSZWNvcmQ8c3RyaW5nLCAoKSA9PiBib29sZWFuPiA9IHt9XG5cbiAgICBpZiAoaXNNYWNPUygpKSB7XG4gICAgICBzaG9ydGN1dHNbJ01vZC1TaGlmdC1zJ10gPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVTdHJpa2UoKVxuICAgIH0gZWxzZSB7XG4gICAgICBzaG9ydGN1dHNbJ0N0cmwtU2hpZnQtcyddID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlU3RyaWtlKClcbiAgICB9XG5cbiAgICByZXR1cm4gc2hvcnRjdXRzXG4gIH0sXG5cbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcblxuICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogcGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgY29uc3QgVGV4dCA9IE5vZGUuY3JlYXRlKHtcbiAgbmFtZTogJ3RleHQnLFxuICBncm91cDogJ2lubGluZScsXG59KVxuIiwgImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IEJsb2NrcXVvdGUsIEJsb2NrcXVvdGVPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZSdcbmltcG9ydCB7IEJvbGQsIEJvbGRPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tYm9sZCdcbmltcG9ydCB7IEJ1bGxldExpc3QsIEJ1bGxldExpc3RPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tYnVsbGV0LWxpc3QnXG5pbXBvcnQgeyBDb2RlLCBDb2RlT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUnXG5pbXBvcnQgeyBDb2RlQmxvY2ssIENvZGVCbG9ja09wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1jb2RlLWJsb2NrJ1xuaW1wb3J0IHsgRG9jdW1lbnQgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1kb2N1bWVudCdcbmltcG9ydCB7IERyb3BjdXJzb3IsIERyb3BjdXJzb3JPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tZHJvcGN1cnNvcidcbmltcG9ydCB7IEdhcGN1cnNvciB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWdhcGN1cnNvcidcbmltcG9ydCB7IEhhcmRCcmVhaywgSGFyZEJyZWFrT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWhhcmQtYnJlYWsnXG5pbXBvcnQgeyBIZWFkaW5nLCBIZWFkaW5nT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWhlYWRpbmcnXG5pbXBvcnQgeyBIaXN0b3J5LCBIaXN0b3J5T3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWhpc3RvcnknXG5pbXBvcnQgeyBIb3Jpem9udGFsUnVsZSwgSG9yaXpvbnRhbFJ1bGVPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24taG9yaXpvbnRhbC1ydWxlJ1xuaW1wb3J0IHsgSXRhbGljLCBJdGFsaWNPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24taXRhbGljJ1xuaW1wb3J0IHsgTGlzdEl0ZW0sIExpc3RJdGVtT3B0aW9ucyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3QtaXRlbSdcbmltcG9ydCB7IE9yZGVyZWRMaXN0LCBPcmRlcmVkTGlzdE9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1vcmRlcmVkLWxpc3QnXG5pbXBvcnQgeyBQYXJhZ3JhcGgsIFBhcmFncmFwaE9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1wYXJhZ3JhcGgnXG5pbXBvcnQgeyBTdHJpa2UsIFN0cmlrZU9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1zdHJpa2UnXG5pbXBvcnQgeyBUZXh0IH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tdGV4dCdcblxuZXhwb3J0IGludGVyZmFjZSBTdGFydGVyS2l0T3B0aW9ucyB7XG4gIGJsb2NrcXVvdGU6IFBhcnRpYWw8QmxvY2txdW90ZU9wdGlvbnM+IHwgZmFsc2UsXG4gIGJvbGQ6IFBhcnRpYWw8Qm9sZE9wdGlvbnM+IHwgZmFsc2UsXG4gIGJ1bGxldExpc3Q6IFBhcnRpYWw8QnVsbGV0TGlzdE9wdGlvbnM+IHwgZmFsc2UsXG4gIGNvZGU6IFBhcnRpYWw8Q29kZU9wdGlvbnM+IHwgZmFsc2UsXG4gIGNvZGVCbG9jazogUGFydGlhbDxDb2RlQmxvY2tPcHRpb25zPiB8IGZhbHNlLFxuICBkb2N1bWVudDogZmFsc2UsXG4gIGRyb3BjdXJzb3I6IFBhcnRpYWw8RHJvcGN1cnNvck9wdGlvbnM+IHwgZmFsc2UsXG4gIGdhcGN1cnNvcjogZmFsc2UsXG4gIGhhcmRCcmVhazogUGFydGlhbDxIYXJkQnJlYWtPcHRpb25zPiB8IGZhbHNlLFxuICBoZWFkaW5nOiBQYXJ0aWFsPEhlYWRpbmdPcHRpb25zPiB8IGZhbHNlLFxuICBoaXN0b3J5OiBQYXJ0aWFsPEhpc3RvcnlPcHRpb25zPiB8IGZhbHNlLFxuICBob3Jpem9udGFsUnVsZTogUGFydGlhbDxIb3Jpem9udGFsUnVsZU9wdGlvbnM+IHwgZmFsc2UsXG4gIGl0YWxpYzogUGFydGlhbDxJdGFsaWNPcHRpb25zPiB8IGZhbHNlLFxuICBsaXN0SXRlbTogUGFydGlhbDxMaXN0SXRlbU9wdGlvbnM+IHwgZmFsc2UsXG4gIG9yZGVyZWRMaXN0OiBQYXJ0aWFsPE9yZGVyZWRMaXN0T3B0aW9ucz4gfCBmYWxzZSxcbiAgcGFyYWdyYXBoOiBQYXJ0aWFsPFBhcmFncmFwaE9wdGlvbnM+IHwgZmFsc2UsXG4gIHN0cmlrZTogUGFydGlhbDxTdHJpa2VPcHRpb25zPiB8IGZhbHNlLFxuICB0ZXh0OiBmYWxzZSxcbn1cblxuZXhwb3J0IGNvbnN0IFN0YXJ0ZXJLaXQgPSBFeHRlbnNpb24uY3JlYXRlPFN0YXJ0ZXJLaXRPcHRpb25zPih7XG4gIG5hbWU6ICdzdGFydGVyS2l0JyxcblxuICBhZGRFeHRlbnNpb25zKCkge1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBbXVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ibG9ja3F1b3RlICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEJsb2NrcXVvdGUuY29uZmlndXJlKHRoaXMub3B0aW9ucz8uYmxvY2txdW90ZSkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ib2xkICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEJvbGQuY29uZmlndXJlKHRoaXMub3B0aW9ucz8uYm9sZCkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5idWxsZXRMaXN0ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEJ1bGxldExpc3QuY29uZmlndXJlKHRoaXMub3B0aW9ucz8uYnVsbGV0TGlzdCkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb2RlICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKENvZGUuY29uZmlndXJlKHRoaXMub3B0aW9ucz8uY29kZSkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb2RlQmxvY2sgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goQ29kZUJsb2NrLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LmNvZGVCbG9jaykpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kb2N1bWVudCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChEb2N1bWVudC5jb25maWd1cmUodGhpcy5vcHRpb25zPy5kb2N1bWVudCkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kcm9wY3Vyc29yICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKERyb3BjdXJzb3IuY29uZmlndXJlKHRoaXMub3B0aW9ucz8uZHJvcGN1cnNvcikpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5nYXBjdXJzb3IgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goR2FwY3Vyc29yLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LmdhcGN1cnNvcikpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5oYXJkQnJlYWsgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goSGFyZEJyZWFrLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LmhhcmRCcmVhaykpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkaW5nICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhlYWRpbmcuY29uZmlndXJlKHRoaXMub3B0aW9ucz8uaGVhZGluZykpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5oaXN0b3J5ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhpc3RvcnkuY29uZmlndXJlKHRoaXMub3B0aW9ucz8uaGlzdG9yeSkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ob3Jpem9udGFsUnVsZSAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChIb3Jpem9udGFsUnVsZS5jb25maWd1cmUodGhpcy5vcHRpb25zPy5ob3Jpem9udGFsUnVsZSkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5pdGFsaWMgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goSXRhbGljLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/Lml0YWxpYykpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5saXN0SXRlbSAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChMaXN0SXRlbS5jb25maWd1cmUodGhpcy5vcHRpb25zPy5saXN0SXRlbSkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vcmRlcmVkTGlzdCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChPcmRlcmVkTGlzdC5jb25maWd1cmUodGhpcy5vcHRpb25zPy5vcmRlcmVkTGlzdCkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXJhZ3JhcGggIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goUGFyYWdyYXBoLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LnBhcmFncmFwaCkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdHJpa2UgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goU3RyaWtlLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnM/LnN0cmlrZSkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy50ZXh0ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKFRleHQuY29uZmlndXJlKHRoaXMub3B0aW9ucz8udGV4dCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvbnNcbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHtFeHRlbnNpb259IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGRlZmF1bHQgRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ3N0YXRlUGF0aEV4dGVuc2lvbicsXG5cbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdGVQYXRoOiBudWxsLFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZFN0b3JhZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0ZVBhdGg6IG51bGxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkNyZWF0ZSgpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnN0YXRlUGF0aCA9IHRoaXMub3B0aW9ucy5zdGF0ZVBhdGhcbiAgICB9XG59KVxuIiwgIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTm9kZVZpZXdXcmFwcGVyIH0gZnJvbSAnc3ZlbHRlLXRpcHRhcCdcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCBEcmFnSGFuZGxlIGZyb20gJy4vRHJhZ0hhbmRsZS5zdmVsdGUnXG4gICAgaW1wb3J0IEJsb2NrQWN0aW9ucyBmcm9tICcuL0Jsb2NrQWN0aW9ucy5zdmVsdGUnXG4gICAgaW1wb3J0IHRpcHB5IGZyb20gJ3RpcHB5LmpzJ1xuICAgIGltcG9ydCBPcHRpb25zTWVudSBmcm9tICcuLi9jb21wb25lbnRzL09wdGlvbnNNZW51LnN2ZWx0ZSdcblxuICAgIGV4cG9ydCBsZXQgZWRpdG9yO1xuICAgIGV4cG9ydCBsZXQgbm9kZTtcbiAgICBleHBvcnQgbGV0IHNlbGVjdGVkID0gZmFsc2U7XG4gICAgZXhwb3J0IGxldCB1cGRhdGVBdHRyaWJ1dGVzO1xuXG4gICAgbGV0IHZpZXcgPSBudWxsO1xuICAgICQ6IHdyYXBwZXIgPSBudWxsO1xuXG4gICAgbGV0IGNvbXBvbmVudDtcbiAgICBsZXQgcG9wdXBJbnN0YW5jZTtcblxuICAgIGNvbnN0IGhhbmRsZU1lbnVPcGVuID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIC8vIEluaXppYWxpenphIHByaW1hIGlsIGNvbXBvbmVudGUgc2VuemEgcG9wdXBJbnN0YW5jZVxuICAgICAgICBjb21wb25lbnQgPSBuZXcgT3B0aW9uc01lbnUoe1xuICAgICAgICAgICAgdGFyZ2V0OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgLy8gQ3JlYSB1biBlbGVtZW50byBkaXYgcGVyIG1vbnRhcmUgaWwgY29tcG9uZW50ZSBTdmVsdGVcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgb25DbG9zZTogKCkgPT4gY2xvc2VPcHRpb25zKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcG9wdXBJbnN0YW5jZSA9IHRpcHB5KCdib2R5Jywge1xuICAgICAgICAgICAgY29udGVudDogY29tcG9uZW50LiQkLnJvb3QsXG4gICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiAoKSA9PiBjbGllbnRSZWN0LFxuICAgICAgICAgICAgYWxsb3dIVE1MOiB0cnVlLFxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICB0cmlnZ2VyOiAnbWFudWFsJyxcbiAgICAgICAgICAgIHBsYWNlbWVudDogJ2xlZnQnLFxuICAgICAgICAgICAgc2hvd09uQ3JlYXRlOiB0cnVlLFxuICAgICAgICAgICAgaGlkZU9uQ2xpY2s6IHRydWUsXG4gICAgICAgICAgICB0aGVtZTogJ3NjcmliYmxlLW9wdGlvbnMnLFxuICAgICAgICAgICAgYXJyb3c6IHRydWUsXG4gICAgICAgICAgICB6SW5kZXg6IDk5OTksXG4gICAgICAgICAgICBvbkhpZGRlbihpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGNsb3NlT3B0aW9ucyA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb3B1cEluc3RhbmNlKSkge1xuICAgICAgICAgICAgcG9wdXBJbnN0YW5jZS5mb3JFYWNoKGluc3RhbmNlID0+IGluc3RhbmNlLmhpZGUoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3B1cEluc3RhbmNlLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICQ6IGdldFZpZXcgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzY3JpYmJsZS1yZW5kZXJlcicpLmdldEF0dHJpYnV0ZSgnd2lyZTppZCcpXG4gICAgICAgIGNvbnNvbGUubG9nKG5vZGUuYXR0cnMudmFsdWVzKTtcbiAgICAgICAgd2luZG93LkxpdmV3aXJlXG4gICAgICAgICAgICAuZmluZChjb21wb25lbnQpXG4gICAgICAgICAgICAuY2FsbCgnZ2V0VmlldycsIG5vZGUuYXR0cnMuaWRlbnRpZmllciwgbm9kZS5hdHRycy52YWx1ZXMpXG4gICAgICAgICAgICAudGhlbihlID0+IHtcbiAgICAgICAgICAgICAgICB2aWV3ID0gZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuYW1lID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdpZCcpLnJlcGxhY2UoJ2RhdGEuJywgJycpXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUF0dHJpYnV0ZXMoeyB2YWx1ZXM6IHsuLi5ub2RlLmF0dHJzLnZhbHVlcywgW25hbWVdOiB2YWx1ZSB9IH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgfVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGdldFZpZXcoKVxuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVkQmxvY2snLCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGUuZGV0YWlsLmlkZW50aWZpZXIgPT09IG5vZGUuYXR0cnMuaWRlbnRpZmllclxuICAgICAgICAgICAgICAgICYmIGUuZGV0YWlsLnN0YXRlUGF0aCA9PT0gZWRpdG9yLnN0b3JhZ2U/LnN0YXRlUGF0aEV4dGVuc2lvbi5zdGF0ZVBhdGhcbiAgICAgICAgICAgICAgICAmJiBlLmRldGFpbC5ibG9ja0lkID09PSBub2RlLmF0dHJzLmlkXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVBdHRyaWJ1dGVzKHsgdmFsdWVzOiBlLmRldGFpbC52YWx1ZXMgfSlcbiAgICAgICAgICAgICAgICBnZXRWaWV3KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KVxuPC9zY3JpcHQ+XG5cbjxOb2RlVmlld1dyYXBwZXI+XG4gICAgPGRpdiBjbGFzcz1cInNjcmliYmxlLWJsb2NrXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzY3JpYmJsZS1ibG9jay1jb250ZW50IHtzZWxlY3RlZCA/ICdQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGUnIDogJyd9XCIgYmluZDp0aGlzPXt3cmFwcGVyfT5cbiAgICAgICAgICAgIHsjaWYgdmlld31cbiAgICAgICAgICAgICAgICB7QGh0bWwgdmlld31cbiAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibG9hZGluZy1ibG9ja1wiPlxuICAgICAgICAgICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgY2xhc3M9XCJvcGFjaXR5LTI1XCIgY3g9XCIxMlwiIGN5PVwiMTJcIiByPVwiMTBcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCI0XCI+PC9jaXJjbGU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBjbGFzcz1cIm9wYWNpdHktNzVcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZD1cIk00IDEyYTggOCAwIDAxOC04VjBDNS4zNzMgMCAwIDUuMzczIDAgMTJoNHptMiA1LjI5MUE3Ljk2MiA3Ljk2MiAwIDAxNCAxMkgwYzAgMy4wNDIgMS4xMzUgNS44MjQgMyA3LjkzOGwzLTIuNjQ3elwiPjwvcGF0aD5cbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPEJsb2NrQWN0aW9ucz5cbiAgICAgICAgICAgIDxEcmFnSGFuZGxlIHtoYW5kbGVNZW51T3Blbn0gLz5cbiAgICAgICAgPC9CbG9ja0FjdGlvbnM+XG4gICAgPC9kaXY+XG48L05vZGVWaWV3V3JhcHBlcj5cbiIsICJpbXBvcnQgeyBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHsgU3ZlbHRlTm9kZVZpZXdSZW5kZXJlciB9IGZyb20gJ3N2ZWx0ZS10aXB0YXAnXG5pbXBvcnQgU2NyaWJibGVCbG9ja1ZpZXcgZnJvbSBcIi4uL2NvbXBvbmVudHMvU2NyaWJibGVCbG9jay5zdmVsdGVcIlxuaW1wb3J0IHsgdXVpZCwgb3BlblNjcmliYmxlTW9kYWwgfSBmcm9tIFwiLi4vdXRpbHMuanNcIlxuXG5leHBvcnQgZGVmYXVsdCBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ3NjcmliYmxlQmxvY2snLFxuICAgIGlzQmxvY2s6IHRydWUsXG4gICAgaW5saW5lOiBmYWxzZSxcbiAgICBncm91cDogJ2Jsb2NrJyxcbiAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgZGVmaW5pbmc6IHRydWUsXG4gICAgc2VsZWN0YWJsZTogdHJ1ZSxcblxuICAgIGFkZFN0b3JhZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0ZVBhdGg6IG51bGxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICdibG9jaydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZGVudGlmaWVyOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnc2NyaWJibGUtYmxvY2snLFxuICAgICAgICAgICAgICAgIGdldEF0dHJzOiAoZG9tKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRvbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWydzY3JpYmJsZS1ibG9jaycsIEpTT04uc3RyaW5naWZ5KEhUTUxBdHRyaWJ1dGVzKV07XG4gICAgfSxcblxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0U2NyaWJibGVCbG9jazogKG9wdGlvbnMpID0+ICh7IHRyLCBzdGF0ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgb3BlblNjcmliYmxlTW9kYWwob3B0aW9ucy5pZGVudGlmaWVyLCB7IC4uLm9wdGlvbnMgfSlcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpbnNlcnRTY3JpYmJsZUJsb2NrOiAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoeyB0ciwgZGlzcGF0Y2gsIGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnR5cGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLntpZDogdXVpZCgpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5yZXBsYWNlUmFuZ2VXaXRoKHNlbGVjdGlvbi5mcm9tIC0gc2VsZWN0aW9uLiRhbmNob3IucGFyZW50T2Zmc2V0LCBzZWxlY3Rpb24udG8sIG5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kcy5zZXROb2RlU2VsZWN0aW9uKHRyLm1hcHBpbmcubWFwKHRyLnN0ZXBzW3RyLnN0ZXBzLmxlbmd0aCAtIDFdLmZyb20pLCAxKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZE5vZGVWaWV3KCkge1xuICAgICAgICByZXR1cm4gU3ZlbHRlTm9kZVZpZXdSZW5kZXJlcihTY3JpYmJsZUJsb2NrVmlldylcbiAgICB9XG59KVxuIiwgIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb3BlblNjcmliYmxlTW9kYWwsIGNvbW1hbmRSdW5uZXIsIHJlcGxhY2VTdGF0ZVBhdGggfSBmcm9tICcuLi91dGlscy5qcydcblxuICAgIGV4cG9ydCBsZXQgaXRlbXNcbiAgICBleHBvcnQgbGV0IGVkaXRvclxuICAgIGV4cG9ydCBsZXQgcmFuZ2VcbiAgICBleHBvcnQgbGV0IHN0YXRlUGF0aFxuXG4gICAgbGV0IHNlbGVjdGVkSW5kZXggPSAwXG4gICAgbGV0IGRyb3Bkb3duXG4gICAgbGV0IGdyb3Vwc1xuXG4gICAgY29uc3QgZ2V0R3JvdXBzID0gYXJyYXkgPT4ge1xuICAgICAgICBsZXQgbWFwID0gYXJyYXkubWFwKChlLCBpKSA9PiB7XG4gICAgICAgICAgICBlLmluZGV4ID0gaVxuICAgICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgfSlcblxuICAgICAgICBncm91cHMgPSBtYXAucmVkdWNlKGZ1bmN0aW9uKHIsIGEpIHtcbiAgICAgICAgICAgIHJbYS5ncm91cF0gPSByW2EuZ3JvdXBdIHx8IFtdXG4gICAgICAgICAgICByW2EuZ3JvdXBdLnB1c2goYSlcbiAgICAgICAgICAgIHJldHVybiByXG4gICAgICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpXG4gICAgfVxuXG4gICAgJDogZ2V0R3JvdXBzKGl0ZW1zKVxuXG4gICAgZXhwb3J0IGNvbnN0IHJlc2V0SW5kZXggPSAoKSA9PiBzZWxlY3RlZEluZGV4ID0gMFxuXG4gICAgZXhwb3J0IGNvbnN0IG9uS2V5RG93biA9ICh7IGV2ZW50IH0pID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0Fycm93VXAnKSB7XG4gICAgICAgICAgICB1cEhhbmRsZXIoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5rZXkgPT09ICdBcnJvd0Rvd24nKSB7XG4gICAgICAgICAgICBkb3duSGFuZGxlcigpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgZW50ZXJIYW5kbGVyKClcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCB1cEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHNlbGVjdGVkSW5kZXggPSAoKHNlbGVjdGVkSW5kZXggKyBpdGVtcy5sZW5ndGgpIC0gMSkgJSBpdGVtcy5sZW5ndGhcbiAgICAgICAgc2Nyb2xsVG9TZWxlY3QoKVxuICAgIH1cblxuICAgIGNvbnN0IGRvd25IYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBzZWxlY3RlZEluZGV4ID0gKHNlbGVjdGVkSW5kZXggKyAxKSAlIGl0ZW1zLmxlbmd0aFxuICAgICAgICBzY3JvbGxUb1NlbGVjdCgpXG4gICAgfVxuXG4gICAgY29uc3QgZW50ZXJIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBzZWxlY3RJdGVtKHNlbGVjdGVkSW5kZXgpXG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0SXRlbSA9IGluZGV4ID0+IHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2luZGV4XVxuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBlZGl0b3IuY29tbWFuZHMuZGVsZXRlUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgc3dpdGNoIChpdGVtLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tYW5kJzpcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZFJ1bm5lcihlZGl0b3IsIGl0ZW0uY29tbWFuZHMpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAnZXZlbnQnOlxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlU3RhdGVQYXRoKGl0ZW0uZXZlbnQuZGF0YSwgc3RhdGVQYXRoKVxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuTGl2ZXdpcmUuZGlzcGF0Y2goaXRlbS5ldmVudC5uYW1lLCBpdGVtLmV2ZW50LmRhdGEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIGNhc2UgJ21vZGFsJzpcbiAgICAgICAgICAgICAgICAgICAgb3BlblNjcmliYmxlTW9kYWwoaXRlbS5vcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZVBhdGg6IHN0YXRlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGl0ZW0uaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGVkaXRvci5nZXRBdHRyaWJ1dGVzKGl0ZW0uZXh0ZW5zaW9uKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlICdzdGF0aWMnOlxuICAgICAgICAgICAgICAgICAgICBlZGl0b3IuY2hhaW4oKS5pbnNlcnRTY3JpYmJsZUJsb2NrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGl0ZW0uaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGl0ZW0udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlUGF0aDogc3RhdGVQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tJZDogaXRlbS5ibG9ja0lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiB7fVxuICAgICAgICAgICAgICAgICAgICB9KS5mb2N1cygpLnJ1bigpO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5jb21tYW5kcy5zZXRTY3JpYmJsZUJsb2NrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGl0ZW0uaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlUGF0aDogc3RhdGVQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tJZDogaXRlbS5ibG9ja0lkLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2Nyb2xsVG9TZWxlY3QgPSAoKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZHJvcGRvd24ucXVlcnlTZWxlY3RvcignLmFjdGl2ZS1vcHRpb24nKS5zY3JvbGxJbnRvVmlldyh7XG4gICAgICAgICAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnLFxuICAgICAgICAgICAgICAgIGJsb2NrOiAnbmVhcmVzdCcsXG4gICAgICAgICAgICAgICAgaW5saW5lOiAnZW5kJyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIDApXG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxkaXZcbiAgICBjbGFzcz1cInNjcmliYmxlLXN1Z2dlc3Rpb25zXCJcbiAgICBiaW5kOnRoaXM9e2Ryb3Bkb3dufVxuPlxuICAgIDxkaXYgY2xhc3M9XCJncm91cFwiPlxuICAgICAgICB7I2lmIGl0ZW1zLmxlbmd0aH1cbiAgICAgICAgICAgIHsjZWFjaCBPYmplY3Qua2V5cyhncm91cHMpIGFzIGdyb3VwfVxuICAgICAgICAgICAgICAgIHsjaWYgZ3JvdXAgfVxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZ3JvdXAtdGl0bGVcIj57Z3JvdXB9PC9kaXY+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICB7I2VhY2ggZ3JvdXBzW2dyb3VwXSBhcyBpdGVtfVxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBvbjpjbGljaz17KCkgPT4gc2VsZWN0SXRlbShpdGVtLmluZGV4KX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiIHsgaXRlbS5pbmRleCA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPyAnYWN0aXZlLW9wdGlvbicgOiAnJyB9XCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge0BodG1sIGl0ZW0uaWNvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGV4dFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibGFiZWxcIj57aXRlbS5sYWJlbH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBpdGVtLmRlc2NyaXB0aW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZGVzY3JpcHRpb25cIj57aXRlbS5kZXNjcmlwdGlvbn08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICB7L2lmfVxuXG4gICAgICAgIHsjaWYgIWl0ZW1zLmxlbmd0aH1cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJuby1ibG9ja3NcIj5ObyBibG9ja3MgZm91bmQ8L2Rpdj5cbiAgICAgICAgey9pZn1cbiAgICA8L2Rpdj5cbjwvZGl2PlxuIiwgImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCBTdWdnZXN0aW9uIGZyb20gJ0B0aXB0YXAvc3VnZ2VzdGlvbidcbmltcG9ydCBDb21tYW5kc0xpc3QgZnJvbSAnLi4vY29tcG9uZW50cy9Db21tYW5kc0xpc3Quc3ZlbHRlJ1xuaW1wb3J0IHRpcHB5IGZyb20gJ3RpcHB5LmpzJ1xuaW1wb3J0IHsgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGRlZmF1bHQgRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ3NsYXNoRXh0ZW5zaW9uJyxcblxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b29sczoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFtdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXRlUGF0aDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgU3VnZ2VzdGlvbih7XG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICBjaGFyOiAnLycsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogKHsgZWRpdG9yLCByYW5nZSwgcHJvcHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5jb21tYW5kKHsgZWRpdG9yLCByYW5nZSB9KVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RhcnRPZkxpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgcGx1Z2luS2V5OiBuZXcgUGx1Z2luS2V5KCdzbGFzaEV4dGVuc2lvbicpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiAoeyBxdWVyeSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudG9vbHMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5sYWJlbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5LnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVuZGVyOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvcHVwXG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU3RhcnQ6IHByb3BzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BzLmNsaWVudFJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBuZXcgQ29tbWFuZHNMaXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHByb3BzLml0ZW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiBwcm9wcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogcHJvcHMucmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZVBhdGg6IHRoaXMub3B0aW9ucy5zdGF0ZVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wdXAgPSB0aXBweSgnYm9keScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogcHJvcHMuY2xpZW50UmVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kVG86ICgpID0+IGRvY3VtZW50LmJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbXBvbmVudC4kJC5yb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93T25DcmVhdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyOiAnbWFudWFsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tLXN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWU6ICdzY3JpYmJsZS1wYW5lbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycm93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgekluZGV4OiA0MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uVXBkYXRlKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LiRzZXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogcHJvcHMuaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcjogcHJvcHMuZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogcHJvcHMucmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5yZXNldEluZGV4KClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvcHMuY2xpZW50UmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3B1cFswXS5zZXRQcm9wcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IHByb3BzLmNsaWVudFJlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uS2V5RG93bihwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcy5ldmVudC5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVwWzBdLmhpZGUoKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5vbktleURvd24ocHJvcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25FeGl0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVwWzBdLmRlc3Ryb3koKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC4kZGVzdHJveSgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXVxuICAgIH1cbn0pXG4iLCAiaW1wb3J0IHsgTWFyaywgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFN1YnNjcmlwdEV4dGVuc2lvbk9wdGlvbnMge1xuICBIVE1MQXR0cmlidXRlczogT2JqZWN0LFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc3Vic2NyaXB0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBhIHN1YnNjcmlwdCBtYXJrXG4gICAgICAgKi9cbiAgICAgIHNldFN1YnNjcmlwdDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGEgc3Vic2NyaXB0IG1hcmtcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlU3Vic2NyaXB0OiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgICAgLyoqXG4gICAgICAgKiBVbnNldCBhIHN1YnNjcmlwdCBtYXJrXG4gICAgICAgKi9cbiAgICAgIHVuc2V0U3Vic2NyaXB0OiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgU3Vic2NyaXB0ID0gTWFyay5jcmVhdGU8U3Vic2NyaXB0RXh0ZW5zaW9uT3B0aW9ucz4oe1xuICBuYW1lOiAnc3Vic2NyaXB0JyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdzdWInLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6ICd2ZXJ0aWNhbC1hbGlnbicsXG4gICAgICAgIGdldEF0dHJzKHZhbHVlKSB7XG4gICAgICAgICAgLy8gRG9u4oCZdCBtYXRjaCB0aGlzIHJ1bGUgaWYgdGhlIHZlcnRpY2FsIGFsaWduIGlzbuKAmXQgc3ViLlxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJ3N1YicpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIGl0IGZhbGxzIHRocm91Z2ggd2XigJlsbCBtYXRjaCwgYW5kIHRoaXMgbWFyayB3aWxsIGJlIGFwcGxpZWQuXG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnc3ViJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRTdWJzY3JpcHQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZVN1YnNjcmlwdDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdW5zZXRTdWJzY3JpcHQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC0sJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlU3Vic2NyaXB0KCksXG4gICAgfVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBNYXJrLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU3VwZXJzY3JpcHRFeHRlbnNpb25PcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IE9iamVjdCxcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHN1cGVyc2NyaXB0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBhIHN1cGVyc2NyaXB0IG1hcmtcbiAgICAgICAqL1xuICAgICAgc2V0U3VwZXJzY3JpcHQ6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIHN1cGVyc2NyaXB0IG1hcmtcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlU3VwZXJzY3JpcHQ6ICgpID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGEgc3VwZXJzY3JpcHQgbWFya1xuICAgICAgICovXG4gICAgICB1bnNldFN1cGVyc2NyaXB0OiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgU3VwZXJzY3JpcHQgPSBNYXJrLmNyZWF0ZTxTdXBlcnNjcmlwdEV4dGVuc2lvbk9wdGlvbnM+KHtcbiAgbmFtZTogJ3N1cGVyc2NyaXB0JyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdzdXAnLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6ICd2ZXJ0aWNhbC1hbGlnbicsXG4gICAgICAgIGdldEF0dHJzKHZhbHVlKSB7XG4gICAgICAgICAgLy8gRG9u4oCZdCBtYXRjaCB0aGlzIHJ1bGUgaWYgdGhlIHZlcnRpY2FsIGFsaWduIGlzbuKAmXQgc3VwZXIuXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSAnc3VwZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBpdCBmYWxscyB0aHJvdWdoIHdl4oCZbGwgbWF0Y2gsIGFuZCB0aGlzIG1hcmsgd2lsbCBiZSBhcHBsaWVkLlxuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ3N1cCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0U3VwZXJzY3JpcHQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZVN1cGVyc2NyaXB0OiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgICB1bnNldFN1cGVyc2NyaXB0OiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtLic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVN1cGVyc2NyaXB0KCksXG4gICAgfVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBkZWZhdWx0IEV4dGVuc2lvbi5jcmVhdGUoe1xuICAgIG5hbWU6ICd0ZXh0QWxpZ24nLFxuXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGVzOiBbXSxcbiAgICAgICAgICAgIGFsaWdubWVudHM6IFsnc3RhcnQnLCAnY2VudGVyJywgJ2VuZCcsICdqdXN0aWZ5J10sXG4gICAgICAgICAgICBkZWZhdWx0QWxpZ25tZW50OiAnc3RhcnQnLFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZEdsb2JhbEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZXM6IHRoaXMub3B0aW9ucy50eXBlcyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLmRlZmF1bHRBbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4gZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gfHwgdGhpcy5vcHRpb25zLmRlZmF1bHRBbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJIVE1MOiBhdHRyaWJ1dGVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcy50ZXh0QWxpZ24gPT09IHRoaXMub3B0aW9ucy5kZWZhdWx0QWxpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0eWxlOiBgdGV4dC1hbGlnbjogJHthdHRyaWJ1dGVzLnRleHRBbGlnbn1gIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF1cbiAgICB9LFxuXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXRUZXh0QWxpZ246IChhbGlnbm1lbnQpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGlnbm1lbnRzLmluY2x1ZGVzKGFsaWdubWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlcy5ldmVyeSh0eXBlID0+IGNvbW1hbmRzLnVwZGF0ZUF0dHJpYnV0ZXModHlwZSwgeyB0ZXh0QWxpZ246IGFsaWdubWVudCB9KSlcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHVuc2V0VGV4dEFsaWduOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlcy5ldmVyeSh0eXBlID0+IGNvbW1hbmRzLnJlc2V0QXR0cmlidXRlcyh0eXBlLCAndGV4dEFsaWduJykpXG4gICAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1TaGlmdC1sJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0VGV4dEFsaWduKCdzdGFydCcpLFxuICAgICAgICAgICAgJ01vZC1TaGlmdC1lJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0VGV4dEFsaWduKCdjZW50ZXInKSxcbiAgICAgICAgICAgICdNb2QtU2hpZnQtcic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldFRleHRBbGlnbignZW5kJyksXG4gICAgICAgICAgICAnTW9kLVNoaWZ0LWonOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRUZXh0QWxpZ24oJ2p1c3RpZnknKSxcbiAgICAgICAgfVxuICAgIH0sXG59KVxuIiwgImltcG9ydCB7XG4gIGdldE1hcmtBdHRyaWJ1dGVzLFxuICBNYXJrLFxuICBtZXJnZUF0dHJpYnV0ZXMsXG59IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBUZXh0U3R5bGVPcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIHNwYW5zIHdpdGhvdXQgaW5saW5lIHN0eWxlIGF0dHJpYnV0ZXMuXG4gICAgICAgKi9cbiAgICAgIHJlbW92ZUVtcHR5VGV4dFN0eWxlOiAoKSA9PiBSZXR1cm5UeXBlLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgVGV4dFN0eWxlID0gTWFyay5jcmVhdGU8VGV4dFN0eWxlT3B0aW9ucz4oe1xuICBuYW1lOiAndGV4dFN0eWxlJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdzcGFuJyxcbiAgICAgICAgZ2V0QXR0cnM6IGVsZW1lbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IGhhc1N0eWxlcyA9IChlbGVtZW50IGFzIEhUTUxFbGVtZW50KS5oYXNBdHRyaWJ1dGUoJ3N0eWxlJylcblxuICAgICAgICAgIGlmICghaGFzU3R5bGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge31cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnc3BhbicsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlRW1wdHlUZXh0U3R5bGU6ICgpID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZXRNYXJrQXR0cmlidXRlcyhzdGF0ZSwgdGhpcy50eXBlKVxuICAgICAgICBjb25zdCBoYXNTdHlsZXMgPSBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5zb21lKChbLCB2YWx1ZV0pID0+ICEhdmFsdWUpXG5cbiAgICAgICAgaWYgKGhhc1N0eWxlcykge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG59KVxuIiwgImltcG9ydCB7IE1hcmssIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBVbmRlcmxpbmVPcHRpb25zIHtcbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB1bmRlcmxpbmU6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGFuIHVuZGVybGluZSBtYXJrXG4gICAgICAgKi9cbiAgICAgIHNldFVuZGVybGluZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGFuIHVuZGVybGluZSBtYXJrXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZVVuZGVybGluZTogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVW5zZXQgYW4gdW5kZXJsaW5lIG1hcmtcbiAgICAgICAqL1xuICAgICAgdW5zZXRVbmRlcmxpbmU6ICgpID0+IFJldHVyblR5cGUsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBVbmRlcmxpbmUgPSBNYXJrLmNyZWF0ZTxVbmRlcmxpbmVPcHRpb25zPih7XG4gIG5hbWU6ICd1bmRlcmxpbmUnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ3UnLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6ICd0ZXh0LWRlY29yYXRpb24nLFxuICAgICAgICBjb25zdW1pbmc6IGZhbHNlLFxuICAgICAgICBnZXRBdHRyczogc3R5bGUgPT4gKChzdHlsZSBhcyBzdHJpbmcpLmluY2x1ZGVzKCd1bmRlcmxpbmUnKSA/IHt9IDogZmFsc2UpLFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWyd1JywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRVbmRlcmxpbmU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZVVuZGVybGluZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgICAgdW5zZXRVbmRlcmxpbmU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC11JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlVW5kZXJsaW5lKCksXG4gICAgICAnTW9kLVUnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVVbmRlcmxpbmUoKSxcbiAgICB9XG4gIH0sXG59KVxuIiwgImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKXt2YXIgbz1lLmxlbmd0aDtmb3IodD0wO3Q8bzt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpfWVsc2UgZm9yKGYgaW4gZSllW2ZdJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCIsbz1hcmd1bWVudHMubGVuZ3RoO2Y8bztmKyspKGU9YXJndW1lbnRzW2ZdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7IiwgIjxzY3JpcHQ+XG4gICAgaW1wb3J0IGN4IGZyb20gJ2Nsc3gnXG5cbiAgICBleHBvcnQgbGV0IGVkaXRvclxuICAgIGV4cG9ydCBsZXQga2V5XG4gICAgZXhwb3J0IGxldCBhY3RpdmUgPSBmYWxzZVxuICAgIGV4cG9ydCBsZXQgaGlkZGVuXG48L3NjcmlwdD5cblxueyNpZiBlZGl0b3IgJiYgIWhpZGRlbn1cbjxidXR0b25cbiAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICBjbGFzczphY3RpdmU9e2FjdGl2ZX1cbiAgICBvbjpjbGlja1xuICAgIGNsYXNzPXtjeChcbiAgICAgICAgYHNjcmliYmxlLWJ1dHRvbiBzY3JpYmJsZS0ke2tleX1gLFxuICAgICAgICB7XG4gICAgICAgICAgICAnYWN0aXZlJzogYWN0aXZlXG4gICAgICAgIH1cbiAgICApfVxuPlxuICAgIDxzbG90IC8+XG48L2J1dHRvbj5cbnsvaWZ9XG4iLCAiPHNjcmlwdD5cbiAgICBpbXBvcnQgQnV0dG9uIGZyb20gJy4vQnV0dG9uLnN2ZWx0ZSdcblxuICAgIGV4cG9ydCBsZXQgZWRpdG9yXG4gICAgZXhwb3J0IGxldCBzdGF0ZVBhdGhcblxuICAgIGNvbnN0IHRvZ2dsZUZ1bGxzY3JlZW4gPSAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgndG9nZ2xlLWZ1bGxzY3JlZW4nLCB7IGRldGFpbDogeyBzdGF0ZVBhdGg6IHN0YXRlUGF0aCB9IH0pKVxuICAgICAgICBlZGl0b3IuY29tbWFuZHMuZm9jdXMoKVxuICAgIH1cbjwvc2NyaXB0PlxuXG57I2lmIGVkaXRvcn1cbjxkaXYgY2xhc3M9XCJzY3JpYmJsZS1jb250cm9sc1wiPlxuICAgIDxkaXYgY2xhc3M9XCJzY3JpYmJsZS1jb250cm9scy1wYW5lbFwiPlxuICAgICAgICA8QnV0dG9uIHtlZGl0b3J9IGtleT1cInVuZG9cIiBvbjpjbGljaz17KCkgPT4gZWRpdG9yLmNoYWluKCkuZm9jdXMoKS51bmRvKCkucnVuKCl9PlxuICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCA1MTIgNTEyXCI+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjMyXCIgZD1cIk0yNDAgNDI0di05NmMxMTYuNCAwIDE1OS4zOSAzMy43NiAyMDggOTZjMC0xMTkuMjMtMzkuNTctMjQwLTIwOC0yNDBWODhMNjQgMjU2WlwiLz5cbiAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPEJ1dHRvbiB7ZWRpdG9yfSBrZXk9XCJyZWRvXCIgb246Y2xpY2s9eygpID0+IGVkaXRvci5jaGFpbigpLmZvY3VzKCkucmVkbygpLnJ1bigpfT5cbiAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiPlxuICAgICAgICAgICAgICAgIDxwYXRoIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIzMlwiIGQ9XCJNNDQ4IDI1NkwyNzIgODh2OTZDMTAzLjU3IDE4NCA2NCAzMDQuNzcgNjQgNDI0YzQ4LjYxLTYyLjI0IDkxLjYtOTYgMjA4LTk2djk2WlwiLz5cbiAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPEJ1dHRvbiB7ZWRpdG9yfSBrZXk9XCJjbGVhclwiIG9uOmNsaWNrPXsoKSA9PiBlZGl0b3IuY2hhaW4oKS5mb2N1cygpLmNsZWFyQ29udGVudCh0cnVlKS5ydW4oKX0+XG4gICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiPlxuICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMTMuOTk5OSAxOC45OTY3SDIwLjk5OTlWMjAuOTk2N0gxMS45OTk5TDguMDAyMjkgMjAuOTk5MkwxLjUxNDU3IDE0LjUxMTVDMS4xMjQwNSAxNC4xMjA5IDEuMTI0MDUgMTMuNDg3OCAxLjUxNDU3IDEzLjA5NzJMMTIuMTIxMiAyLjQ5MDY1QzEyLjUxMTcgMi4xMDAxMiAxMy4xNDQ5IDIuMTAwMTIgMTMuNTM1NCAyLjQ5MDY1TDIxLjMxMzYgMTAuMjY4OEMyMS43MDQxIDEwLjY1OTMgMjEuNzA0MSAxMS4yOTI1IDIxLjMxMzYgMTEuNjgzTDEzLjk5OTkgMTguOTk2N1pNMTUuNjU2NyAxNC41MTE1TDE5LjE5MjIgMTAuOTc1OUwxMi44MjgzIDQuNjExOTdMOS4yOTI3NSA4LjE0NzVMMTUuNjU2NyAxNC41MTE1WlwiLz5cbiAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPEJ1dHRvbiB7ZWRpdG9yfSBrZXk9XCJlbnRlci1mdWxsc2NyZWVuXCIgb246Y2xpY2s9e3RvZ2dsZUZ1bGxzY3JlZW59PlxuICAgICAgICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIj5cbiAgICAgICAgICAgICAgICA8cGF0aCBmaWxsPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIvPjxwYXRoIGQ9XCJNMjAgM2gydjZoLTJWNWgtNFYzaDR6TTQgM2g0djJINHY0SDJWM2gyem0xNiAxNnYtNGgydjZoLTZ2LTJoNHpNNCAxOWg0djJIMnYtNmgydjR6XCIvPlxuICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgIDwvQnV0dG9uPlxuICAgICAgICA8QnV0dG9uIHtlZGl0b3J9IGtleT1cImV4aXQtZnVsbHNjcmVlblwiIG9uOmNsaWNrPXt0b2dnbGVGdWxsc2NyZWVufT5cbiAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwiY3VycmVudENvbG9yXCI+XG4gICAgICAgICAgICAgICAgPHBhdGggZmlsbD1cIm5vbmVcIiBkPVwiTTAgMGgyNHYyNEgwelwiLz48cGF0aCBkPVwiTTE4IDdoNHYyaC02VjNoMnY0ek04IDlIMlY3aDRWM2gydjZ6bTEwIDh2NGgtMnYtNmg2djJoLTR6TTggMTV2Nkg2di00SDJ2LTJoNnpcIi8+XG4gICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgPC9CdXR0b24+XG4gICAgPC9kaXY+XG48L2Rpdj5cbnsvaWZ9XG4iLCAiPHNjcmlwdD5cbiAgICBpbXBvcnQgQnV0dG9uIGZyb20gJy4vQnV0dG9uLnN2ZWx0ZSdcblxuICAgIGV4cG9ydCBsZXQgZWRpdG9yXG4gICAgZXhwb3J0IGxldCBpc0FjdGl2ZVxuICAgIGV4cG9ydCBsZXQgdG9vbHNcbiAgICBleHBvcnQgbGV0IGhhbmRsZVRvb2xDbGlja1xuXG4gICAgbGV0IGdyb3VwcyA9IHt9XG5cbiAgICBjb25zdCBnZXRHcm91cHMgPSBhcnJheSA9PiB7XG4gICAgICAgIGxldCBtYXAgPSBhcnJheS5tYXAoKGUsIGkpID0+IHtcbiAgICAgICAgICAgIGUuaW5kZXggPSBpXG4gICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICB9KVxuXG4gICAgICAgIGdyb3VwcyA9IG1hcC5yZWR1Y2UoZnVuY3Rpb24ociwgYSkge1xuICAgICAgICAgICAgclthLmdyb3VwXSA9IHJbYS5ncm91cF0gfHwgW11cbiAgICAgICAgICAgIHJbYS5ncm91cF0ucHVzaChhKVxuICAgICAgICAgICAgcmV0dXJuIHJcbiAgICAgICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSlcbiAgICB9XG5cbiAgICAkOiBnZXRHcm91cHModG9vbHMpXG48L3NjcmlwdD5cblxueyNpZiBlZGl0b3J9XG4gICAgPGRpdiBjbGFzcz1cInNjcmliYmxlLWJ1YmJsZS1tZW51XCI+XG4gICAgICAgIHsjaWYgIWlzQWN0aXZlKCdsaW5rJyl9XG4gICAgICAgICAgICB7I2lmIHRvb2xzLmxlbmd0aH1cbiAgICAgICAgICAgICAgICB7I2VhY2ggdG9vbHMgYXMgdG9vbH1cbiAgICAgICAgICAgICAgICAgICAgeyNpZiB0b29sLnR5cGUgPT09ICdkaXZpZGVyJ31cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkaXZpZGVyXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiB7ZWRpdG9yfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17dG9vbC5leHRlbnNpb259XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlPXtpc0FjdGl2ZSh0b29sLmFjdGl2ZS5leHRlbnNpb24sIHRvb2wuYWN0aXZlLmF0dHJzKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjpjbGljaz17KCkgPT4gaGFuZGxlVG9vbENsaWNrKHRvb2wpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbj17dG9vbC5pc0hpZGRlbn1cbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGh0bWwgdG9vbC5pY29ufVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgezplbHNlIGlmIGlzQWN0aXZlKCdsaW5rJyl9XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImxpbmstcHJldmlld1wiPntlZGl0b3IuZ2V0QXR0cmlidXRlcygnbGluaycpLnRpdGxlID8/IGVkaXRvci5nZXRBdHRyaWJ1dGVzKCdsaW5rJykuaHJlZn08L3NwYW4+XG4gICAgICAgICAgICA8QnV0dG9uIHtlZGl0b3J9IGtleT1cImVkaXRMaW5rXCIgb246Y2xpY2s9eygpID0+IGhhbmRsZVRvb2xDbGljayh0b29scy5maW5kKChpdGVtKSA9PiBpdGVtLmV4dGVuc2lvbiA9PT0gJ2xpbmsnKSwgdHJ1ZSl9PlxuICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwiY3VycmVudENvbG9yXCI+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNNi40MTQyMSAxNS44OUwxNi41NTYzIDUuNzQ3ODZMMTUuMTQyMSA0LjMzMzY1TDUgMTQuNDc1OFYxNS44OUg2LjQxNDIxWk03LjI0MjY0IDE3Ljg5SDNWMTMuNjQ3NEwxNC40MzUgMi4yMTIzM0MxNC44MjU2IDEuODIxOCAxNS40NTg3IDEuODIxOCAxNS44NDkyIDIuMjEyMzNMMTguNjc3NyA1LjA0MDc1QzE5LjA2ODIgNS40MzEyOCAxOS4wNjgyIDYuMDY0NDQgMTguNjc3NyA2LjQ1NDk3TDcuMjQyNjQgMTcuODlaTTMgMTkuODlIMjFWMjEuODlIM1YxOS44OVpcIi8+XG4gICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgIDxCdXR0b24ge2VkaXRvcn0ga2V5PVwidW5zZXRMaW5rXCIgb246Y2xpY2s9eygpID0+IGVkaXRvci5jaGFpbigpLmZvY3VzKCkuZXh0ZW5kTWFya1JhbmdlKCdsaW5rJykudW5zZXRMaW5rKCkuc2VsZWN0VGV4dGJsb2NrRW5kKCkucnVuKCl9PlxuICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwiY3VycmVudENvbG9yXCI+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMTcgMTdIMjJWMTlIMTlWMjJIMTdWMTdaTTcgN0gyVjVINVYySDdWN1pNMTguMzY0IDE1LjUzNTVMMTYuOTQ5NyAxNC4xMjEzTDE4LjM2NCAxMi43MDcxQzIwLjMxNjYgMTAuNzU0NSAyMC4zMTY2IDcuNTg4NjYgMTguMzY0IDUuNjM2MDRDMTYuNDExMyAzLjY4MzQyIDEzLjI0NTUgMy42ODM0MiAxMS4yOTI5IDUuNjM2MDRMOS44Nzg2OCA3LjA1MDI1TDguNDY0NDcgNS42MzYwNEw5Ljg3ODY4IDQuMjIxODNDMTIuNjEyMyAxLjQ4ODE2IDE3LjA0NDUgMS40ODgxNiAxOS43NzgyIDQuMjIxODNDMjIuNTExOCA2Ljk1NTUgMjIuNTExOCAxMS4zODc3IDE5Ljc3ODIgMTQuMTIxM0wxOC4zNjQgMTUuNTM1NVpNMTUuNTM1NSAxOC4zNjRMMTQuMTIxMyAxOS43NzgyQzExLjM4NzcgMjIuNTExOCA2Ljk1NTUgMjIuNTExOCA0LjIyMTgzIDE5Ljc3ODJDMS40ODgxNiAxNy4wNDQ1IDEuNDg4MTYgMTIuNjEyMyA0LjIyMTgzIDkuODc4NjhMNS42MzYwNCA4LjQ2NDQ3TDcuMDUwMjUgOS44Nzg2OEw1LjYzNjA0IDExLjI5MjlDMy42ODM0MiAxMy4yNDU1IDMuNjgzNDIgMTYuNDExMyA1LjYzNjA0IDE4LjM2NEM3LjU4ODY2IDIwLjMxNjYgMTAuNzU0NSAyMC4zMTY2IDEyLjcwNzEgMTguMzY0TDE0LjEyMTMgMTYuOTQ5N0wxNS41MzU1IDE4LjM2NFpNMTQuODI4NCA3Ljc1NzM2TDE2LjI0MjYgOS4xNzE1N0w5LjE3MTU3IDE2LjI0MjZMNy43NTczNiAxNC44Mjg0TDE0LjgyODQgNy43NTczNlpcIi8+XG4gICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgey9pZn1cbiAgICA8L2Rpdj5cbnsvaWZ9XG4iLCAiPHNjcmlwdD5cbiAgICBpbXBvcnQgQnV0dG9uIGZyb20gJy4vQnV0dG9uLnN2ZWx0ZSdcblxuICAgIGV4cG9ydCBsZXQgZWRpdG9yXG4gICAgZXhwb3J0IGxldCBpc0FjdGl2ZVxuICAgIGV4cG9ydCBsZXQgdG9vbHNcbiAgICBleHBvcnQgbGV0IGhhbmRsZVRvb2xDbGlja1xuXG4gICAgbGV0IGdyb3VwcyA9IHt9XG5cbiAgICBjb25zdCBnZXRHcm91cHMgPSBhcnJheSA9PiB7XG4gICAgICAgIGxldCBtYXAgPSBhcnJheS5tYXAoKGUsIGkpID0+IHtcbiAgICAgICAgICAgIGUuaW5kZXggPSBpXG4gICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICB9KVxuXG4gICAgICAgIGdyb3VwcyA9IG1hcC5yZWR1Y2UoZnVuY3Rpb24ociwgYSkge1xuICAgICAgICAgICAgclthLmdyb3VwXSA9IHJbYS5ncm91cF0gfHwgW11cbiAgICAgICAgICAgIHJbYS5ncm91cF0ucHVzaChhKVxuICAgICAgICAgICAgcmV0dXJuIHJcbiAgICAgICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSlcbiAgICB9XG5cbiAgICAkOiBnZXRHcm91cHModG9vbHMpXG48L3NjcmlwdD5cblxueyNpZiBlZGl0b3IgJiYgdG9vbHMgJiYgdG9vbHMubGVuZ3RoID4gMH1cbiAgICA8ZGl2IGNsYXNzPVwic2NyaWJibGUtdG9vbGJhclwiPlxuICAgICAgICB7I2lmIHRvb2xzLmxlbmd0aH1cbiAgICAgICAgICAgIHsjZWFjaCB0b29scyBhcyB0b29sfVxuICAgICAgICAgICAgICAgIHsjaWYgdG9vbC50eXBlID09PSAnZGl2aWRlcid9XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkaXZpZGVyXCIgLz5cbiAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b24ge2VkaXRvcn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e3Rvb2wuZXh0ZW5zaW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZT17aXNBY3RpdmUodG9vbC5hY3RpdmUuZXh0ZW5zaW9uLCB0b29sLmFjdGl2ZS5hdHRycyl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb246Y2xpY2s9eygpID0+IGhhbmRsZVRvb2xDbGljayh0b29sKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW49e3Rvb2wuaXNIaWRkZW59XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtAaHRtbCB0b29sLmljb259XG4gICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC9kaXY+XG57L2lmfVxuIiwgImltcG9ydCB7XG4gIE1hcmssXG4gIG1hcmtJbnB1dFJ1bGUsXG4gIG1hcmtQYXN0ZVJ1bGUsXG4gIG1lcmdlQXR0cmlidXRlcyxcbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEhpZ2hsaWdodE9wdGlvbnMge1xuICBtdWx0aWNvbG9yOiBib29sZWFuLFxuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGhpZ2hsaWdodDoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYSBoaWdobGlnaHQgbWFya1xuICAgICAgICovXG4gICAgICBzZXRIaWdobGlnaHQ6IChhdHRyaWJ1dGVzPzogeyBjb2xvcjogc3RyaW5nIH0pID0+IFJldHVyblR5cGUsXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIGhpZ2hsaWdodCBtYXJrXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUhpZ2hsaWdodDogKGF0dHJpYnV0ZXM/OiB7IGNvbG9yOiBzdHJpbmcgfSkgPT4gUmV0dXJuVHlwZSxcbiAgICAgIC8qKlxuICAgICAgICogVW5zZXQgYSBoaWdobGlnaHQgbWFya1xuICAgICAgICovXG4gICAgICB1bnNldEhpZ2hsaWdodDogKCkgPT4gUmV0dXJuVHlwZSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGlucHV0UmVnZXggPSAvKD86XnxcXHMpKD09KD8hXFxzKz09KSgoPzpbXj1dKykpPT0oPyFcXHMrPT0pKSQvXG5leHBvcnQgY29uc3QgcGFzdGVSZWdleCA9IC8oPzpefFxccykoPT0oPyFcXHMrPT0pKCg/OltePV0rKSk9PSg/IVxccys9PSkpL2dcblxuZXhwb3J0IGNvbnN0IEhpZ2hsaWdodCA9IE1hcmsuY3JlYXRlPEhpZ2hsaWdodE9wdGlvbnM+KHtcbiAgbmFtZTogJ2hpZ2hsaWdodCcsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbXVsdGljb2xvcjogZmFsc2UsXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMubXVsdGljb2xvcikge1xuICAgICAgcmV0dXJuIHt9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgIHBhcnNlSFRNTDogZWxlbWVudCA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1jb2xvcicpIHx8IGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICByZW5kZXJIVE1MOiBhdHRyaWJ1dGVzID0+IHtcbiAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXMuY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnZGF0YS1jb2xvcic6IGF0dHJpYnV0ZXMuY29sb3IsXG4gICAgICAgICAgICBzdHlsZTogYGJhY2tncm91bmQtY29sb3I6ICR7YXR0cmlidXRlcy5jb2xvcn07IGNvbG9yOiBpbmhlcml0YCxcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnbWFyaycsXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ21hcmsnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEhpZ2hsaWdodDogYXR0cmlidXRlcyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSwgYXR0cmlidXRlcylcbiAgICAgIH0sXG4gICAgICB0b2dnbGVIaWdobGlnaHQ6IGF0dHJpYnV0ZXMgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMpXG4gICAgICB9LFxuICAgICAgdW5zZXRIaWdobGlnaHQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC1TaGlmdC1oJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlSGlnaGxpZ2h0KCksXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG5cbiAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IHBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiLy8gVEhJUyBGSUxFIElTIEFVVE9NQVRJQ0FMTFkgR0VORVJBVEVEIERPIE5PVCBFRElUIERJUkVDVExZXG4vLyBTZWUgdXBkYXRlLXRsZHMuanMgZm9yIGVuY29kaW5nL2RlY29kaW5nIGZvcm1hdFxuLy8gaHR0cHM6Ly9kYXRhLmlhbmEub3JnL1RMRC90bGRzLWFscGhhLWJ5LWRvbWFpbi50eHRcbmNvbnN0IGVuY29kZWRUbGRzID0gJ2FhYTFycDNiYjBvdHQzdmllNGMxbGUyb2dhZG81dWRoYWJpN2MwYWRlbXk1Y2VudHVyZTZvdW50YW50MHM5bzF0b3I0ZDBzMXVsdDRlMGcxcm8ydG5hNGYwbDFyaWNhNWcwYWtoYW41ZW5jeTVpMGcxcmJ1czNmb3JjZTV0ZWw1a2RuM2wwaWJhYmE0cGF5NGxmaW5hbno2c3RhdGU1eTJzYWNlM3RvbTVtMGF6b240ZXJpY2FuZXhwcmVzczdmYW1pbHkxMXgyZmFtM2ljYTNzdGVyZGFtOG5hbHl0aWNzN2Ryb2lkNXF1YW40ejJvMGwycGFydG1lbnRzOHAwbGU0cTB1YXJlbGxlOHIwYWIxbWNvNGNoaTNteTJwYTJ0MGUzczBkYTJpYTJzb2NpYXRlczl0MGhsZXRhNXRvcm5leTd1MGN0aW9uNWRpMGJsZTNvM3Nwb3N0NXRob3IzbzBzNHZpYW5jYTZ3MHMyeDBhMnowdXJlNWJhMGJ5MmlkdTNuYW1leDNuYXJlcHVibGljMTFkMWsycjBjZWxvbmE1bGF5Y2FyZDRzNWVmb290NWdhaW5zNnNlYmFsbDVrZXRiYWxsOHVoYXVzNXllcm41YjBjMXQxdmEzY2cxbjJkMWUwYXRzMnV0eTRlcjJudGxleTVybGluNHN0MGJ1eTV0MmYxZzFoMGFydGk1aTBibGUzZDFrZTJuZzBvM28xejJqMWxhY2swZnJpZGF5OW9ja2J1c3RlcjhnMW9tYmVyZzd1ZTNtMHMxdzJuMHBwYXJpYmFzOW8wYXRzM2VocmluZ2VyOGZhMm0xbmQybzBrMGluZzVzY2gydGlrMm9uNHQxdXRpcXVlNngycjBhZGVzY282aWRnZXN0b25lOW9hZHdheTVrZXIzdGhlcjV1c3NlbHM3czF0MXVpbGQwZXJzNnNpbmVzczZ5MXp6M3YxdzF5MXowaDNjYTBiMWZlMmwwbDF2aW5rbGVpbjltMGVyYTNwMm5vbjNwZXRvd241aXRhbDBvbmU4cjBhdmFuNGRzMmUwZXIwczRzMnNhMWUxaDFpbm80dDBlcmluZzVob2xpYzdiYTFuMXJlM2MxZDFlbnRlcjRvMXJuM2YwYTFkMmcxaDBhbmVsMm5lbDRyaXR5NHNlMnQyZWFwM2ludGFpNXJpc3RtYXM2b21lNHVyY2g1aTBwcmlhbmk2cmNsZTRzY28zdGFkZWw0aTBjMnkzazFsMGFpbXM0ZWFuaW5nNmljazJuaWMxcXVlNm90aGluZzV1ZDN1YjBtZWQ2bTFuMW8wYWNoM2RlczNmZmVlNGxsZWdlNG9nbmU1bTBjYXN0NG1iYW5rNHVuaXR5NnBhbnkycmUzdXRlcjVzZWM0bmRvczNzdHJ1Y3Rpb244dWx0aW5nN3RhY3QzcmFjdG9yczlva2luZzRsMXAycnNpY2E1dW50cnk0cG9uMHM0cnNlczZwYTJyMGVkaXQwY2FyZDR1bmlvbjlpY2tldDVvd24zczF1aXNlMHM2dTBpc2luZWxsYTl2MXcxeDF5MG1ydTNvdTN6MmRhYnVyM2QxbmNlM3RhMWUxaW5nM3N1bjR5MmNsazNkczJlMGFsMGVyMnMzZ3JlZTRsaXZlcnk1bDFvaXR0ZTV0YTNtb2NyYXQ2bnRhbDJpc3Q1c2kwZ240djJobDJpYW1vbmRzNmV0MmdpdGFsNXJlY3Qwb3J5N3Njb3VudDN2ZXI1aDJ5MmoxazFtMW5wMm8wY3MxdG9yNGcxbWFpbnM1dDF3bmxvYWQ3cml2ZTR0djJ1YmFpM25sb3A0cG9udDRyYmFuNXZhZzJyMnoyZWFydGgzdDJjMG8yZGVrYTN1MGNhdGlvbjhlMWcxbWFpbDNlcmNrNW5lcmd5NGdpbmVlcjBpbmc5dGVycHJpc2VzMTBwc29uNHF1aXBtZW50OHIwaWNzc29uNm5pM3MwcTF0YXRlNXQxdTByb3Zpc2lvbjhzMnZlbnRzNXhjaGFuZ2U2cGVydDNvc2VkNHJlc3M1dHJhc3BhY2UxMGZhZ2UyaWwxcndpbmRzNnRoM21pbHk0bjBzMnJtMGVyczVzaGlvbjR0M2VkZXgzZWRiYWNrNnJyYXJpM2VybzZpMGRlbGl0eTVvMmxtMm5hbDFuY2UxaWFsN3JlMHN0b25lNm1kYWxlNnNoMGluZzV0MG5lc3M2ajFrMWxpY2tyM2dodHM0cjJvcmlzdDR3ZXJzNXkybTFvMG8wZDF0YmFsbDZyZDFleDJzYWxlNHVtM3VuZGF0aW9uOHgycjBlZTFzZW5pdXM3bDFvZ2FuczRudGllcjd0cjJ1aml0c3U1bjBkMnJuaXR1cmU3dGJvbDV5aTNnYTBsMGxlcnkzbzF1cDRtZTBzM3AxcmRlbjR5MmIwaXozZDBuMmUwYTFudDBpbmc1b3JnZTVmMWcwZWUzaDFpMGZ0MHMzdmVzMmluZzVsMGFzczNlMW9iYWwybzRtMGFpbDNiaDJvMXgybjFvZGFkZHk1bGQwcG9pbnQ2ZjJvMGR5ZWFyNWcwbGU0cDF0MXYycDFxMXIwYWluZ2VyNXBoaWNzNXRpczRlZW4zaXBlM29jZXJ5NHVwNHMxdDF1MGFyZGlhbjZjY2kzZ2UyaWRlMnRhcnM1cnUzdzF5MmhhaXIybWJ1cmc1bmdvdXQ1dXMzYm8yZGZjMGJhbms3ZWFsdGgwY2FyZThscDFzaW5raTZyZTFtZXM1aXBob3A0c2FtaXRzdTd0YWNoaTV2MmswdDJtMW4xb2NrZXk0bGRpbmdzNWlkYXk1bWVkZXBvdDVnb29kczVzMGVuc2U3bmRhM3JzZTNzcGl0YWw1dDBpbmc1dDBlbHMzbWFpbDV1c2UzdzJyMXNiYzN0MXUwZ2hlczV5YXR0M3VuZGFpN2libTJjYmMyZTF1MmQxZTBlZTNmbTJrYW5vNGwxbTBhbWF0NGRiMm1vMGJpbGllbjluMGMxZHVzdHJpZXM4ZmluaXRpNW8yZzFrMXN0aXR1dGU2dXJhbmNlNGU0dDBlcm5hdGlvbmFsMTB1aXQ0dmVzdG1lbnRzMTBvMXBpcmFuZ2E3cTFyMGlzaDRzMG1haWxpNXQwYW5idWw3dDBhdTJ2M2phZ3VhcjR2YTNjYjJlMGVwMnR6dDN3ZWxyeTZpbzJsbDJtMHAybmoybzBiczF1cmc0dDF5MnAwbW9yZ2FuNnJzM3VlZ29zNG5pcGVyN2thdWZlbjVkZGkzZTBycnlob3RlbHM2bG9naXN0aWNzOXByb3BlcnRpZXMxNGZoMmcxaDFpMGExZHMybTFuZGxlNHRjaGVuNXdpM20xbjFvZWxuM21hdHN1NXNoZXI1cDBtZzJuMnIwZDFlZDN1b2tncm91cDh3MXkwb3RvNHoybGEwY2FpeGE1bWJvcmdoaW5pOGVyM25jYXN0ZXI2ZDByb3ZlcjZ4ZXNzNXNhbGxlNXQwaW5vM3JvYmU1dzB5ZXI1YjFjMWRzMmVhc2UzY2xlcmM1ZnJhazRnYWwybzJ4dXM0Z2J0M2kwZGwyZmUwaW5zdXJhbmNlOXN0eWxlN2dodGluZzZrZTJsbHkzbWl0ZWQ0bzJuY29sbjRrMnBzeTN2ZTFpbmc1azFsYzFwMm9hbjBzM2NrZXIzdXMzbDFuZG9uNHR0ZTFvM3ZlM3BsMGZpbmFuY2lhbDExcjFzMXQwZDBhM3UwbmRiZWNrNnhlMXVyeTV2MXkybWEwZHJpZDRpZjFzb240a2V1cDRuMGFnZW1lbnQ3Z28zcDFya2V0MGluZzNzNHJpb3R0NXNoYWxsczd0dGVsNWJhMmMwa2luc2V5N2QxZTBkMGlhM2V0Mmxib3VybmU3bWUxb3JpYWw2bjB1MnJja21zZDdnMWgxaWFtaTNjcm9zb2Z0N2wxbmkxdDJ0MHN1YmlzaGk5azFsMGIxczJtMGEybjFvMGJpMGxlNGRhMmUxaTFtMW5hc2gzZXkyc3RlcjVybW9uM3RnYWdlNnNjb3c0dG8wcmN5Y2xlczl2MGllNHAxcTFyMXMwZDJ0MG4xcjJ1MHNldW0zaWM0djF3MXgxeTF6Mm5hMGIxZ295YTRtZTJ0dXJhNHZ5M2JhMmMxZTBjMXQwYmFuazRmbGl4NHdvcms1dXN0YXI1dzBzMnh0MGRpcmVjdDd1czRmMGwyZzBvMmhrMmkwY28ya2Uxb24zbmphM3NzYW4xeTVsMW8wa2lhM3J0b240dzBydXozdHY0cDFyMGExdzJ0dDJ1MXljMnoyb2JpMXNlcnZlcjdmZmljZTVraW5hd2E2bGF5YW4wZ3JvdXA5ZG5hdnk1bG8zbTBlZ2E0bmUxZzFsMGluZTVvbzJwZW4zcmFjbGUzbmdlNGcwYW5pYzVpZ2luczZzYWthNHRzdWthNHQydmgzcGEwZ2UybmFzb25pYzdyaXMyczF0bmVyczRzMXkzeTJjY3czZTB0MmYwaXplcjVnMWgwYXJtYWN5NmQxaWxpcHM1b25lMnRvMGdyYXBoeTZzNHlzaW81aWNzMXRldDJ1cmVzNmQxbjBnMWsyb25lZXI1enphNGsxbDBhY2UyeTBzdGF0aW9uOXVtYmluZzVzM20xbjBjMm9obDJrZXIzbGl0aWU1cm4yc3QzcjBhbWVyaWNhNnhpM2VzczNpbWUzbzBkMHVjdGlvbnM4ZjFncmVzc2l2ZThtbzJwZXJ0aWVzM3k1dGVjdGlvbjh1MGRlbnRpYWw5czF0MXViMncwYzJ5MnFhMXBvbjN1ZWJlYzNzdDVyYWNpbmc0ZGlvNGUwYWQxbGVzdGF0ZTZ0b3IyeTRjaXBlczVkMHN0b25lNXVtYnJlbGxhOWhhYjNpc2UwbjN0MmxpYW5jZTZuMHQwYWxzNXBhaXIzb3J0M3VibGljYW44c3QwYXVyYW50OHZpZXcwczV4cm90aDZpY2gwYXJkbGk2b2gzbDFvMXAybzBja3MzZGVvM2dlcnM0b20zczB2cDN1MGdieTNocjJuMncwZTJ5dWt5dTZzYTBhcmxhbmQ2ZmUwdHk0a3VyYTRsZTFvbjNtc2NsdWI0dW5nNW5kdmlrMGNvcm9tYW50MTJvZmk0cDFybDJzMXZlMnhvM2IwaTFzMmMwYTFiMWhhZWZmbGVyN21pZHQ0b2xhcnNoaXBzOG9sM3VsZTN3YXJ6NWllbmNlNW90M2QxZTBhcmNoM3QyY3VyZTFpdHk2ZWsybGVjdDRuZXIzcnZpY2VzNnZlbjN3MXgweTNmcjJnMWgwYW5ncmlsYTZycDJ3MmVsbDNpYTFrc2hhNW9lczJwMHBpbmc1dWppM3czaTBsazJuYTFnbGVzNXRlM2oxazBpMG4yeTBwZTRsMGluZzRtMGFydDNpbGU0bjBjZjNvMGNjZXIzaWFsNGZ0YmFuazR3YXJlNmh1MmxhcjJ1dGlvbnM3bmcxeTJ5MnBhMGNlM29ydDJ0M3IwbDJzMXQwYWRhMnBsZXM0cjF0ZWJhbms0ZmFybTdjMGdyb3VwNm9ja2hvbG02cmFnZTNlM3JlYW00dWRpbzJ5M3lsZTR1MGNrczNwcGxpZXMzeTJvcnQ1cmYxZ2VyeTV6dWtpNXYxd2F0Y2g0aXNzNHgxeTBkbmV5NHN0ZW1zNnoydGFiMWlwZWk0bGsyb2JhbzRyZ2V0NHRhbW90b3JzNnIydG9vNHgwaTNjMGkyZDBrMmVhbTJjaDBub2xvZ3k4bDFtYXNlazVubmlzNHZhM2YxZzFoMGQxZWF0ZXIycmU2aWFhMmNrZXRzNWVuZGE0cHMycmVzMm9sNGowbWF4eDR4MmswbWF4eDVsMW0wYWxsNG4xbzBkYXkza3lvM29sczNwMXJheTNzaGliYTV0YWwzdXJzM3duMnlvdGEzczNyMGFkZTFpbmc0aW5pbmc1dmVsMGVyczBpbnN1cmFuY2UxNnVzdDN2MnQxdWJlMmkxbmVzM3NodTR2MHMydzF6MnVhMWJhbmszczJnMWsxbmljb20zdmVyc2l0eThvMm9sMnBzMnMxeTF6MnZhMGNhdGlvbnM3bmExZ3VhcmQ3YzFlMGdhczNudHVyZXM2cmlzaWduNW1cdTAwRjZnZW5zYmVyYXRlcjJ1bmcxNHNpY2hlcnVuZzEwdDJnMWkwYWplczRkZW8zZzFraW5nNGxsYXM0bjFwMXJnaW40c2ExaW9uNHZhMW8zbGFhbmRlcmVuOW4xb2RrYTNsdm8zdGUxaW5nM28yeWFnZTV1MndhbGVzMm1hcnQ0dGVyNG5nMGdvdTV0Y2gwZXM2ZWF0aGVyMGNoYW5uZWwxMmJjYW0zZXIyc2l0ZTVkMGRpbmc1aWJvMnIzZjFob3N3aG82aWVuMmtpMmxsaWFtaGlsbDluMGRvd3M0ZTFuZXJzNm1lMm9sdGVyc2tsdXdlcjExb2RzaWRlNnJrMHMybGQzdzJzMXRjMWYzeGJveDNlcm94NGZpbml0eTZpaHVhbjRuMnh4Mnl6M3lhY2h0czRob28zbWF4dW41bmRleDVlMW9kb2Jhc2hpN2dhMmtvaGFtYTZ1MHR1YmU2dDF1bjN6YTBwcG9zNHJhM2VybzNpcDJtMW9uZTN1ZXJpY2g2dzInO1xuLy8gSW50ZXJuYXRpb25hbGl6ZWQgZG9tYWluIG5hbWVzIGNvbnRhaW5pbmcgbm9uLUFTQ0lJXG5jb25zdCBlbmNvZGVkVXRsZHMgPSAnXHUwM0I1XHUwM0JCMVx1MDNDNTJcdTA0MzFcdTA0MzMxXHUwNDM1XHUwNDNCM1x1MDQzNFx1MDQzNVx1MDQ0Mlx1MDQzODRcdTA0MzVcdTA0NEUyXHUwNDNBXHUwNDMwXHUwNDQyXHUwNDNFXHUwNDNCXHUwNDM4XHUwNDNBNlx1MDQzRVx1MDQzQzNcdTA0M0NcdTA0M0FcdTA0MzQyXHUwNDNFXHUwNDNEMVx1MDQ0MVx1MDQzQVx1MDQzMlx1MDQzMDZcdTA0M0VcdTA0M0RcdTA0M0JcdTA0MzBcdTA0MzlcdTA0M0Q1XHUwNDQwXHUwNDMzM1x1MDQ0MFx1MDQ0M1x1MDQ0MTJcdTA0NDQyXHUwNDQxXHUwNDMwXHUwNDM5XHUwNDQyM1x1MDQ0MFx1MDQzMTNcdTA0NDNcdTA0M0FcdTA0NDAzXHUwNDlCXHUwNDMwXHUwNDM3M1x1MDU3MFx1MDU2MVx1MDU3NTNcdTA1RDlcdTA1RTlcdTA1RThcdTA1RDBcdTA1REM1XHUwNUU3XHUwNUQ1XHUwNUREM1x1MDYyN1x1MDYyOFx1MDY0OFx1MDYzOFx1MDYyOFx1MDY0QTVcdTA2MzFcdTA2MjdcdTA2NDVcdTA2NDNcdTA2NDg1XHUwNjQ0XHUwNjI3XHUwNjMxXHUwNjJGXHUwNjQ2NFx1MDYyOFx1MDYyRFx1MDYzMVx1MDY0QVx1MDY0NjVcdTA2MkNcdTA2MzJcdTA2MjdcdTA2MjZcdTA2MzE1XHUwNjMzXHUwNjM5XHUwNjQ4XHUwNjJGXHUwNjRBXHUwNjI5Nlx1MDYzOVx1MDY0NFx1MDY0QVx1MDYyN1x1MDY0NjVcdTA2NDVcdTA2M0FcdTA2MzFcdTA2Mjg1XHUwNjQ1XHUwNjI3XHUwNjMxXHUwNjI3XHUwNjJBNVx1MDZDQ1x1MDYzMVx1MDYyN1x1MDY0NjVcdTA2MjhcdTA2MjdcdTA2MzFcdTA2MkEyXHUwNjMyXHUwNjI3XHUwNjMxNFx1MDY0QVx1MDYyQVx1MDY0MzNcdTA2QkVcdTA2MjdcdTA2MzFcdTA2MkE1XHUwNjJBXHUwNjQ4XHUwNjQ2XHUwNjMzNFx1MDYzM1x1MDY0OFx1MDYyRlx1MDYyN1x1MDY0NjNcdTA2MzFcdTA2NEFcdTA2Mjk1XHUwNjM0XHUwNjI4XHUwNjQzXHUwNjI5NFx1MDYzOVx1MDYzMVx1MDYyN1x1MDY0MjJcdTA2MjgyXHUwNjQ1XHUwNjI3XHUwNjQ2NFx1MDY0MVx1MDY0NFx1MDYzM1x1MDYzN1x1MDY0QVx1MDY0NjZcdTA2NDJcdTA2MzdcdTA2MzEzXHUwNjQzXHUwNjI3XHUwNjJCXHUwNjQ4XHUwNjQ0XHUwNjRBXHUwNjQzNlx1MDY0OFx1MDY0NTNcdTA2NDVcdTA2MzVcdTA2MzEyXHUwNjQ0XHUwNjRBXHUwNjMzXHUwNjRBXHUwNjI3NVx1MDY0OFx1MDYzMVx1MDY0QVx1MDYyQVx1MDYyN1x1MDY0Nlx1MDY0QVx1MDYyNzdcdTA2NDJcdTA2Mzk0XHUwNjQ3XHUwNjQ1XHUwNjMxXHUwNjI3XHUwNjQ3NVx1MDY3RVx1MDYyN1x1MDZBOVx1MDYzM1x1MDYyQVx1MDYyN1x1MDY0NjdcdTA2ODBcdTA2MjdcdTA2MzFcdTA2MkE0XHUwOTE1XHUwOTQ5XHUwOTJFM1x1MDkyOFx1MDk0N1x1MDkxRjNcdTA5MkRcdTA5M0VcdTA5MzBcdTA5MjQwXHUwOTJFXHUwOTREM1x1MDk0Qlx1MDkyNDVcdTA5MzhcdTA5MDJcdTA5MTdcdTA5MjBcdTA5Mjg1XHUwOUFDXHUwOUJFXHUwOTgyXHUwOUIyXHUwOUJFNVx1MDlBRFx1MDlCRVx1MDlCMFx1MDlBNDJcdTA5RjBcdTA5QTQ0XHUwQTJEXHUwQTNFXHUwQTMwXHUwQTI0NFx1MEFBRFx1MEFCRVx1MEFCMFx1MEFBNDRcdTBCMkRcdTBCM0VcdTBCMzBcdTBCMjQ0XHUwQjg3XHUwQkE4XHUwQkNEXHUwQkE0XHUwQkJGXHUwQkFGXHUwQkJFNlx1MEJCMlx1MEI5OVx1MEJDRFx1MEI5NVx1MEJDODZcdTBCOUFcdTBCQkZcdTBCOTlcdTBCQ0RcdTBCOTVcdTBCQUFcdTBCQ0RcdTBCQUFcdTBCQzJcdTBCQjBcdTBCQ0QxMVx1MEMyRFx1MEMzRVx1MEMzMFx1MEMyNFx1MEM0RDVcdTBDQURcdTBDQkVcdTBDQjBcdTBDQTQ0XHUwRDJEXHUwRDNFXHUwRDMwXHUwRDI0XHUwRDAyNVx1MERCRFx1MEQ4Mlx1MEQ5QVx1MERDRjRcdTBFMDRcdTBFMkRcdTBFMjEzXHUwRTQ0XHUwRTE3XHUwRTIyM1x1MEVBNVx1MEVCMlx1MEVBNzNcdTEwRDJcdTEwRDQyXHUzMDdGXHUzMDkzXHUzMDZBM1x1MzBBMlx1MzBERVx1MzBCRVx1MzBGMzRcdTMwQUZcdTMwRTlcdTMwQTZcdTMwQzk0XHUzMEIwXHUzMEZDXHUzMEIwXHUzMEVCNFx1MzBCM1x1MzBFMDJcdTMwQjlcdTMwQzhcdTMwQTIzXHUzMEJCXHUzMEZDXHUzMEVCM1x1MzBENVx1MzBBMVx1MzBDM1x1MzBCN1x1MzBFN1x1MzBGMzZcdTMwRERcdTMwQTRcdTMwRjNcdTMwQzg0XHU0RTE2XHU3NTRDMlx1NEUyRFx1NEZFMTFcdTU2RkQxXHU1NzBCMVx1NjU4N1x1N0Y1MTNcdTRFOUFcdTlBNkNcdTkwMEEzXHU0RjAxXHU0RTFBMlx1NEY1Qlx1NUM3MTJcdTRGRTFcdTYwNkYyXHU1MDY1XHU1RUI3Mlx1NTE2Qlx1NTM2NjJcdTUxNkNcdTUzRjgxXHU3NkNBMlx1NTNGMFx1NkU3RTFcdTcwNjMyXHU1NTQ2XHU1N0NFMVx1NUU5NzFcdTY4MDcyXHU1NjA5XHU5MUNDMFx1NTkyN1x1OTE1Mlx1NUU5NzVcdTU3MjhcdTdFQkYyXHU1OTI3XHU2MkZGMlx1NTkyOVx1NEUzQlx1NjU1OTNcdTVBMzFcdTRFNTAyXHU1QkI2XHU5NkZCMlx1NUU3Rlx1NEUxQzJcdTVGQUVcdTUzNUEyXHU2MTQ4XHU1NTg0Mlx1NjIxMVx1NzIzMVx1NEY2MDNcdTYyNEJcdTY3M0EyXHU2MkRCXHU4MDU4Mlx1NjUzRlx1NTJBMTFcdTVFOUMyXHU2NUIwXHU1MkEwXHU1NzYxMlx1OTVGQjJcdTY1RjZcdTVDMUEyXHU2NkY4XHU3QzREMlx1NjczQVx1Njc4NDJcdTZERTFcdTlBNkNcdTk1MjEzXHU2RTM4XHU2MjBGMlx1NkZCM1x1OTU4MDJcdTcwQjlcdTc3MEIyXHU3OUZCXHU1MkE4Mlx1N0VDNFx1N0VDN1x1NjczQVx1Njc4NDRcdTdGNTFcdTU3NDAxXHU1RTk3MVx1N0FEOTFcdTdFREMyXHU4MDU0XHU5MDFBMlx1OEMzN1x1NkI0QzJcdThEMkRcdTcyNjkyXHU5MDFBXHU4Q0E5Mlx1OTZDNlx1NTZFMjJcdTk2RkJcdThBMEFcdTc2QzhcdTc5RDE0XHU5OERFXHU1MjI5XHU2RDY2M1x1OThERlx1NTRDMTJcdTk5MTBcdTUzODUyXHU5OTk5XHU2ODNDXHU5MUNDXHU2MkM5M1x1NkUyRjJcdUIyRjdcdUIxMzcxXHVDRUY0Mlx1QzBCQ1x1QzEzMTJcdUQ1NUNcdUFENkQyJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgQVxuICogQHRlbXBsYXRlIEJcbiAqIEBwYXJhbSB7QX0gdGFyZ2V0XG4gKiBAcGFyYW0ge0J9IHByb3BlcnRpZXNcbiAqIEByZXR1cm4ge0EgJiBCfVxuICovXG5jb25zdCBhc3NpZ24gPSAodGFyZ2V0LCBwcm9wZXJ0aWVzKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICB0YXJnZXRba2V5XSA9IHByb3BlcnRpZXNba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBGaW5pdGUgU3RhdGUgTWFjaGluZSBnZW5lcmF0aW9uIHV0aWxpdGllc1xuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHt7IFtncm91cDogc3RyaW5nXTogVFtdIH19IENvbGxlY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7eyBbZ3JvdXA6IHN0cmluZ106IHRydWUgfX0gRmxhZ3NcbiAqL1xuXG4vLyBLZXlzIGluIHNjYW5uZXIgQ29sbGVjdGlvbnMgaW5zdGFuY2VzXG5jb25zdCBudW1lcmljID0gJ251bWVyaWMnO1xuY29uc3QgYXNjaWkgPSAnYXNjaWknO1xuY29uc3QgYWxwaGEgPSAnYWxwaGEnO1xuY29uc3QgYXNjaWludW1lcmljID0gJ2FzY2lpbnVtZXJpYyc7XG5jb25zdCBhbHBoYW51bWVyaWMgPSAnYWxwaGFudW1lcmljJztcbmNvbnN0IGRvbWFpbiA9ICdkb21haW4nO1xuY29uc3QgZW1vamkgPSAnZW1vamknO1xuY29uc3Qgc2NoZW1lID0gJ3NjaGVtZSc7XG5jb25zdCBzbGFzaHNjaGVtZSA9ICdzbGFzaHNjaGVtZSc7XG5jb25zdCB3aGl0ZXNwYWNlID0gJ3doaXRlc3BhY2UnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gZ3JvdXBzIHRvIHJlZ2lzdGVyIGluXG4gKiBAcmV0dXJucyB7VFtdfSBDdXJyZW50IGxpc3Qgb2YgdG9rZW5zIGluIHRoZSBnaXZlbiBjb2xsZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyR3JvdXAobmFtZSwgZ3JvdXBzKSB7XG4gIGlmICghKG5hbWUgaW4gZ3JvdXBzKSkge1xuICAgIGdyb3Vwc1tuYW1lXSA9IFtdO1xuICB9XG4gIHJldHVybiBncm91cHNbbmFtZV07XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdCB0b2tlbiB0byBhZGRcbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IGdyb3Vwc1xuICogQHBhcmFtIHtGbGFnc30gZmxhZ3NcbiAqL1xuZnVuY3Rpb24gYWRkVG9Hcm91cHModCwgZmxhZ3MsIGdyb3Vwcykge1xuICBpZiAoZmxhZ3NbbnVtZXJpY10pIHtcbiAgICBmbGFnc1thc2NpaW51bWVyaWNdID0gdHJ1ZTtcbiAgICBmbGFnc1thbHBoYW51bWVyaWNdID0gdHJ1ZTtcbiAgfVxuICBpZiAoZmxhZ3NbYXNjaWldKSB7XG4gICAgZmxhZ3NbYXNjaWludW1lcmljXSA9IHRydWU7XG4gICAgZmxhZ3NbYWxwaGFdID0gdHJ1ZTtcbiAgfVxuICBpZiAoZmxhZ3NbYXNjaWludW1lcmljXSkge1xuICAgIGZsYWdzW2FscGhhbnVtZXJpY10gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1thbHBoYV0pIHtcbiAgICBmbGFnc1thbHBoYW51bWVyaWNdID0gdHJ1ZTtcbiAgfVxuICBpZiAoZmxhZ3NbYWxwaGFudW1lcmljXSkge1xuICAgIGZsYWdzW2RvbWFpbl0gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1tlbW9qaV0pIHtcbiAgICBmbGFnc1tkb21haW5dID0gdHJ1ZTtcbiAgfVxuICBmb3IgKGNvbnN0IGsgaW4gZmxhZ3MpIHtcbiAgICBjb25zdCBncm91cCA9IHJlZ2lzdGVyR3JvdXAoaywgZ3JvdXBzKTtcbiAgICBpZiAoZ3JvdXAuaW5kZXhPZih0KSA8IDApIHtcbiAgICAgIGdyb3VwLnB1c2godCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdCB0b2tlbiB0byBjaGVja1xuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gZ3JvdXBzXG4gKiBAcmV0dXJucyB7RmxhZ3N9IGdyb3VwIGZsYWdzIHRoYXQgY29udGFpbiB0aGlzIHRva2VuXG4gKi9cbmZ1bmN0aW9uIGZsYWdzRm9yVG9rZW4odCwgZ3JvdXBzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IGMgaW4gZ3JvdXBzKSB7XG4gICAgaWYgKGdyb3Vwc1tjXS5pbmRleE9mKHQpID49IDApIHtcbiAgICAgIHJlc3VsdFtjXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0eXBlZGVmIHtudWxsIHwgVCB9IFRyYW5zaXRpb25cbiAqL1xuXG4vKipcbiAqIERlZmluZSBhIGJhc2ljIHN0YXRlIG1hY2hpbmUgc3RhdGUuIGogaXMgdGhlIGxpc3Qgb2YgY2hhcmFjdGVyIHRyYW5zaXRpb25zLFxuICoganIgaXMgdGhlIGxpc3Qgb2YgcmVnZXgtbWF0Y2ggdHJhbnNpdGlvbnMsIGpkIGlzIHRoZSBkZWZhdWx0IHN0YXRlIHRvXG4gKiB0cmFuc2l0aW9uIHRvIHQgaXMgdGhlIGFjY2VwdGluZyB0b2tlbiB0eXBlLCBpZiBhbnkuIElmIHRoaXMgaXMgdGhlIHRlcm1pbmFsXG4gKiBzdGF0ZSwgdGhlbiBpdCBkb2VzIG5vdCBlbWl0IGEgdG9rZW4uXG4gKlxuICogVGhlIHRlbXBsYXRlIHR5cGUgVCByZXByZXNlbnRzIHRoZSB0eXBlIG9mIHRoZSB0b2tlbiB0aGlzIHN0YXRlIGFjY2VwdHMuIFRoaXNcbiAqIHNob3VsZCBiZSBhIHN0cmluZyAoc3VjaCBhcyBvZiB0aGUgdG9rZW4gZXhwb3J0cyBpbiBgdGV4dC5qc2ApIG9yIGFcbiAqIE11bHRpVG9rZW4gc3ViY2xhc3MgKGZyb20gYG11bHRpLmpzYClcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBbdG9rZW5dIFRva2VuIHRoYXQgdGhpcyBzdGF0ZSBlbWl0c1xuICovXG5mdW5jdGlvbiBTdGF0ZSh0b2tlbikge1xuICBpZiAodG9rZW4gPT09IHZvaWQgMCkge1xuICAgIHRva2VuID0gbnVsbDtcbiAgfVxuICAvLyB0aGlzLm4gPSBudWxsOyAvLyBERUJVRzogU3RhdGUgbmFtZVxuICAvKiogQHR5cGUge3sgW2lucHV0OiBzdHJpbmddOiBTdGF0ZTxUPiB9fSBqICovXG4gIHRoaXMuaiA9IHt9OyAvLyBJTVBMRU1FTlRBVElPTiAxXG4gIC8vIHRoaXMuaiA9IFtdOyAvLyBJTVBMRU1FTlRBVElPTiAyXG4gIC8qKiBAdHlwZSB7W1JlZ0V4cCwgU3RhdGU8VD5dW119IGpyICovXG4gIHRoaXMuanIgPSBbXTtcbiAgLyoqIEB0eXBlIHs/U3RhdGU8VD59IGpkICovXG4gIHRoaXMuamQgPSBudWxsO1xuICAvKiogQHR5cGUgez9UfSB0ICovXG4gIHRoaXMudCA9IHRva2VuO1xufVxuXG4vKipcbiAqIFNjYW5uZXIgdG9rZW4gZ3JvdXBzXG4gKiBAdHlwZSBDb2xsZWN0aW9uczxzdHJpbmc+XG4gKi9cblN0YXRlLmdyb3VwcyA9IHt9O1xuU3RhdGUucHJvdG90eXBlID0ge1xuICBhY2NlcHRzKCkge1xuICAgIHJldHVybiAhIXRoaXMudDtcbiAgfSxcbiAgLyoqXG4gICAqIEZvbGxvdyBhbiBleGlzdGluZyB0cmFuc2l0aW9uIGZyb20gdGhlIGdpdmVuIGlucHV0IHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKiBEb2VzIG5vdCBtdXRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBjaGFyYWN0ZXIgb3IgdG9rZW4gdHlwZSB0byB0cmFuc2l0aW9uIG9uXG4gICAqIEByZXR1cm5zIHs/U3RhdGU8VD59IHRoZSBuZXh0IHN0YXRlLCBpZiBhbnlcbiAgICovXG4gIGdvKGlucHV0KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzO1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IHN0YXRlLmpbaW5wdXRdO1xuICAgIGlmIChuZXh0U3RhdGUpIHtcbiAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuanIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlZ2V4ID0gc3RhdGUuanJbaV1bMF07XG4gICAgICBjb25zdCBuZXh0U3RhdGUgPSBzdGF0ZS5qcltpXVsxXTsgLy8gbm90ZTogbWlnaHQgYmUgZW1wdHkgdG8gcHJldmVudCBkZWZhdWx0IGp1bXBcbiAgICAgIGlmIChuZXh0U3RhdGUgJiYgcmVnZXgudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm93aGVyZSBsZWZ0IHRvIGp1bXAhIFJldHVybiBkZWZhdWx0LCBpZiBhbnlcbiAgICByZXR1cm4gc3RhdGUuamQ7XG4gIH0sXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdGF0ZSBoYXMgYSB0cmFuc2l0aW9uIGZvciB0aGUgZ2l2ZW4gaW5wdXQuIFNldCB0aGUgc2Vjb25kXG4gICAqIGFyZ3VtZW50IHRvIHRydWUgdG8gb25seSBsb29rIGZvciBhbiBleGFjdCBtYXRjaCAoYW5kIG5vdCBhIGRlZmF1bHQgb3JcbiAgICogcmVndWxhci1leHByZXNzaW9uLWJhc2VkIHRyYW5zaXRpb24pXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV4YWN0T25seVxuICAgKi9cbiAgaGFzKGlucHV0LCBleGFjdE9ubHkpIHtcbiAgICBpZiAoZXhhY3RPbmx5ID09PSB2b2lkIDApIHtcbiAgICAgIGV4YWN0T25seSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZXhhY3RPbmx5ID8gaW5wdXQgaW4gdGhpcy5qIDogISF0aGlzLmdvKGlucHV0KTtcbiAgfSxcbiAgLyoqXG4gICAqIFNob3J0IGZvciBcInRyYW5zaXRpb24gYWxsXCI7IGNyZWF0ZSBhIHRyYW5zaXRpb24gZnJvbSB0aGUgYXJyYXkgb2YgaXRlbXNcbiAgICogaW4gdGhlIGdpdmVuIGxpc3QgdG8gdGhlIHNhbWUgZmluYWwgcmVzdWx0aW5nIHN0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBpbnB1dHMgR3JvdXAgb2YgaW5wdXRzIHRvIHRyYW5zaXRpb24gb25cbiAgICogQHBhcmFtIHtUcmFuc2l0aW9uPFQ+IHwgU3RhdGU8VD59IFtuZXh0XSBUcmFuc2l0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGbGFnc30gW2ZsYWdzXSBDb2xsZWN0aW9ucyBmbGFncyB0byBhZGQgdG9rZW4gdG9cbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc10gTWFzdGVyIGxpc3Qgb2YgdG9rZW4gZ3JvdXBzXG4gICAqL1xuICB0YShpbnB1dHMsIG5leHQsIGZsYWdzLCBncm91cHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy50dChpbnB1dHNbaV0sIG5leHQsIGZsYWdzLCBncm91cHMpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFNob3J0IGZvciBcInRha2UgcmVnZXhwIHRyYW5zaXRpb25cIjsgZGVmaW5lcyBhIHRyYW5zaXRpb24gZm9yIHRoaXMgc3RhdGVcbiAgICogd2hlbiBpdCBlbmNvdW50ZXJzIGEgdG9rZW4gd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHAgUmVndWxhciBleHByZXNzaW9uIHRyYW5zaXRpb24gKHBvcHVsYXRlIGZpcnN0KVxuICAgKiBAcGFyYW0ge1QgfCBTdGF0ZTxUPn0gW25leHRdIFRyYW5zaXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdIENvbGxlY3Rpb25zIGZsYWdzIHRvIGFkZCB0b2tlbiB0b1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXSBNYXN0ZXIgbGlzdCBvZiB0b2tlbiBncm91cHNcbiAgICogQHJldHVybnMge1N0YXRlPFQ+fSB0YWtlbiBhZnRlciB0aGUgZ2l2ZW4gaW5wdXRcbiAgICovXG4gIHRyKHJlZ2V4cCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcykge1xuICAgIGdyb3VwcyA9IGdyb3VwcyB8fCBTdGF0ZS5ncm91cHM7XG4gICAgbGV0IG5leHRTdGF0ZTtcbiAgICBpZiAobmV4dCAmJiBuZXh0LmopIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRva2VuIHdpdGggbWF5YmUgdG9rZW4gZ3JvdXBzXG4gICAgICBuZXh0U3RhdGUgPSBuZXcgU3RhdGUobmV4dCk7XG4gICAgICBpZiAoZmxhZ3MgJiYgZ3JvdXBzKSB7XG4gICAgICAgIGFkZFRvR3JvdXBzKG5leHQsIGZsYWdzLCBncm91cHMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmpyLnB1c2goW3JlZ2V4cCwgbmV4dFN0YXRlXSk7XG4gICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgfSxcbiAgLyoqXG4gICAqIFNob3J0IGZvciBcInRha2UgdHJhbnNpdGlvbnNcIiwgd2lsbCB0YWtlIGFzIG1hbnkgc2VxdWVudGlhbCB0cmFuc2l0aW9ucyBhc1xuICAgKiB0aGUgbGVuZ3RoIG9mIHRoZSBnaXZlbiBpbnB1dCBhbmQgcmV0dXJucyB0aGVcbiAgICogcmVzdWx0aW5nIGZpbmFsIHN0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBpbnB1dFxuICAgKiBAcGFyYW0ge1QgfCBTdGF0ZTxUPn0gW25leHRdIFRyYW5zaXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdIENvbGxlY3Rpb25zIGZsYWdzIHRvIGFkZCB0b2tlbiB0b1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXSBNYXN0ZXIgbGlzdCBvZiB0b2tlbiBncm91cHNcbiAgICogQHJldHVybnMge1N0YXRlPFQ+fSB0YWtlbiBhZnRlciB0aGUgZ2l2ZW4gaW5wdXRcbiAgICovXG4gIHRzKGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcztcbiAgICBjb25zdCBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgIHN0YXRlID0gc3RhdGUudHQoaW5wdXRbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUudHQoaW5wdXRbbGVuIC0gMV0sIG5leHQsIGZsYWdzLCBncm91cHMpO1xuICB9LFxuICAvKipcbiAgICogU2hvcnQgZm9yIFwidGFrZSB0cmFuc2l0aW9uXCIsIHRoaXMgaXMgYSBtZXRob2QgZm9yIGJ1aWxkaW5nL3dvcmtpbmcgd2l0aFxuICAgKiBzdGF0ZSBtYWNoaW5lcy5cbiAgICpcbiAgICogSWYgYSBzdGF0ZSBhbHJlYWR5IGV4aXN0cyBmb3IgdGhlIGdpdmVuIGlucHV0LCByZXR1cm5zIGl0LlxuICAgKlxuICAgKiBJZiBhIHRva2VuIGlzIHNwZWNpZmllZCwgdGhhdCBzdGF0ZSB3aWxsIGVtaXQgdGhhdCB0b2tlbiB3aGVuIHJlYWNoZWQgYnlcbiAgICogdGhlIGxpbmtpZnkgZW5naW5lLlxuICAgKlxuICAgKiBJZiBubyBzdGF0ZSBleGlzdHMsIGl0IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBzb21lIGRlZmF1bHQgdHJhbnNpdGlvbnNcbiAgICogdGhhdCByZXNlbWJsZSBleGlzdGluZyBkZWZhdWx0IHRyYW5zaXRpb25zLlxuICAgKlxuICAgKiBJZiBhIHN0YXRlIGlzIGdpdmVuIGZvciB0aGUgc2Vjb25kIGFyZ3VtZW50LCB0aGF0IHN0YXRlIHdpbGwgYmVcbiAgICogdHJhbnNpdGlvbmVkIHRvIG9uIHRoZSBnaXZlbiBpbnB1dCByZWdhcmRsZXNzIG9mIHdoYXQgdGhhdCBpbnB1dFxuICAgKiBwcmV2aW91c2x5IGRpZC5cbiAgICpcbiAgICogU3BlY2lmeSBhIHRva2VuIGdyb3VwIGZsYWdzIHRvIGRlZmluZSBncm91cHMgdGhhdCB0aGlzIHRva2VuIGJlbG9uZ3MgdG8uXG4gICAqIFRoZSB0b2tlbiB3aWxsIGJlIGFkZGVkIHRvIGNvcnJlc3BvbmRpbmcgZW50aXJlcyBpbiB0aGUgZ2l2ZW4gZ3JvdXBzXG4gICAqIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IGNoYXJhY3RlciwgdG9rZW4gdHlwZSB0byB0cmFuc2l0aW9uIG9uXG4gICAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF0gVHJhbnNpdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc10gQ29sbGVjdGlvbnMgZmxhZ3MgdG8gYWRkIHRva2VuIHRvXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdIE1hc3RlciBsaXN0IG9mIGdyb3Vwc1xuICAgKiBAcmV0dXJucyB7U3RhdGU8VD59IHRha2VuIGFmdGVyIHRoZSBnaXZlbiBpbnB1dFxuICAgKi9cbiAgdHQoaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpIHtcbiAgICBncm91cHMgPSBncm91cHMgfHwgU3RhdGUuZ3JvdXBzO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcztcblxuICAgIC8vIENoZWNrIGlmIGV4aXN0aW5nIHN0YXRlIGdpdmVuLCBqdXN0IGEgYmFzaWMgdHJhbnNpdGlvblxuICAgIGlmIChuZXh0ICYmIG5leHQuaikge1xuICAgICAgc3RhdGUualtpbnB1dF0gPSBuZXh0O1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICAgIGNvbnN0IHQgPSBuZXh0O1xuXG4gICAgLy8gVGFrZSB0aGUgdHJhbnNpdGlvbiB3aXRoIHRoZSB1c3VhbCBkZWZhdWx0IG1lY2hhbmlzbXMgYW5kIHVzZSB0aGF0IGFzXG4gICAgLy8gYSB0ZW1wbGF0ZSBmb3IgY3JlYXRpbmcgdGhlIG5leHQgc3RhdGVcbiAgICBsZXQgbmV4dFN0YXRlLFxuICAgICAgdGVtcGxhdGVTdGF0ZSA9IHN0YXRlLmdvKGlucHV0KTtcbiAgICBpZiAodGVtcGxhdGVTdGF0ZSkge1xuICAgICAgbmV4dFN0YXRlID0gbmV3IFN0YXRlKCk7XG4gICAgICBhc3NpZ24obmV4dFN0YXRlLmosIHRlbXBsYXRlU3RhdGUuaik7XG4gICAgICBuZXh0U3RhdGUuanIucHVzaC5hcHBseShuZXh0U3RhdGUuanIsIHRlbXBsYXRlU3RhdGUuanIpO1xuICAgICAgbmV4dFN0YXRlLmpkID0gdGVtcGxhdGVTdGF0ZS5qZDtcbiAgICAgIG5leHRTdGF0ZS50ID0gdGVtcGxhdGVTdGF0ZS50O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0U3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICB9XG4gICAgaWYgKHQpIHtcbiAgICAgIC8vIEVuc3VyZSBuZXdseSB0b2tlbiBpcyBpbiB0aGUgc2FtZSBncm91cHMgYXMgdGhlIG9sZCB0b2tlblxuICAgICAgaWYgKGdyb3Vwcykge1xuICAgICAgICBpZiAobmV4dFN0YXRlLnQgJiYgdHlwZW9mIG5leHRTdGF0ZS50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IGFsbEZsYWdzID0gYXNzaWduKGZsYWdzRm9yVG9rZW4obmV4dFN0YXRlLnQsIGdyb3VwcyksIGZsYWdzKTtcbiAgICAgICAgICBhZGRUb0dyb3Vwcyh0LCBhbGxGbGFncywgZ3JvdXBzKTtcbiAgICAgICAgfSBlbHNlIGlmIChmbGFncykge1xuICAgICAgICAgIGFkZFRvR3JvdXBzKHQsIGZsYWdzLCBncm91cHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGUudCA9IHQ7IC8vIG92ZXJ3cml0ZSBhbnl0aGluZyB0aGF0IHdhcyBwcmV2aW91c2x5IHRoZXJlXG4gICAgfVxuXG4gICAgc3RhdGUualtpbnB1dF0gPSBuZXh0U3RhdGU7XG4gICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9ucyB0byBpbXByb3ZlIG1pbmlmaWNhdGlvbiAobm90IGV4cG9ydGVkIG91dHNpZGUgbGlua2lmeWpzIG1vZHVsZSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTdGF0ZTxUPn0gc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGlucHV0XG4gKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXVxuICovXG5jb25zdCB0YSA9IChzdGF0ZSwgaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpID0+IHN0YXRlLnRhKGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTdGF0ZTxUPn0gc3RhdGVcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF1cbiAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc11cbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdXG4gKi9cbmNvbnN0IHRyID0gKHN0YXRlLCByZWdleHAsIG5leHQsIGZsYWdzLCBncm91cHMpID0+IHN0YXRlLnRyKHJlZ2V4cCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7U3RhdGU8VD59IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBpbnB1dFxuICogQHBhcmFtIHtUIHwgU3RhdGU8VD59IFtuZXh0XVxuICogQHBhcmFtIHtGbGFnc30gW2ZsYWdzXVxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc11cbiAqL1xuY29uc3QgdHMgPSAoc3RhdGUsIGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKSA9PiBzdGF0ZS50cyhpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7U3RhdGU8VD59IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF1cbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdXG4gKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdXG4gKi9cbmNvbnN0IHR0ID0gKHN0YXRlLCBpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3VwcykgPT4gc3RhdGUudHQoaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5UZXh0IFRva2Vuc1xuSWRlbnRpZmllcnMgZm9yIHRva2VuIG91dHB1dHMgZnJvbSB0aGUgcmVnZXhwIHNjYW5uZXJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gQSB2YWxpZCB3ZWIgZG9tYWluIHRva2VuXG5jb25zdCBXT1JEID0gJ1dPUkQnOyAvLyBvbmx5IGNvbnRhaW5zIGEtelxuY29uc3QgVVdPUkQgPSAnVVdPUkQnOyAvLyBjb250YWlucyBsZXR0ZXJzIG90aGVyIHRoYW4gYS16LCB1c2VkIGZvciBJRE5cblxuLy8gU3BlY2lhbCBjYXNlIG9mIHdvcmRcbmNvbnN0IExPQ0FMSE9TVCA9ICdMT0NBTEhPU1QnO1xuXG4vLyBWYWxpZCB0b3AtbGV2ZWwgZG9tYWluLCBzcGVjaWFsIGNhc2Ugb2YgV09SRCAoc2VlIHRsZHMuanMpXG5jb25zdCBUTEQgPSAnVExEJztcblxuLy8gVmFsaWQgSUROIFRMRCwgc3BlY2lhbCBjYXNlIG9mIFVXT1JEIChzZWUgdGxkcy5qcylcbmNvbnN0IFVUTEQgPSAnVVRMRCc7XG5cbi8vIFRoZSBzY2hlbWUgcG9ydGlvbiBvZiBhIHdlYiBVUkkgcHJvdG9jb2wuIFN1cHBvcnRlZCB0eXBlcyBpbmNsdWRlOiBgbWFpbHRvYCxcbi8vIGBmaWxlYCwgYW5kIHVzZXItZGVmaW5lZCBjdXN0b20gcHJvdG9jb2xzLiBMaW1pdGVkIHRvIHNjaGVtZXMgdGhhdCBjb250YWluXG4vLyBvbmx5IGxldHRlcnNcbmNvbnN0IFNDSEVNRSA9ICdTQ0hFTUUnO1xuXG4vLyBTaW1pbGFyIHRvIFNDSEVNRSwgZXhjZXB0IG1ha2VzIGRpc3RpbmN0aW9uIGZvciBzY2hlbWVzIHRoYXQgbXVzdCBhbHdheXMgYmVcbi8vIGZvbGxvd2VkIGJ5IGA6Ly9gLCBub3QganVzdCBgOmAuIFN1cHBvcnRlZCB0eXBlcyBpbmNsdWRlIGBodHRwYCwgYGh0dHBzYCxcbi8vIGBmdHBgLCBgZnRwc2BcbmNvbnN0IFNMQVNIX1NDSEVNRSA9ICdTTEFTSF9TQ0hFTUUnO1xuXG4vLyBBbnkgc2VxdWVuY2Ugb2YgZGlnaXRzIDAtOVxuY29uc3QgTlVNID0gJ05VTSc7XG5cbi8vIEFueSBudW1iZXIgb2YgY29uc2VjdXRpdmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBuZXdsaW5lXG5jb25zdCBXUyA9ICdXUyc7XG5cbi8vIE5ldyBsaW5lICh1bml4IHN0eWxlKVxuY29uc3QgTkwkMSA9ICdOTCc7IC8vIFxcblxuXG4vLyBPcGVuaW5nL2Nsb3NpbmcgYnJhY2tldCBjbGFzc2VzXG4vLyBUT0RPOiBSZW5hbWUgT1BFTiAtPiBMRUZUIGFuZCBDTE9TRSAtPiBSSUdIVCBpbiB2NSB0byBmaXQgd2l0aCBVbmljb2RlIG5hbWVzXG4vLyBBbHNvIHJlbmFtZSBhbmdsZSBicmFja2VzIHRvIExFU1NUSEFOIGFuZCBHUkVBVEVSIFRIQU5cbmNvbnN0IE9QRU5CUkFDRSA9ICdPUEVOQlJBQ0UnOyAvLyB7XG5jb25zdCBDTE9TRUJSQUNFID0gJ0NMT1NFQlJBQ0UnOyAvLyB9XG5jb25zdCBPUEVOQlJBQ0tFVCA9ICdPUEVOQlJBQ0tFVCc7IC8vIFtcbmNvbnN0IENMT1NFQlJBQ0tFVCA9ICdDTE9TRUJSQUNLRVQnOyAvLyBdXG5jb25zdCBPUEVOUEFSRU4gPSAnT1BFTlBBUkVOJzsgLy8gKFxuY29uc3QgQ0xPU0VQQVJFTiA9ICdDTE9TRVBBUkVOJzsgLy8gKVxuY29uc3QgT1BFTkFOR0xFQlJBQ0tFVCA9ICdPUEVOQU5HTEVCUkFDS0VUJzsgLy8gPFxuY29uc3QgQ0xPU0VBTkdMRUJSQUNLRVQgPSAnQ0xPU0VBTkdMRUJSQUNLRVQnOyAvLyA+XG5jb25zdCBGVUxMV0lEVEhMRUZUUEFSRU4gPSAnRlVMTFdJRFRITEVGVFBBUkVOJzsgLy8gXHVGRjA4XG5jb25zdCBGVUxMV0lEVEhSSUdIVFBBUkVOID0gJ0ZVTExXSURUSFJJR0hUUEFSRU4nOyAvLyBcdUZGMDlcbmNvbnN0IExFRlRDT1JORVJCUkFDS0VUID0gJ0xFRlRDT1JORVJCUkFDS0VUJzsgLy8gXHUzMDBDXG5jb25zdCBSSUdIVENPUk5FUkJSQUNLRVQgPSAnUklHSFRDT1JORVJCUkFDS0VUJzsgLy8gXHUzMDBEXG5jb25zdCBMRUZUV0hJVEVDT1JORVJCUkFDS0VUID0gJ0xFRlRXSElURUNPUk5FUkJSQUNLRVQnOyAvLyBcdTMwMEVcbmNvbnN0IFJJR0hUV0hJVEVDT1JORVJCUkFDS0VUID0gJ1JJR0hUV0hJVEVDT1JORVJCUkFDS0VUJzsgLy8gXHUzMDBGXG5jb25zdCBGVUxMV0lEVEhMRVNTVEhBTiA9ICdGVUxMV0lEVEhMRVNTVEhBTic7IC8vIFx1RkYxQ1xuY29uc3QgRlVMTFdJRFRIR1JFQVRFUlRIQU4gPSAnRlVMTFdJRFRIR1JFQVRFUlRIQU4nOyAvLyBcdUZGMUVcblxuLy8gVmFyaW91cyBzeW1ib2xzXG5jb25zdCBBTVBFUlNBTkQgPSAnQU1QRVJTQU5EJzsgLy8gJlxuY29uc3QgQVBPU1RST1BIRSA9ICdBUE9TVFJPUEhFJzsgLy8gJ1xuY29uc3QgQVNURVJJU0sgPSAnQVNURVJJU0snOyAvLyAqXG5jb25zdCBBVCA9ICdBVCc7IC8vIEBcbmNvbnN0IEJBQ0tTTEFTSCA9ICdCQUNLU0xBU0gnOyAvLyBcXFxuY29uc3QgQkFDS1RJQ0sgPSAnQkFDS1RJQ0snOyAvLyBgXG5jb25zdCBDQVJFVCA9ICdDQVJFVCc7IC8vIF5cbmNvbnN0IENPTE9OID0gJ0NPTE9OJzsgLy8gOlxuY29uc3QgQ09NTUEgPSAnQ09NTUEnOyAvLyAsXG5jb25zdCBET0xMQVIgPSAnRE9MTEFSJzsgLy8gJFxuY29uc3QgRE9UID0gJ0RPVCc7IC8vIC5cbmNvbnN0IEVRVUFMUyA9ICdFUVVBTFMnOyAvLyA9XG5jb25zdCBFWENMQU1BVElPTiA9ICdFWENMQU1BVElPTic7IC8vICFcbmNvbnN0IEhZUEhFTiA9ICdIWVBIRU4nOyAvLyAtXG5jb25zdCBQRVJDRU5UID0gJ1BFUkNFTlQnOyAvLyAlXG5jb25zdCBQSVBFID0gJ1BJUEUnOyAvLyB8XG5jb25zdCBQTFVTID0gJ1BMVVMnOyAvLyArXG5jb25zdCBQT1VORCA9ICdQT1VORCc7IC8vICNcbmNvbnN0IFFVRVJZID0gJ1FVRVJZJzsgLy8gP1xuY29uc3QgUVVPVEUgPSAnUVVPVEUnOyAvLyBcIlxuXG5jb25zdCBTRU1JID0gJ1NFTUknOyAvLyA7XG5jb25zdCBTTEFTSCA9ICdTTEFTSCc7IC8vIC9cbmNvbnN0IFRJTERFID0gJ1RJTERFJzsgLy8gflxuY29uc3QgVU5ERVJTQ09SRSA9ICdVTkRFUlNDT1JFJzsgLy8gX1xuXG4vLyBFbW9qaSBzeW1ib2xcbmNvbnN0IEVNT0pJJDEgPSAnRU1PSkknO1xuXG4vLyBEZWZhdWx0IHRva2VuIC0gYW55dGhpbmcgdGhhdCBpcyBub3Qgb25lIG9mIHRoZSBhYm92ZVxuY29uc3QgU1lNID0gJ1NZTSc7XG5cbnZhciB0ayA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRXT1JEOiBXT1JELFxuXHRVV09SRDogVVdPUkQsXG5cdExPQ0FMSE9TVDogTE9DQUxIT1NULFxuXHRUTEQ6IFRMRCxcblx0VVRMRDogVVRMRCxcblx0U0NIRU1FOiBTQ0hFTUUsXG5cdFNMQVNIX1NDSEVNRTogU0xBU0hfU0NIRU1FLFxuXHROVU06IE5VTSxcblx0V1M6IFdTLFxuXHROTDogTkwkMSxcblx0T1BFTkJSQUNFOiBPUEVOQlJBQ0UsXG5cdENMT1NFQlJBQ0U6IENMT1NFQlJBQ0UsXG5cdE9QRU5CUkFDS0VUOiBPUEVOQlJBQ0tFVCxcblx0Q0xPU0VCUkFDS0VUOiBDTE9TRUJSQUNLRVQsXG5cdE9QRU5QQVJFTjogT1BFTlBBUkVOLFxuXHRDTE9TRVBBUkVOOiBDTE9TRVBBUkVOLFxuXHRPUEVOQU5HTEVCUkFDS0VUOiBPUEVOQU5HTEVCUkFDS0VULFxuXHRDTE9TRUFOR0xFQlJBQ0tFVDogQ0xPU0VBTkdMRUJSQUNLRVQsXG5cdEZVTExXSURUSExFRlRQQVJFTjogRlVMTFdJRFRITEVGVFBBUkVOLFxuXHRGVUxMV0lEVEhSSUdIVFBBUkVOOiBGVUxMV0lEVEhSSUdIVFBBUkVOLFxuXHRMRUZUQ09STkVSQlJBQ0tFVDogTEVGVENPUk5FUkJSQUNLRVQsXG5cdFJJR0hUQ09STkVSQlJBQ0tFVDogUklHSFRDT1JORVJCUkFDS0VULFxuXHRMRUZUV0hJVEVDT1JORVJCUkFDS0VUOiBMRUZUV0hJVEVDT1JORVJCUkFDS0VULFxuXHRSSUdIVFdISVRFQ09STkVSQlJBQ0tFVDogUklHSFRXSElURUNPUk5FUkJSQUNLRVQsXG5cdEZVTExXSURUSExFU1NUSEFOOiBGVUxMV0lEVEhMRVNTVEhBTixcblx0RlVMTFdJRFRIR1JFQVRFUlRIQU46IEZVTExXSURUSEdSRUFURVJUSEFOLFxuXHRBTVBFUlNBTkQ6IEFNUEVSU0FORCxcblx0QVBPU1RST1BIRTogQVBPU1RST1BIRSxcblx0QVNURVJJU0s6IEFTVEVSSVNLLFxuXHRBVDogQVQsXG5cdEJBQ0tTTEFTSDogQkFDS1NMQVNILFxuXHRCQUNLVElDSzogQkFDS1RJQ0ssXG5cdENBUkVUOiBDQVJFVCxcblx0Q09MT046IENPTE9OLFxuXHRDT01NQTogQ09NTUEsXG5cdERPTExBUjogRE9MTEFSLFxuXHRET1Q6IERPVCxcblx0RVFVQUxTOiBFUVVBTFMsXG5cdEVYQ0xBTUFUSU9OOiBFWENMQU1BVElPTixcblx0SFlQSEVOOiBIWVBIRU4sXG5cdFBFUkNFTlQ6IFBFUkNFTlQsXG5cdFBJUEU6IFBJUEUsXG5cdFBMVVM6IFBMVVMsXG5cdFBPVU5EOiBQT1VORCxcblx0UVVFUlk6IFFVRVJZLFxuXHRRVU9URTogUVVPVEUsXG5cdFNFTUk6IFNFTUksXG5cdFNMQVNIOiBTTEFTSCxcblx0VElMREU6IFRJTERFLFxuXHRVTkRFUlNDT1JFOiBVTkRFUlNDT1JFLFxuXHRFTU9KSTogRU1PSkkkMSxcblx0U1lNOiBTWU1cbn0pO1xuXG4vLyBOb3RlIHRoYXQgdGhlc2UgdHdvIFVuaWNvZGUgb25lcyBleHBhbmQgaW50byBhIHJlYWxseSBiaWcgb25lIHdpdGggQmFiZWxcbmNvbnN0IEFTQ0lJX0xFVFRFUiA9IC9bYS16XS87XG5jb25zdCBMRVRURVIgPSAvXFxwe0x9L3U7IC8vIEFueSBVbmljb2RlIGNoYXJhY3RlciB3aXRoIGxldHRlciBkYXRhIHR5cGVcbmNvbnN0IEVNT0pJID0gL1xccHtFbW9qaX0vdTsgLy8gQW55IFVuaWNvZGUgZW1vamkgY2hhcmFjdGVyXG5jb25zdCBFTU9KSV9WQVJJQVRJT04kMSA9IC9cXHVmZTBmLztcbmNvbnN0IERJR0lUID0gL1xcZC87XG5jb25zdCBTUEFDRSA9IC9cXHMvO1xuXG52YXIgcmVnZXhwID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdEFTQ0lJX0xFVFRFUjogQVNDSUlfTEVUVEVSLFxuXHRMRVRURVI6IExFVFRFUixcblx0RU1PSkk6IEVNT0pJLFxuXHRFTU9KSV9WQVJJQVRJT046IEVNT0pJX1ZBUklBVElPTiQxLFxuXHRESUdJVDogRElHSVQsXG5cdFNQQUNFOiBTUEFDRVxufSk7XG5cbi8qKlxuXHRUaGUgc2Nhbm5lciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdGhhdCB0YWtlcyBhIHN0cmluZyBvZiB0ZXh0IGFzIGlucHV0LCBhbmRcblx0b3V0cHV0cyBhbiBhcnJheSBvZiB0b2tlbnMgaW5zdGFuY2VzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGVhc3kgVVJMIHBhcnNpbmcuXG4qL1xuY29uc3QgTkwgPSAnXFxuJzsgLy8gTmV3IGxpbmUgY2hhcmFjdGVyXG5jb25zdCBFTU9KSV9WQVJJQVRJT04gPSAnXFx1ZmUwZic7IC8vIFZhcmlhdGlvbiBzZWxlY3RvciwgZm9sbG93cyBoZWFydCBhbmQgb3RoZXJzXG5jb25zdCBFTU9KSV9KT0lORVIgPSAnXFx1MjAwZCc7IC8vIHplcm8td2lkdGggam9pbmVyXG5cbmxldCB0bGRzID0gbnVsbCxcbiAgdXRsZHMgPSBudWxsOyAvLyBkb24ndCBjaGFuZ2Ugc28gb25seSBoYXZlIHRvIGJlIGNvbXB1dGVkIG9uY2VcblxuLyoqXG4gKiBTY2FubmVyIG91dHB1dCB0b2tlbjpcbiAqIC0gYHRgIGlzIHRoZSB0b2tlbiBuYW1lIChlLmcuLCAnTlVNJywgJ0VNT0pJJywgJ1RMRCcpXG4gKiAtIGB2YCBpcyB0aGUgdmFsdWUgb2YgdGhlIHRva2VuIChlLmcuLCAnMTIzJywgJ1x1Mjc2NFx1RkUwRicsICdjb20nKVxuICogLSBgc2AgaXMgdGhlIHN0YXJ0IGluZGV4IG9mIHRoZSB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gKiAtIGBlYCBpcyB0aGUgZW5kIGluZGV4IG9mIHRoZSB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gKiBAdHlwZWRlZiB7e3Q6IHN0cmluZywgdjogc3RyaW5nLCBzOiBudW1iZXIsIGU6IG51bWJlcn19IFRva2VuXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge3sgW2NvbGxlY3Rpb246IHN0cmluZ106IFRbXSB9fSBDb2xsZWN0aW9uc1xuICovXG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgc2Nhbm5lciBjaGFyYWN0ZXItYmFzZWQgc3RhdGUgbWFjaGluZSBmb3IgdGhlIGdpdmVuIHN0YXJ0XG4gKiBzdGF0ZVxuICogQHBhcmFtIHtbc3RyaW5nLCBib29sZWFuXVtdfSBjdXN0b21TY2hlbWVzIExpc3Qgb2YgY3VzdG9tIHNjaGVtZXMsIHdoZXJlIGVhY2hcbiAqIGl0ZW0gaXMgYSBsZW5ndGgtMiB0dXBsZSB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IHNldCB0byB0aGUgc3RyaW5nIHNjaGVtZSwgYW5kXG4gKiB0aGUgc2Vjb25kIGVsZW1lbnQgc2V0IHRvIGB0cnVlYCBpZiB0aGUgYDovL2AgYWZ0ZXIgdGhlIHNjaGVtZSBpcyBvcHRpb25hbFxuICovXG5mdW5jdGlvbiBpbml0JDIoY3VzdG9tU2NoZW1lcykge1xuICBpZiAoY3VzdG9tU2NoZW1lcyA9PT0gdm9pZCAwKSB7XG4gICAgY3VzdG9tU2NoZW1lcyA9IFtdO1xuICB9XG4gIC8vIEZyZXF1ZW50bHkgdXNlZCBzdGF0ZXMgKG5hbWUgYXJndW1lbnQgcmVtb3ZlZCBkdXJpbmcgbWluaWZpY2F0aW9uKVxuICAvKiogQHR5cGUgQ29sbGVjdGlvbnM8c3RyaW5nPiAqL1xuICBjb25zdCBncm91cHMgPSB7fTsgLy8gb2YgdG9rZW5zXG4gIFN0YXRlLmdyb3VwcyA9IGdyb3VwcztcbiAgLyoqIEB0eXBlIFN0YXRlPHN0cmluZz4gKi9cbiAgY29uc3QgU3RhcnQgPSBuZXcgU3RhdGUoKTtcbiAgaWYgKHRsZHMgPT0gbnVsbCkge1xuICAgIHRsZHMgPSBkZWNvZGVUbGRzKGVuY29kZWRUbGRzKTtcbiAgfVxuICBpZiAodXRsZHMgPT0gbnVsbCkge1xuICAgIHV0bGRzID0gZGVjb2RlVGxkcyhlbmNvZGVkVXRsZHMpO1xuICB9XG5cbiAgLy8gU3RhdGVzIGZvciBzcGVjaWFsIFVSTCBzeW1ib2xzIHRoYXQgYWNjZXB0IGltbWVkaWF0ZWx5IGFmdGVyIHN0YXJ0XG4gIHR0KFN0YXJ0LCBcIidcIiwgQVBPU1RST1BIRSk7XG4gIHR0KFN0YXJ0LCAneycsIE9QRU5CUkFDRSk7XG4gIHR0KFN0YXJ0LCAnfScsIENMT1NFQlJBQ0UpO1xuICB0dChTdGFydCwgJ1snLCBPUEVOQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAnXScsIENMT1NFQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAnKCcsIE9QRU5QQVJFTik7XG4gIHR0KFN0YXJ0LCAnKScsIENMT1NFUEFSRU4pO1xuICB0dChTdGFydCwgJzwnLCBPUEVOQU5HTEVCUkFDS0VUKTtcbiAgdHQoU3RhcnQsICc+JywgQ0xPU0VBTkdMRUJSQUNLRVQpO1xuICB0dChTdGFydCwgJ1x1RkYwOCcsIEZVTExXSURUSExFRlRQQVJFTik7XG4gIHR0KFN0YXJ0LCAnXHVGRjA5JywgRlVMTFdJRFRIUklHSFRQQVJFTik7XG4gIHR0KFN0YXJ0LCAnXHUzMDBDJywgTEVGVENPUk5FUkJSQUNLRVQpO1xuICB0dChTdGFydCwgJ1x1MzAwRCcsIFJJR0hUQ09STkVSQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAnXHUzMDBFJywgTEVGVFdISVRFQ09STkVSQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAnXHUzMDBGJywgUklHSFRXSElURUNPUk5FUkJSQUNLRVQpO1xuICB0dChTdGFydCwgJ1x1RkYxQycsIEZVTExXSURUSExFU1NUSEFOKTtcbiAgdHQoU3RhcnQsICdcdUZGMUUnLCBGVUxMV0lEVEhHUkVBVEVSVEhBTik7XG4gIHR0KFN0YXJ0LCAnJicsIEFNUEVSU0FORCk7XG4gIHR0KFN0YXJ0LCAnKicsIEFTVEVSSVNLKTtcbiAgdHQoU3RhcnQsICdAJywgQVQpO1xuICB0dChTdGFydCwgJ2AnLCBCQUNLVElDSyk7XG4gIHR0KFN0YXJ0LCAnXicsIENBUkVUKTtcbiAgdHQoU3RhcnQsICc6JywgQ09MT04pO1xuICB0dChTdGFydCwgJywnLCBDT01NQSk7XG4gIHR0KFN0YXJ0LCAnJCcsIERPTExBUik7XG4gIHR0KFN0YXJ0LCAnLicsIERPVCk7XG4gIHR0KFN0YXJ0LCAnPScsIEVRVUFMUyk7XG4gIHR0KFN0YXJ0LCAnIScsIEVYQ0xBTUFUSU9OKTtcbiAgdHQoU3RhcnQsICctJywgSFlQSEVOKTtcbiAgdHQoU3RhcnQsICclJywgUEVSQ0VOVCk7XG4gIHR0KFN0YXJ0LCAnfCcsIFBJUEUpO1xuICB0dChTdGFydCwgJysnLCBQTFVTKTtcbiAgdHQoU3RhcnQsICcjJywgUE9VTkQpO1xuICB0dChTdGFydCwgJz8nLCBRVUVSWSk7XG4gIHR0KFN0YXJ0LCAnXCInLCBRVU9URSk7XG4gIHR0KFN0YXJ0LCAnLycsIFNMQVNIKTtcbiAgdHQoU3RhcnQsICc7JywgU0VNSSk7XG4gIHR0KFN0YXJ0LCAnficsIFRJTERFKTtcbiAgdHQoU3RhcnQsICdfJywgVU5ERVJTQ09SRSk7XG4gIHR0KFN0YXJ0LCAnXFxcXCcsIEJBQ0tTTEFTSCk7XG4gIGNvbnN0IE51bSA9IHRyKFN0YXJ0LCBESUdJVCwgTlVNLCB7XG4gICAgW251bWVyaWNdOiB0cnVlXG4gIH0pO1xuICB0cihOdW0sIERJR0lULCBOdW0pO1xuXG4gIC8vIFN0YXRlIHdoaWNoIGVtaXRzIGEgd29yZCB0b2tlblxuICBjb25zdCBXb3JkID0gdHIoU3RhcnQsIEFTQ0lJX0xFVFRFUiwgV09SRCwge1xuICAgIFthc2NpaV06IHRydWVcbiAgfSk7XG4gIHRyKFdvcmQsIEFTQ0lJX0xFVFRFUiwgV29yZCk7XG5cbiAgLy8gU2FtZSBhcyBwcmV2aW91cywgYnV0IHNwZWNpZmljIHRvIG5vbi1mc20uYXNjaWkgYWxwaGFiZXQgd29yZHNcbiAgY29uc3QgVVdvcmQgPSB0cihTdGFydCwgTEVUVEVSLCBVV09SRCwge1xuICAgIFthbHBoYV06IHRydWVcbiAgfSk7XG4gIHRyKFVXb3JkLCBBU0NJSV9MRVRURVIpOyAvLyBOb24tYWNjZXB0aW5nXG4gIHRyKFVXb3JkLCBMRVRURVIsIFVXb3JkKTtcblxuICAvLyBXaGl0ZXNwYWNlIGp1bXBzXG4gIC8vIFRva2VucyBvZiBvbmx5IG5vbi1uZXdsaW5lIHdoaXRlc3BhY2UgYXJlIGFyYml0cmFyaWx5IGxvbmdcbiAgLy8gSWYgYW55IHdoaXRlc3BhY2UgZXhjZXB0IG5ld2xpbmUsIG1vcmUgd2hpdGVzcGFjZSFcbiAgY29uc3QgV3MgPSB0cihTdGFydCwgU1BBQ0UsIFdTLCB7XG4gICAgW3doaXRlc3BhY2VdOiB0cnVlXG4gIH0pO1xuICB0dChTdGFydCwgTkwsIE5MJDEsIHtcbiAgICBbd2hpdGVzcGFjZV06IHRydWVcbiAgfSk7XG4gIHR0KFdzLCBOTCk7IC8vIG5vbi1hY2NlcHRpbmcgc3RhdGUgdG8gYXZvaWQgbWl4aW5nIHdoaXRlc3BhY2VzXG4gIHRyKFdzLCBTUEFDRSwgV3MpO1xuXG4gIC8vIEVtb2ppIHRva2Vucy4gVGhleSBhcmUgbm90IGdyb3VwZWQgYnkgdGhlIHNjYW5uZXIgZXhjZXB0IGluIGNhc2VzIHdoZXJlIGFcbiAgLy8gemVyby13aWR0aCBqb2luZXIgaXMgcHJlc2VudFxuICBjb25zdCBFbW9qaSA9IHRyKFN0YXJ0LCBFTU9KSSwgRU1PSkkkMSwge1xuICAgIFtlbW9qaV06IHRydWVcbiAgfSk7XG4gIHRyKEVtb2ppLCBFTU9KSSwgRW1vamkpO1xuICB0dChFbW9qaSwgRU1PSklfVkFSSUFUSU9OLCBFbW9qaSk7XG4gIC8vIHR0KFN0YXJ0LCBFTU9KSV9WQVJJQVRJT04sIEVtb2ppKTsgLy8gVGhpcyBvbmUgaXMgc2tldGNoeVxuXG4gIGNvbnN0IEVtb2ppSm9pbmVyID0gdHQoRW1vamksIEVNT0pJX0pPSU5FUik7XG4gIHRyKEVtb2ppSm9pbmVyLCBFTU9KSSwgRW1vamkpO1xuICAvLyB0dChFbW9qaUpvaW5lciwgRU1PSklfVkFSSUFUSU9OLCBFbW9qaSk7IC8vIGFsc28gc2tldGNoeVxuXG4gIC8vIEdlbmVyYXRlcyBzdGF0ZXMgZm9yIHRvcC1sZXZlbCBkb21haW5zXG4gIC8vIE5vdGUgdGhhdCB0aGlzIGlzIG1vc3QgYWNjdXJhdGUgd2hlbiB0bGRzIGFyZSBpbiBhbHBoYWJldGljYWwgb3JkZXJcbiAgY29uc3Qgd29yZGpyID0gW1tBU0NJSV9MRVRURVIsIFdvcmRdXTtcbiAgY29uc3QgdXdvcmRqciA9IFtbQVNDSUlfTEVUVEVSLCBudWxsXSwgW0xFVFRFUiwgVVdvcmRdXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0bGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZmFzdHRzKFN0YXJ0LCB0bGRzW2ldLCBUTEQsIFdPUkQsIHdvcmRqcik7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dGxkcy5sZW5ndGg7IGkrKykge1xuICAgIGZhc3R0cyhTdGFydCwgdXRsZHNbaV0sIFVUTEQsIFVXT1JELCB1d29yZGpyKTtcbiAgfVxuICBhZGRUb0dyb3VwcyhUTEQsIHtcbiAgICB0bGQ6IHRydWUsXG4gICAgYXNjaWk6IHRydWVcbiAgfSwgZ3JvdXBzKTtcbiAgYWRkVG9Hcm91cHMoVVRMRCwge1xuICAgIHV0bGQ6IHRydWUsXG4gICAgYWxwaGE6IHRydWVcbiAgfSwgZ3JvdXBzKTtcblxuICAvLyBDb2xsZWN0IHRoZSBzdGF0ZXMgZ2VuZXJhdGVkIGJ5IGRpZmZlcmVudCBwcm90b2NvbHMuIE5PVEU6IElmIGFueSBuZXcgVExEc1xuICAvLyBnZXQgYWRkZWQgdGhhdCBhcmUgYWxzbyBwcm90b2NvbHMsIHNldCB0aGUgdG9rZW4gdG8gYmUgdGhlIHNhbWUgYXMgdGhlXG4gIC8vIHByb3RvY29sIHRvIGVuc3VyZSBwYXJzaW5nIHdvcmtzIGFzIGV4cGVjdGVkLlxuICBmYXN0dHMoU3RhcnQsICdmaWxlJywgU0NIRU1FLCBXT1JELCB3b3JkanIpO1xuICBmYXN0dHMoU3RhcnQsICdtYWlsdG8nLCBTQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGZhc3R0cyhTdGFydCwgJ2h0dHAnLCBTTEFTSF9TQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGZhc3R0cyhTdGFydCwgJ2h0dHBzJywgU0xBU0hfU0NIRU1FLCBXT1JELCB3b3JkanIpO1xuICBmYXN0dHMoU3RhcnQsICdmdHAnLCBTTEFTSF9TQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGZhc3R0cyhTdGFydCwgJ2Z0cHMnLCBTTEFTSF9TQ0hFTUUsIFdPUkQsIHdvcmRqcik7XG4gIGFkZFRvR3JvdXBzKFNDSEVNRSwge1xuICAgIHNjaGVtZTogdHJ1ZSxcbiAgICBhc2NpaTogdHJ1ZVxuICB9LCBncm91cHMpO1xuICBhZGRUb0dyb3VwcyhTTEFTSF9TQ0hFTUUsIHtcbiAgICBzbGFzaHNjaGVtZTogdHJ1ZSxcbiAgICBhc2NpaTogdHJ1ZVxuICB9LCBncm91cHMpO1xuXG4gIC8vIFJlZ2lzdGVyIGN1c3RvbSBzY2hlbWVzLiBBc3N1bWVzIGVhY2ggc2NoZW1lIGlzIGFzY2lpbnVtZXJpYyB3aXRoIGh5cGhlbnNcbiAgY3VzdG9tU2NoZW1lcyA9IGN1c3RvbVNjaGVtZXMuc29ydCgoYSwgYikgPT4gYVswXSA+IGJbMF0gPyAxIDogLTEpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGN1c3RvbVNjaGVtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzY2ggPSBjdXN0b21TY2hlbWVzW2ldWzBdO1xuICAgIGNvbnN0IG9wdGlvbmFsU2xhc2hTbGFzaCA9IGN1c3RvbVNjaGVtZXNbaV1bMV07XG4gICAgY29uc3QgZmxhZ3MgPSBvcHRpb25hbFNsYXNoU2xhc2ggPyB7XG4gICAgICBbc2NoZW1lXTogdHJ1ZVxuICAgIH0gOiB7XG4gICAgICBbc2xhc2hzY2hlbWVdOiB0cnVlXG4gICAgfTtcbiAgICBpZiAoc2NoLmluZGV4T2YoJy0nKSA+PSAwKSB7XG4gICAgICBmbGFnc1tkb21haW5dID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFBU0NJSV9MRVRURVIudGVzdChzY2gpKSB7XG4gICAgICBmbGFnc1tudW1lcmljXSA9IHRydWU7IC8vIG51bWJlcnMgb25seVxuICAgIH0gZWxzZSBpZiAoRElHSVQudGVzdChzY2gpKSB7XG4gICAgICBmbGFnc1thc2NpaW51bWVyaWNdID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxhZ3NbYXNjaWldID0gdHJ1ZTtcbiAgICB9XG4gICAgdHMoU3RhcnQsIHNjaCwgc2NoLCBmbGFncyk7XG4gIH1cblxuICAvLyBMb2NhbGhvc3QgdG9rZW5cbiAgdHMoU3RhcnQsICdsb2NhbGhvc3QnLCBMT0NBTEhPU1QsIHtcbiAgICBhc2NpaTogdHJ1ZVxuICB9KTtcblxuICAvLyBTZXQgZGVmYXVsdCB0cmFuc2l0aW9uIGZvciBzdGFydCBzdGF0ZSAoc29tZSBzeW1ib2wpXG4gIFN0YXJ0LmpkID0gbmV3IFN0YXRlKFNZTSk7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IFN0YXJ0LFxuICAgIHRva2VuczogYXNzaWduKHtcbiAgICAgIGdyb3Vwc1xuICAgIH0sIHRrKVxuICB9O1xufVxuXG4vKipcblx0R2l2ZW4gYSBzdHJpbmcsIHJldHVybnMgYW4gYXJyYXkgb2YgVE9LRU4gaW5zdGFuY2VzIHJlcHJlc2VudGluZyB0aGVcblx0Y29tcG9zaXRpb24gb2YgdGhhdCBzdHJpbmcuXG5cblx0QG1ldGhvZCBydW5cblx0QHBhcmFtIHtTdGF0ZTxzdHJpbmc+fSBzdGFydCBzY2FubmVyIHN0YXJ0aW5nIHN0YXRlXG5cdEBwYXJhbSB7c3RyaW5nfSBzdHIgaW5wdXQgc3RyaW5nIHRvIHNjYW5cblx0QHJldHVybiB7VG9rZW5bXX0gbGlzdCBvZiB0b2tlbnMsIGVhY2ggd2l0aCBhIHR5cGUgYW5kIHZhbHVlXG4qL1xuZnVuY3Rpb24gcnVuJDEoc3RhcnQsIHN0cikge1xuICAvLyBTdGF0ZSBtYWNoaW5lIGlzIG5vdCBjYXNlIHNlbnNpdGl2ZSwgc28gaW5wdXQgaXMgdG9rZW5pemVkIGluIGxvd2VyY2FzZWRcbiAgLy8gZm9ybSAoc3RpbGwgcmV0dXJucyByZWd1bGFyIGNhc2UpLiBVc2VzIHNlbGVjdGl2ZSBgdG9Mb3dlckNhc2VgIGJlY2F1c2VcbiAgLy8gbG93ZXJjYXNpbmcgdGhlIGVudGlyZSBzdHJpbmcgY2F1c2VzIHRoZSBsZW5ndGggYW5kIGNoYXJhY3RlciBwb3NpdGlvbiB0b1xuICAvLyB2YXJ5IGluIHNvbWUgbm9uLUVuZ2xpc2ggc3RyaW5ncyB3aXRoIFY4LWJhc2VkIHJ1bnRpbWVzLlxuICBjb25zdCBpdGVyYWJsZSA9IHN0cmluZ1RvQXJyYXkoc3RyLnJlcGxhY2UoL1tBLVpdL2csIGMgPT4gYy50b0xvd2VyQ2FzZSgpKSk7XG4gIGNvbnN0IGNoYXJDb3VudCA9IGl0ZXJhYmxlLmxlbmd0aDsgLy8gPD0gbGVuIGlmIHRoZXJlIGFyZSBlbW9qaXMsIGV0Y1xuICBjb25zdCB0b2tlbnMgPSBbXTsgLy8gcmV0dXJuIHZhbHVlXG5cbiAgLy8gY3Vyc29yIHRocm91Z2ggdGhlIHN0cmluZyBpdHNlbGYsIGFjY291bnRpbmcgZm9yIGNoYXJhY3RlcnMgdGhhdCBoYXZlXG4gIC8vIHdpZHRoIHdpdGggbGVuZ3RoIDIgc3VjaCBhcyBlbW9qaXNcbiAgbGV0IGN1cnNvciA9IDA7XG5cbiAgLy8gQ3Vyc29yIHRocm91Z2ggdGhlIGFycmF5LXJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdHJpbmdcbiAgbGV0IGNoYXJDdXJzb3IgPSAwO1xuXG4gIC8vIFRva2VuaXplIHRoZSBzdHJpbmdcbiAgd2hpbGUgKGNoYXJDdXJzb3IgPCBjaGFyQ291bnQpIHtcbiAgICBsZXQgc3RhdGUgPSBzdGFydDtcbiAgICBsZXQgbmV4dFN0YXRlID0gbnVsbDtcbiAgICBsZXQgdG9rZW5MZW5ndGggPSAwO1xuICAgIGxldCBsYXRlc3RBY2NlcHRpbmcgPSBudWxsO1xuICAgIGxldCBzaW5jZUFjY2VwdHMgPSAtMTtcbiAgICBsZXQgY2hhcnNTaW5jZUFjY2VwdHMgPSAtMTtcbiAgICB3aGlsZSAoY2hhckN1cnNvciA8IGNoYXJDb3VudCAmJiAobmV4dFN0YXRlID0gc3RhdGUuZ28oaXRlcmFibGVbY2hhckN1cnNvcl0pKSkge1xuICAgICAgc3RhdGUgPSBuZXh0U3RhdGU7XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxhdGVzdCBhY2NlcHRpbmcgc3RhdGVcbiAgICAgIGlmIChzdGF0ZS5hY2NlcHRzKCkpIHtcbiAgICAgICAgc2luY2VBY2NlcHRzID0gMDtcbiAgICAgICAgY2hhcnNTaW5jZUFjY2VwdHMgPSAwO1xuICAgICAgICBsYXRlc3RBY2NlcHRpbmcgPSBzdGF0ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2luY2VBY2NlcHRzID49IDApIHtcbiAgICAgICAgc2luY2VBY2NlcHRzICs9IGl0ZXJhYmxlW2NoYXJDdXJzb3JdLmxlbmd0aDtcbiAgICAgICAgY2hhcnNTaW5jZUFjY2VwdHMrKztcbiAgICAgIH1cbiAgICAgIHRva2VuTGVuZ3RoICs9IGl0ZXJhYmxlW2NoYXJDdXJzb3JdLmxlbmd0aDtcbiAgICAgIGN1cnNvciArPSBpdGVyYWJsZVtjaGFyQ3Vyc29yXS5sZW5ndGg7XG4gICAgICBjaGFyQ3Vyc29yKys7XG4gICAgfVxuXG4gICAgLy8gUm9sbCBiYWNrIHRvIHRoZSBsYXRlc3QgYWNjZXB0aW5nIHN0YXRlXG4gICAgY3Vyc29yIC09IHNpbmNlQWNjZXB0cztcbiAgICBjaGFyQ3Vyc29yIC09IGNoYXJzU2luY2VBY2NlcHRzO1xuICAgIHRva2VuTGVuZ3RoIC09IHNpbmNlQWNjZXB0cztcblxuICAgIC8vIE5vIG1vcmUganVtcHMsIGp1c3QgbWFrZSBhIG5ldyB0b2tlbiBmcm9tIHRoZSBsYXN0IGFjY2VwdGluZyBvbmVcbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICB0OiBsYXRlc3RBY2NlcHRpbmcudCxcbiAgICAgIC8vIHRva2VuIHR5cGUvbmFtZVxuICAgICAgdjogc3RyLnNsaWNlKGN1cnNvciAtIHRva2VuTGVuZ3RoLCBjdXJzb3IpLFxuICAgICAgLy8gc3RyaW5nIHZhbHVlXG4gICAgICBzOiBjdXJzb3IgLSB0b2tlbkxlbmd0aCxcbiAgICAgIC8vIHN0YXJ0IGluZGV4XG4gICAgICBlOiBjdXJzb3IgLy8gZW5kIGluZGV4IChleGNsdWRpbmcpXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBTdHJpbmcgdG8gYW4gQXJyYXkgb2YgY2hhcmFjdGVycywgdGFraW5nIGludG8gYWNjb3VudCB0aGF0IHNvbWVcbiAqIGNoYXJhY3RlcnMgbGlrZSBlbW9qaXMgdGFrZSB1cCB0d28gc3RyaW5nIGluZGV4ZXMuXG4gKlxuICogQWRhcHRlZCBmcm9tIGNvcmUtanMgKE1JVCBsaWNlbnNlKVxuICogaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi8yZDY5Y2Y1Zjk5YWIzZWEzNDYzYzM5NWRmODFlNWExNWI2OGY0OWQ5L3BhY2thZ2VzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy1tdWx0aWJ5dGUuanNcbiAqXG4gKiBAZnVuY3Rpb24gc3RyaW5nVG9BcnJheVxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybnMge3N0cmluZ1tdfVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcbiAgbGV0IGluZGV4ID0gMDtcbiAgd2hpbGUgKGluZGV4IDwgbGVuKSB7XG4gICAgbGV0IGZpcnN0ID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIGxldCBzZWNvbmQ7XG4gICAgbGV0IGNoYXIgPSBmaXJzdCA8IDB4ZDgwMCB8fCBmaXJzdCA+IDB4ZGJmZiB8fCBpbmRleCArIDEgPT09IGxlbiB8fCAoc2Vjb25kID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKSkgPCAweGRjMDAgfHwgc2Vjb25kID4gMHhkZmZmID8gc3RyW2luZGV4XSAvLyBzaW5nbGUgY2hhcmFjdGVyXG4gICAgOiBzdHIuc2xpY2UoaW5kZXgsIGluZGV4ICsgMik7IC8vIHR3by1pbmRleCBjaGFyYWN0ZXJzXG4gICAgcmVzdWx0LnB1c2goY2hhcik7XG4gICAgaW5kZXggKz0gY2hhci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBGYXN0IHZlcnNpb24gb2YgdHMgZnVuY3Rpb24gZm9yIHdoZW4gdHJhbnNpdGlvbiBkZWZhdWx0cyBhcmUgd2VsbCBrbm93blxuICogQHBhcmFtIHtTdGF0ZTxzdHJpbmc+fSBzdGF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcGFyYW0ge3N0cmluZ30gdFxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHR0XG4gKiBAcGFyYW0ge1tSZWdFeHAsIFN0YXRlPHN0cmluZz5dW119IGpyXG4gKiBAcmV0dXJucyB7U3RhdGU8c3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZmFzdHRzKHN0YXRlLCBpbnB1dCwgdCwgZGVmYXVsdHQsIGpyKSB7XG4gIGxldCBuZXh0O1xuICBjb25zdCBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IGlucHV0W2ldO1xuICAgIGlmIChzdGF0ZS5qW2NoYXJdKSB7XG4gICAgICBuZXh0ID0gc3RhdGUualtjaGFyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dCA9IG5ldyBTdGF0ZShkZWZhdWx0dCk7XG4gICAgICBuZXh0LmpyID0ganIuc2xpY2UoKTtcbiAgICAgIHN0YXRlLmpbY2hhcl0gPSBuZXh0O1xuICAgIH1cbiAgICBzdGF0ZSA9IG5leHQ7XG4gIH1cbiAgbmV4dCA9IG5ldyBTdGF0ZSh0KTtcbiAgbmV4dC5qciA9IGpyLnNsaWNlKCk7XG4gIHN0YXRlLmpbaW5wdXRbbGVuIC0gMV1dID0gbmV4dDtcbiAgcmV0dXJuIG5leHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVG9wLUxldmVsIERvbWFpbiBuYW1lcyBlbmNvZGVkIGluIHVwZGF0ZS10bGRzLmpzIGJhY2tcbiAqIGludG8gYSBsaXN0IG9mIHN0cmluZ3MuXG4gKiBAcGFyYW0ge3N0cn0gZW5jb2RlZCBlbmNvZGVkIFRMRHMgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyW119IG9yaWdpbmFsIFRMRHMgbGlzdFxuICovXG5mdW5jdGlvbiBkZWNvZGVUbGRzKGVuY29kZWQpIHtcbiAgY29uc3Qgd29yZHMgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgbGV0IGkgPSAwO1xuICBsZXQgZGlnaXRzID0gJzAxMjM0NTY3ODknO1xuICB3aGlsZSAoaSA8IGVuY29kZWQubGVuZ3RoKSB7XG4gICAgbGV0IHBvcERpZ2l0Q291bnQgPSAwO1xuICAgIHdoaWxlIChkaWdpdHMuaW5kZXhPZihlbmNvZGVkW2kgKyBwb3BEaWdpdENvdW50XSkgPj0gMCkge1xuICAgICAgcG9wRGlnaXRDb3VudCsrOyAvLyBlbmNvdW50ZXJlZCBzb21lIGRpZ2l0cywgaGF2ZSB0byBwb3AgdG8gZ28gb25lIGxldmVsIHVwIHRyaWVcbiAgICB9XG5cbiAgICBpZiAocG9wRGlnaXRDb3VudCA+IDApIHtcbiAgICAgIHdvcmRzLnB1c2goc3RhY2suam9pbignJykpOyAvLyB3aGF0ZXZlciBwcmVjZWRlZCB0aGUgcG9wIGRpZ2l0cyBtdXN0IGJlIGEgd29yZFxuICAgICAgZm9yIChsZXQgcG9wQ291bnQgPSBwYXJzZUludChlbmNvZGVkLnN1YnN0cmluZyhpLCBpICsgcG9wRGlnaXRDb3VudCksIDEwKTsgcG9wQ291bnQgPiAwOyBwb3BDb3VudC0tKSB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgfVxuICAgICAgaSArPSBwb3BEaWdpdENvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFjay5wdXNoKGVuY29kZWRbaV0pOyAvLyBkcm9wIGRvd24gYSBsZXZlbCBpbnRvIHRoZSB0cmllXG4gICAgICBpKys7XG4gICAgfVxuICB9XG4gIHJldHVybiB3b3Jkcztcbn1cblxuLyoqXG4gKiBBbiBvYmplY3Qgd2hlcmUgZWFjaCBrZXkgaXMgYSB2YWxpZCBET00gRXZlbnQgTmFtZSBzdWNoIGFzIGBjbGlja2Agb3IgYGZvY3VzYFxuICogYW5kIGVhY2ggdmFsdWUgaXMgYW4gZXZlbnQgaGFuZGxlciBmdW5jdGlvbi5cbiAqXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudCNldmVudHNcbiAqIEB0eXBlZGVmIHs/eyBbZXZlbnQ6IHN0cmluZ106IEZ1bmN0aW9uIH19IEV2ZW50TGlzdGVuZXJzXG4gKi9cblxuLyoqXG4gKiBBbGwgZm9ybWF0dGVkIHByb3BlcnRpZXMgcmVxdWlyZWQgdG8gcmVuZGVyIGEgbGluaywgaW5jbHVkaW5nIGB0YWdOYW1lYCxcbiAqIGBhdHRyaWJ1dGVzYCwgYGNvbnRlbnRgIGFuZCBgZXZlbnRMaXN0ZW5lcnNgLlxuICogQHR5cGVkZWYge3sgdGFnTmFtZTogYW55LCBhdHRyaWJ1dGVzOiB7W2F0dHI6IHN0cmluZ106IGFueX0sIGNvbnRlbnQ6IHN0cmluZyxcbiAqIGV2ZW50TGlzdGVuZXJzOiBFdmVudExpc3RlbmVycyB9fSBJbnRlcm1lZGlhdGVSZXByZXNlbnRhdGlvblxuICovXG5cbi8qKlxuICogU3BlY2lmeSBlaXRoZXIgYW4gb2JqZWN0IGRlc2NyaWJlZCBieSB0aGUgdGVtcGxhdGUgdHlwZSBgT2Agb3IgYSBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gdGFrZXMgYSBzdHJpbmcgdmFsdWUgKHVzdWFsbHkgdGhlIGxpbmsncyBocmVmIGF0dHJpYnV0ZSksIHRoZVxuICogbGluayB0eXBlIChgJ3VybCdgLCBgJ2hhc2h0YWdgJywgZXRjLikgYW5kIGFuIGludGVybmFsIHRva2VuIHJlcHJlc2VudGF0aW9uXG4gKiBvZiB0aGUgbGluay4gSXQgc2hvdWxkIHJldHVybiBhbiBvYmplY3Qgb2YgdGhlIHRlbXBsYXRlIHR5cGUgYE9gXG4gKiBAdGVtcGxhdGUgT1xuICogQHR5cGVkZWYge08gfCAoKHZhbHVlOiBzdHJpbmcsIHR5cGU6IHN0cmluZywgdG9rZW46IE11bHRpVG9rZW4pID0+IE8pfSBPcHRPYmpcbiAqL1xuXG4vKipcbiAqIFNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gZGVzY3JpYmVkIGJ5IHRlbXBsYXRlIHR5cGUgYEZgIG9yIGFuIG9iamVjdC5cbiAqXG4gKiBFYWNoIGtleSBpbiB0aGUgb2JqZWN0IHNob3VsZCBiZSBhIGxpbmsgdHlwZSAoYCd1cmwnYCwgYCdoYXNodGFnYCcsIGV0Yy4pLiBFYWNoXG4gKiB2YWx1ZSBzaG91bGQgYmUgYSBmdW5jdGlvbiB3aXRoIHRlbXBsYXRlIHR5cGUgYEZgIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlXG4gKiBjb3JyZXNwb25kaW5nIGxpbmsgdHlwZSBpcyBlbmNvdW50ZXJlZC5cbiAqIEB0ZW1wbGF0ZSBGXG4gKiBAdHlwZWRlZiB7RiB8IHsgW3R5cGU6IHN0cmluZ106IEZ9fSBPcHRGblxuICovXG5cbi8qKlxuICogU3BlY2lmeSBlaXRoZXIgYSB2YWx1ZSB3aXRoIHRlbXBsYXRlIHR5cGUgYFZgLCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgVmAgb3JcbiAqIGFuIG9iamVjdCB3aGVyZSBlYWNoIHZhbHVlIHJlc29sdmVzIHRvIGBWYC5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gdGFrZXMgYSBzdHJpbmcgdmFsdWUgKHVzdWFsbHkgdGhlIGxpbmsncyBocmVmIGF0dHJpYnV0ZSksIHRoZVxuICogbGluayB0eXBlIChgJ3VybCdgLCBgJ2hhc2h0YWdgJywgZXRjLikgYW5kIGFuIGludGVybmFsIHRva2VuIHJlcHJlc2VudGF0aW9uXG4gKiBvZiB0aGUgbGluay4gSXQgc2hvdWxkIHJldHVybiBhbiBvYmplY3Qgb2YgdGhlIHRlbXBsYXRlIHR5cGUgYFZgXG4gKlxuICogRm9yIHRoZSBvYmplY3QsIGVhY2gga2V5IHNob3VsZCBiZSBhIGxpbmsgdHlwZSAoYCd1cmwnYCwgYCdoYXNodGFnYCcsIGV0Yy4pLlxuICogRWFjaCB2YWx1ZSBzaG91bGQgZWl0aGVyIGhhdmUgdHlwZSBgVmAgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgVi4gVGhpc1xuICogZnVuY3Rpb24gc2ltaWxhcmx5IHRha2VzIGEgc3RyaW5nIHZhbHVlIGFuZCBhIHRva2VuLlxuICpcbiAqIEV4YW1wbGUgdmFsaWQgdHlwZXMgZm9yIGBPcHQ8c3RyaW5nPmA6XG4gKlxuICogYGBganNcbiAqICdoZWxsbydcbiAqICh2YWx1ZSwgdHlwZSwgdG9rZW4pID0+ICd3b3JsZCdcbiAqIHsgdXJsOiAnaGVsbG8nLCBlbWFpbDogKHZhbHVlLCB0b2tlbikgPT4gJ3dvcmxkJ31cbiAqIGBgYFxuICogQHRlbXBsYXRlIFZcbiAqIEB0eXBlZGVmIHtWIHwgKCh2YWx1ZTogc3RyaW5nLCB0eXBlOiBzdHJpbmcsIHRva2VuOiBNdWx0aVRva2VuKSA9PiBWKSB8IHsgW3R5cGU6IHN0cmluZ106IFYgfCAoKHZhbHVlOiBzdHJpbmcsIHRva2VuOiBNdWx0aVRva2VuKSA9PiBWKSB9fSBPcHRcbiAqL1xuXG4vKipcbiAqIFNlZSBhdmFpbGFibGUgb3B0aW9uczogaHR0cHM6Ly9saW5raWZ5LmpzLm9yZy9kb2NzL29wdGlvbnMuaHRtbFxuICogQHR5cGVkZWYge3tcbiAqIFx0ZGVmYXVsdFByb3RvY29sPzogc3RyaW5nLFxuICogIGV2ZW50cz86IE9wdE9iajxFdmVudExpc3RlbmVycz4sXG4gKiBcdGZvcm1hdD86IE9wdDxzdHJpbmc+LFxuICogXHRmb3JtYXRIcmVmPzogT3B0PHN0cmluZz4sXG4gKiBcdG5sMmJyPzogYm9vbGVhbixcbiAqIFx0dGFnTmFtZT86IE9wdDxhbnk+LFxuICogXHR0YXJnZXQ/OiBPcHQ8c3RyaW5nPixcbiAqIFx0cmVsPzogT3B0PHN0cmluZz4sXG4gKiBcdHZhbGlkYXRlPzogT3B0PGJvb2xlYW4+LFxuICogXHR0cnVuY2F0ZT86IE9wdDxudW1iZXI+LFxuICogXHRjbGFzc05hbWU/OiBPcHQ8c3RyaW5nPixcbiAqIFx0YXR0cmlidXRlcz86IE9wdE9iajwoeyBbYXR0cjogc3RyaW5nXTogYW55IH0pPixcbiAqICBpZ25vcmVUYWdzPzogc3RyaW5nW10sXG4gKiBcdHJlbmRlcj86IE9wdEZuPCgoaXI6IEludGVybWVkaWF0ZVJlcHJlc2VudGF0aW9uKSA9PiBhbnkpPlxuICogfX0gT3B0c1xuICovXG5cbi8qKlxuICogQHR5cGUgUmVxdWlyZWQ8T3B0cz5cbiAqL1xuY29uc3QgZGVmYXVsdHMgPSB7XG4gIGRlZmF1bHRQcm90b2NvbDogJ2h0dHAnLFxuICBldmVudHM6IG51bGwsXG4gIGZvcm1hdDogbm9vcCxcbiAgZm9ybWF0SHJlZjogbm9vcCxcbiAgbmwyYnI6IGZhbHNlLFxuICB0YWdOYW1lOiAnYScsXG4gIHRhcmdldDogbnVsbCxcbiAgcmVsOiBudWxsLFxuICB2YWxpZGF0ZTogdHJ1ZSxcbiAgdHJ1bmNhdGU6IEluZmluaXR5LFxuICBjbGFzc05hbWU6IG51bGwsXG4gIGF0dHJpYnV0ZXM6IG51bGwsXG4gIGlnbm9yZVRhZ3M6IFtdLFxuICByZW5kZXI6IG51bGxcbn07XG5cbi8qKlxuICogVXRpbGl0eSBjbGFzcyBmb3IgbGlua2lmeSBpbnRlcmZhY2VzIHRvIGFwcGx5IHNwZWNpZmllZFxuICoge0BsaW5rIE9wdHMgZm9ybWF0dGluZyBhbmQgcmVuZGVyaW5nIG9wdGlvbnN9LlxuICpcbiAqIEBwYXJhbSB7T3B0cyB8IE9wdGlvbnN9IFtvcHRzXSBPcHRpb24gdmFsdWUgb3ZlcnJpZGVzLlxuICogQHBhcmFtIHsoaXI6IEludGVybWVkaWF0ZVJlcHJlc2VudGF0aW9uKSA9PiBhbnl9IFtkZWZhdWx0UmVuZGVyXSAoRm9yXG4gKiAgIGludGVybmFsIHVzZSkgZGVmYXVsdCByZW5kZXIgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIGhvdyB0byBnZW5lcmF0ZSBhblxuICogICBIVE1MIGVsZW1lbnQgYmFzZWQgb24gYSBsaW5rIHRva2VuJ3MgZGVyaXZlZCB0YWdOYW1lLCBhdHRyaWJ1dGVzIGFuZCBIVE1MLlxuICogICBTaW1pbGFyIHRvIHJlbmRlciBvcHRpb25cbiAqL1xuZnVuY3Rpb24gT3B0aW9ucyhvcHRzLCBkZWZhdWx0UmVuZGVyKSB7XG4gIGlmIChkZWZhdWx0UmVuZGVyID09PSB2b2lkIDApIHtcbiAgICBkZWZhdWx0UmVuZGVyID0gbnVsbDtcbiAgfVxuICBsZXQgbyA9IGFzc2lnbih7fSwgZGVmYXVsdHMpO1xuICBpZiAob3B0cykge1xuICAgIG8gPSBhc3NpZ24obywgb3B0cyBpbnN0YW5jZW9mIE9wdGlvbnMgPyBvcHRzLm8gOiBvcHRzKTtcbiAgfVxuXG4gIC8vIEVuc3VyZSBhbGwgaWdub3JlZCB0YWdzIGFyZSB1cHBlcmNhc2VcbiAgY29uc3QgaWdub3JlZFRhZ3MgPSBvLmlnbm9yZVRhZ3M7XG4gIGNvbnN0IHVwcGVyY2FzZUlnbm9yZWRUYWdzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWdub3JlZFRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB1cHBlcmNhc2VJZ25vcmVkVGFncy5wdXNoKGlnbm9yZWRUYWdzW2ldLnRvVXBwZXJDYXNlKCkpO1xuICB9XG4gIC8qKiBAcHJvdGVjdGVkICovXG4gIHRoaXMubyA9IG87XG4gIGlmIChkZWZhdWx0UmVuZGVyKSB7XG4gICAgdGhpcy5kZWZhdWx0UmVuZGVyID0gZGVmYXVsdFJlbmRlcjtcbiAgfVxuICB0aGlzLmlnbm9yZVRhZ3MgPSB1cHBlcmNhc2VJZ25vcmVkVGFncztcbn1cbk9wdGlvbnMucHJvdG90eXBlID0ge1xuICBvOiBkZWZhdWx0cyxcbiAgLyoqXG4gICAqIEB0eXBlIHN0cmluZ1tdXG4gICAqL1xuICBpZ25vcmVUYWdzOiBbXSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7SW50ZXJtZWRpYXRlUmVwcmVzZW50YXRpb259IGlyXG4gICAqIEByZXR1cm5zIHthbnl9XG4gICAqL1xuICBkZWZhdWx0UmVuZGVyKGlyKSB7XG4gICAgcmV0dXJuIGlyO1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGJhc2VkIG9uIHdoZXRoZXIgYSB0b2tlbiBzaG91bGQgYmUgZGlzcGxheWVkIGFzIGFcbiAgICogbGluayBiYXNlZCBvbiB0aGUgdXNlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge011bHRpVG9rZW59IHRva2VuXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY2hlY2sodG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3ZhbGlkYXRlJywgdG9rZW4udG9TdHJpbmcoKSwgdG9rZW4pO1xuICB9LFxuICAvLyBQcml2YXRlIG1ldGhvZHNcblxuICAvKipcbiAgICogUmVzb2x2ZSBhbiBvcHRpb24ncyB2YWx1ZSBiYXNlZCBvbiB0aGUgdmFsdWUgb2YgdGhlIG9wdGlvbiBhbmQgdGhlIGdpdmVuXG4gICAqIHBhcmFtcy4gSWYgb3BlcmF0b3IgYW5kIHRva2VuIGFyZSBzcGVjaWZpZWQgYW5kIHRoZSB0YXJnZXQgb3B0aW9uIGlzXG4gICAqIGNhbGxhYmxlLCBhdXRvbWF0aWNhbGx5IGNhbGxzIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudC5cbiAgICogQHRlbXBsYXRlIHtrZXlvZiBPcHRzfSBLXG4gICAqIEBwYXJhbSB7S30ga2V5IE5hbWUgb2Ygb3B0aW9uIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wZXJhdG9yXSB3aWxsIGJlIHBhc3NlZCB0byB0aGUgdGFyZ2V0IG9wdGlvbiBpZiBpdCdzIGFcbiAgICogZnVuY3Rpb24uIElmIG5vdCBzcGVjaWZpZWQsIFJBVyBmdW5jdGlvbiB2YWx1ZSBnZXRzIHJldHVybmVkXG4gICAqIEBwYXJhbSB7TXVsdGlUb2tlbn0gW3Rva2VuXSBUaGUgdG9rZW4gZnJvbSBsaW5raWZ5LnRva2VuaXplXG4gICAqIEByZXR1cm5zIHtPcHRzW0tdIHwgYW55fVxuICAgKi9cbiAgZ2V0KGtleSwgb3BlcmF0b3IsIHRva2VuKSB7XG4gICAgY29uc3QgaXNDYWxsYWJsZSA9IG9wZXJhdG9yICE9IG51bGw7XG4gICAgbGV0IG9wdGlvbiA9IHRoaXMub1trZXldO1xuICAgIGlmICghb3B0aW9uKSB7XG4gICAgICByZXR1cm4gb3B0aW9uO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbiA9IHRva2VuLnQgaW4gb3B0aW9uID8gb3B0aW9uW3Rva2VuLnRdIDogZGVmYXVsdHNba2V5XTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnZnVuY3Rpb24nICYmIGlzQ2FsbGFibGUpIHtcbiAgICAgICAgb3B0aW9uID0gb3B0aW9uKG9wZXJhdG9yLCB0b2tlbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnZnVuY3Rpb24nICYmIGlzQ2FsbGFibGUpIHtcbiAgICAgIG9wdGlvbiA9IG9wdGlvbihvcGVyYXRvciwgdG9rZW4udCwgdG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uO1xuICB9LFxuICAvKipcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBPcHRzfSBMXG4gICAqIEBwYXJhbSB7TH0ga2V5IE5hbWUgb2Ygb3B0aW9ucyBvYmplY3QgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3BlcmF0b3JdXG4gICAqIEBwYXJhbSB7TXVsdGlUb2tlbn0gW3Rva2VuXVxuICAgKiBAcmV0dXJucyB7T3B0c1tMXSB8IGFueX1cbiAgICovXG4gIGdldE9iaihrZXksIG9wZXJhdG9yLCB0b2tlbikge1xuICAgIGxldCBvYmogPSB0aGlzLm9ba2V5XTtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyAmJiBvcGVyYXRvciAhPSBudWxsKSB7XG4gICAgICBvYmogPSBvYmoob3BlcmF0b3IsIHRva2VuLnQsIHRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfSxcbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIGdpdmVuIHRva2VuIHRvIGEgcmVuZGVyZWQgZWxlbWVudCB0aGF0IG1heSBiZSBhZGRlZCB0byB0aGVcbiAgICogY2FsbGluZy1pbnRlcmZhY2UncyBET01cbiAgICogQHBhcmFtIHtNdWx0aVRva2VufSB0b2tlbiBUb2tlbiB0byByZW5kZXIgdG8gYW4gSFRNTCBlbGVtZW50XG4gICAqIEByZXR1cm5zIHthbnl9IFJlbmRlciByZXN1bHQ7IGUuZy4sIEhUTUwgc3RyaW5nLCBET00gZWxlbWVudCwgUmVhY3RcbiAgICogICBDb21wb25lbnQsIGV0Yy5cbiAgICovXG4gIHJlbmRlcih0b2tlbikge1xuICAgIGNvbnN0IGlyID0gdG9rZW4ucmVuZGVyKHRoaXMpOyAvLyBpbnRlcm1lZGlhdGUgcmVwcmVzZW50YXRpb25cbiAgICBjb25zdCByZW5kZXJGbiA9IHRoaXMuZ2V0KCdyZW5kZXInLCBudWxsLCB0b2tlbikgfHwgdGhpcy5kZWZhdWx0UmVuZGVyO1xuICAgIHJldHVybiByZW5kZXJGbihpciwgdG9rZW4udCwgdG9rZW4pO1xuICB9XG59O1xuZnVuY3Rpb24gbm9vcCh2YWwpIHtcbiAgcmV0dXJuIHZhbDtcbn1cblxudmFyIG9wdGlvbnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0ZGVmYXVsdHM6IGRlZmF1bHRzLFxuXHRPcHRpb25zOiBPcHRpb25zLFxuXHRhc3NpZ246IGFzc2lnblxufSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0TXVsdGktVG9rZW5zXG5cdFRva2VucyBjb21wb3NlZCBvZiBhcnJheXMgb2YgVGV4dFRva2Vuc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtUb2tlbltdfSB0b2tlbnNcbiAqL1xuZnVuY3Rpb24gTXVsdGlUb2tlbih2YWx1ZSwgdG9rZW5zKSB7XG4gIHRoaXMudCA9ICd0b2tlbic7XG4gIHRoaXMudiA9IHZhbHVlO1xuICB0aGlzLnRrID0gdG9rZW5zO1xufVxuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHVzZWQgZm9yIG1hbnVmYWN0dXJpbmcgdG9rZW5zIG9mIHRleHQgdG9rZW5zLiBUaGF0IGlzIHJhdGhlclxuICogdGhhbiB0aGUgdmFsdWUgZm9yIGEgdG9rZW4gYmVpbmcgYSBzbWFsbCBzdHJpbmcgb2YgdGV4dCwgaXQncyB2YWx1ZSBhbiBhcnJheVxuICogb2YgdGV4dCB0b2tlbnMuXG4gKlxuICogVXNlZCBmb3IgZ3JvdXBpbmcgdG9nZXRoZXIgVVJMcywgZW1haWxzLCBoYXNodGFncywgYW5kIG90aGVyIHBvdGVudGlhbFxuICogY3JlYXRpb25zLlxuICogQGNsYXNzIE11bHRpVG9rZW5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gdlxuICogQHByb3BlcnR5IHtUb2tlbltdfSB0a1xuICogQGFic3RyYWN0XG4gKi9cbk11bHRpVG9rZW4ucHJvdG90eXBlID0ge1xuICBpc0xpbms6IGZhbHNlLFxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzdHJpbmcgdGhpcyB0b2tlbiByZXByZXNlbnRzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy52O1xuICB9LFxuICAvKipcbiAgICogV2hhdCBzaG91bGQgdGhlIHZhbHVlIGZvciB0aGlzIHRva2VuIGJlIGluIHRoZSBgaHJlZmAgSFRNTCBhdHRyaWJ1dGU/XG4gICAqIFJldHVybnMgdGhlIGAudG9TdHJpbmdgIHZhbHVlIGJ5IGRlZmF1bHQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NoZW1lXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICovXG4gIHRvSHJlZihzY2hlbWUpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9LFxuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIEZvcm1hdHRpbmcgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXR0ZWRTdHJpbmcob3B0aW9ucykge1xuICAgIGNvbnN0IHZhbCA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICBjb25zdCB0cnVuY2F0ZSA9IG9wdGlvbnMuZ2V0KCd0cnVuY2F0ZScsIHZhbCwgdGhpcyk7XG4gICAgY29uc3QgZm9ybWF0dGVkID0gb3B0aW9ucy5nZXQoJ2Zvcm1hdCcsIHZhbCwgdGhpcyk7XG4gICAgcmV0dXJuIHRydW5jYXRlICYmIGZvcm1hdHRlZC5sZW5ndGggPiB0cnVuY2F0ZSA/IGZvcm1hdHRlZC5zdWJzdHJpbmcoMCwgdHJ1bmNhdGUpICsgJ1x1MjAyNicgOiBmb3JtYXR0ZWQ7XG4gIH0sXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHRvRm9ybWF0dGVkSHJlZihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZ2V0KCdmb3JtYXRIcmVmJywgdGhpcy50b0hyZWYob3B0aW9ucy5nZXQoJ2RlZmF1bHRQcm90b2NvbCcpKSwgdGhpcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgc3RhcnQgaW5kZXggb2YgdGhpcyB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgaW5wdXQgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBzdGFydEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLnRrWzBdLnM7XG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgZW5kIGluZGV4IG9mIHRoaXMgdG9rZW4gaW4gdGhlIG9yaWdpbmFsIGlucHV0IHN0cmluZyAodXAgdG8gdGhpc1xuICAgKiBpbmRleCBidXQgbm90IGluY2x1ZGluZyBpdClcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGVuZEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLnRrW3RoaXMudGsubGVuZ3RoIC0gMV0uZTtcbiAgfSxcbiAgLyoqXG4gIFx0UmV0dXJucyBhbiBvYmplY3QgIG9mIHJlbGV2YW50IHZhbHVlcyBmb3IgdGhpcyB0b2tlbiwgd2hpY2ggaW5jbHVkZXMga2V5c1xuICBcdCogdHlwZSAtIEtpbmQgb2YgdG9rZW4gKCd1cmwnLCAnZW1haWwnLCBldGMuKVxuICBcdCogdmFsdWUgLSBPcmlnaW5hbCB0ZXh0XG4gIFx0KiBocmVmIC0gVGhlIHZhbHVlIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBhbmNob3IgdGFnJ3MgaHJlZlxuICBcdFx0YXR0cmlidXRlXG4gIFx0XHRAbWV0aG9kIHRvT2JqZWN0XG4gIFx0QHBhcmFtIHtzdHJpbmd9IFtwcm90b2NvbF0gYCdodHRwJ2AgYnkgZGVmYXVsdFxuICAqL1xuICB0b09iamVjdChwcm90b2NvbCkge1xuICAgIGlmIChwcm90b2NvbCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm90b2NvbCA9IGRlZmF1bHRzLmRlZmF1bHRQcm90b2NvbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHRoaXMudCxcbiAgICAgIHZhbHVlOiB0aGlzLnRvU3RyaW5nKCksXG4gICAgICBpc0xpbms6IHRoaXMuaXNMaW5rLFxuICAgICAgaHJlZjogdGhpcy50b0hyZWYocHJvdG9jb2wpLFxuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnRJbmRleCgpLFxuICAgICAgZW5kOiB0aGlzLmVuZEluZGV4KClcbiAgICB9O1xuICB9LFxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIEZvcm1hdHRpbmcgb3B0aW9uXG4gICAqL1xuICB0b0Zvcm1hdHRlZE9iamVjdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHRoaXMudCxcbiAgICAgIHZhbHVlOiB0aGlzLnRvRm9ybWF0dGVkU3RyaW5nKG9wdGlvbnMpLFxuICAgICAgaXNMaW5rOiB0aGlzLmlzTGluayxcbiAgICAgIGhyZWY6IHRoaXMudG9Gb3JtYXR0ZWRIcmVmKG9wdGlvbnMpLFxuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnRJbmRleCgpLFxuICAgICAgZW5kOiB0aGlzLmVuZEluZGV4KClcbiAgICB9O1xuICB9LFxuICAvKipcbiAgICogV2hldGhlciB0aGlzIHRva2VuIHNob3VsZCBiZSByZW5kZXJlZCBhcyBhIGxpbmsgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHZhbGlkYXRlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5nZXQoJ3ZhbGlkYXRlJywgdGhpcy50b1N0cmluZygpLCB0aGlzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybiBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGhvdyB0aGlzIGxpbmsgc2hvdWxkIGJlIHJlbmRlcmVkLlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgRm9ybWF0dGlubmcgb3B0aW9uc1xuICAgKi9cbiAgcmVuZGVyKG9wdGlvbnMpIHtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXM7XG4gICAgY29uc3QgaHJlZiA9IHRoaXMudG9IcmVmKG9wdGlvbnMuZ2V0KCdkZWZhdWx0UHJvdG9jb2wnKSk7XG4gICAgY29uc3QgZm9ybWF0dGVkSHJlZiA9IG9wdGlvbnMuZ2V0KCdmb3JtYXRIcmVmJywgaHJlZiwgdGhpcyk7XG4gICAgY29uc3QgdGFnTmFtZSA9IG9wdGlvbnMuZ2V0KCd0YWdOYW1lJywgaHJlZiwgdG9rZW4pO1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLnRvRm9ybWF0dGVkU3RyaW5nKG9wdGlvbnMpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBvcHRpb25zLmdldCgnY2xhc3NOYW1lJywgaHJlZiwgdG9rZW4pO1xuICAgIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMuZ2V0KCd0YXJnZXQnLCBocmVmLCB0b2tlbik7XG4gICAgY29uc3QgcmVsID0gb3B0aW9ucy5nZXQoJ3JlbCcsIGhyZWYsIHRva2VuKTtcbiAgICBjb25zdCBhdHRycyA9IG9wdGlvbnMuZ2V0T2JqKCdhdHRyaWJ1dGVzJywgaHJlZiwgdG9rZW4pO1xuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gb3B0aW9ucy5nZXRPYmooJ2V2ZW50cycsIGhyZWYsIHRva2VuKTtcbiAgICBhdHRyaWJ1dGVzLmhyZWYgPSBmb3JtYXR0ZWRIcmVmO1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgPSBjbGFzc05hbWU7XG4gICAgfVxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGF0dHJpYnV0ZXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAocmVsKSB7XG4gICAgICBhdHRyaWJ1dGVzLnJlbCA9IHJlbDtcbiAgICB9XG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICBhc3NpZ24oYXR0cmlidXRlcywgYXR0cnMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdGFnTmFtZSxcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICBjb250ZW50LFxuICAgICAgZXZlbnRMaXN0ZW5lcnNcbiAgICB9O1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0b2tlbiB0aGF0IGNhbiBiZSBlbWl0dGVkIGJ5IHRoZSBwYXJzZXIgc3RhdGUgbWFjaGluZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgcmVhZGFibGUgdHlwZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBwcm9wZXJ0aWVzIHRvIGFzc2lnbiBvciBvdmVycmlkZSwgaW5jbHVkaW5nIGlzTGluayA9IHRydWUgb3IgZmFsc2VcbiAqIEByZXR1cm5zIHtuZXcgKHZhbHVlOiBzdHJpbmcsIHRva2VuczogVG9rZW5bXSkgPT4gTXVsdGlUb2tlbn0gbmV3IHRva2VuIGNsYXNzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRva2VuQ2xhc3ModHlwZSwgcHJvcHMpIHtcbiAgY2xhc3MgVG9rZW4gZXh0ZW5kcyBNdWx0aVRva2VuIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdG9rZW5zKSB7XG4gICAgICBzdXBlcih2YWx1ZSwgdG9rZW5zKTtcbiAgICAgIHRoaXMudCA9IHR5cGU7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgcCBpbiBwcm9wcykge1xuICAgIFRva2VuLnByb3RvdHlwZVtwXSA9IHByb3BzW3BdO1xuICB9XG4gIFRva2VuLnQgPSB0eXBlO1xuICByZXR1cm4gVG9rZW47XG59XG5cbi8qKlxuXHRSZXByZXNlbnRzIGEgbGlzdCBvZiB0b2tlbnMgbWFraW5nIHVwIGEgdmFsaWQgZW1haWwgYWRkcmVzc1xuKi9cbmNvbnN0IEVtYWlsID0gY3JlYXRlVG9rZW5DbGFzcygnZW1haWwnLCB7XG4gIGlzTGluazogdHJ1ZSxcbiAgdG9IcmVmKCkge1xuICAgIHJldHVybiAnbWFpbHRvOicgKyB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cbn0pO1xuXG4vKipcblx0UmVwcmVzZW50cyBzb21lIHBsYWluIHRleHRcbiovXG5jb25zdCBUZXh0ID0gY3JlYXRlVG9rZW5DbGFzcygndGV4dCcpO1xuXG4vKipcblx0TXVsdGktbGluZWJyZWFrIHRva2VuIC0gcmVwcmVzZW50cyBhIGxpbmUgYnJlYWtcblx0QGNsYXNzIE5sXG4qL1xuY29uc3QgTmwgPSBjcmVhdGVUb2tlbkNsYXNzKCdubCcpO1xuXG4vKipcblx0UmVwcmVzZW50cyBhIGxpc3Qgb2YgdGV4dCB0b2tlbnMgbWFraW5nIHVwIGEgdmFsaWQgVVJMXG5cdEBjbGFzcyBVcmxcbiovXG5jb25zdCBVcmwgPSBjcmVhdGVUb2tlbkNsYXNzKCd1cmwnLCB7XG4gIGlzTGluazogdHJ1ZSxcbiAgLyoqXG4gIFx0TG93ZXJjYXNlcyByZWxldmFudCBwYXJ0cyBvZiB0aGUgZG9tYWluIGFuZCBhZGRzIHRoZSBwcm90b2NvbCBpZlxuICBcdHJlcXVpcmVkLiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBlc2NhcGUgdW5zYWZlIEhUTUwgY2hhcmFjdGVycyBpbiB0aGVcbiAgXHRVUkwuXG4gIFx0XHRAcGFyYW0ge3N0cmluZ30gW3NjaGVtZV0gZGVmYXVsdCBzY2hlbWUgKGUuZy4sICdodHRwcycpXG4gIFx0QHJldHVybiB7c3RyaW5nfSB0aGUgZnVsbCBocmVmXG4gICovXG4gIHRvSHJlZihzY2hlbWUpIHtcbiAgICBpZiAoc2NoZW1lID09PSB2b2lkIDApIHtcbiAgICAgIHNjaGVtZSA9IGRlZmF1bHRzLmRlZmF1bHRQcm90b2NvbDtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBoYXMgYSBwcmVmaXggc2NoZW1lXG4gICAgcmV0dXJuIHRoaXMuaGFzUHJvdG9jb2woKSA/IHRoaXMudiA6IGAke3NjaGVtZX06Ly8ke3RoaXMudn1gO1xuICB9LFxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGlzIFVSTCB0b2tlbiBoYXMgYSBwcm90b2NvbFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzUHJvdG9jb2woKSB7XG4gICAgY29uc3QgdG9rZW5zID0gdGhpcy50aztcbiAgICByZXR1cm4gdG9rZW5zLmxlbmd0aCA+PSAyICYmIHRva2Vuc1swXS50ICE9PSBMT0NBTEhPU1QgJiYgdG9rZW5zWzFdLnQgPT09IENPTE9OO1xuICB9XG59KTtcblxudmFyIG11bHRpID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdE11bHRpVG9rZW46IE11bHRpVG9rZW4sXG5cdEJhc2U6IE11bHRpVG9rZW4sXG5cdGNyZWF0ZVRva2VuQ2xhc3M6IGNyZWF0ZVRva2VuQ2xhc3MsXG5cdEVtYWlsOiBFbWFpbCxcblx0VGV4dDogVGV4dCxcblx0Tmw6IE5sLFxuXHRVcmw6IFVybFxufSk7XG5cbi8qKlxuXHROb3QgZXhhY3RseSBwYXJzZXIsIG1vcmUgbGlrZSB0aGUgc2Vjb25kLXN0YWdlIHNjYW5uZXIgKGFsdGhvdWdoIHdlIGNhblxuXHR0aGVvcmV0aWNhbGx5IGhvdHN3YXAgdGhlIGNvZGUgaGVyZSB3aXRoIGEgcmVhbCBwYXJzZXIgaW4gdGhlIGZ1dHVyZS4uLiBidXRcblx0Zm9yIGEgbGl0dGxlIFVSTC1maW5kaW5nIHV0aWxpdHkgYWJzdHJhY3Qgc3ludGF4IHRyZWVzIG1heSBiZSBhIGxpdHRsZVxuXHRvdmVya2lsbCkuXG5cblx0VVJMIGZvcm1hdDogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VUklfc2NoZW1lXG5cdEVtYWlsIGZvcm1hdDogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbWFpbEFkZHJlc3MgKGxpbmtzIHRvIFJGQyBpblxuXHRyZWZlcmVuY2UpXG5cblx0QG1vZHVsZSBsaW5raWZ5XG5cdEBzdWJtb2R1bGUgcGFyc2VyXG5cdEBtYWluIHJ1blxuKi9cbmNvbnN0IG1ha2VTdGF0ZSA9IGFyZyA9PiBuZXcgU3RhdGUoYXJnKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgcGFyc2VyIG11bHRpIHRva2VuLWJhc2VkIHN0YXRlIG1hY2hpbmVcbiAqIEBwYXJhbSB7eyBncm91cHM6IENvbGxlY3Rpb25zPHN0cmluZz4gfX0gdG9rZW5zXG4gKi9cbmZ1bmN0aW9uIGluaXQkMShfcmVmKSB7XG4gIGxldCB7XG4gICAgZ3JvdXBzXG4gIH0gPSBfcmVmO1xuICAvLyBUeXBlcyBvZiBjaGFyYWN0ZXJzIHRoZSBVUkwgY2FuIGRlZmluaXRlbHkgZW5kIGluXG4gIGNvbnN0IHFzQWNjZXB0aW5nID0gZ3JvdXBzLmRvbWFpbi5jb25jYXQoW0FNUEVSU0FORCwgQVNURVJJU0ssIEFULCBCQUNLU0xBU0gsIEJBQ0tUSUNLLCBDQVJFVCwgRE9MTEFSLCBFUVVBTFMsIEhZUEhFTiwgTlVNLCBQRVJDRU5ULCBQSVBFLCBQTFVTLCBQT1VORCwgU0xBU0gsIFNZTSwgVElMREUsIFVOREVSU0NPUkVdKTtcblxuICAvLyBUeXBlcyBvZiB0b2tlbnMgdGhhdCBjYW4gZm9sbG93IGEgVVJMIGFuZCBiZSBwYXJ0IG9mIHRoZSBxdWVyeSBzdHJpbmdcbiAgLy8gYnV0IGNhbm5vdCBiZSB0aGUgdmVyeSBsYXN0IGNoYXJhY3RlcnNcbiAgLy8gQ2hhcmFjdGVycyB0aGF0IGNhbm5vdCBhcHBlYXIgaW4gdGhlIFVSTCBhdCBhbGwgc2hvdWxkIGJlIGV4Y2x1ZGVkXG4gIGNvbnN0IHFzTm9uQWNjZXB0aW5nID0gW0FQT1NUUk9QSEUsIENPTE9OLCBDT01NQSwgRE9ULCBFWENMQU1BVElPTiwgUVVFUlksIFFVT1RFLCBTRU1JLCBPUEVOQU5HTEVCUkFDS0VULCBDTE9TRUFOR0xFQlJBQ0tFVCwgT1BFTkJSQUNFLCBDTE9TRUJSQUNFLCBDTE9TRUJSQUNLRVQsIE9QRU5CUkFDS0VULCBPUEVOUEFSRU4sIENMT1NFUEFSRU4sIEZVTExXSURUSExFRlRQQVJFTiwgRlVMTFdJRFRIUklHSFRQQVJFTiwgTEVGVENPUk5FUkJSQUNLRVQsIFJJR0hUQ09STkVSQlJBQ0tFVCwgTEVGVFdISVRFQ09STkVSQlJBQ0tFVCwgUklHSFRXSElURUNPUk5FUkJSQUNLRVQsIEZVTExXSURUSExFU1NUSEFOLCBGVUxMV0lEVEhHUkVBVEVSVEhBTl07XG5cbiAgLy8gRm9yIGFkZHJlc3NlcyB3aXRob3V0IHRoZSBtYWlsdG8gcHJlZml4XG4gIC8vIFRva2VucyBhbGxvd2VkIGluIHRoZSBsb2NhbHBhcnQgb2YgdGhlIGVtYWlsXG4gIGNvbnN0IGxvY2FscGFydEFjY2VwdGluZyA9IFtBTVBFUlNBTkQsIEFQT1NUUk9QSEUsIEFTVEVSSVNLLCBCQUNLU0xBU0gsIEJBQ0tUSUNLLCBDQVJFVCwgRE9MTEFSLCBFUVVBTFMsIEhZUEhFTiwgT1BFTkJSQUNFLCBDTE9TRUJSQUNFLCBQRVJDRU5ULCBQSVBFLCBQTFVTLCBQT1VORCwgUVVFUlksIFNMQVNILCBTWU0sIFRJTERFLCBVTkRFUlNDT1JFXTtcblxuICAvLyBUaGUgdW5pdmVyc2FsIHN0YXJ0aW5nIHN0YXRlLlxuICAvKipcbiAgICogQHR5cGUgU3RhdGU8VG9rZW4+XG4gICAqL1xuICBjb25zdCBTdGFydCA9IG1ha2VTdGF0ZSgpO1xuICBjb25zdCBMb2NhbHBhcnQgPSB0dChTdGFydCwgVElMREUpOyAvLyBMb2NhbCBwYXJ0IG9mIHRoZSBlbWFpbCBhZGRyZXNzXG4gIHRhKExvY2FscGFydCwgbG9jYWxwYXJ0QWNjZXB0aW5nLCBMb2NhbHBhcnQpO1xuICB0YShMb2NhbHBhcnQsIGdyb3Vwcy5kb21haW4sIExvY2FscGFydCk7XG4gIGNvbnN0IERvbWFpbiA9IG1ha2VTdGF0ZSgpLFxuICAgIFNjaGVtZSA9IG1ha2VTdGF0ZSgpLFxuICAgIFNsYXNoU2NoZW1lID0gbWFrZVN0YXRlKCk7XG4gIHRhKFN0YXJ0LCBncm91cHMuZG9tYWluLCBEb21haW4pOyAvLyBwYXJzZWQgc3RyaW5nIGVuZHMgd2l0aCBhIHBvdGVudGlhbCBkb21haW4gbmFtZSAoQSlcbiAgdGEoU3RhcnQsIGdyb3Vwcy5zY2hlbWUsIFNjaGVtZSk7IC8vIGUuZy4sICdtYWlsdG8nXG4gIHRhKFN0YXJ0LCBncm91cHMuc2xhc2hzY2hlbWUsIFNsYXNoU2NoZW1lKTsgLy8gZS5nLiwgJ2h0dHAnXG5cbiAgdGEoRG9tYWluLCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHRhKERvbWFpbiwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgY29uc3QgTG9jYWxwYXJ0QXQgPSB0dChEb21haW4sIEFUKTsgLy8gTG9jYWwgcGFydCBvZiB0aGUgZW1haWwgYWRkcmVzcyBwbHVzIEBcblxuICB0dChMb2NhbHBhcnQsIEFULCBMb2NhbHBhcnRBdCk7IC8vIGNsb3NlIHRvIGFuIGVtYWlsIGFkZHJlc3Mgbm93XG5cbiAgLy8gTG9jYWwgcGFydCBvZiBhbiBlbWFpbCBhZGRyZXNzIGNhbiBiZSBlLmcuICdodHRwJyBvciAnbWFpbHRvJ1xuICB0dChTY2hlbWUsIEFULCBMb2NhbHBhcnRBdCk7XG4gIHR0KFNsYXNoU2NoZW1lLCBBVCwgTG9jYWxwYXJ0QXQpO1xuICBjb25zdCBMb2NhbHBhcnREb3QgPSB0dChMb2NhbHBhcnQsIERPVCk7IC8vIExvY2FsIHBhcnQgb2YgdGhlIGVtYWlsIGFkZHJlc3MgcGx1cyAnLicgKGxvY2FscGFydCBjYW5ub3QgZW5kIGluIC4pXG4gIHRhKExvY2FscGFydERvdCwgbG9jYWxwYXJ0QWNjZXB0aW5nLCBMb2NhbHBhcnQpO1xuICB0YShMb2NhbHBhcnREb3QsIGdyb3Vwcy5kb21haW4sIExvY2FscGFydCk7XG4gIGNvbnN0IEVtYWlsRG9tYWluID0gbWFrZVN0YXRlKCk7XG4gIHRhKExvY2FscGFydEF0LCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7IC8vIHBhcnNlZCBzdHJpbmcgc3RhcnRzIHdpdGggbG9jYWwgZW1haWwgaW5mbyArIEAgd2l0aCBhIHBvdGVudGlhbCBkb21haW4gbmFtZVxuICB0YShFbWFpbERvbWFpbiwgZ3JvdXBzLmRvbWFpbiwgRW1haWxEb21haW4pO1xuICBjb25zdCBFbWFpbERvbWFpbkRvdCA9IHR0KEVtYWlsRG9tYWluLCBET1QpOyAvLyBkb21haW4gZm9sbG93ZWQgYnkgRE9UXG4gIHRhKEVtYWlsRG9tYWluRG90LCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7XG4gIGNvbnN0IEVtYWlsJDEgPSBtYWtlU3RhdGUoRW1haWwpOyAvLyBQb3NzaWJsZSBlbWFpbCBhZGRyZXNzIChjb3VsZCBoYXZlIG1vcmUgdGxkcylcbiAgdGEoRW1haWxEb21haW5Eb3QsIGdyb3Vwcy50bGQsIEVtYWlsJDEpO1xuICB0YShFbWFpbERvbWFpbkRvdCwgZ3JvdXBzLnV0bGQsIEVtYWlsJDEpO1xuICB0dChMb2NhbHBhcnRBdCwgTE9DQUxIT1NULCBFbWFpbCQxKTtcblxuICAvLyBIeXBoZW4gY2FuIGp1bXAgYmFjayB0byBhIGRvbWFpbiBuYW1lXG4gIGNvbnN0IEVtYWlsRG9tYWluSHlwaGVuID0gdHQoRW1haWxEb21haW4sIEhZUEhFTik7IC8vIHBhcnNlZCBzdHJpbmcgc3RhcnRzIHdpdGggbG9jYWwgZW1haWwgaW5mbyArIEAgd2l0aCBhIHBvdGVudGlhbCBkb21haW4gbmFtZVxuICB0YShFbWFpbERvbWFpbkh5cGhlbiwgZ3JvdXBzLmRvbWFpbiwgRW1haWxEb21haW4pO1xuICB0YShFbWFpbCQxLCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7XG4gIHR0KEVtYWlsJDEsIERPVCwgRW1haWxEb21haW5Eb3QpO1xuICB0dChFbWFpbCQxLCBIWVBIRU4sIEVtYWlsRG9tYWluSHlwaGVuKTtcblxuICAvLyBGaW5hbCBwb3NzaWJsZSBlbWFpbCBzdGF0ZXNcbiAgY29uc3QgRW1haWxDb2xvbiA9IHR0KEVtYWlsJDEsIENPTE9OKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IGNvbG9uIChwb3RlbnRpYWwgcG9ydCBudW1iZXIgaGVyZSlcbiAgLypjb25zdCBFbWFpbENvbG9uUG9ydCA9ICovXG4gIHRhKEVtYWlsQ29sb24sIGdyb3Vwcy5udW1lcmljLCBFbWFpbCk7IC8vIFVSTCBmb2xsb3dlZCBieSBjb2xvbiBhbmQgcG9ydCBudW1iZXJcblxuICAvLyBBY2NvdW50IGZvciBkb3RzIGFuZCBoeXBoZW5zLiBIeXBoZW5zIGFyZSB1c3VhbGx5IHBhcnRzIG9mIGRvbWFpbiBuYW1lc1xuICAvLyAoYnV0IG5vdCBUTERzKVxuICBjb25zdCBEb21haW5IeXBoZW4gPSB0dChEb21haW4sIEhZUEhFTik7IC8vIGRvbWFpbiBmb2xsb3dlZCBieSBoeXBoZW5cbiAgY29uc3QgRG9tYWluRG90ID0gdHQoRG9tYWluLCBET1QpOyAvLyBkb21haW4gZm9sbG93ZWQgYnkgRE9UXG4gIHRhKERvbWFpbkh5cGhlbiwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgdGEoRG9tYWluRG90LCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHRhKERvbWFpbkRvdCwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgY29uc3QgRG9tYWluRG90VGxkID0gbWFrZVN0YXRlKFVybCk7IC8vIFNpbXBsZXN0IHBvc3NpYmxlIFVSTCB3aXRoIG5vIHF1ZXJ5IHN0cmluZ1xuICB0YShEb21haW5Eb3QsIGdyb3Vwcy50bGQsIERvbWFpbkRvdFRsZCk7XG4gIHRhKERvbWFpbkRvdCwgZ3JvdXBzLnV0bGQsIERvbWFpbkRvdFRsZCk7XG4gIHRhKERvbWFpbkRvdFRsZCwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgdGEoRG9tYWluRG90VGxkLCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHR0KERvbWFpbkRvdFRsZCwgRE9ULCBEb21haW5Eb3QpO1xuICB0dChEb21haW5Eb3RUbGQsIEhZUEhFTiwgRG9tYWluSHlwaGVuKTtcbiAgdHQoRG9tYWluRG90VGxkLCBBVCwgTG9jYWxwYXJ0QXQpO1xuICBjb25zdCBEb21haW5Eb3RUbGRDb2xvbiA9IHR0KERvbWFpbkRvdFRsZCwgQ09MT04pOyAvLyBVUkwgZm9sbG93ZWQgYnkgY29sb24gKHBvdGVudGlhbCBwb3J0IG51bWJlciBoZXJlKVxuICBjb25zdCBEb21haW5Eb3RUbGRDb2xvblBvcnQgPSBtYWtlU3RhdGUoVXJsKTsgLy8gVExEIGZvbGxvd2VkIGJ5IGEgcG9ydCBudW1iZXJcbiAgdGEoRG9tYWluRG90VGxkQ29sb24sIGdyb3Vwcy5udW1lcmljLCBEb21haW5Eb3RUbGRDb2xvblBvcnQpO1xuXG4gIC8vIExvbmcgVVJMIHdpdGggb3B0aW9uYWwgcG9ydCBhbmQgbWF5YmUgcXVlcnkgc3RyaW5nXG4gIGNvbnN0IFVybCQxID0gbWFrZVN0YXRlKFVybCk7XG5cbiAgLy8gVVJMIHdpdGggZXh0cmEgc3ltYm9scyBhdCB0aGUgZW5kLCBmb2xsb3dlZCBieSBhbiBvcGVuaW5nIGJyYWNrZXRcbiAgY29uc3QgVXJsTm9uYWNjZXB0ID0gbWFrZVN0YXRlKCk7IC8vIFVSTCBmb2xsb3dlZCBieSBzb21lIHN5bWJvbHMgKHdpbGwgbm90IGJlIHBhcnQgb2YgdGhlIGZpbmFsIFVSTClcblxuICAvLyBRdWVyeSBzdHJpbmdzXG4gIHRhKFVybCQxLCBxc0FjY2VwdGluZywgVXJsJDEpO1xuICB0YShVcmwkMSwgcXNOb25BY2NlcHRpbmcsIFVybE5vbmFjY2VwdCk7XG4gIHRhKFVybE5vbmFjY2VwdCwgcXNBY2NlcHRpbmcsIFVybCQxKTtcbiAgdGEoVXJsTm9uYWNjZXB0LCBxc05vbkFjY2VwdGluZywgVXJsTm9uYWNjZXB0KTtcblxuICAvLyBCZWNvbWUgcmVhbCBVUkxzIGFmdGVyIGBTTEFTSGAgb3IgYENPTE9OIE5VTSBTTEFTSGBcbiAgLy8gSGVyZSB3b3JrcyB3aXRoIG9yIHdpdGhvdXQgc2NoZW1lOi8vIHByZWZpeFxuICB0dChEb21haW5Eb3RUbGQsIFNMQVNILCBVcmwkMSk7XG4gIHR0KERvbWFpbkRvdFRsZENvbG9uUG9ydCwgU0xBU0gsIFVybCQxKTtcblxuICAvLyBOb3RlIHRoYXQgZG9tYWlucyB0aGF0IGJlZ2luIHdpdGggc2NoZW1lcyBhcmUgdHJlYXRlZCBzbGlnaGx5IGRpZmZlcmVudGx5XG4gIGNvbnN0IFNjaGVtZUNvbG9uID0gdHQoU2NoZW1lLCBDT0xPTik7IC8vIGUuZy4sICdtYWlsdG86J1xuICBjb25zdCBTbGFzaFNjaGVtZUNvbG9uID0gdHQoU2xhc2hTY2hlbWUsIENPTE9OKTsgLy8gZS5nLiwgJ2h0dHA6J1xuICBjb25zdCBTbGFzaFNjaGVtZUNvbG9uU2xhc2ggPSB0dChTbGFzaFNjaGVtZUNvbG9uLCBTTEFTSCk7IC8vIGUuZy4sICdodHRwOi8nXG5cbiAgY29uc3QgVXJpUHJlZml4ID0gdHQoU2xhc2hTY2hlbWVDb2xvblNsYXNoLCBTTEFTSCk7IC8vIGUuZy4sICdodHRwOi8vJ1xuXG4gIC8vIFNjaGVtZSBzdGF0ZXMgY2FuIHRyYW5zaXRpb24gdG8gZG9tYWluIHN0YXRlc1xuICB0YShTY2hlbWUsIGdyb3Vwcy5kb21haW4sIERvbWFpbik7XG4gIHR0KFNjaGVtZSwgRE9ULCBEb21haW5Eb3QpO1xuICB0dChTY2hlbWUsIEhZUEhFTiwgRG9tYWluSHlwaGVuKTtcbiAgdGEoU2xhc2hTY2hlbWUsIGdyb3Vwcy5kb21haW4sIERvbWFpbik7XG4gIHR0KFNsYXNoU2NoZW1lLCBET1QsIERvbWFpbkRvdCk7XG4gIHR0KFNsYXNoU2NoZW1lLCBIWVBIRU4sIERvbWFpbkh5cGhlbik7XG5cbiAgLy8gRm9yY2UgVVJMIHdpdGggc2NoZW1lIHByZWZpeCBmb2xsb3dlZCBieSBhbnl0aGluZyBzYW5lXG4gIHRhKFNjaGVtZUNvbG9uLCBncm91cHMuZG9tYWluLCBVcmwkMSk7XG4gIHR0KFNjaGVtZUNvbG9uLCBTTEFTSCwgVXJsJDEpO1xuICB0YShVcmlQcmVmaXgsIGdyb3Vwcy5kb21haW4sIFVybCQxKTtcbiAgdGEoVXJpUHJlZml4LCBxc0FjY2VwdGluZywgVXJsJDEpO1xuICB0dChVcmlQcmVmaXgsIFNMQVNILCBVcmwkMSk7XG4gIGNvbnN0IGJyYWNrZXRQYWlycyA9IFtbT1BFTkJSQUNFLCBDTE9TRUJSQUNFXSxcbiAgLy8ge31cbiAgW09QRU5CUkFDS0VULCBDTE9TRUJSQUNLRVRdLFxuICAvLyBbXVxuICBbT1BFTlBBUkVOLCBDTE9TRVBBUkVOXSxcbiAgLy8gKClcbiAgW09QRU5BTkdMRUJSQUNLRVQsIENMT1NFQU5HTEVCUkFDS0VUXSxcbiAgLy8gPD5cbiAgW0ZVTExXSURUSExFRlRQQVJFTiwgRlVMTFdJRFRIUklHSFRQQVJFTl0sXG4gIC8vIFx1RkYwOFx1RkYwOVxuICBbTEVGVENPUk5FUkJSQUNLRVQsIFJJR0hUQ09STkVSQlJBQ0tFVF0sXG4gIC8vIFx1MzAwQ1x1MzAwRFxuICBbTEVGVFdISVRFQ09STkVSQlJBQ0tFVCwgUklHSFRXSElURUNPUk5FUkJSQUNLRVRdLFxuICAvLyBcdTMwMEVcdTMwMEZcbiAgW0ZVTExXSURUSExFU1NUSEFOLCBGVUxMV0lEVEhHUkVBVEVSVEhBTl0gLy8gXHVGRjFDXHVGRjFFXG4gIF07XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBicmFja2V0UGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBbT1BFTiwgQ0xPU0VdID0gYnJhY2tldFBhaXJzW2ldO1xuICAgIGNvbnN0IFVybE9wZW4gPSB0dChVcmwkMSwgT1BFTik7IC8vIFVSTCBmb2xsb3dlZCBieSBvcGVuIGJyYWNrZXRcblxuICAgIC8vIENvbnRpbnVlIG5vdCBhY2NlcHRpbmcgZm9yIG9wZW4gYnJhY2tldHNcbiAgICB0dChVcmxOb25hY2NlcHQsIE9QRU4sIFVybE9wZW4pO1xuXG4gICAgLy8gQ2xvc2luZyBicmFja2V0IGNvbXBvbmVudC4gVGhpcyBjaGFyYWN0ZXIgV0lMTCBiZSBpbmNsdWRlZCBpbiB0aGUgVVJMXG4gICAgdHQoVXJsT3BlbiwgQ0xPU0UsIFVybCQxKTtcblxuICAgIC8vIFVSTCB0aGF0IGJlaW5ncyB3aXRoIGFuIG9wZW5pbmcgYnJhY2tldCwgZm9sbG93ZWQgYnkgYSBzeW1ib2xzLlxuICAgIC8vIE5vdGUgdGhhdCB0aGUgZmluYWwgc3RhdGUgY2FuIHN0aWxsIGJlIGBVcmxPcGVuYCAoaWYgdGhlIFVSTCBoYXMgYVxuICAgIC8vIHNpbmdsZSBvcGVuaW5nIGJyYWNrZXQgZm9yIHNvbWUgcmVhc29uKS5cbiAgICBjb25zdCBVcmxPcGVuUSA9IG1ha2VTdGF0ZShVcmwpO1xuICAgIHRhKFVybE9wZW4sIHFzQWNjZXB0aW5nLCBVcmxPcGVuUSk7XG4gICAgY29uc3QgVXJsT3BlblN5bXMgPSBtYWtlU3RhdGUoKTsgLy8gVXJsT3BlbiBmb2xsb3dlZCBieSBzb21lIHN5bWJvbHMgaXQgY2Fubm90IGVuZCBpdFxuICAgIHRhKFVybE9wZW4sIHFzTm9uQWNjZXB0aW5nKTtcblxuICAgIC8vIFVSTCB0aGF0IGJlZ2lucyB3aXRoIGFuIG9wZW5pbmcgYnJhY2tldCwgZm9sbG93ZWQgYnkgc29tZSBzeW1ib2xzXG4gICAgdGEoVXJsT3BlblEsIHFzQWNjZXB0aW5nLCBVcmxPcGVuUSk7XG4gICAgdGEoVXJsT3BlblEsIHFzTm9uQWNjZXB0aW5nLCBVcmxPcGVuU3ltcyk7XG4gICAgdGEoVXJsT3BlblN5bXMsIHFzQWNjZXB0aW5nLCBVcmxPcGVuUSk7XG4gICAgdGEoVXJsT3BlblN5bXMsIHFzTm9uQWNjZXB0aW5nLCBVcmxPcGVuU3ltcyk7XG5cbiAgICAvLyBDbG9zZSBicmFjZS9icmFja2V0IHRvIGJlY29tZSByZWd1bGFyIFVSTFxuICAgIHR0KFVybE9wZW5RLCBDTE9TRSwgVXJsJDEpO1xuICAgIHR0KFVybE9wZW5TeW1zLCBDTE9TRSwgVXJsJDEpO1xuICB9XG4gIHR0KFN0YXJ0LCBMT0NBTEhPU1QsIERvbWFpbkRvdFRsZCk7IC8vIGxvY2FsaG9zdCBpcyBhIHZhbGlkIFVSTCBzdGF0ZVxuICB0dChTdGFydCwgTkwkMSwgTmwpOyAvLyBzaW5nbGUgbmV3IGxpbmVcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBTdGFydCxcbiAgICB0b2tlbnM6IHRrXG4gIH07XG59XG5cbi8qKlxuICogUnVuIHRoZSBwYXJzZXIgc3RhdGUgbWFjaGluZSBvbiBhIGxpc3Qgb2Ygc2Nhbm5lZCBzdHJpbmctYmFzZWQgdG9rZW5zIHRvXG4gKiBjcmVhdGUgYSBsaXN0IG9mIG11bHRpIHRva2VucywgZWFjaCBvZiB3aGljaCByZXByZXNlbnRzIGEgVVJMLCBlbWFpbCBhZGRyZXNzLFxuICogcGxhaW4gdGV4dCwgZXRjLlxuICpcbiAqIEBwYXJhbSB7U3RhdGU8TXVsdGlUb2tlbj59IHN0YXJ0IHBhcnNlciBzdGFydCBzdGF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IHRoZSBvcmlnaW5hbCBpbnB1dCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBnaXZlbiB0b2tlbnNcbiAqIEBwYXJhbSB7VG9rZW5bXX0gdG9rZW5zIGxpc3Qgb2Ygc2Nhbm5lZCB0b2tlbnNcbiAqIEByZXR1cm5zIHtNdWx0aVRva2VuW119XG4gKi9cbmZ1bmN0aW9uIHJ1bihzdGFydCwgaW5wdXQsIHRva2Vucykge1xuICBsZXQgbGVuID0gdG9rZW5zLmxlbmd0aDtcbiAgbGV0IGN1cnNvciA9IDA7XG4gIGxldCBtdWx0aXMgPSBbXTtcbiAgbGV0IHRleHRUb2tlbnMgPSBbXTtcbiAgd2hpbGUgKGN1cnNvciA8IGxlbikge1xuICAgIGxldCBzdGF0ZSA9IHN0YXJ0O1xuICAgIGxldCBzZWNvbmRTdGF0ZSA9IG51bGw7XG4gICAgbGV0IG5leHRTdGF0ZSA9IG51bGw7XG4gICAgbGV0IG11bHRpTGVuZ3RoID0gMDtcbiAgICBsZXQgbGF0ZXN0QWNjZXB0aW5nID0gbnVsbDtcbiAgICBsZXQgc2luY2VBY2NlcHRzID0gLTE7XG4gICAgd2hpbGUgKGN1cnNvciA8IGxlbiAmJiAhKHNlY29uZFN0YXRlID0gc3RhdGUuZ28odG9rZW5zW2N1cnNvcl0udCkpKSB7XG4gICAgICAvLyBTdGFydGluZyB0b2tlbnMgd2l0aCBub3doZXJlIHRvIGp1bXAgdG8uXG4gICAgICAvLyBDb25zaWRlciB0aGVzZSB0byBiZSBqdXN0IHBsYWluIHRleHRcbiAgICAgIHRleHRUb2tlbnMucHVzaCh0b2tlbnNbY3Vyc29yKytdKTtcbiAgICB9XG4gICAgd2hpbGUgKGN1cnNvciA8IGxlbiAmJiAobmV4dFN0YXRlID0gc2Vjb25kU3RhdGUgfHwgc3RhdGUuZ28odG9rZW5zW2N1cnNvcl0udCkpKSB7XG4gICAgICAvLyBHZXQgdGhlIG5leHQgc3RhdGVcbiAgICAgIHNlY29uZFN0YXRlID0gbnVsbDtcbiAgICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBsYXRlc3QgYWNjZXB0aW5nIHN0YXRlXG4gICAgICBpZiAoc3RhdGUuYWNjZXB0cygpKSB7XG4gICAgICAgIHNpbmNlQWNjZXB0cyA9IDA7XG4gICAgICAgIGxhdGVzdEFjY2VwdGluZyA9IHN0YXRlO1xuICAgICAgfSBlbHNlIGlmIChzaW5jZUFjY2VwdHMgPj0gMCkge1xuICAgICAgICBzaW5jZUFjY2VwdHMrKztcbiAgICAgIH1cbiAgICAgIGN1cnNvcisrO1xuICAgICAgbXVsdGlMZW5ndGgrKztcbiAgICB9XG4gICAgaWYgKHNpbmNlQWNjZXB0cyA8IDApIHtcbiAgICAgIC8vIE5vIGFjY2VwdGluZyBzdGF0ZSB3YXMgZm91bmQsIHBhcnQgb2YgYSByZWd1bGFyIHRleHQgdG9rZW4gYWRkXG4gICAgICAvLyB0aGUgZmlyc3QgdGV4dCB0b2tlbiB0byB0aGUgdGV4dCB0b2tlbnMgYXJyYXkgYW5kIHRyeSBhZ2FpbiBmcm9tXG4gICAgICAvLyB0aGUgbmV4dFxuICAgICAgY3Vyc29yIC09IG11bHRpTGVuZ3RoO1xuICAgICAgaWYgKGN1cnNvciA8IGxlbikge1xuICAgICAgICB0ZXh0VG9rZW5zLnB1c2godG9rZW5zW2N1cnNvcl0pO1xuICAgICAgICBjdXJzb3IrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWNjZXB0aW5nIHN0YXRlIVxuICAgICAgLy8gRmlyc3QgY2xvc2Ugb2ZmIHRoZSB0ZXh0VG9rZW5zIChpZiBhdmFpbGFibGUpXG4gICAgICBpZiAodGV4dFRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG11bHRpcy5wdXNoKGluaXRNdWx0aVRva2VuKFRleHQsIGlucHV0LCB0ZXh0VG9rZW5zKSk7XG4gICAgICAgIHRleHRUb2tlbnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgLy8gUm9sbCBiYWNrIHRvIHRoZSBsYXRlc3QgYWNjZXB0aW5nIHN0YXRlXG4gICAgICBjdXJzb3IgLT0gc2luY2VBY2NlcHRzO1xuICAgICAgbXVsdGlMZW5ndGggLT0gc2luY2VBY2NlcHRzO1xuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgbXVsdGl0b2tlblxuICAgICAgY29uc3QgTXVsdGkgPSBsYXRlc3RBY2NlcHRpbmcudDtcbiAgICAgIGNvbnN0IHN1YnRva2VucyA9IHRva2Vucy5zbGljZShjdXJzb3IgLSBtdWx0aUxlbmd0aCwgY3Vyc29yKTtcbiAgICAgIG11bHRpcy5wdXNoKGluaXRNdWx0aVRva2VuKE11bHRpLCBpbnB1dCwgc3VidG9rZW5zKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gRmluYWxseSBjbG9zZSBvZmYgdGhlIHRleHRUb2tlbnMgKGlmIGF2YWlsYWJsZSlcbiAgaWYgKHRleHRUb2tlbnMubGVuZ3RoID4gMCkge1xuICAgIG11bHRpcy5wdXNoKGluaXRNdWx0aVRva2VuKFRleHQsIGlucHV0LCB0ZXh0VG9rZW5zKSk7XG4gIH1cbiAgcmV0dXJuIG11bHRpcztcbn1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBpbnN0YW50aWF0aW5nIGEgbmV3IG11bHRpdG9rZW4gd2l0aCBhbGwgdGhlIHJlbGV2YW50XG4gKiBmaWVsZHMgZHVyaW5nIHBhcnNpbmcuXG4gKiBAcGFyYW0ge25ldyAodmFsdWU6IHN0cmluZywgdG9rZW5zOiBUb2tlbltdKSA9PiBNdWx0aVRva2VufSBNdWx0aSBjbGFzcyB0byBpbnN0YW50aWF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IG9yaWdpbmFsIGlucHV0IHN0cmluZ1xuICogQHBhcmFtIHtUb2tlbltdfSB0b2tlbnMgY29uc2VjdXRpdmUgdG9rZW5zIHNjYW5uZWQgZnJvbSBpbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIHtNdWx0aVRva2VufVxuICovXG5mdW5jdGlvbiBpbml0TXVsdGlUb2tlbihNdWx0aSwgaW5wdXQsIHRva2Vucykge1xuICBjb25zdCBzdGFydElkeCA9IHRva2Vuc1swXS5zO1xuICBjb25zdCBlbmRJZHggPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLmU7XG4gIGNvbnN0IHZhbHVlID0gaW5wdXQuc2xpY2Uoc3RhcnRJZHgsIGVuZElkeCk7XG4gIHJldHVybiBuZXcgTXVsdGkodmFsdWUsIHRva2Vucyk7XG59XG5cbmNvbnN0IHdhcm4gPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZSAmJiBjb25zb2xlLndhcm4gfHwgKCgpID0+IHt9KTtcbmNvbnN0IHdhcm5BZHZpY2UgPSAndW50aWwgbWFudWFsIGNhbGwgb2YgbGlua2lmeS5pbml0KCkuIFJlZ2lzdGVyIGFsbCBzY2hlbWVzIGFuZCBwbHVnaW5zIGJlZm9yZSBpbnZva2luZyBsaW5raWZ5IHRoZSBmaXJzdCB0aW1lLic7XG5cbi8vIFNpZGUtZWZmZWN0IGluaXRpYWxpemF0aW9uIHN0YXRlXG5jb25zdCBJTklUID0ge1xuICBzY2FubmVyOiBudWxsLFxuICBwYXJzZXI6IG51bGwsXG4gIHRva2VuUXVldWU6IFtdLFxuICBwbHVnaW5RdWV1ZTogW10sXG4gIGN1c3RvbVNjaGVtZXM6IFtdLFxuICBpbml0aWFsaXplZDogZmFsc2Vcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqIFx0c3RhcnQ6IFN0YXRlPHN0cmluZz4sXG4gKiBcdHRva2VuczogeyBncm91cHM6IENvbGxlY3Rpb25zPHN0cmluZz4gfSAmIHR5cGVvZiB0a1xuICogfX0gU2Nhbm5lckluaXRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiBcdHN0YXJ0OiBTdGF0ZTxNdWx0aVRva2VuPixcbiAqIFx0dG9rZW5zOiB0eXBlb2YgbXVsdGlcbiAqIH19IFBhcnNlckluaXRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoYXJnOiB7IHNjYW5uZXI6IFNjYW5uZXJJbml0IH0pID0+IHZvaWR9IFRva2VuUGx1Z2luXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KGFyZzogeyBzY2FubmVyOiBTY2FubmVySW5pdCwgcGFyc2VyOiBQYXJzZXJJbml0IH0pID0+IHZvaWR9IFBsdWdpblxuICovXG5cbi8qKlxuICogRGUtcmVnaXN0ZXIgYWxsIHBsdWdpbnMgYW5kIHJlc2V0IHRoZSBpbnRlcm5hbCBzdGF0ZS1tYWNoaW5lLiBVc2VkIGZvclxuICogdGVzdGluZzsgbm90IHJlcXVpcmVkIGluIHByYWN0aWNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzZXQoKSB7XG4gIFN0YXRlLmdyb3VwcyA9IHt9O1xuICBJTklULnNjYW5uZXIgPSBudWxsO1xuICBJTklULnBhcnNlciA9IG51bGw7XG4gIElOSVQudG9rZW5RdWV1ZSA9IFtdO1xuICBJTklULnBsdWdpblF1ZXVlID0gW107XG4gIElOSVQuY3VzdG9tU2NoZW1lcyA9IFtdO1xuICBJTklULmluaXRpYWxpemVkID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVnaXN0ZXIgYSB0b2tlbiBwbHVnaW4gdG8gYWxsb3cgdGhlIHNjYW5uZXIgdG8gcmVjb2duaXplIGFkZGl0aW9uYWwgdG9rZW5cbiAqIHR5cGVzIGJlZm9yZSB0aGUgcGFyc2VyIHN0YXRlIG1hY2hpbmUgaXMgY29uc3RydWN0ZWQgZnJvbSB0aGUgcmVzdWx0cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG9mIHBsdWdpbiB0byByZWdpc3RlclxuICogQHBhcmFtIHtUb2tlblBsdWdpbn0gcGx1Z2luIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgc2Nhbm5lciBzdGF0ZSBtYWNoaW5lXG4gKiBhbmQgYXZhaWxhYmxlIHNjYW5uZXIgdG9rZW5zIGFuZCBjb2xsZWN0aW9ucyBhbmQgZXh0ZW5kcyB0aGUgc3RhdGUgbWFjaGluZSB0b1xuICogcmVjb2duaXplIGFkZGl0aW9uYWwgdG9rZW5zIG9yIGdyb3Vwcy5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJUb2tlblBsdWdpbihuYW1lLCBwbHVnaW4pIHtcbiAgaWYgKHR5cGVvZiBwbHVnaW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGxpbmtpZnlqczogSW52YWxpZCB0b2tlbiBwbHVnaW4gJHtwbHVnaW59IChleHBlY3RzIGZ1bmN0aW9uKWApO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgSU5JVC50b2tlblF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5hbWUgPT09IElOSVQudG9rZW5RdWV1ZVtpXVswXSkge1xuICAgICAgd2FybihgbGlua2lmeWpzOiB0b2tlbiBwbHVnaW4gXCIke25hbWV9XCIgYWxyZWFkeSByZWdpc3RlcmVkIC0gd2lsbCBiZSBvdmVyd3JpdHRlbmApO1xuICAgICAgSU5JVC50b2tlblF1ZXVlW2ldID0gW25hbWUsIHBsdWdpbl07XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIElOSVQudG9rZW5RdWV1ZS5wdXNoKFtuYW1lLCBwbHVnaW5dKTtcbiAgaWYgKElOSVQuaW5pdGlhbGl6ZWQpIHtcbiAgICB3YXJuKGBsaW5raWZ5anM6IGFscmVhZHkgaW5pdGlhbGl6ZWQgLSB3aWxsIG5vdCByZWdpc3RlciB0b2tlbiBwbHVnaW4gXCIke25hbWV9XCIgJHt3YXJuQWR2aWNlfWApO1xuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBsaW5raWZ5IHBsdWdpblxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgb2YgcGx1Z2luIHRvIHJlZ2lzdGVyXG4gKiBAcGFyYW0ge1BsdWdpbn0gcGx1Z2luIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgcGFyc2VyIHN0YXRlIG1hY2hpbmUgYW5kXG4gKiBleHRlbmRzIHRoZSBwYXJzZXIgdG8gcmVjb2duaXplIGFkZGl0aW9uYWwgbGluayB0eXBlc1xuICovXG5mdW5jdGlvbiByZWdpc3RlclBsdWdpbihuYW1lLCBwbHVnaW4pIHtcbiAgaWYgKHR5cGVvZiBwbHVnaW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGxpbmtpZnlqczogSW52YWxpZCBwbHVnaW4gJHtwbHVnaW59IChleHBlY3RzIGZ1bmN0aW9uKWApO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgSU5JVC5wbHVnaW5RdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChuYW1lID09PSBJTklULnBsdWdpblF1ZXVlW2ldWzBdKSB7XG4gICAgICB3YXJuKGBsaW5raWZ5anM6IHBsdWdpbiBcIiR7bmFtZX1cIiBhbHJlYWR5IHJlZ2lzdGVyZWQgLSB3aWxsIGJlIG92ZXJ3cml0dGVuYCk7XG4gICAgICBJTklULnBsdWdpblF1ZXVlW2ldID0gW25hbWUsIHBsdWdpbl07XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIElOSVQucGx1Z2luUXVldWUucHVzaChbbmFtZSwgcGx1Z2luXSk7XG4gIGlmIChJTklULmluaXRpYWxpemVkKSB7XG4gICAgd2FybihgbGlua2lmeWpzOiBhbHJlYWR5IGluaXRpYWxpemVkIC0gd2lsbCBub3QgcmVnaXN0ZXIgcGx1Z2luIFwiJHtuYW1lfVwiICR7d2FybkFkdmljZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIERldGVjdCBVUkxzIHdpdGggdGhlIGZvbGxvd2luZyBhZGRpdGlvbmFsIHByb3RvY29sLiBBbnl0aGluZyB3aXRoIGZvcm1hdFxuICogXCJwcm90b2NvbDovLy4uLlwiIHdpbGwgYmUgY29uc2lkZXJlZCBhIGxpbmsuIElmIGBvcHRpb25hbFNsYXNoU2xhc2hgIGlzIHNldCB0b1xuICogYHRydWVgLCBhbnl0aGluZyB3aXRoIGZvcm1hdCBcInByb3RvY29sOi4uLlwiIHdpbGwgYmUgY29uc2lkZXJlZCBhIGxpbmsuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvdG9jb2xcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbmFsU2xhc2hTbGFzaF1cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJDdXN0b21Qcm90b2NvbChzY2hlbWUsIG9wdGlvbmFsU2xhc2hTbGFzaCkge1xuICBpZiAob3B0aW9uYWxTbGFzaFNsYXNoID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25hbFNsYXNoU2xhc2ggPSBmYWxzZTtcbiAgfVxuICBpZiAoSU5JVC5pbml0aWFsaXplZCkge1xuICAgIHdhcm4oYGxpbmtpZnlqczogYWxyZWFkeSBpbml0aWFsaXplZCAtIHdpbGwgbm90IHJlZ2lzdGVyIGN1c3RvbSBzY2hlbWUgXCIke3NjaGVtZX1cIiAke3dhcm5BZHZpY2V9YCk7XG4gIH1cbiAgaWYgKCEvXlswLTlhLXpdKygtWzAtOWEtel0rKSokLy50ZXN0KHNjaGVtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGxpbmtpZnlqczogaW5jb3JyZWN0IHNjaGVtZSBmb3JtYXQuXG4xLiBNdXN0IG9ubHkgY29udGFpbiBkaWdpdHMsIGxvd2VyY2FzZSBBU0NJSSBsZXR0ZXJzIG9yIFwiLVwiXG4yLiBDYW5ub3Qgc3RhcnQgb3IgZW5kIHdpdGggXCItXCJcbjMuIFwiLVwiIGNhbm5vdCByZXBlYXRgKTtcbiAgfVxuICBJTklULmN1c3RvbVNjaGVtZXMucHVzaChbc2NoZW1lLCBvcHRpb25hbFNsYXNoU2xhc2hdKTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBsaW5raWZ5IHN0YXRlIG1hY2hpbmUuIENhbGxlZCBhdXRvbWF0aWNhbGx5IHRoZSBmaXJzdCB0aW1lXG4gKiBsaW5raWZ5IGlzIGNhbGxlZCBvbiBhIHN0cmluZywgYnV0IG1heSBiZSBjYWxsZWQgbWFudWFsbHkgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gaW5pdCgpIHtcbiAgLy8gSW5pdGlhbGl6ZSBzY2FubmVyIHN0YXRlIG1hY2hpbmUgYW5kIHBsdWdpbnNcbiAgSU5JVC5zY2FubmVyID0gaW5pdCQyKElOSVQuY3VzdG9tU2NoZW1lcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgSU5JVC50b2tlblF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgSU5JVC50b2tlblF1ZXVlW2ldWzFdKHtcbiAgICAgIHNjYW5uZXI6IElOSVQuc2Nhbm5lclxuICAgIH0pO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYXJzZXIgc3RhdGUgbWFjaGluZSBhbmQgcGx1Z2luc1xuICBJTklULnBhcnNlciA9IGluaXQkMShJTklULnNjYW5uZXIudG9rZW5zKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBJTklULnBsdWdpblF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgSU5JVC5wbHVnaW5RdWV1ZVtpXVsxXSh7XG4gICAgICBzY2FubmVyOiBJTklULnNjYW5uZXIsXG4gICAgICBwYXJzZXI6IElOSVQucGFyc2VyXG4gICAgfSk7XG4gIH1cbiAgSU5JVC5pbml0aWFsaXplZCA9IHRydWU7XG59XG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgaW50byB0b2tlbnMgdGhhdCByZXByZXNlbnQgbGlua2FibGUgYW5kIG5vbi1saW5rYWJsZSBzdWItY29tcG9uZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7TXVsdGlUb2tlbltdfSB0b2tlbnNcbiAqL1xuZnVuY3Rpb24gdG9rZW5pemUoc3RyKSB7XG4gIGlmICghSU5JVC5pbml0aWFsaXplZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICByZXR1cm4gcnVuKElOSVQucGFyc2VyLnN0YXJ0LCBzdHIsIHJ1biQxKElOSVQuc2Nhbm5lci5zdGFydCwgc3RyKSk7XG59XG5cbi8qKlxuICogRmluZCBhIGxpc3Qgb2YgbGlua2FibGUgaXRlbXMgaW4gdGhlIGdpdmVuIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgc3RyaW5nIHRvIGZpbmQgbGlua3MgaW5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgT3B0c30gW3R5cGVdIGVpdGhlciBmb3JtYXR0aW5nIG9wdGlvbnMgb3Igc3BlY2lmaWMgdHlwZSBvZlxuICogbGlua3MgdG8gZmluZCwgZS5nLiwgJ3VybCcgb3IgJ2VtYWlsJ1xuICogQHBhcmFtIHtPcHRzfSBbb3B0c10gZm9ybWF0dGluZyBvcHRpb25zIGZvciBmaW5hbCBvdXRwdXQuIENhbm5vdCBiZSBzcGVjaWZpZWRcbiAqIGlmIG9wdHMgYWxyZWFkeSBwcm92aWRlZCBpbiBgdHlwZWAgYXJndW1lbnRcbiAqL1xuZnVuY3Rpb24gZmluZChzdHIsIHR5cGUsIG9wdHMpIHtcbiAgaWYgKHR5cGUgPT09IHZvaWQgMCkge1xuICAgIHR5cGUgPSBudWxsO1xuICB9XG4gIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICBvcHRzID0gbnVsbDtcbiAgfVxuICBpZiAodHlwZSAmJiB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAob3B0cykge1xuICAgICAgdGhyb3cgRXJyb3IoYGxpbmtpZnlqczogSW52YWxpZCBsaW5rIHR5cGUgJHt0eXBlfTsgbXVzdCBiZSBhIHN0cmluZ2ApO1xuICAgIH1cbiAgICBvcHRzID0gdHlwZTtcbiAgICB0eXBlID0gbnVsbDtcbiAgfVxuICBjb25zdCBvcHRpb25zID0gbmV3IE9wdGlvbnMob3B0cyk7XG4gIGNvbnN0IHRva2VucyA9IHRva2VuaXplKHN0cik7XG4gIGNvbnN0IGZpbHRlcmVkID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgaWYgKHRva2VuLmlzTGluayAmJiAoIXR5cGUgfHwgdG9rZW4udCA9PT0gdHlwZSkgJiYgb3B0aW9ucy5jaGVjayh0b2tlbikpIHtcbiAgICAgIGZpbHRlcmVkLnB1c2godG9rZW4udG9Gb3JtYXR0ZWRPYmplY3Qob3B0aW9ucykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmlsdGVyZWQ7XG59XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIHN0cmluZyB2YWxpZCBsaW5rYWJsZSB0ZXh0IG9mIHNvbWUgc29ydC4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3RcbiAqIHRyaW0gdGhlIHRleHQgZm9yIHlvdS5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYSBzZWNvbmQgYHR5cGVgIHBhcmFtLCB3aGljaCBpcyB0aGUgdHlwZSBvZiBsaW5rIHRvIHRlc3RcbiAqIGZvci5cbiAqXG4gKiBGb3IgZXhhbXBsZSxcbiAqXG4gKiAgICAgbGlua2lmeS50ZXN0KHN0ciwgJ2VtYWlsJyk7XG4gKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgc3RyIGlzIGEgdmFsaWQgZW1haWwuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIHN0cmluZyB0byB0ZXN0IGZvciBsaW5rc1xuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBvcHRpb25hbCBzcGVjaWZpYyBsaW5rIHR5cGUgdG8gbG9vayBmb3JcbiAqIEByZXR1cm5zIGJvb2xlYW4gdHJ1ZS9mYWxzZVxuICovXG5mdW5jdGlvbiB0ZXN0KHN0ciwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7XG4gICAgdHlwZSA9IG51bGw7XG4gIH1cbiAgY29uc3QgdG9rZW5zID0gdG9rZW5pemUoc3RyKTtcbiAgcmV0dXJuIHRva2Vucy5sZW5ndGggPT09IDEgJiYgdG9rZW5zWzBdLmlzTGluayAmJiAoIXR5cGUgfHwgdG9rZW5zWzBdLnQgPT09IHR5cGUpO1xufVxuXG5leHBvcnQgeyBNdWx0aVRva2VuLCBPcHRpb25zLCBTdGF0ZSwgY3JlYXRlVG9rZW5DbGFzcywgZmluZCwgaW5pdCwgbXVsdGksIG9wdGlvbnMsIHJlZ2V4cCwgcmVnaXN0ZXJDdXN0b21Qcm90b2NvbCwgcmVnaXN0ZXJQbHVnaW4sIHJlZ2lzdGVyVG9rZW5QbHVnaW4sIHJlc2V0LCBzdHJpbmdUb0FycmF5LCB0ZXN0LCB0b2tlbml6ZSB9O1xuIiwgImltcG9ydCB7XG4gIGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzLFxuICBmaW5kQ2hpbGRyZW5JblJhbmdlLFxuICBnZXRDaGFuZ2VkUmFuZ2VzLFxuICBnZXRNYXJrc0JldHdlZW4sXG4gIE5vZGVXaXRoUG9zLFxufSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBmaW5kIH0gZnJvbSAnbGlua2lmeWpzJ1xuXG50eXBlIEF1dG9saW5rT3B0aW9ucyA9IHtcbiAgdHlwZTogTWFya1R5cGVcbiAgdmFsaWRhdGU/OiAodXJsOiBzdHJpbmcpID0+IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF1dG9saW5rKG9wdGlvbnM6IEF1dG9saW5rT3B0aW9ucyk6IFBsdWdpbiB7XG4gIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2F1dG9saW5rJyksXG4gICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBuZXdTdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgZG9jQ2hhbmdlcyA9IHRyYW5zYWN0aW9ucy5zb21lKHRyYW5zYWN0aW9uID0+IHRyYW5zYWN0aW9uLmRvY0NoYW5nZWQpICYmICFvbGRTdGF0ZS5kb2MuZXEobmV3U3RhdGUuZG9jKVxuICAgICAgY29uc3QgcHJldmVudEF1dG9saW5rID0gdHJhbnNhY3Rpb25zLnNvbWUodHJhbnNhY3Rpb24gPT4gdHJhbnNhY3Rpb24uZ2V0TWV0YSgncHJldmVudEF1dG9saW5rJykpXG5cbiAgICAgIGlmICghZG9jQ2hhbmdlcyB8fCBwcmV2ZW50QXV0b2xpbmspIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgdHIgfSA9IG5ld1N0YXRlXG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBjb21iaW5lVHJhbnNhY3Rpb25TdGVwcyhvbGRTdGF0ZS5kb2MsIFsuLi50cmFuc2FjdGlvbnNdKVxuICAgICAgY29uc3QgY2hhbmdlcyA9IGdldENoYW5nZWRSYW5nZXModHJhbnNmb3JtKVxuXG4gICAgICBjaGFuZ2VzLmZvckVhY2goKHsgbmV3UmFuZ2UgfSkgPT4ge1xuICAgICAgICAvLyBOb3cgbGV04oCZcyBzZWUgaWYgd2UgY2FuIGFkZCBuZXcgbGlua3MuXG4gICAgICAgIGNvbnN0IG5vZGVzSW5DaGFuZ2VkUmFuZ2VzID0gZmluZENoaWxkcmVuSW5SYW5nZShcbiAgICAgICAgICBuZXdTdGF0ZS5kb2MsXG4gICAgICAgICAgbmV3UmFuZ2UsXG4gICAgICAgICAgbm9kZSA9PiBub2RlLmlzVGV4dGJsb2NrLFxuICAgICAgICApXG5cbiAgICAgICAgbGV0IHRleHRCbG9jazogTm9kZVdpdGhQb3MgfCB1bmRlZmluZWRcbiAgICAgICAgbGV0IHRleHRCZWZvcmVXaGl0ZXNwYWNlOiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAgICAgICBpZiAobm9kZXNJbkNoYW5nZWRSYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIC8vIEdyYWIgdGhlIGZpcnN0IG5vZGUgd2l0aGluIHRoZSBjaGFuZ2VkIHJhbmdlcyAoZXguIHRoZSBmaXJzdCBvZiB0d28gcGFyYWdyYXBocyB3aGVuIGhpdHRpbmcgZW50ZXIpLlxuICAgICAgICAgIHRleHRCbG9jayA9IG5vZGVzSW5DaGFuZ2VkUmFuZ2VzWzBdXG4gICAgICAgICAgdGV4dEJlZm9yZVdoaXRlc3BhY2UgPSBuZXdTdGF0ZS5kb2MudGV4dEJldHdlZW4oXG4gICAgICAgICAgICB0ZXh0QmxvY2sucG9zLFxuICAgICAgICAgICAgdGV4dEJsb2NrLnBvcyArIHRleHRCbG9jay5ub2RlLm5vZGVTaXplLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgJyAnLFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBub2Rlc0luQ2hhbmdlZFJhbmdlcy5sZW5ndGhcbiAgICAgICAgICAvLyBXZSB3YW50IHRvIG1ha2Ugc3VyZSB0byBpbmNsdWRlIHRoZSBibG9jayBzZXBlcmF0b3IgYXJndW1lbnQgdG8gdHJlYXQgaGFyZCBicmVha3MgbGlrZSBzcGFjZXMuXG4gICAgICAgICAgJiYgbmV3U3RhdGUuZG9jLnRleHRCZXR3ZWVuKG5ld1JhbmdlLmZyb20sIG5ld1JhbmdlLnRvLCAnICcsICcgJykuZW5kc1dpdGgoJyAnKVxuICAgICAgICApIHtcbiAgICAgICAgICB0ZXh0QmxvY2sgPSBub2Rlc0luQ2hhbmdlZFJhbmdlc1swXVxuICAgICAgICAgIHRleHRCZWZvcmVXaGl0ZXNwYWNlID0gbmV3U3RhdGUuZG9jLnRleHRCZXR3ZWVuKFxuICAgICAgICAgICAgdGV4dEJsb2NrLnBvcyxcbiAgICAgICAgICAgIG5ld1JhbmdlLnRvLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgJyAnLFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0QmxvY2sgJiYgdGV4dEJlZm9yZVdoaXRlc3BhY2UpIHtcbiAgICAgICAgICBjb25zdCB3b3Jkc0JlZm9yZVdoaXRlc3BhY2UgPSB0ZXh0QmVmb3JlV2hpdGVzcGFjZS5zcGxpdCgnICcpLmZpbHRlcihzID0+IHMgIT09ICcnKVxuXG4gICAgICAgICAgaWYgKHdvcmRzQmVmb3JlV2hpdGVzcGFjZS5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbGFzdFdvcmRCZWZvcmVTcGFjZSA9IHdvcmRzQmVmb3JlV2hpdGVzcGFjZVt3b3Jkc0JlZm9yZVdoaXRlc3BhY2UubGVuZ3RoIC0gMV1cbiAgICAgICAgICBjb25zdCBsYXN0V29yZEFuZEJsb2NrT2Zmc2V0ID0gdGV4dEJsb2NrLnBvcyArIHRleHRCZWZvcmVXaGl0ZXNwYWNlLmxhc3RJbmRleE9mKGxhc3RXb3JkQmVmb3JlU3BhY2UpXG5cbiAgICAgICAgICBpZiAoIWxhc3RXb3JkQmVmb3JlU3BhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpbmQobGFzdFdvcmRCZWZvcmVTcGFjZSlcbiAgICAgICAgICAgIC5maWx0ZXIobGluayA9PiBsaW5rLmlzTGluaylcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBsaW5rIHBvc2l0aW9uLlxuICAgICAgICAgICAgLm1hcChsaW5rID0+ICh7XG4gICAgICAgICAgICAgIC4uLmxpbmssXG4gICAgICAgICAgICAgIGZyb206IGxhc3RXb3JkQW5kQmxvY2tPZmZzZXQgKyBsaW5rLnN0YXJ0ICsgMSxcbiAgICAgICAgICAgICAgdG86IGxhc3RXb3JkQW5kQmxvY2tPZmZzZXQgKyBsaW5rLmVuZCArIDEsXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC8vIGlnbm9yZSBsaW5rIGluc2lkZSBjb2RlIG1hcmtcbiAgICAgICAgICAgIC5maWx0ZXIobGluayA9PiB7XG4gICAgICAgICAgICAgIGlmICghbmV3U3RhdGUuc2NoZW1hLm1hcmtzLmNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuICFuZXdTdGF0ZS5kb2MucmFuZ2VIYXNNYXJrKFxuICAgICAgICAgICAgICAgIGxpbmsuZnJvbSxcbiAgICAgICAgICAgICAgICBsaW5rLnRvLFxuICAgICAgICAgICAgICAgIG5ld1N0YXRlLnNjaGVtYS5tYXJrcy5jb2RlLFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLy8gdmFsaWRhdGUgbGlua1xuICAgICAgICAgICAgLmZpbHRlcihsaW5rID0+IHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy52YWxpZGF0ZShsaW5rLnZhbHVlKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLy8gQWRkIGxpbmsgbWFyay5cbiAgICAgICAgICAgIC5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgICAgICAgICBpZiAoZ2V0TWFya3NCZXR3ZWVuKGxpbmsuZnJvbSwgbGluay50bywgbmV3U3RhdGUuZG9jKS5zb21lKGl0ZW0gPT4gaXRlbS5tYXJrLnR5cGUgPT09IG9wdGlvbnMudHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRyLmFkZE1hcmsoXG4gICAgICAgICAgICAgICAgbGluay5mcm9tLFxuICAgICAgICAgICAgICAgIGxpbmsudG8sXG4gICAgICAgICAgICAgICAgb3B0aW9ucy50eXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICBocmVmOiBsaW5rLmhyZWYsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGlmICghdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IGdldEF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbnR5cGUgQ2xpY2tIYW5kbGVyT3B0aW9ucyA9IHtcbiAgdHlwZTogTWFya1R5cGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsaWNrSGFuZGxlcihvcHRpb25zOiBDbGlja0hhbmRsZXJPcHRpb25zKTogUGx1Z2luIHtcbiAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgIGtleTogbmV3IFBsdWdpbktleSgnaGFuZGxlQ2xpY2tMaW5rJyksXG4gICAgcHJvcHM6IHtcbiAgICAgIGhhbmRsZUNsaWNrOiAodmlldywgcG9zLCBldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYSA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudFxuICAgICAgICBjb25zdCBlbHMgPSBbXVxuXG4gICAgICAgIHdoaWxlIChhLm5vZGVOYW1lICE9PSAnRElWJykge1xuICAgICAgICAgIGVscy5wdXNoKGEpXG4gICAgICAgICAgYSA9IGEucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlbHMuZmluZCh2YWx1ZSA9PiB2YWx1ZS5ub2RlTmFtZSA9PT0gJ0EnKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXR0cnMgPSBnZXRBdHRyaWJ1dGVzKHZpZXcuc3RhdGUsIG9wdGlvbnMudHlwZS5uYW1lKVxuICAgICAgICBjb25zdCBsaW5rID0gKGV2ZW50LnRhcmdldCBhcyBIVE1MTGlua0VsZW1lbnQpXG5cbiAgICAgICAgY29uc3QgaHJlZiA9IGxpbms/LmhyZWYgPz8gYXR0cnMuaHJlZlxuICAgICAgICBjb25zdCB0YXJnZXQgPSBsaW5rPy50YXJnZXQgPz8gYXR0cnMudGFyZ2V0XG5cbiAgICAgICAgaWYgKGxpbmsgJiYgaHJlZikge1xuICAgICAgICAgIHdpbmRvdy5vcGVuKGhyZWYsIHRhcmdldClcblxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0sXG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBFZGl0b3IgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBmaW5kIH0gZnJvbSAnbGlua2lmeWpzJ1xuXG50eXBlIFBhc3RlSGFuZGxlck9wdGlvbnMgPSB7XG4gIGVkaXRvcjogRWRpdG9yXG4gIHR5cGU6IE1hcmtUeXBlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXN0ZUhhbmRsZXIob3B0aW9uczogUGFzdGVIYW5kbGVyT3B0aW9ucyk6IFBsdWdpbiB7XG4gIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2hhbmRsZVBhc3RlTGluaycpLFxuICAgIHByb3BzOiB7XG4gICAgICBoYW5kbGVQYXN0ZTogKHZpZXcsIGV2ZW50LCBzbGljZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSB2aWV3XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICAgICAgICBjb25zdCB7IGVtcHR5IH0gPSBzZWxlY3Rpb25cblxuICAgICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0ZXh0Q29udGVudCA9ICcnXG5cbiAgICAgICAgc2xpY2UuY29udGVudC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgIHRleHRDb250ZW50ICs9IG5vZGUudGV4dENvbnRlbnRcbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBsaW5rID0gZmluZCh0ZXh0Q29udGVudCkuZmluZChpdGVtID0+IGl0ZW0uaXNMaW5rICYmIGl0ZW0udmFsdWUgPT09IHRleHRDb250ZW50KVxuXG4gICAgICAgIGlmICghdGV4dENvbnRlbnQgfHwgIWxpbmspIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMuZWRpdG9yLmNvbW1hbmRzLnNldE1hcmsob3B0aW9ucy50eXBlLCB7XG4gICAgICAgICAgaHJlZjogbGluay5ocmVmLFxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9LFxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHtcbiAgTWFyaywgbWFya1Bhc3RlUnVsZSwgbWVyZ2VBdHRyaWJ1dGVzLCBQYXN0ZVJ1bGVNYXRjaCxcbn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IGZpbmQsIHJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wsIHJlc2V0IH0gZnJvbSAnbGlua2lmeWpzJ1xuXG5pbXBvcnQgeyBhdXRvbGluayB9IGZyb20gJy4vaGVscGVycy9hdXRvbGluay5qcydcbmltcG9ydCB7IGNsaWNrSGFuZGxlciB9IGZyb20gJy4vaGVscGVycy9jbGlja0hhbmRsZXIuanMnXG5pbXBvcnQgeyBwYXN0ZUhhbmRsZXIgfSBmcm9tICcuL2hlbHBlcnMvcGFzdGVIYW5kbGVyLmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIExpbmtQcm90b2NvbE9wdGlvbnMge1xuICBzY2hlbWU6IHN0cmluZztcbiAgb3B0aW9uYWxTbGFzaGVzPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IHBhc3RlUmVnZXggPSAvaHR0cHM/OlxcL1xcLyg/Ond3d1xcLik/Wy1hLXpBLVowLTlAOiUuXyt+Iz1dezEsMjU2fVxcLlthLXpBLVpdezIsfVxcYig/OlstYS16QS1aMC05QDolLl8rfiM9PyEmL10qKSg/OlstYS16QS1aMC05QDolLl8rfiM9PyEmL10qKS9naVxuXG5leHBvcnQgaW50ZXJmYWNlIExpbmtPcHRpb25zIHtcbiAgLyoqXG4gICAqIElmIGVuYWJsZWQsIGl0IGFkZHMgbGlua3MgYXMgeW91IHR5cGUuXG4gICAqL1xuICBhdXRvbGluazogYm9vbGVhblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgY3VzdG9tIHByb3RvY29scyB0byBiZSByZWdpc3RlcmVkIHdpdGggbGlua2lmeWpzLlxuICAgKi9cbiAgcHJvdG9jb2xzOiBBcnJheTxMaW5rUHJvdG9jb2xPcHRpb25zIHwgc3RyaW5nPlxuICAvKipcbiAgICogSWYgZW5hYmxlZCwgbGlua3Mgd2lsbCBiZSBvcGVuZWQgb24gY2xpY2suXG4gICAqL1xuICBvcGVuT25DbGljazogYm9vbGVhblxuICAvKipcbiAgICogQWRkcyBhIGxpbmsgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlmIHRoZSBwYXN0ZWQgY29udGVudCBvbmx5IGNvbnRhaW5zIGFuIHVybC5cbiAgICovXG4gIGxpbmtPblBhc3RlOiBib29sZWFuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgSFRNTCBhdHRyaWJ1dGVzIHRvIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgLyoqXG4gICAqIEEgdmFsaWRhdGlvbiBmdW5jdGlvbiB0aGF0IG1vZGlmaWVzIGxpbmsgdmVyaWZpY2F0aW9uIGZvciB0aGUgYXV0byBsaW5rZXIuXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgdXJsIHRvIGJlIHZhbGlkYXRlZC5cbiAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSB1cmwgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHZhbGlkYXRlPzogKHVybDogc3RyaW5nKSA9PiBib29sZWFuXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBsaW5rOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBhIGxpbmsgbWFya1xuICAgICAgICovXG4gICAgICBzZXRMaW5rOiAoYXR0cmlidXRlczogeyBocmVmOiBzdHJpbmc7IHRhcmdldD86IHN0cmluZyB8IG51bGw7IHJlbD86IHN0cmluZyB8IG51bGw7IGNsYXNzPzogc3RyaW5nIHwgbnVsbCB9KSA9PiBSZXR1cm5UeXBlXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIGxpbmsgbWFya1xuICAgICAgICovXG4gICAgICB0b2dnbGVMaW5rOiAoYXR0cmlidXRlczogeyBocmVmOiBzdHJpbmc7IHRhcmdldD86IHN0cmluZyB8IG51bGw7IHJlbD86IHN0cmluZyB8IG51bGw7IGNsYXNzPzogc3RyaW5nIHwgbnVsbCB9KSA9PiBSZXR1cm5UeXBlXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGEgbGluayBtYXJrXG4gICAgICAgKi9cbiAgICAgIHVuc2V0TGluazogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgTGluayA9IE1hcmsuY3JlYXRlPExpbmtPcHRpb25zPih7XG4gIG5hbWU6ICdsaW5rJyxcblxuICBwcmlvcml0eTogMTAwMCxcblxuICBrZWVwT25TcGxpdDogZmFsc2UsXG5cbiAgb25DcmVhdGUoKSB7XG4gICAgdGhpcy5vcHRpb25zLnByb3RvY29scy5mb3JFYWNoKHByb3RvY29sID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2wgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wocHJvdG9jb2wpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmVnaXN0ZXJDdXN0b21Qcm90b2NvbChwcm90b2NvbC5zY2hlbWUsIHByb3RvY29sLm9wdGlvbmFsU2xhc2hlcylcbiAgICB9KVxuICB9LFxuXG4gIG9uRGVzdHJveSgpIHtcbiAgICByZXNldCgpXG4gIH0sXG5cbiAgaW5jbHVzaXZlKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXV0b2xpbmtcbiAgfSxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcGVuT25DbGljazogdHJ1ZSxcbiAgICAgIGxpbmtPblBhc3RlOiB0cnVlLFxuICAgICAgYXV0b2xpbms6IHRydWUsXG4gICAgICBwcm90b2NvbHM6IFtdLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgdGFyZ2V0OiAnX2JsYW5rJyxcbiAgICAgICAgcmVsOiAnbm9vcGVuZXIgbm9yZWZlcnJlciBub2ZvbGxvdycsXG4gICAgICAgIGNsYXNzOiBudWxsLFxuICAgICAgfSxcbiAgICAgIHZhbGlkYXRlOiB1bmRlZmluZWQsXG4gICAgfVxuICB9LFxuXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhyZWY6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgIH0sXG4gICAgICB0YXJnZXQ6IHtcbiAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLnRhcmdldCxcbiAgICAgIH0sXG4gICAgICByZWw6IHtcbiAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLnJlbCxcbiAgICAgIH0sXG4gICAgICBjbGFzczoge1xuICAgICAgICBkZWZhdWx0OiB0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMuY2xhc3MsXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFt7IHRhZzogJ2FbaHJlZl06bm90KFtocmVmICo9IFwiamF2YXNjcmlwdDpcIiBpXSknIH1dXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAvLyBGYWxzZSBwb3NpdGl2ZTsgd2UncmUgZXhwbGljaXRseSBjaGVja2luZyBmb3IgamF2YXNjcmlwdDogbGlua3MgdG8gaWdub3JlIHRoZW1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2NyaXB0LXVybFxuICAgIGlmIChIVE1MQXR0cmlidXRlcy5ocmVmPy5zdGFydHNXaXRoKCdqYXZhc2NyaXB0OicpKSB7XG4gICAgICAvLyBzdHJpcCBvdXQgdGhlIGhyZWZcbiAgICAgIHJldHVybiBbJ2EnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCB7IC4uLkhUTUxBdHRyaWJ1dGVzLCBocmVmOiAnJyB9KSwgMF1cbiAgICB9XG4gICAgcmV0dXJuIFsnYScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0TGluazpcbiAgICAgICAgYXR0cmlidXRlcyA9PiAoeyBjaGFpbiB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNoYWluKCkuc2V0TWFyayh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMpLnNldE1ldGEoJ3ByZXZlbnRBdXRvbGluaycsIHRydWUpLnJ1bigpXG4gICAgICAgIH0sXG5cbiAgICAgIHRvZ2dsZUxpbms6XG4gICAgICAgIGF0dHJpYnV0ZXMgPT4gKHsgY2hhaW4gfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjaGFpbigpXG4gICAgICAgICAgICAudG9nZ2xlTWFyayh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMsIHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2U6IHRydWUgfSlcbiAgICAgICAgICAgIC5zZXRNZXRhKCdwcmV2ZW50QXV0b2xpbmsnLCB0cnVlKVxuICAgICAgICAgICAgLnJ1bigpXG4gICAgICAgIH0sXG5cbiAgICAgIHVuc2V0TGluazpcbiAgICAgICAgKCkgPT4gKHsgY2hhaW4gfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjaGFpbigpXG4gICAgICAgICAgICAudW5zZXRNYXJrKHRoaXMubmFtZSwgeyBleHRlbmRFbXB0eU1hcmtSYW5nZTogdHJ1ZSB9KVxuICAgICAgICAgICAgLnNldE1ldGEoJ3ByZXZlbnRBdXRvbGluaycsIHRydWUpXG4gICAgICAgICAgICAucnVuKClcbiAgICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6ICh0ZXh0LCBldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGh0bWwgPSBldmVudD8uY2xpcGJvYXJkRGF0YT8uZ2V0RGF0YSgndGV4dC9odG1sJylcblxuICAgICAgICAgIGNvbnN0IGZvdW5kTGlua3M6IFBhc3RlUnVsZU1hdGNoW10gPSBbXVxuXG4gICAgICAgICAgaWYgKGh0bWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvbSA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoaHRtbCwgJ3RleHQvaHRtbCcpXG4gICAgICAgICAgICBjb25zdCBhbmNob3JzID0gZG9tLnF1ZXJ5U2VsZWN0b3JBbGwoJ2EnKVxuXG4gICAgICAgICAgICBpZiAoYW5jaG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgWy4uLmFuY2hvcnNdLmZvckVhY2goYW5jaG9yID0+IChmb3VuZExpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRleHQ6IGFuY2hvci5pbm5lclRleHQsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgaHJlZjogYW5jaG9yLmdldEF0dHJpYnV0ZSgnaHJlZicpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgYW5jaG9yIGluc2lkZSB0aGUgdGV4dFxuICAgICAgICAgICAgICAgIC8vIGFuZCBhZGQgdGhlIGxlbmd0aCBvZiB0aGUgYW5jaG9yIHRleHRcbiAgICAgICAgICAgICAgICBpbmRleDogZG9tLmJvZHkuaW5uZXJUZXh0LmluZGV4T2YoYW5jaG9yLmlubmVyVGV4dCkgKyBhbmNob3IuaW5uZXJUZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgfSkpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rcyA9IGZpbmQodGV4dCkuZmlsdGVyKGl0ZW0gPT4gaXRlbS5pc0xpbmspXG5cbiAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbGlua3MuZm9yRWFjaChsaW5rID0+IChmb3VuZExpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRleHQ6IGxpbmsudmFsdWUsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgaHJlZjogbGluay5ocmVmLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5kZXg6IGxpbmsuc3RhcnQsXG4gICAgICAgICAgICAgIH0pKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZm91bmRMaW5rc1xuICAgICAgICB9LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaHJlZjogbWF0Y2guZGF0YT8uaHJlZixcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIGNvbnN0IHBsdWdpbnM6IFBsdWdpbltdID0gW11cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b2xpbmspIHtcbiAgICAgIHBsdWdpbnMucHVzaChcbiAgICAgICAgYXV0b2xpbmsoe1xuICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICB2YWxpZGF0ZTogdGhpcy5vcHRpb25zLnZhbGlkYXRlLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9wZW5PbkNsaWNrKSB7XG4gICAgICBwbHVnaW5zLnB1c2goXG4gICAgICAgIGNsaWNrSGFuZGxlcih7XG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpbmtPblBhc3RlKSB7XG4gICAgICBwbHVnaW5zLnB1c2goXG4gICAgICAgIHBhc3RlSGFuZGxlcih7XG4gICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiBwbHVnaW5zXG4gIH0sXG59KVxuIiwgImltcG9ydCBMaW5rIGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWxpbmsnXG5cbmV4cG9ydCBkZWZhdWx0IExpbmsuZXh0ZW5kKHtcbiAgICBpbmNsdXNpdmU6IGZhbHNlLFxuXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wZW5PbkNsaWNrOiBmYWxzZSxcbiAgICAgICAgICAgIGxpbmtPblBhc3RlOiB0cnVlLFxuICAgICAgICAgICAgYXV0b2xpbms6IGZhbHNlLFxuICAgICAgICAgICAgcHJvdG9jb2xzOiBbXSxcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgICAgIHZhbGlkYXRlOiB1bmRlZmluZWQsXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhyZWY6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vZGVsX2lkOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb2RlbF90eXBlOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMudGFyZ2V0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWw6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgZGVmYXVsdCAgRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdFbWJlZCcsXG5cbi8vICAgYWRkUGFzdGVSdWxlcygpIHtcbi8vICAgICByZXR1cm4gW1xuLy8gICAgICAge1xuLy8gICAgICAgICBmaW5kOiAvXihodHRwcz86XFwvXFwvKT8od3d3XFwueW91dHViZVxcLmNvbVxcL3dhdGNoXFw/dj18eW91dHVcXC5iZVxcLykoW2EtekEtWjAtOV8tXSspJC9nLFxuLy8gICAgICAgICBoYW5kbGVyOiAoeyBtYXRjaCwgY29tbWFuZHMgfSkgPT4ge1xuLy8gICAgICAgICAgIGNvbnN0IHVybCA9IG1hdGNoWzBdO1xuLy8gICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4vLyAgICAgICAgICAgICBpZGVudGlmaWVyOiAnZW1iZWQnLFxuLy8gICAgICAgICAgICAgdmFsdWVzOiB7XG4vLyAgICAgICAgICAgICAgICAgZW1iZWQ6IHVybFxuLy8gICAgICAgICAgICAgIH0sXG4vLyAgICAgICAgICAgfTtcblxuLy8gICAgICAgICAgIGNvbW1hbmRzLmluc2VydFNjcmliYmxlQmxvY2sob3B0aW9ucyk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH0sXG4vLyAgICAgXTtcbi8vICAgfVxufSk7XG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSdcbmltcG9ydCB7IERPTVBhcnNlciBhcyBQcm9zZU1pcnJvckRPTVBhcnNlciB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJ1xuXG5cbmV4cG9ydCBkZWZhdWx0IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAnb0VtYmVkRXh0ZW5zaW9uJyxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0T2VtYmVkQ29udGVudDogb3B0aW9ucyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5pbnNlcnRDb250ZW50KGA8ZGl2IGNsYXNzPVwib2VtYmVkXCI+JHtvcHRpb25zLmh0bWx9PC9kaXY+YClcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnaGFuZGxlUGFzdGUnKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBoYW5kbGVQYXN0ZSh2aWV3LCBldmVudCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuICAgICAgICAgICAgY29uc3QgdXJsUmVnZXggPSAvKGh0dHBzPzpcXC9cXC9bXlxcc10rKS9nO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmxSZWdleC5leGVjKHRleHQpO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgLy8gUHJldmVudCB0aGUgZGVmYXVsdCBiZWhhdmlvclxuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgIC8vIFVzZSB5b3VyIGhhbmRsZXIgdG8gcHJvY2VzcyB0aGUgVVJMXG4gICAgICAgICAgICAgIGNvbnN0IHVybCA9IG1hdGNoWzBdO1xuXG4gICAgICAgICAgICAgIC8vIENhbGwgeW91ciBjdXN0b20gaGFuZGxlclxuICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvb2VtYmVkLWNoZWNrJywge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgICAgJ1gtQ1NSRi1UT0tFTic6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cImNzcmYtdG9rZW5cIl0nKS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHVybCB9KSxcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoZGF0YS5pc1ZhbGlkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAvLyBVc2lhbW8gaWwgZGlzcGF0Y2hlciBkZWwgdmlldyBwZXIgcmljaGlhbWFyZSBpbCBjb21hbmRvXG4gICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKFxuICAgICAgICAgICAgICAgICAgICAgdmlldy5zdGF0ZS5zY2hlbWEubm9kZXMuc2NyaWJibGVCbG9jay5jcmVhdGVBbmRGaWxsKHsgaWRlbnRpZmllcjogJ2VtYmVkJywgdmFsdWVzOiB7IHVybDogdXJsIH0gfSkgLy8gQXNzdW1lbmRvIGNoZSBcIm9FbWJlZFwiIHNpYSBpbCB0aXBvIGRpIG5vZG8gZGVmaW5pdG8gbmVsIHR1byBzY2hlbWFcbiAgICAgICAgICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQmxvY2sgaW5zZXJ0ZWQgc3VjY2Vzc2Z1bGx5IHdpdGggZmV0Y2ggZGF0YScpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1VSTCBub24gXHUwMEU4IHVuIGVtYmVkJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZldGNoIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaGFuZGxlcigpO1xuXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pO1xuIiwgIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTm9kZVZpZXdXcmFwcGVyIH0gZnJvbSAnc3ZlbHRlLXRpcHRhcCdcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCBCbG9ja0FjdGlvbnMgZnJvbSAnLi9CbG9ja0FjdGlvbnMuc3ZlbHRlJ1xuICAgIGltcG9ydCBEcmFnSGFuZGxlIGZyb20gJy4vRHJhZ0hhbmRsZS5zdmVsdGUnXG4gICAgaW1wb3J0IHRpcHB5IGZyb20gJ3RpcHB5LmpzJ1xuICAgIGltcG9ydCBPcHRpb25zTWVudSBmcm9tICcuL09wdGlvbnNNZW51LnN2ZWx0ZSdcblxuICAgIGV4cG9ydCBsZXQgZWRpdG9yO1xuICAgIGV4cG9ydCBsZXQgbm9kZTtcbiAgICBleHBvcnQgbGV0IHNlbGVjdGVkID0gZmFsc2U7XG4gICAgZXhwb3J0IGxldCB1cGRhdGVBdHRyaWJ1dGVzO1xuXG4gICAgbGV0IGNvbXBvbmVudDtcbiAgICBsZXQgcG9wdXBJbnN0YW5jZTtcblxuICAgIGNvbnN0IGhhbmRsZU1lbnVPcGVuID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIC8vIEluaXppYWxpenphIHByaW1hIGlsIGNvbXBvbmVudGUgc2VuemEgcG9wdXBJbnN0YW5jZVxuICAgICAgICBjb21wb25lbnQgPSBuZXcgT3B0aW9uc01lbnUoe1xuICAgICAgICAgICAgdGFyZ2V0OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgLy8gQ3JlYSB1biBlbGVtZW50byBkaXYgcGVyIG1vbnRhcmUgaWwgY29tcG9uZW50ZSBTdmVsdGVcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICBzaG93U2V0dGluZ3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICBvbkNsb3NlOiAoKSA9PiBjbG9zZU9wdGlvbnMoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwb3B1cEluc3RhbmNlID0gdGlwcHkoJ2JvZHknLCB7XG4gICAgICAgICAgICBjb250ZW50OiBjb21wb25lbnQuJCQucm9vdCxcbiAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6ICgpID0+IGNsaWVudFJlY3QsXG4gICAgICAgICAgICBhbGxvd0hUTUw6IHRydWUsXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgcGxhY2VtZW50OiAnbGVmdCcsXG4gICAgICAgICAgICBzaG93T25DcmVhdGU6IHRydWUsXG4gICAgICAgICAgICBoaWRlT25DbGljazogdHJ1ZSxcbiAgICAgICAgICAgIHRoZW1lOiAnc2NyaWJibGUtb3B0aW9ucycsXG4gICAgICAgICAgICBhcnJvdzogdHJ1ZSxcbiAgICAgICAgICAgIHpJbmRleDogOTk5OSxcbiAgICAgICAgICAgIG9uSGlkZGVuKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgY2xvc2VPcHRpb25zID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBvcHVwSW5zdGFuY2UpKSB7XG4gICAgICAgICAgICBwb3B1cEluc3RhbmNlLmZvckVhY2goaW5zdGFuY2UgPT4gaW5zdGFuY2UuaGlkZSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcHVwSW5zdGFuY2UuaGlkZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVkQmxvY2snLCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGUuZGV0YWlsLnR5cGUgPT09IG5vZGUuYXR0cnMudHlwZVxuICAgICAgICAgICAgICAgICYmIGUuZGV0YWlsLnN0YXRlUGF0aCA9PT0gZWRpdG9yLnN0b3JhZ2U/LnN0YXRlUGF0aEV4dGVuc2lvbi5zdGF0ZVBhdGhcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUF0dHJpYnV0ZXMoeyB2YWx1ZXM6IGUuZGV0YWlsLnZhbHVlcyB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0pXG48L3NjcmlwdD5cblxuPE5vZGVWaWV3V3JhcHBlcj5cbiAgICA8ZGl2IGNsYXNzPVwic2NyaWJibGUtYmxvY2tcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNjcmliYmxlLWJsb2NrLWNvbnRlbnQge3NlbGVjdGVkID8gJ1Byb3NlTWlycm9yLXNlbGVjdGVkbm9kZScgOiAnJ31cIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwLThcIj5cbiAgICAgICAgICAgICAgICB7bm9kZS5hdHRycy51cmx9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxCbG9ja0FjdGlvbnM+XG4gICAgICAgICAgICA8RHJhZ0hhbmRsZSB7aGFuZGxlTWVudU9wZW59IC8+XG4gICAgICAgIDwvQmxvY2tBY3Rpb25zPlxuICAgIDwvZGl2PlxuPC9Ob2RlVmlld1dyYXBwZXI+XG4iLCAiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmltcG9ydCBvRW1iZWRWaWV3IGZyb20gXCIuLi9jb21wb25lbnRzL29FbWJlZFZpZXcuc3ZlbHRlXCJcbmltcG9ydCB7IFN2ZWx0ZU5vZGVWaWV3UmVuZGVyZXIgfSBmcm9tICdzdmVsdGUtdGlwdGFwJ1xuaW1wb3J0IHsgdXVpZCB9IGZyb20gXCIuLi91dGlscy5qc1wiXG5cbmV4cG9ydCBkZWZhdWx0IE5vZGUuY3JlYXRlKHtcbiAgbmFtZTogJ29FbWJlZCcsXG4gIGlzQmxvY2s6IHRydWUsXG4gICAgaW5saW5lOiBmYWxzZSxcbiAgICBncm91cDogJ2Jsb2NrJyxcbiAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgZGVmaW5pbmc6IHRydWUsXG4gICAgc2VsZWN0YWJsZTogdHJ1ZSxcblxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmw6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhZzogJ29FbWJlZCcsXG4gICAgICAgICAgICAgICAgZ2V0QXR0cnM6IChkb20pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZG9tLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBbJ29FbWJlZCcsIEpTT04uc3RyaW5naWZ5KEhUTUxBdHRyaWJ1dGVzKV07XG4gICAgfSxcblxuICAgIGFkZE5vZGVWaWV3KCkge1xuICAgICAgICByZXR1cm4gU3ZlbHRlTm9kZVZpZXdSZW5kZXJlcihvRW1iZWRWaWV3KVxuICAgIH1cbn0pO1xuIiwgIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHtvbk1vdW50LCBvbkRlc3Ryb3l9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQge0VkaXRvcn0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuICAgIGltcG9ydCB7QnViYmxlTWVudSBhcyBUaXB0YXBCdWJibGVNZW51fSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1idWJibGUtbWVudSdcbiAgICBpbXBvcnQgQ2xhc3NFeHRlbnNpb24gZnJvbSAnLi9leHRlbnNpb25zL0NsYXNzRXh0ZW5zaW9uLmpzJ1xuICAgIGltcG9ydCBDb21tYW5kc0V4dGVuc2lvbiBmcm9tICcuL2V4dGVuc2lvbnMvQ29tbWFuZHNFeHRlbnNpb24uanMnXG4gICAgaW1wb3J0IEdyaWQgZnJvbSAnLi9leHRlbnNpb25zL0dyaWQvR3JpZC5qcydcbiAgICBpbXBvcnQgR3JpZENvbHVtbiBmcm9tICcuL2V4dGVuc2lvbnMvR3JpZC9HcmlkQ29sdW1uLmpzJ1xuICAgIGltcG9ydCBEZXRhaWxzIGZyb20gJy4vZXh0ZW5zaW9ucy9EZXRhaWxzL0RldGFpbHMuanMnXG4gICAgaW1wb3J0IERldGFpbHNTdW1tYXJ5IGZyb20gJy4vZXh0ZW5zaW9ucy9EZXRhaWxzL0RldGFpbHNTdW1tYXJ5LmpzJ1xuICAgIGltcG9ydCBEZXRhaWxzQ29udGVudCBmcm9tICcuL2V4dGVuc2lvbnMvRGV0YWlscy9EZXRhaWxzQ29udGVudC5qcydcbiAgICBpbXBvcnQgSWRFeHRlbnNpb24gZnJvbSAnLi9leHRlbnNpb25zL0lkRXh0ZW5zaW9uLmpzJ1xuICAgIGltcG9ydCBNZWRpYUV4dGVuc2lvbiBmcm9tICcuL2V4dGVuc2lvbnMvTWVkaWFFeHRlbnNpb24uanMnXG4gICAgaW1wb3J0IE1lcmdlVGFnIGZyb20gJy4vZXh0ZW5zaW9ucy9NZXJnZVRhZy5qcydcbiAgICBpbXBvcnQgTWVyZ2VUYWdzRXh0ZW5zaW9uIGZyb20gJy4vZXh0ZW5zaW9ucy9NZXJnZVRhZ3NFeHRlbnNpb24uanMnXG4gICAgaW1wb3J0IFBsYWNlaG9sZGVyIGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLXBsYWNlaG9sZGVyJ1xuICAgIGltcG9ydCBTdGFydGVyS2l0IGZyb20gJ0B0aXB0YXAvc3RhcnRlci1raXQnO1xuICAgIGltcG9ydCBTdGF0ZVBhdGhFeHRlbnNpb24gZnJvbSAnLi9leHRlbnNpb25zL1N0YXRlUGF0aEV4dGVuc2lvbi5qcydcbiAgICBpbXBvcnQgU2NyaWJibGVCbG9jayBmcm9tICcuL2V4dGVuc2lvbnMvU2NyaWJibGVCbG9jayc7XG4gICAgaW1wb3J0IFNsYXNoRXh0ZW5zaW9uIGZyb20gJy4vZXh0ZW5zaW9ucy9TbGFzaEV4dGVuc2lvbi5qcydcbiAgICBpbXBvcnQgU3Vic2NyaXB0IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLXN1YnNjcmlwdCdcbiAgICBpbXBvcnQgU3VwZXJzY3JpcHQgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tc3VwZXJzY3JpcHQnXG4gICAgaW1wb3J0IFRleHRBbGlnbiBmcm9tICcuL2V4dGVuc2lvbnMvVGV4dEFsaWduRXh0ZW5zaW9uLmpzJ1xuICAgIGltcG9ydCBUZXh0U3R5bGUgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tdGV4dC1zdHlsZSdcbiAgICBpbXBvcnQge1VuZGVybGluZX0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tdW5kZXJsaW5lJ1xuICAgIGltcG9ydCB7b3BlblNjcmliYmxlTW9kYWwsIGNvbW1hbmRSdW5uZXIsIHJlcGxhY2VTdGF0ZVBhdGh9IGZyb20gJy4vdXRpbHMuanMnXG4gICAgaW1wb3J0IENvbnRyb2xzIGZyb20gJy4vY29tcG9uZW50cy9Db250cm9scy5zdmVsdGUnXG4gICAgaW1wb3J0IEJ1YmJsZU1lbnUgZnJvbSAnLi9jb21wb25lbnRzL0J1YmJsZU1lbnUuc3ZlbHRlJ1xuICAgIGltcG9ydCBUb29sYmFyIGZyb20gJy4vY29tcG9uZW50cy9Ub29sYmFyLnN2ZWx0ZSdcbiAgICBpbXBvcnQge0hpZ2hsaWdodH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWhpZ2hsaWdodFwiO1xuICAgIGltcG9ydCBMaW5rQ3VzdG9tIGZyb20gXCIuL2V4dGVuc2lvbnMvTGlua0N1c3RvbS5qc1wiO1xuICAgIGltcG9ydCBFbWJlZCBmcm9tIFwiLi9leHRlbnNpb25zL0VtYmVkLmpzXCI7XG4gICAgaW1wb3J0IG9FbWJlZEV4dGVuc2lvbiBmcm9tIFwiLi9leHRlbnNpb25zL29FbWJlZEV4dGVuc2lvbi5qc1wiO1xuICAgIGltcG9ydCBvRW1iZWQgZnJvbSBcIi4vZXh0ZW5zaW9ucy9vRW1iZWQuanNcIjtcblxuICAgIGxldCBlZGl0b3I7XG4gICAgbGV0IGVsZW1lbnQ7XG4gICAgbGV0IGJ1YmJsZU1lbnVFbGVtZW50O1xuICAgIGxldCB0b29scztcblxuICAgIGV4cG9ydCBsZXQgY29udGVudDtcbiAgICBleHBvcnQgbGV0IHN0YXRlUGF0aDtcbiAgICBleHBvcnQgbGV0IHBsYWNlaG9sZGVyO1xuICAgIGV4cG9ydCBsZXQgYnViYmxlVG9vbHM7XG4gICAgZXhwb3J0IGxldCBzdWdnZXN0aW9uVG9vbHM7XG4gICAgZXhwb3J0IGxldCB0b29sYmFyVG9vbHM7XG4gICAgZXhwb3J0IGxldCBtZXJnZVRhZ3M7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgbGV0IGN1c3RvbUV4dGVuc2lvbnMgPSB3aW5kb3c/LnNjcmliYmxlRXh0ZW5zaW9ucyB8fCBbXTtcbiAgICAgICAgbGV0IGV4dGVuc2lvbnMgPSBbXG4gICAgICAgICAgICBTdGF0ZVBhdGhFeHRlbnNpb24uY29uZmlndXJlKHtcbiAgICAgICAgICAgICAgIHN0YXRlUGF0aDogc3RhdGVQYXRoXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFN0YXJ0ZXJLaXQsXG4gICAgICAgICAgICBDbGFzc0V4dGVuc2lvbixcbiAgICAgICAgICAgIENvbW1hbmRzRXh0ZW5zaW9uLFxuICAgICAgICAgICAgSWRFeHRlbnNpb24sXG4gICAgICAgICAgICBHcmlkLFxuICAgICAgICAgICAgTGlua0N1c3RvbSxcbiAgICAgICAgICAgIEVtYmVkLFxuICAgICAgICAgICAgSGlnaGxpZ2h0LFxuICAgICAgICAgICAgb0VtYmVkRXh0ZW5zaW9uLFxuICAgICAgICAgICAgR3JpZENvbHVtbixcbiAgICAgICAgICAgIERldGFpbHMsXG4gICAgICAgICAgICBEZXRhaWxzQ29udGVudCxcbiAgICAgICAgICAgIERldGFpbHNTdW1tYXJ5LFxuICAgICAgICAgICAgU2NyaWJibGVCbG9jayxcbiAgICAgICAgICAgIFN1YnNjcmlwdCxcbiAgICAgICAgICAgIFN1cGVyc2NyaXB0LFxuICAgICAgICAgICAgb0VtYmVkLFxuICAgICAgICAgICAgTWVkaWFFeHRlbnNpb24sXG4gICAgICAgICAgICBVbmRlcmxpbmUsXG4gICAgICAgICAgICBUZXh0QWxpZ24uY29uZmlndXJlKHtcbiAgICAgICAgICAgICAgICB0eXBlczogWydoZWFkaW5nJywgJ3BhcmFncmFwaCddXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIFRleHRTdHlsZSxcbiAgICAgICAgICAgIFRpcHRhcEJ1YmJsZU1lbnUuY29uZmlndXJlKHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBidWJibGVNZW51RWxlbWVudCxcbiAgICAgICAgICAgICAgICB0aXBweU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tLXN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgdGhlbWU6ICdzY3JpYmJsZS1idWJibGUnLFxuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNob3VsZFNob3c6ICh7IGVkaXRvciwgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PT0gdG8gJiYgZWRpdG9yLmlzQWN0aXZlKCdsaW5rJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSAhPT0gdG8gJiYgZWRpdG9yLmlzQWN0aXZlKCdsaW5rJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJvbSAhPT0gdG8gJiYgISAoXG4gICAgICAgICAgICAgICAgICAgICAgICBidWJibGVUb29scy5maWx0ZXIodG9vbCA9PiAhIHRvb2wuaXNIaWRkZW4pLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmlzQWN0aXZlKCdpbWFnZScpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuaXNBY3RpdmUoJ3NjcmliYmxlQmxvY2snKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmlzQWN0aXZlKCdzbGFzaEV4dGVuc2lvbicpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAuLi5jdXN0b21FeHRlbnNpb25zLFxuICAgICAgICBdXG5cbiAgICAgICAgaWYgKHN1Z2dlc3Rpb25Ub29scz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goXG4gICAgICAgICAgICAgICAgU2xhc2hFeHRlbnNpb24uY29uZmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHM6IHN1Z2dlc3Rpb25Ub29scyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVQYXRoOiBzdGF0ZVBhdGgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChcbiAgICAgICAgICAgICAgICBQbGFjZWhvbGRlci5jb25maWd1cmUoe1xuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgICAgICAgIGVtcHR5RWRpdG9yQ2xhc3M6ICdpcy1lZGl0b3ItZW1wdHknLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lcmdlVGFncz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goXG4gICAgICAgICAgICAgICAgTWVyZ2VUYWcuY29uZmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUYWdzLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goXG4gICAgICAgICAgICAgICAgTWVyZ2VUYWdzRXh0ZW5zaW9uLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IG1lcmdlVGFncyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVQYXRoOiBzdGF0ZVBhdGhcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgZWRpdG9yID0gbmV3IEVkaXRvcih7XG4gICAgICAgICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMsXG4gICAgICAgICAgICBvbkZvY3VzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdmb2N1c1NjcmliYmxlQ29tcG9uZW50Jywge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlUGF0aDogc3RhdGVQYXRoLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uVHJhbnNhY3Rpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICBlZGl0b3IgPSBlZGl0b3JcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblVwZGF0ZSh7ZWRpdG9yfSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgndXBkYXRlZEVkaXRvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZVBhdGg6IHN0YXRlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGVkaXRvci5nZXRKU09OKCksXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgIH0pXG5cbiAgICBvbkRlc3Ryb3koKCkgPT4ge1xuICAgICAgICBlZGl0b3IuZGVzdHJveSgpXG4gICAgfSlcblxuICAgIHRvb2xzID0gQXJyYXkuZnJvbShuZXcgU2V0KFtcbiAgICAgICAgLi4uYnViYmxlVG9vbHMuZmxhdCgpLFxuICAgICAgICAuLi5zdWdnZXN0aW9uVG9vbHMuZmxhdCgpLFxuICAgICAgICAuLi50b29sYmFyVG9vbHMuZmxhdCgpXG4gICAgXSkpXG5cbiAgICBsZXQganNvbk9iamVjdCA9IHRvb2xzLm1hcChKU09OLnN0cmluZ2lmeSk7XG4gICAgbGV0IHVuaXF1ZVNldCA9IG5ldyBTZXQoanNvbk9iamVjdCk7XG4gICAgdG9vbHMgPSBBcnJheS5mcm9tKHVuaXF1ZVNldCkubWFwKEpTT04ucGFyc2UpO1xuXG4gICAgJDogaXNBY3RpdmUgPSAobmFtZSwgYXR0cnMgPSB7fSkgPT4gZWRpdG9yLmlzQWN0aXZlKG5hbWUsIGF0dHJzKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGBpbnNlcnQtY29udGVudGAsIGRhdGEgPT4ge1xuICAgICAgICBpZiAoZGF0YS5kZXRhaWwuc3RhdGVQYXRoICE9PSBzdGF0ZVBhdGgpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEuZGV0YWlsLnR5cGUgPT09ICdtZWRpYScpIHtcbiAgICAgICAgICAgIGRhdGEuZGV0YWlsLm1lZGlhLmZvckVhY2goKGl0ZW0pID0+IGVkaXRvci5jaGFpbigpLnNldE1lZGlhKGl0ZW0pLmZvY3VzKCkucnVuKCkpXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgdG9vbHMuZm9yRWFjaCh0b29sID0+IHtcbiAgICAgICAgaWYgKHRvb2wub3B0aW9ucykge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoYGhhbmRsZS0ke3Rvb2wuaWRlbnRpZmllcn1gLCBkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5kZXRhaWwuc3RhdGVQYXRoICE9PSBzdGF0ZVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRvb2wudHlwZSA9PT0gJ2Jsb2NrJyB8fCB0b29sLnR5cGUgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmRldGFpbC5jb250ZXh0ID09PSAnaW5zZXJ0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmNoYWluKCkuaW5zZXJ0U2NyaWJibGVCbG9jayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogdG9vbC5pZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRvb2wudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0lkOiBkYXRhLmRldGFpbC5ibG9ja0lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogZGF0YS5kZXRhaWwudmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5mb2N1cygpLnJ1bigpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCd1cGRhdGVkQmxvY2snLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlUGF0aDogc3RhdGVQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiB0b29sLmlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRvb2wudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tJZDogZGF0YS5kZXRhaWwuYmxvY2tJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBkYXRhLmRldGFpbC52YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29tbWFuZFJ1bm5lcihlZGl0b3IsIHRvb2wuY29tbWFuZHMsIGRhdGEuZGV0YWlsLnZhbHVlcylcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3QgaGFuZGxlVG9vbENsaWNrID0gKHRvb2wsIHVwZGF0ZSA9IGZhbHNlKSA9PiB7XG4gICAgICAgIHN3aXRjaCAodG9vbC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdjb21tYW5kJzpcbiAgICAgICAgICAgICAgICBjb21tYW5kUnVubmVyKGVkaXRvciwgdG9vbC5jb21tYW5kcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICBjYXNlICdldmVudCc6XG4gICAgICAgICAgICAgICAgcmVwbGFjZVN0YXRlUGF0aCh0b29sLmV2ZW50LmRhdGEsIHN0YXRlUGF0aClcbiAgICAgICAgICAgICAgICB3aW5kb3cuTGl2ZXdpcmUuZGlzcGF0Y2godG9vbC5ldmVudC5uYW1lLCB0b29sLmV2ZW50LmRhdGEpXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICBjYXNlICdtb2RhbCc6XG4gICAgICAgICAgICAgICAgb3BlblNjcmliYmxlTW9kYWwodG9vbC5pZGVudGlmaWVyLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlUGF0aDogc3RhdGVQYXRoLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogdG9vbC5pZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBlZGl0b3IuZ2V0QXR0cmlidXRlcyh0b29sLmV4dGVuc2lvbilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIGNhc2UgJ3N0YXRpYyc6XG4gICAgICAgICAgICAgICAgZWRpdG9yLmNoYWluKCkuaW5zZXJ0U2NyaWJibGVCbG9jayh7XG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IHRvb2wuaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9vbC50eXBlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHt9XG4gICAgICAgICAgICAgICAgfSkuZm9jdXMoKS5ydW4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZWRpdG9yLmNvbW1hbmRzLnNldFNjcmliYmxlQmxvY2soe1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZVBhdGg6IHN0YXRlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogdG9vbC5pZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b29sLnR5cGUsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVDb250ZW50JywgZSA9PiB7XG4gICAgICAgIGlmIChlLmRldGFpbC5zdGF0ZVBhdGggPT09IHN0YXRlUGF0aCkge1xuICAgICAgICAgICAgZWRpdG9yLmNoYWluKCkuc2V0Q29udGVudChlLmRldGFpbC5uZXdDb250ZW50KS5ydW4oKVxuICAgICAgICB9XG4gICAgfSlcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwic2NyaWJibGUtZWRpdG9yLXdyYXBwZXJcIj5cbiAgICA8Q29udHJvbHMge2VkaXRvcn0ge3N0YXRlUGF0aH0gLz5cblxuICAgIDxUb29sYmFyIHtlZGl0b3J9IHRvb2xzPXt0b29sYmFyVG9vbHN9IHtoYW5kbGVUb29sQ2xpY2t9IHtpc0FjdGl2ZX0gLz5cblxuICAgIDxkaXYgY2xhc3M9XCJzY3JpYmJsZS1lZGl0b3JcIiBiaW5kOnRoaXM9e2VsZW1lbnR9IC8+XG5cbiAgICA8ZGl2IGJpbmQ6dGhpcz17YnViYmxlTWVudUVsZW1lbnR9PlxuICAgICAgICA8QnViYmxlTWVudSB7ZWRpdG9yfSB0b29scz17YnViYmxlVG9vbHN9IHtoYW5kbGVUb29sQ2xpY2t9IHtpc0FjdGl2ZX0gLz5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuIiwgImltcG9ydCBTY3JpYmJsZSBmcm9tICcuL1NjcmliYmxlLnN2ZWx0ZSdcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2NyaWJibGUoYnViYmxlVG9vbHMsIHN1Z2dlc3Rpb25Ub29scywgdG9vbGJhclRvb2xzLCBtZXJnZVRhZ3MsIHN0YXRlLCBzdGF0ZVBhdGgsIHBsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYnViYmxlVG9vbHMsXG4gICAgICAgIHN1Z2dlc3Rpb25Ub29scyxcbiAgICAgICAgdG9vbGJhclRvb2xzLFxuICAgICAgICBtZXJnZVRhZ3MsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBzdGF0ZVBhdGgsXG4gICAgICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlciA/PyBcImRpZ2l0YSAnLycgcGVyIGFnZ2l1bmdlcmUgdW4gYmxvY2NvXCIsXG4gICAgICAgIGZ1bGxzY3JlZW46IGZhbHNlLFxuICAgICAgICB1cGRhdGVkRnJvbUVkaXRvcjogZmFsc2UsXG4gICAgICAgIGlzRm9jdXNlZDogZmFsc2UsXG5cbiAgICAgICAgaW5pdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IF90aGlzID0gdGhpc1xuXG4gICAgICAgICAgICBuZXcgU2NyaWJibGUoe1xuICAgICAgICAgICAgICAgIHRhcmdldDogX3RoaXMuJHJvb3QsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlVG9vbHM6IF90aGlzLmJ1YmJsZVRvb2xzLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uVG9vbHM6IF90aGlzLnN1Z2dlc3Rpb25Ub29scyxcbiAgICAgICAgICAgICAgICAgICAgdG9vbGJhclRvb2xzOiBfdGhpcy50b29sYmFyVG9vbHMsXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGFnczogX3RoaXMubWVyZ2VUYWdzLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBfdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVQYXRoOiBfdGhpcy5zdGF0ZVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBfdGhpcy5wbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLiR3YXRjaCgnc3RhdGUnLCAobmV3U3RhdGUsIG9sZFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEgX3RoaXMudXBkYXRlZEZyb21FZGl0b3IgJiYgSlNPTi5zdHJpbmdpZnkobmV3U3RhdGUpICE9PSBKU09OLnN0cmluZ2lmeShvbGRTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCd1cGRhdGVDb250ZW50Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVQYXRoOiBzdGF0ZVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udGVudDogbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVkRnJvbUVkaXRvciA9IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGVkRWRpdG9yJywgZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUuZGV0YWlsLnN0YXRlUGF0aCA9PT0gX3RoaXMuc3RhdGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZWRGcm9tRWRpdG9yID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9IGUuZGV0YWlsLmNvbnRlbnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNTY3JpYmJsZUNvbXBvbmVudCcsIGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLmRldGFpbC5zdGF0ZVBhdGggPT09IF90aGlzLnN0YXRlUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc0ZvY3VzZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcblxuICAgICAgICB0b2dnbGVGdWxsc2NyZWVuKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuZGV0YWlsLnN0YXRlUGF0aCAhPT0gdGhpcy5zdGF0ZVBhdGgpIHJldHVyblxuICAgICAgICAgICAgdGhpcy5mdWxsc2NyZWVuID0gIXRoaXMuZnVsbHNjcmVlblxuICAgICAgICB9LFxuICAgIH1cbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7O0FBQ08sU0FBUyxPQUFPO0FBQUM7QUFXakIsU0FBUyxPQUFPLEtBQUssS0FBSztBQUVoQyxhQUFXLEtBQUs7QUFBSyxRQUFJLENBQUMsSUFBSSxJQUFJLENBQUM7QUFDbkM7QUFBQTtBQUFBLElBQTZCO0FBQUE7QUFDOUI7QUF1Qk8sU0FBUyxJQUFJQSxLQUFJO0FBQ3ZCLFNBQU9BLElBQUc7QUFDWDtBQUVPLFNBQVMsZUFBZTtBQUM5QixTQUFPLHVCQUFPLE9BQU8sSUFBSTtBQUMxQjtBQU1PLFNBQVMsUUFBUSxLQUFLO0FBQzVCLE1BQUksUUFBUSxHQUFHO0FBQ2hCO0FBTU8sU0FBUyxZQUFZLE9BQU87QUFDbEMsU0FBTyxPQUFPLFVBQVU7QUFDekI7QUFHTyxTQUFTLGVBQWUsR0FBRyxHQUFHO0FBQ3BDLFNBQU8sS0FBSyxJQUFJLEtBQUssSUFBSSxNQUFNLEtBQU0sS0FBSyxPQUFPLE1BQU0sWUFBYSxPQUFPLE1BQU07QUFDbEY7QUFFQSxJQUFJO0FBT0csU0FBUyxjQUFjLGFBQWEsS0FBSztBQUMvQyxNQUFJLGdCQUFnQjtBQUFLLFdBQU87QUFDaEMsTUFB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LEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUNQO0FBRU8sSUFBSSxRQUFRO0FBQUEsRUFDakIsSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osSUFBSTtBQUFBLEVBQ0osS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUNQO0FBRUEsSUFBSUMsT0FBTSxPQUFPLGFBQWEsZUFBZSxNQUFNLEtBQUssVUFBVSxRQUFRO0FB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QUFBLE1BQ0osQ0FBQztBQUVELGFBQU8saUJBQWlCLGlCQUFpQixPQUFLO0FBQzFDLFlBQUksRUFBRSxPQUFPLGNBQWMsTUFBTSxXQUFXO0FBQ3hDLGdCQUFNLG9CQUFvQjtBQUMxQixnQkFBTSxRQUFRLEVBQUUsT0FBTztBQUFBLFFBQzNCO0FBQUEsTUFDSixDQUFDO0FBRUQsYUFBTyxpQkFBaUIsMEJBQTBCLE9BQUs7QUFDbkQsWUFBSSxFQUFFLE9BQU8sY0FBYyxNQUFNLFdBQVc7QUFDeEMsZ0JBQU0sWUFBWTtBQUFBLFFBQ3RCO0FBQUEsTUFDSixDQUFDO0FBQUEsSUFDTDtBQUFBLElBRUEsaUJBQWlCLE9BQU87QUFDcEIsVUFBSSxNQUFNLE9BQU8sY0FBYyxLQUFLO0FBQVc7QUFDL0MsV0FBSyxhQUFhLENBQUMsS0FBSztBQUFBLElBQzVCO0FBQUEsRUFDSjtBQUNKOyIsCiAgIm5hbWVzIjogWyJmbiIsICJmbiIsICJrZXlzIiwgImVsZW1lbnQiLCAiZm4iLCAiZWxlbWVudCIsICJ0ZXh0IiwgImVsZW1lbnQiLCAiZWxlbWVudCIsICJmbiIsICJmbiIsICJmbiIsICJmbiIsICJkZXRhY2giLCAidXBkYXRlIiwgImluc3RhbmNlIiwgImNyZWF0ZV9mcmFnbWVudCIsICJjcmVhdGVfc2xvdCIsICJhdHRyIiwgImZvdW5kIiwgIm1hcCIsICJmcm9tIiwgImVuZCIsICJzdGFydCIsICJ0ZXh0IiwgImZpcnN0IiwgImNvcHkiLCAiZm91bmQiLCAicm91bmQiLCAib2Zmc2V0IiwgImluc2VydCIsICJzbGljZSIsICJtYWluIiwgImRvYyIsICJiYXNlIiwgImkiLCAibWluIiwgIm1heCIsICJ0eXBlIiwgIm5mYSIsICJlZGdlIiwgImV4cHIiLCAibG9vcCIsICJub2RlIiwgInN0YXRlcyIsICJkZWZhdWx0cyIsICJhdHRyIiwgIm1hcmsiLCAiRE9NUGFyc2VyIiwgInIiLCAic3R5bGUiLCAid3JhcCIsICJ0b3AiLCAic3BhY2UiLCAib2Zmc2V0IiwgInN0YXJ0IiwgImVuZCIsICJkZWwiLCAiZnJvbSIsICJtYXAiLCAiZG9jIiwgInNsaWNlIiwgInBhcmVudCIsICJpbnNlcnQiLCAidHIiLCAiZm91bmQiLCAic3R5bGUiLCAiYmFzZSIsICJpbmRleCIsICJqb2luYWJsZSIsICJmaXJzdCIsICJ3cmFwIiwgIm1hdGNoZXMiLCAidG9wIiwgIm1hdGNoIiwgInR5cGUiLCAiY2xvc2UiLCAiYXR0ciIsICJUcmFuc2Zvcm1FcnJvciIsICJ0ciIsICJmcm9tIiwgImZvdW5kIiwgImRvYyIsICJ0ZXh0IiwgIm1hcCIsICJlbmQiLCAic2xpY2UiLCAiaW5zdGFuY2UiLCAiZnJvbSIsICJvZmZzZXQiLCAiZG9jIiwgInRvcCIsICJsZWZ0IiwgImVsZW1lbnQiLCAiZmlyc3QiLCAiY2hpbGRyZW4iLCAiZW5kIiwgImVudGVyIiwgImJhc2UiLCAid3JhcCIsICJ0ZXh0IiwgImNvcHkiLCAic3RhcnQiLCAiZm91bmQiLCAicHJlTWF0Y2giLCAibWF0Y2hlcyIsICJlbXB0eSIsICJ0ciIsICJzbGljZSIsICJET01QYXJzZXIiLCAiZG9tIiwgImV2ZW50IiwgImhhbmRsZXJzIiwgIm5vdyIsICJjdXQiLCAiTm9kZVR5cGUiLCAiciIsICJpIiwgIm9sZE9mZnNldCIsICJyZWFkIiwgImZpbmQiLCAiYW5jaG9yIiwgInNlbCIsICJ1cGRhdGUiLCAiZnJvbSIsICJmb3VuZCIsICJwcm9wIiwgIm9mZnNldCIsICJ0ZXh0IiwgInRyIiwgImF0dHIiLCAibWFjIiwgImllIiwgIm1hYyIsICJzaGlmdCIsICJtYXAiLCAiY29weSIsICJ0ciIsICJlbXB0eSIsICJsaWZ0IiwgImZpcnN0IiwgImVuZCIsICJ3cmFwIiwgInRyIiwgInNldEJsb2NrVHlwZSIsICJmcm9tIiwgImNvbW1hbmRzIiwgIm1hYyIsICJ3cmFwIiwgInRyIiwgImZvdW5kIiwgImZpcnN0IiwgInRyIiwgImVuZCIsICJzdGFydCIsICJzbGljZSIsICJkb2MiLCAidHIiLCAiY29tbWFuZCIsICJydW4iLCAiZm4iLCAiZXh0ZW5zaW9ucyIsICJfYSIsICJ0ZXh0IiwgImZpbmQiLCAiZnJvbSIsICJjb21tYW5kcyIsICJtYXRjaGVzIiwgImhhbmRsZXJzIiwgInN0YXJ0IiwgImVuZCIsICJvbkNyZWF0ZSIsICJvbkRlc3Ryb3kiLCAiTWFyayIsICJyYW5nZSIsICJjcmVhdGVQYXJhZ3JhcGhOZWFyIiwgIm9yaWdpbmFsQ3JlYXRlUGFyYWdyYXBoTmVhciIsICJkZWxldGVSYW5nZSIsICJkZWxldGVTZWxlY3Rpb24iLCAib3JpZ2luYWxEZWxldGVTZWxlY3Rpb24iLCAiZXhpdENvZGUiLCAib3JpZ2luYWxFeGl0Q29kZSIsICJrZXlzIiwgIm1pbiIsICJtYXgiLCAiY2hpbGRyZW4iLCAiRE9NUGFyc2VyIiwgInNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kIiwgIm1hcCIsICJqb2luVXAiLCAib3JpZ2luYWxKb2luVXAiLCAiam9pbkRvd24iLCAib3JpZ2luYWxKb2luRG93biIsICJqb2luQmFja3dhcmQiLCAib3JpZ2luYWxKb2luQmFja3dhcmQiLCAiam9pbkZvcndhcmQiLCAib3JpZ2luYWxKb2luRm9yd2FyZCIsICJqb2luVGV4dGJsb2NrQmFja3dhcmQiLCAib3JpZ2luYWxDb21tYW5kIiwgImpvaW5UZXh0YmxvY2tGb3J3YXJkIiwgIm5vcm1hbGl6ZUtleU5hbWUiLCAic2hpZnQiLCAiZW1wdHkiLCAibGlmdCIsICJpc0FjdGl2ZSIsICJvcmlnaW5hbExpZnQiLCAibGlmdEVtcHR5QmxvY2siLCAib3JpZ2luYWxMaWZ0RW1wdHlCbG9jayIsICJsaWZ0TGlzdEl0ZW0iLCAib3JpZ2luYWxMaWZ0TGlzdEl0ZW0iLCAibmV3bGluZUluQ29kZSIsICJvcmlnaW5hbE5ld2xpbmVJbkNvZGUiLCAic2VsZWN0QWxsIiwgInNlbGVjdE5vZGVCYWNrd2FyZCIsICJvcmlnaW5hbFNlbGVjdE5vZGVCYWNrd2FyZCIsICJzZWxlY3ROb2RlRm9yd2FyZCIsICJvcmlnaW5hbFNlbGVjdE5vZGVGb3J3YXJkIiwgInNlbGVjdFBhcmVudE5vZGUiLCAib3JpZ2luYWxTZWxlY3RQYXJlbnROb2RlIiwgInNlbGVjdFRleHRibG9ja0VuZCIsICJvcmlnaW5hbFNlbGVjdFRleHRibG9ja0VuZCIsICJzZWxlY3RUZXh0YmxvY2tTdGFydCIsICJvcmlnaW5hbFNlbGVjdFRleHRibG9ja1N0YXJ0IiwgImRvY3VtZW50IiwgImRlZmF1bHRCbG9ja0F0IiwgImdldFRleHQiLCAiZnJvbSIsICJub2RlIiwgImZyb20iLCAiZG9jIiwgImVtcHR5IiwgImZyb20iLCAicmFuZ2UiLCAiZXh0ZW5zaW9ucyIsICJmcm9tIiwgInN0YXJ0IiwgImVuZCIsICJ0b3AiLCAiYm90dG9tIiwgImxlZnQiLCAicmlnaHQiLCAidHIiLCAiZW1wdHkiLCAiY29tbWFuZHMiLCAic2V0QmxvY2tUeXBlIiwgImRvYyIsICJzaW5rTGlzdEl0ZW0iLCAib3JpZ2luYWxTaW5rTGlzdEl0ZW0iLCAic3BsaXRCbG9jayIsICJkZWZhdWx0QmxvY2tBdCIsICJmaXJzdCIsICJ3cmFwIiwgIm5ld05leHRUeXBlQXR0cmlidXRlcyIsICJuZXh0VHlwZSIsICJpc0FjdGl2ZSIsICJ3cmFwSW4iLCAib3JpZ2luYWxXcmFwSW4iLCAid3JhcEluTGlzdCIsICJvcmlnaW5hbFdyYXBJbkxpc3QiLCAiY2hpbGRyZW4iLCAib2Zmc2V0IiwgInN0eWxlIiwgImZuIiwgImZvY3VzIiwgImJsdXIiLCAiZ2V0VGV4dCIsICJ0ciIsICJNYXJrIiwgInJlbW92ZU1hcmsiLCAiTm9kZSIsICJmcm9tIiwgImVsZW1lbnQiLCAic3R5bGUiLCAiZWxlbWVudCIsICJuYW1lIiwgImVsZW1lbnQiLCAiY2xpZW50UmVjdCIsICJlbGVtZW50IiwgImNsaWVudFJlY3QiLCAiZ2V0Q29tcHV0ZWRTdHlsZSIsICJlbGVtZW50IiwgImVsZW1lbnQiLCAiZWxlbWVudCIsICJlbGVtZW50IiwgImVsZW1lbnQiLCAiZ2V0Q29tcHV0ZWRTdHlsZSIsICJ3aW5kb3ciLCAibWluIiwgIm1heCIsICJrZXlzIiwgInRvUGFkZGluZ09iamVjdCIsICJwb3BwZXJPZmZzZXRzIiwgIm1pbiIsICJtYXgiLCAib2Zmc2V0IiwgImVmZmVjdCIsICJwb3BwZXIiLCAiZ2V0Q29tcHV0ZWRTdHlsZSIsICJlZmZlY3QiLCAiaW5zdGFuY2UiLCAid2luZG93IiwgImhhc2giLCAiZWxlbWVudCIsICJlbGVtZW50IiwgImVsZW1lbnQiLCAiZ2V0Q29tcHV0ZWRTdHlsZSIsICJlbGVtZW50IiwgImdldENvbXB1dGVkU3R5bGUiLCAiZWxlbWVudCIsICJlbGVtZW50IiwgImNsaXBwaW5nUGFyZW50cyIsICJnZXRDb21wdXRlZFN0eWxlIiwgInJlZmVyZW5jZSIsICJlbGVtZW50IiwgImVsZW1lbnQiLCAicG9wcGVyT2Zmc2V0cyIsICJvZmZzZXQiLCAicGxhY2VtZW50cyIsICJwbGFjZW1lbnQiLCAicGxhY2VtZW50cyIsICJwbGFjZW1lbnQiLCAiX2xvb3AiLCAiX2kiLCAiY2hlY2tzIiwgIm9mZnNldCIsICJwb3BwZXJPZmZzZXRzIiwgIm9mZnNldCIsICJtaW4iLCAibWF4IiwgImVsZW1lbnQiLCAiZWxlbWVudCIsICJtb2RpZmllcnMiLCAibWFwIiwgImZuIiwgIm1vZGlmaWVycyIsICJtZXJnZWQiLCAiZWxlbWVudCIsICJkZWZhdWx0TW9kaWZpZXJzIiwgImNyZWF0ZVBvcHBlciIsICJyZWZlcmVuY2UiLCAicG9wcGVyIiwgImluc3RhbmNlIiwgIm9wdGlvbnMiLCAiZm4iLCAic3RhdGUiLCAiZWZmZWN0IiwgIm5vb3BGbiIsICJCT1hfQ0xBU1MiLCAiQ09OVEVOVF9DTEFTUyIsICJCQUNLRFJPUF9DTEFTUyIsICJBUlJPV19DTEFTUyIsICJTVkdfQVJST1dfQ0xBU1MiLCAiVE9VQ0hfT1BUSU9OUyIsICJwYXNzaXZlIiwgImNhcHR1cmUiLCAiVElQUFlfREVGQVVMVF9BUFBFTkRfVE8iLCAiZG9jdW1lbnQiLCAiYm9keSIsICJoYXNPd25Qcm9wZXJ0eSIsICJvYmoiLCAia2V5IiwgImNhbGwiLCAiZ2V0VmFsdWVBdEluZGV4T3JSZXR1cm4iLCAidmFsdWUiLCAiaW5kZXgiLCAiZGVmYXVsdFZhbHVlIiwgIkFycmF5IiwgImlzQXJyYXkiLCAidiIsICJpc1R5cGUiLCAidHlwZSIsICJzdHIiLCAidG9TdHJpbmciLCAiaW5kZXhPZiIsICJpbnZva2VXaXRoQXJnc09yUmV0dXJuIiwgImFyZ3MiLCAiZGVib3VuY2UiLCAiZm4iLCAibXMiLCAidGltZW91dCIsICJhcmciLCAiY2xlYXJUaW1lb3V0IiwgInNldFRpbWVvdXQiLCAicmVtb3ZlUHJvcGVydGllcyIsICJrZXlzIiwgImNsb25lIiwgImZvckVhY2giLCAic3BsaXRCeVNwYWNlcyIsICJzcGxpdCIsICJmaWx0ZXIiLCAiQm9vbGVhbiIsICJub3JtYWxpemVUb0FycmF5IiwgImNvbmNhdCIsICJwdXNoSWZVbmlxdWUiLCAiYXJyIiwgInB1c2giLCAidW5pcXVlIiwgIml0ZW0iLCAiZ2V0QmFzZVBsYWNlbWVudCIsICJwbGFjZW1lbnQiLCAiYXJyYXlGcm9tIiwgInNsaWNlIiwgInJlbW92ZVVuZGVmaW5lZFByb3BzIiwgIk9iamVjdCIsICJyZWR1Y2UiLCAiYWNjIiwgInVuZGVmaW5lZCIsICJkaXYiLCAiY3JlYXRlRWxlbWVudCIsICJpc0VsZW1lbnQiLCAic29tZSIsICJpc05vZGVMaXN0IiwgImlzTW91c2VFdmVudCIsICJpc1JlZmVyZW5jZUVsZW1lbnQiLCAiX3RpcHB5IiwgInJlZmVyZW5jZSIsICJnZXRBcnJheU9mRWxlbWVudHMiLCAicXVlcnlTZWxlY3RvckFsbCIsICJzZXRUcmFuc2l0aW9uRHVyYXRpb24iLCAiZWxzIiwgImVsIiwgInN0eWxlIiwgInRyYW5zaXRpb25EdXJhdGlvbiIsICJzZXRWaXNpYmlsaXR5U3RhdGUiLCAic3RhdGUiLCAic2V0QXR0cmlidXRlIiwgImdldE93bmVyRG9jdW1lbnQiLCAiZWxlbWVudE9yRWxlbWVudHMiLCAiZWxlbWVudCIsICJvd25lckRvY3VtZW50IiwgImlzQ3Vyc29yT3V0c2lkZUludGVyYWN0aXZlQm9yZGVyIiwgInBvcHBlclRyZWVEYXRhIiwgImV2ZW50IiwgImNsaWVudFgiLCAiY2xpZW50WSIsICJldmVyeSIsICJwb3BwZXJSZWN0IiwgInBvcHBlclN0YXRlIiwgInByb3BzIiwgImludGVyYWN0aXZlQm9yZGVyIiwgImJhc2VQbGFjZW1lbnQiLCAib2Zmc2V0RGF0YSIsICJtb2RpZmllcnNEYXRhIiwgIm9mZnNldCIsICJ0b3BEaXN0YW5jZSIsICJ0b3AiLCAieSIsICJib3R0b21EaXN0YW5jZSIsICJib3R0b20iLCAibGVmdERpc3RhbmNlIiwgImxlZnQiLCAieCIsICJyaWdodERpc3RhbmNlIiwgInJpZ2h0IiwgImV4Y2VlZHNUb3AiLCAiZXhjZWVkc0JvdHRvbSIsICJleGNlZWRzTGVmdCIsICJleGNlZWRzUmlnaHQiLCAidXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyIiwgImJveCIsICJhY3Rpb24iLCAibGlzdGVuZXIiLCAibWV0aG9kIiwgImFjdHVhbENvbnRhaW5zIiwgInBhcmVudCIsICJjaGlsZCIsICJ0YXJnZXQiLCAiY29udGFpbnMiLCAiZ2V0Um9vdE5vZGUiLCAiaG9zdCIsICJjdXJyZW50SW5wdXQiLCAiaXNUb3VjaCIsICJsYXN0TW91c2VNb3ZlVGltZSIsICJvbkRvY3VtZW50VG91Y2hTdGFydCIsICJ3aW5kb3ciLCAicGVyZm9ybWFuY2UiLCAiYWRkRXZlbnRMaXN0ZW5lciIsICJvbkRvY3VtZW50TW91c2VNb3ZlIiwgIm5vdyIsICJyZW1vdmVFdmVudExpc3RlbmVyIiwgIm9uV2luZG93Qmx1ciIsICJhY3RpdmVFbGVtZW50IiwgImluc3RhbmNlIiwgImJsdXIiLCAiaXNWaXNpYmxlIiwgImJpbmRHbG9iYWxFdmVudExpc3RlbmVycyIsICJpc0Jyb3dzZXIiLCAiaXNJRTExIiwgIm1zQ3J5cHRvIiwgImNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nIiwgInR4dCIsICJqb2luIiwgImNsZWFuIiwgInNwYWNlc0FuZFRhYnMiLCAibGluZVN0YXJ0V2l0aFNwYWNlcyIsICJyZXBsYWNlIiwgInRyaW0iLCAiZ2V0RGV2TWVzc2FnZSIsICJtZXNzYWdlIiwgImdldEZvcm1hdHRlZE1lc3NhZ2UiLCAidmlzaXRlZE1lc3NhZ2VzIiwgInJlc2V0VmlzaXRlZE1lc3NhZ2VzIiwgIlNldCIsICJ3YXJuV2hlbiIsICJjb25kaXRpb24iLCAiaGFzIiwgImFkZCIsICJjb25zb2xlIiwgIndhcm4iLCAiZXJyb3JXaGVuIiwgImVycm9yIiwgInZhbGlkYXRlVGFyZ2V0cyIsICJ0YXJnZXRzIiwgImRpZFBhc3NGYWxzeVZhbHVlIiwgImRpZFBhc3NQbGFpbk9iamVjdCIsICJwcm90b3R5cGUiLCAiU3RyaW5nIiwgInBsdWdpblByb3BzIiwgImFuaW1hdGVGaWxsIiwgImZvbGxvd0N1cnNvciIsICJpbmxpbmVQb3NpdGlvbmluZyIsICJzdGlja3kiLCAicmVuZGVyUHJvcHMiLCAiYWxsb3dIVE1MIiwgImFuaW1hdGlvbiIsICJhcnJvdyIsICJjb250ZW50IiwgImluZXJ0aWEiLCAibWF4V2lkdGgiLCAicm9sZSIsICJ0aGVtZSIsICJ6SW5kZXgiLCAiZGVmYXVsdFByb3BzIiwgImFwcGVuZFRvIiwgImFyaWEiLCAiZXhwYW5kZWQiLCAiZGVsYXkiLCAiZHVyYXRpb24iLCAiZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCIsICJoaWRlT25DbGljayIsICJpZ25vcmVBdHRyaWJ1dGVzIiwgImludGVyYWN0aXZlIiwgImludGVyYWN0aXZlRGVib3VuY2UiLCAibW92ZVRyYW5zaXRpb24iLCAib25BZnRlclVwZGF0ZSIsICJvbkJlZm9yZVVwZGF0ZSIsICJvbkNyZWF0ZSIsICJvbkRlc3Ryb3kiLCAib25IaWRkZW4iLCAib25IaWRlIiwgIm9uTW91bnQiLCAib25TaG93IiwgIm9uU2hvd24iLCAib25UcmlnZ2VyIiwgIm9uVW50cmlnZ2VyIiwgIm9uQ2xpY2tPdXRzaWRlIiwgInBsdWdpbnMiLCAicG9wcGVyT3B0aW9ucyIsICJyZW5kZXIiLCAic2hvd09uQ3JlYXRlIiwgInRvdWNoIiwgInRyaWdnZXIiLCAidHJpZ2dlclRhcmdldCIsICJkZWZhdWx0S2V5cyIsICJzZXREZWZhdWx0UHJvcHMiLCAicGFydGlhbFByb3BzIiwgInZhbGlkYXRlUHJvcHMiLCAiZ2V0RXh0ZW5kZWRQYXNzZWRQcm9wcyIsICJwYXNzZWRQcm9wcyIsICJwbHVnaW4iLCAibmFtZSIsICJnZXREYXRhQXR0cmlidXRlUHJvcHMiLCAicHJvcEtleXMiLCAidmFsdWVBc1N0cmluZyIsICJnZXRBdHRyaWJ1dGUiLCAiSlNPTiIsICJwYXJzZSIsICJlIiwgImV2YWx1YXRlUHJvcHMiLCAib3V0IiwgInByb3AiLCAibm9uUGx1Z2luUHJvcHMiLCAiZGlkUGFzc1Vua25vd25Qcm9wIiwgImxlbmd0aCIsICJpbm5lckhUTUwiLCAiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCAiaHRtbCIsICJjcmVhdGVBcnJvd0VsZW1lbnQiLCAiY2xhc3NOYW1lIiwgImFwcGVuZENoaWxkIiwgInNldENvbnRlbnQiLCAidGV4dENvbnRlbnQiLCAiZ2V0Q2hpbGRyZW4iLCAicG9wcGVyIiwgImZpcnN0RWxlbWVudENoaWxkIiwgImJveENoaWxkcmVuIiwgImNoaWxkcmVuIiwgImZpbmQiLCAibm9kZSIsICJjbGFzc0xpc3QiLCAiYmFja2Ryb3AiLCAib25VcGRhdGUiLCAicHJldlByb3BzIiwgIm5leHRQcm9wcyIsICJyZW1vdmVBdHRyaWJ1dGUiLCAicmVtb3ZlQ2hpbGQiLCAiJCR0aXBweSIsICJpZENvdW50ZXIiLCAibW91c2VNb3ZlTGlzdGVuZXJzIiwgIm1vdW50ZWRJbnN0YW5jZXMiLCAiY3JlYXRlVGlwcHkiLCAic2hvd1RpbWVvdXQiLCAiaGlkZVRpbWVvdXQiLCAic2NoZWR1bGVIaWRlQW5pbWF0aW9uRnJhbWUiLCAiaXNWaXNpYmxlRnJvbUNsaWNrIiwgImRpZEhpZGVEdWVUb0RvY3VtZW50TW91c2VEb3duIiwgImRpZFRvdWNoTW92ZSIsICJpZ25vcmVPbkZpcnN0VXBkYXRlIiwgImxhc3RUcmlnZ2VyRXZlbnQiLCAiY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lciIsICJvbkZpcnN0VXBkYXRlIiwgImxpc3RlbmVycyIsICJkZWJvdW5jZWRPbk1vdXNlTW92ZSIsICJvbk1vdXNlTW92ZSIsICJjdXJyZW50VGFyZ2V0IiwgImlkIiwgInBvcHBlckluc3RhbmNlIiwgImlzRW5hYmxlZCIsICJpc0Rlc3Ryb3llZCIsICJpc01vdW50ZWQiLCAiaXNTaG93biIsICJjbGVhckRlbGF5VGltZW91dHMiLCAic2V0UHJvcHMiLCAic2hvdyIsICJoaWRlIiwgImhpZGVXaXRoSW50ZXJhY3Rpdml0eSIsICJlbmFibGUiLCAiZGlzYWJsZSIsICJ1bm1vdW50IiwgImRlc3Ryb3kiLCAicGx1Z2luc0hvb2tzIiwgIm1hcCIsICJoYXNBcmlhRXhwYW5kZWQiLCAiaGFzQXR0cmlidXRlIiwgImFkZExpc3RlbmVycyIsICJoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUiLCAiaGFuZGxlU3R5bGVzIiwgImludm9rZUhvb2siLCAic2NoZWR1bGVTaG93IiwgImdldERvY3VtZW50IiwgImdldE5vcm1hbGl6ZWRUb3VjaFNldHRpbmdzIiwgImdldElzQ3VzdG9tVG91Y2hCZWhhdmlvciIsICJnZXRJc0RlZmF1bHRSZW5kZXJGbiIsICJnZXRDdXJyZW50VGFyZ2V0IiwgInBhcmVudE5vZGUiLCAiZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4iLCAiZ2V0RGVsYXkiLCAiaXNTaG93IiwgImZyb21IaWRlIiwgInBvaW50ZXJFdmVudHMiLCAiaG9vayIsICJzaG91bGRJbnZva2VQcm9wc0hvb2siLCAicGx1Z2luSG9va3MiLCAiaGFuZGxlQXJpYUNvbnRlbnRBdHRyaWJ1dGUiLCAiYXR0ciIsICJub2RlcyIsICJjdXJyZW50VmFsdWUiLCAibmV4dFZhbHVlIiwgImNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzIiwgIm9uRG9jdW1lbnRQcmVzcyIsICJhY3R1YWxUYXJnZXQiLCAiY29tcG9zZWRQYXRoIiwgInJlbW92ZURvY3VtZW50UHJlc3MiLCAib25Ub3VjaE1vdmUiLCAib25Ub3VjaFN0YXJ0IiwgImFkZERvY3VtZW50UHJlc3MiLCAiZG9jIiwgIm9uVHJhbnNpdGlvbmVkT3V0IiwgImNhbGxiYWNrIiwgIm9uVHJhbnNpdGlvbkVuZCIsICJvblRyYW5zaXRpb25lZEluIiwgIm9uIiwgImV2ZW50VHlwZSIsICJoYW5kbGVyIiwgIm9wdGlvbnMiLCAib25Nb3VzZUxlYXZlIiwgIm9uQmx1ck9yRm9jdXNPdXQiLCAicmVtb3ZlTGlzdGVuZXJzIiwgInNob3VsZFNjaGVkdWxlQ2xpY2tIaWRlIiwgImlzRXZlbnRMaXN0ZW5lclN0b3BwZWQiLCAid2FzRm9jdXNlZCIsICJzY2hlZHVsZUhpZGUiLCAiaXNDdXJzb3JPdmVyUmVmZXJlbmNlT3JQb3BwZXIiLCAiZ2V0TmVzdGVkUG9wcGVyVHJlZSIsICJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCAic2hvdWxkQmFpbCIsICJyZWxhdGVkVGFyZ2V0IiwgImNyZWF0ZVBvcHBlckluc3RhbmNlIiwgImRlc3Ryb3lQb3BwZXJJbnN0YW5jZSIsICJjb21wdXRlZFJlZmVyZW5jZSIsICJjb250ZXh0RWxlbWVudCIsICJ0aXBweU1vZGlmaWVyIiwgImVuYWJsZWQiLCAicGhhc2UiLCAicmVxdWlyZXMiLCAiYXR0cmlidXRlcyIsICJtb2RpZmllcnMiLCAicGFkZGluZyIsICJhZGFwdGl2ZSIsICJjcmVhdGVQb3BwZXIiLCAibW91bnQiLCAibmV4dEVsZW1lbnRTaWJsaW5nIiwgInRvdWNoVmFsdWUiLCAidG91Y2hEZWxheSIsICJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCAiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCAibmVzdGVkUG9wcGVyIiwgImZvcmNlVXBkYXRlIiwgImlzQWxyZWFkeVZpc2libGUiLCAiaXNEaXNhYmxlZCIsICJpc1RvdWNoQW5kVG91Y2hEaXNhYmxlZCIsICJ2aXNpYmlsaXR5IiwgInRyYW5zaXRpb24iLCAib2Zmc2V0SGVpZ2h0IiwgImlzQWxyZWFkeUhpZGRlbiIsICJpIiwgInRpcHB5IiwgIm9wdGlvbmFsUHJvcHMiLCAiZWxlbWVudHMiLCAiaXNTaW5nbGVDb250ZW50RWxlbWVudCIsICJpc01vcmVUaGFuT25lUmVmZXJlbmNlRWxlbWVudCIsICJpbnN0YW5jZXMiLCAiYXBwbHlTdHlsZXNNb2RpZmllciIsICJhcHBseVN0eWxlcyIsICJlZmZlY3QiLCAic3RhdGUiLCAiaW5pdGlhbFN0eWxlcyIsICJwb3BwZXIiLCAicG9zaXRpb24iLCAib3B0aW9ucyIsICJzdHJhdGVneSIsICJsZWZ0IiwgInRvcCIsICJtYXJnaW4iLCAiYXJyb3ciLCAicmVmZXJlbmNlIiwgIk9iamVjdCIsICJhc3NpZ24iLCAiZWxlbWVudHMiLCAic3R5bGUiLCAic3R5bGVzIiwgInRpcHB5IiwgInNldERlZmF1bHRQcm9wcyIsICJyZW5kZXIiLCAiZWxlbWVudCIsICJ2aWV3IiwgImZyb20iLCAiZG9jIiwgImVtcHR5IiwgInNob3VsZFNob3ciLCAiZWxlbWVudCIsICJOb2RlIiwgImVsZW1lbnQiLCAidHIiLCAib2Zmc2V0IiwgIk5vZGUiLCAiZWxlbWVudCIsICJOb2RlIiwgInNsaWNlIiwgImZyb20iLCAiZW1wdHkiLCAidHIiLCAiTm9kZSIsICJOb2RlIiwgImVtcHR5IiwgIm5vZGUiLCAiZGVmYXVsdEJsb2NrQXQiLCAidHIiLCAiZWxlbWVudCIsICJOb2RlIiwgImNvbW1hbmRzIiwgImVsZW1lbnQiLCAiZnJvbSIsICJjdHgiLCAiZWxlbWVudCIsICJkaXYiLCAiY29tbWFuZHMiLCAiY29tbWFuZCIsICJkaXYiLCAiY3R4IiwgInRyIiwgImRvYyIsICJub2RlU2l6ZSIsICJjdHgiLCAidXBkYXRlQXR0cmlidXRlcyIsICJjbGllbnRSZWN0IiwgImluc3RhbmNlIiwgImNvbW1hbmRzIiwgIk5vZGUiLCAiZWxlbWVudCIsICJ0ciIsICJlbXB0eSIsICJ0ZXh0IiwgImZyb20iLCAiY29tbWFuZCIsICJyZW5kZXIiLCAiZmluZFN1Z2dlc3Rpb25NYXRjaCIsICJkZWZhdWx0RmluZFN1Z2dlc3Rpb25NYXRjaCIsICJfYSIsICJlbXB0eSIsICJjdHgiLCAiZGl2IiwgImNyZWF0ZV9pZl9ibG9ja18xIiwgImNyZWF0ZV9pZl9ibG9jayIsICJlbGVtZW50IiwgImRvYyIsICJpbnB1dFJlZ2V4IiwgIk5vZGUiLCAiY29tbWFuZHMiLCAiTWFyayIsICJjb21tYW5kcyIsICJOb2RlIiwgIk1hcmsiLCAiZWxlbWVudCIsICJjb21tYW5kcyIsICJpbnB1dFJlZ2V4IiwgImlucHV0UmVnZXgiLCAiTWFyayIsICJjb21tYW5kcyIsICJOb2RlIiwgImVsZW1lbnQiLCAiY29tbWFuZHMiLCAiZW1wdHkiLCAidHIiLCAiZG9jIiwgInRleHQiLCAiTm9kZSIsICJ0b3AiLCAicmVjdCIsICJkb2MiLCAiYXJyb3ciLCAiaW5zZXJ0IiwgInRyIiwgIk5vZGUiLCAiY29tbWFuZHMiLCAidHIiLCAiTm9kZSIsICJjb21tYW5kcyIsICJSb3BlU2VxdWVuY2UiLCAiYXBwZW5kIiwgImZyb20iLCAiZm9yRWFjaCIsICJMZWFmIiwgInN0YXJ0IiwgIkFwcGVuZCIsICJsZWZ0IiwgInJpZ2h0IiwgImFwcGVuZElubmVyIiwgImRpc3RfZGVmYXVsdCIsICJlbmQiLCAibWFwIiwgImZyb20iLCAic3RhcnQiLCAiZGlzdF9kZWZhdWx0IiwgImhpc3RvcnkiLCAidHIiLCAicmVkbyIsICJ0ciIsICJjb21tYW5kIiwgIk5vZGUiLCAidHIiLCAic3RhcklucHV0UmVnZXgiLCAic3RhclBhc3RlUmVnZXgiLCAidW5kZXJzY29yZUlucHV0UmVnZXgiLCAidW5kZXJzY29yZVBhc3RlUmVnZXgiLCAiTWFyayIsICJjb21tYW5kcyIsICJMaXN0SXRlbSIsICJOb2RlIiwgIkxpc3RJdGVtIiwgIk5vZGUiLCAiVGV4dFN0eWxlIiwgIk1hcmsiLCAiZWxlbWVudCIsICJjb21tYW5kcyIsICJpbnB1dFJlZ2V4IiwgInN0YXJ0IiwgIk5vZGUiLCAiY29tbWFuZHMiLCAiaW5wdXRSZWdleCIsICJwYXN0ZVJlZ2V4IiwgIk1hcmsiLCAic3R5bGUiLCAiY29tbWFuZHMiLCAiTm9kZSIsICJleHRlbnNpb25zIiwgIkxpc3RJdGVtIiwgImRpdiIsICJjdHgiLCAiY3JlYXRlX2lmX2Jsb2NrIiwgInVwZGF0ZUF0dHJpYnV0ZXMiLCAiY2xpZW50UmVjdCIsICJpbnN0YW5jZSIsICJjb21wb25lbnQiLCAiU2NyaWJibGVCbG9ja19kZWZhdWx0IiwgIk5vZGUiLCAidHIiLCAiY29tbWFuZHMiLCAiY3R4IiwgImRpdiIsICJjcmVhdGVfaWZfYmxvY2tfMiIsICJjcmVhdGVfaWZfYmxvY2tfMSIsICJjcmVhdGVfaWZfYmxvY2siLCAibWFwIiwgInIiLCAiZWxlbWVudCIsICJNYXJrIiwgImNvbW1hbmRzIiwgIk1hcmsiLCAiY29tbWFuZHMiLCAiZWxlbWVudCIsICJjb21tYW5kcyIsICJUZXh0U3R5bGUiLCAiTWFyayIsICJlbGVtZW50IiwgImNvbW1hbmRzIiwgIk1hcmsiLCAic3R5bGUiLCAiY29tbWFuZHMiLCAiY3R4IiwgImNyZWF0ZV9pZl9ibG9jayIsICJjcmVhdGVfaWZfYmxvY2siLCAiY3R4IiwgImN0eCIsICJkaXYiLCAiY3JlYXRlX2lmX2Jsb2NrXzIiLCAiY3JlYXRlX2lmX2Jsb2NrIiwgImlzQWN0aXZlIiwgIm1hcCIsICJyIiwgImNyZWF0ZV9pZl9ibG9ja18xIiwgImRpdiIsICJjdHgiLCAiY3JlYXRlX2lmX2Jsb2NrIiwgImlzQWN0aXZlIiwgIm1hcCIsICJyIiwgImlucHV0UmVnZXgiLCAicGFzdGVSZWdleCIsICJNYXJrIiwgImVsZW1lbnQiLCAiY29tbWFuZHMiLCAiYXNzaWduIiwgIm5leHRTdGF0ZSIsICJhc3NpZ24iLCAicnVuJDEiLCAic3RhcnQiLCAiZmlyc3QiLCAibm9vcCIsICJzY2hlbWUiLCAiYXNzaWduIiwgIlRleHQiLCAicnVuIiwgInN0YXJ0IiwgIlRleHQiLCAic2NoZW1lIiwgImluaXQiLCAicnVuIiwgInJ1biQxIiwgInRyIiwgInNsaWNlIiwgImVtcHR5IiwgIk1hcmsiLCAidGV4dCIsICJjb21tYW5kcyIsICJ0ZXh0IiwgImN0eCIsICJ1cGRhdGVBdHRyaWJ1dGVzIiwgImNsaWVudFJlY3QiLCAiaW5zdGFuY2UiLCAiTm9kZSIsICJjdHgiLCAiZWxlbWVudCIsICJleHRlbnNpb25zIiwgIlNjcmliYmxlQmxvY2tfZGVmYXVsdCIsICJUZXh0U3R5bGUiLCAiZWRpdG9yIiwgImZyb20iLCAidXBkYXRlIiwgImlzQWN0aXZlIl0KfQo=
